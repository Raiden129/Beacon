let JS, qo, pC, nbe, KH, E6, re, Zc, LU, Oc, L;
let __tla = (async ()=>{
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);
        new MutationObserver((s)=>{
            for (const i of s)if (i.type === "childList") for (const l of i.addedNodes)l.tagName === "LINK" && l.rel === "modulepreload" && r(l);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function t(s) {
            const i = {};
            return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i;
        }
        function r(s) {
            if (s.ep) return;
            s.ep = !0;
            const i = t(s);
            fetch(s.href, i);
        }
    })();
    nbe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    Zc = function(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
    };
    var s3 = {
        exports: {}
    }, bh = {};
    var r9;
    function WO() {
        if (r9) return bh;
        r9 = 1;
        var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
        function t(r, s, i) {
            var l = null;
            if (i !== void 0 && (l = "" + i), s.key !== void 0 && (l = "" + s.key), "key" in s) {
                i = {};
                for(var u in s)u !== "key" && (i[u] = s[u]);
            } else i = s;
            return s = i.ref, {
                $$typeof: n,
                type: r,
                key: l,
                ref: s !== void 0 ? s : null,
                props: i
            };
        }
        return bh.Fragment = e, bh.jsx = t, bh.jsxs = t, bh;
    }
    var s9;
    function jO() {
        return s9 || (s9 = 1, s3.exports = WO()), s3.exports;
    }
    var ye = jO(), i3 = {
        exports: {}
    };
    function XO(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
    }
    var KS = {
        exports: {}
    }, Zt = KS.exports = {}, Zs, ei;
    function Dy() {
        throw new Error("setTimeout has not been defined");
    }
    function By() {
        throw new Error("clearTimeout has not been defined");
    }
    (function() {
        try {
            typeof setTimeout == "function" ? Zs = setTimeout : Zs = Dy;
        } catch  {
            Zs = Dy;
        }
        try {
            typeof clearTimeout == "function" ? ei = clearTimeout : ei = By;
        } catch  {
            ei = By;
        }
    })();
    function GS(n) {
        if (Zs === setTimeout) return setTimeout(n, 0);
        if ((Zs === Dy || !Zs) && setTimeout) return Zs = setTimeout, setTimeout(n, 0);
        try {
            return Zs(n, 0);
        } catch  {
            try {
                return Zs.call(null, n, 0);
            } catch  {
                return Zs.call(this, n, 0);
            }
        }
    }
    function JO(n) {
        if (ei === clearTimeout) return clearTimeout(n);
        if ((ei === By || !ei) && clearTimeout) return ei = clearTimeout, clearTimeout(n);
        try {
            return ei(n);
        } catch  {
            try {
                return ei.call(null, n);
            } catch  {
                return ei.call(this, n);
            }
        }
    }
    var Qi = [], wc = !1, Da, Z0 = -1;
    function ZO() {
        !wc || !Da || (wc = !1, Da.length ? Qi = Da.concat(Qi) : Z0 = -1, Qi.length && YS());
    }
    function YS() {
        if (!wc) {
            var n = GS(ZO);
            wc = !0;
            for(var e = Qi.length; e;){
                for(Da = Qi, Qi = []; ++Z0 < e;)Da && Da[Z0].run();
                Z0 = -1, e = Qi.length;
            }
            Da = null, wc = !1, JO(n);
        }
    }
    Zt.nextTick = function(n) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var t = 1; t < arguments.length; t++)e[t - 1] = arguments[t];
        Qi.push(new WS(n, e)), Qi.length === 1 && !wc && GS(YS);
    };
    function WS(n, e) {
        this.fun = n, this.array = e;
    }
    WS.prototype.run = function() {
        this.fun.apply(null, this.array);
    };
    Zt.title = "browser";
    Zt.browser = !0;
    Zt.env = {};
    Zt.argv = [];
    Zt.version = "";
    Zt.versions = {};
    function Xi() {}
    Zt.on = Xi;
    Zt.addListener = Xi;
    Zt.once = Xi;
    Zt.off = Xi;
    Zt.removeListener = Xi;
    Zt.removeAllListeners = Xi;
    Zt.emit = Xi;
    Zt.prependListener = Xi;
    Zt.prependOnceListener = Xi;
    Zt.listeners = function(n) {
        return [];
    };
    Zt.binding = function(n) {
        throw new Error("process.binding is not supported");
    };
    Zt.cwd = function() {
        return "/";
    };
    Zt.chdir = function(n) {
        throw new Error("process.chdir is not supported");
    };
    Zt.umask = function() {
        return 0;
    };
    var e$ = KS.exports;
    const ai = XO(e$);
    var Ue = {}, i9;
    function t$() {
        if (i9) return Ue;
        i9 = 1;
        var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.activity"), w = Symbol.iterator;
        function A(x) {
            return x === null || typeof x != "object" ? null : (x = w && x[w] || x["@@iterator"], typeof x == "function" ? x : null);
        }
        var S = {
            isMounted: function() {
                return !1;
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        }, _ = Object.assign, I = {};
        function k(x, Q, pe) {
            this.props = x, this.context = Q, this.refs = I, this.updater = pe || S;
        }
        k.prototype.isReactComponent = {}, k.prototype.setState = function(x, Q) {
            if (typeof x != "object" && typeof x != "function" && x != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, x, Q, "setState");
        }, k.prototype.forceUpdate = function(x) {
            this.updater.enqueueForceUpdate(this, x, "forceUpdate");
        };
        function G() {}
        G.prototype = k.prototype;
        function P(x, Q, pe) {
            this.props = x, this.context = Q, this.refs = I, this.updater = pe || S;
        }
        var J = P.prototype = new G;
        J.constructor = P, _(J, k.prototype), J.isPureReactComponent = !0;
        var H = Array.isArray;
        function F() {}
        var $ = {
            H: null,
            A: null,
            T: null,
            S: null
        }, Y = Object.prototype.hasOwnProperty;
        function O(x, Q, pe) {
            var de = pe.ref;
            return {
                $$typeof: n,
                type: x,
                key: Q,
                ref: de !== void 0 ? de : null,
                props: pe
            };
        }
        function se(x, Q) {
            return O(x.type, Q, x.props);
        }
        function ae(x) {
            return typeof x == "object" && x !== null && x.$$typeof === n;
        }
        function oe(x) {
            var Q = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + x.replace(/[=:]/g, function(pe) {
                return Q[pe];
            });
        }
        var K = /\/+/g;
        function V(x, Q) {
            return typeof x == "object" && x !== null && x.key != null ? oe("" + x.key) : Q.toString(36);
        }
        function q(x) {
            switch(x.status){
                case "fulfilled":
                    return x.value;
                case "rejected":
                    throw x.reason;
                default:
                    switch(typeof x.status == "string" ? x.then(F, F) : (x.status = "pending", x.then(function(Q) {
                        x.status === "pending" && (x.status = "fulfilled", x.value = Q);
                    }, function(Q) {
                        x.status === "pending" && (x.status = "rejected", x.reason = Q);
                    })), x.status){
                        case "fulfilled":
                            return x.value;
                        case "rejected":
                            throw x.reason;
                    }
            }
            throw x;
        }
        function B(x, Q, pe, de, me) {
            var Ae = typeof x;
            (Ae === "undefined" || Ae === "boolean") && (x = null);
            var Te = !1;
            if (x === null) Te = !0;
            else switch(Ae){
                case "bigint":
                case "string":
                case "number":
                    Te = !0;
                    break;
                case "object":
                    switch(x.$$typeof){
                        case n:
                        case e:
                            Te = !0;
                            break;
                        case p:
                            return Te = x._init, B(Te(x._payload), Q, pe, de, me);
                    }
            }
            if (Te) return me = me(x), Te = de === "" ? "." + V(x, 0) : de, H(me) ? (pe = "", Te != null && (pe = Te.replace(K, "$&/") + "/"), B(me, Q, pe, "", function(mt) {
                return mt;
            })) : me != null && (ae(me) && (me = se(me, pe + (me.key == null || x && x.key === me.key ? "" : ("" + me.key).replace(K, "$&/") + "/") + Te)), Q.push(me)), 1;
            Te = 0;
            var Ve = de === "" ? "." : de + ":";
            if (H(x)) for(var De = 0; De < x.length; De++)de = x[De], Ae = Ve + V(de, De), Te += B(de, Q, pe, Ae, me);
            else if (De = A(x), typeof De == "function") for(x = De.call(x), De = 0; !(de = x.next()).done;)de = de.value, Ae = Ve + V(de, De++), Te += B(de, Q, pe, Ae, me);
            else if (Ae === "object") {
                if (typeof x.then == "function") return B(q(x), Q, pe, de, me);
                throw Q = String(x), Error("Objects are not valid as a React child (found: " + (Q === "[object Object]" ? "object with keys {" + Object.keys(x).join(", ") + "}" : Q) + "). If you meant to render a collection of children, use an array instead.");
            }
            return Te;
        }
        function z(x, Q, pe) {
            if (x == null) return x;
            var de = [], me = 0;
            return B(x, de, "", "", function(Ae) {
                return Q.call(pe, Ae, me++);
            }), de;
        }
        function ee(x) {
            if (x._status === -1) {
                var Q = x._result;
                Q = Q(), Q.then(function(pe) {
                    (x._status === 0 || x._status === -1) && (x._status = 1, x._result = pe);
                }, function(pe) {
                    (x._status === 0 || x._status === -1) && (x._status = 2, x._result = pe);
                }), x._status === -1 && (x._status = 0, x._result = Q);
            }
            if (x._status === 1) return x._result.default;
            throw x._result;
        }
        var j = typeof reportError == "function" ? reportError : function(x) {
            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                var Q = new window.ErrorEvent("error", {
                    bubbles: !0,
                    cancelable: !0,
                    message: typeof x == "object" && x !== null && typeof x.message == "string" ? String(x.message) : String(x),
                    error: x
                });
                if (!window.dispatchEvent(Q)) return;
            } else if (typeof ai == "object" && typeof ai.emit == "function") {
                ai.emit("uncaughtException", x);
                return;
            }
            console.error(x);
        }, ce = {
            map: z,
            forEach: function(x, Q, pe) {
                z(x, function() {
                    Q.apply(this, arguments);
                }, pe);
            },
            count: function(x) {
                var Q = 0;
                return z(x, function() {
                    Q++;
                }), Q;
            },
            toArray: function(x) {
                return z(x, function(Q) {
                    return Q;
                }) || [];
            },
            only: function(x) {
                if (!ae(x)) throw Error("React.Children.only expected to receive a single React element child.");
                return x;
            }
        };
        return Ue.Activity = m, Ue.Children = ce, Ue.Component = k, Ue.Fragment = t, Ue.Profiler = s, Ue.PureComponent = P, Ue.StrictMode = r, Ue.Suspense = h, Ue.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = $, Ue.__COMPILER_RUNTIME = {
            __proto__: null,
            c: function(x) {
                return $.H.useMemoCache(x);
            }
        }, Ue.cache = function(x) {
            return function() {
                return x.apply(null, arguments);
            };
        }, Ue.cacheSignal = function() {
            return null;
        }, Ue.cloneElement = function(x, Q, pe) {
            if (x == null) throw Error("The argument must be a React element, but you passed " + x + ".");
            var de = _({}, x.props), me = x.key;
            if (Q != null) for(Ae in Q.key !== void 0 && (me = "" + Q.key), Q)!Y.call(Q, Ae) || Ae === "key" || Ae === "__self" || Ae === "__source" || Ae === "ref" && Q.ref === void 0 || (de[Ae] = Q[Ae]);
            var Ae = arguments.length - 2;
            if (Ae === 1) de.children = pe;
            else if (1 < Ae) {
                for(var Te = Array(Ae), Ve = 0; Ve < Ae; Ve++)Te[Ve] = arguments[Ve + 2];
                de.children = Te;
            }
            return O(x.type, me, de);
        }, Ue.createContext = function(x) {
            return x = {
                $$typeof: l,
                _currentValue: x,
                _currentValue2: x,
                _threadCount: 0,
                Provider: null,
                Consumer: null
            }, x.Provider = x, x.Consumer = {
                $$typeof: i,
                _context: x
            }, x;
        }, Ue.createElement = function(x, Q, pe) {
            var de, me = {}, Ae = null;
            if (Q != null) for(de in Q.key !== void 0 && (Ae = "" + Q.key), Q)Y.call(Q, de) && de !== "key" && de !== "__self" && de !== "__source" && (me[de] = Q[de]);
            var Te = arguments.length - 2;
            if (Te === 1) me.children = pe;
            else if (1 < Te) {
                for(var Ve = Array(Te), De = 0; De < Te; De++)Ve[De] = arguments[De + 2];
                me.children = Ve;
            }
            if (x && x.defaultProps) for(de in Te = x.defaultProps, Te)me[de] === void 0 && (me[de] = Te[de]);
            return O(x, Ae, me);
        }, Ue.createRef = function() {
            return {
                current: null
            };
        }, Ue.forwardRef = function(x) {
            return {
                $$typeof: u,
                render: x
            };
        }, Ue.isValidElement = ae, Ue.lazy = function(x) {
            return {
                $$typeof: p,
                _payload: {
                    _status: -1,
                    _result: x
                },
                _init: ee
            };
        }, Ue.memo = function(x, Q) {
            return {
                $$typeof: f,
                type: x,
                compare: Q === void 0 ? null : Q
            };
        }, Ue.startTransition = function(x) {
            var Q = $.T, pe = {};
            $.T = pe;
            try {
                var de = x(), me = $.S;
                me !== null && me(pe, de), typeof de == "object" && de !== null && typeof de.then == "function" && de.then(F, j);
            } catch (Ae) {
                j(Ae);
            } finally{
                Q !== null && pe.types !== null && (Q.types = pe.types), $.T = Q;
            }
        }, Ue.unstable_useCacheRefresh = function() {
            return $.H.useCacheRefresh();
        }, Ue.use = function(x) {
            return $.H.use(x);
        }, Ue.useActionState = function(x, Q, pe) {
            return $.H.useActionState(x, Q, pe);
        }, Ue.useCallback = function(x, Q) {
            return $.H.useCallback(x, Q);
        }, Ue.useContext = function(x) {
            return $.H.useContext(x);
        }, Ue.useDebugValue = function() {}, Ue.useDeferredValue = function(x, Q) {
            return $.H.useDeferredValue(x, Q);
        }, Ue.useEffect = function(x, Q) {
            return $.H.useEffect(x, Q);
        }, Ue.useEffectEvent = function(x) {
            return $.H.useEffectEvent(x);
        }, Ue.useId = function() {
            return $.H.useId();
        }, Ue.useImperativeHandle = function(x, Q, pe) {
            return $.H.useImperativeHandle(x, Q, pe);
        }, Ue.useInsertionEffect = function(x, Q) {
            return $.H.useInsertionEffect(x, Q);
        }, Ue.useLayoutEffect = function(x, Q) {
            return $.H.useLayoutEffect(x, Q);
        }, Ue.useMemo = function(x, Q) {
            return $.H.useMemo(x, Q);
        }, Ue.useOptimistic = function(x, Q) {
            return $.H.useOptimistic(x, Q);
        }, Ue.useReducer = function(x, Q, pe) {
            return $.H.useReducer(x, Q, pe);
        }, Ue.useRef = function(x) {
            return $.H.useRef(x);
        }, Ue.useState = function(x) {
            return $.H.useState(x);
        }, Ue.useSyncExternalStore = function(x, Q, pe) {
            return $.H.useSyncExternalStore(x, Q, pe);
        }, Ue.useTransition = function() {
            return $.H.useTransition();
        }, Ue.version = "19.2.4", Ue;
    }
    var o9;
    function W4() {
        return o9 || (o9 = 1, i3.exports = t$()), i3.exports;
    }
    var Dt = W4(), o3 = {
        exports: {}
    }, vh = {}, a3 = {
        exports: {}
    }, l3 = {};
    var a9;
    function n$() {
        return a9 || (a9 = 1, (function(n) {
            function e(B, z) {
                var ee = B.length;
                B.push(z);
                e: for(; 0 < ee;){
                    var j = ee - 1 >>> 1, ce = B[j];
                    if (0 < s(ce, z)) B[j] = z, B[ee] = ce, ee = j;
                    else break e;
                }
            }
            function t(B) {
                return B.length === 0 ? null : B[0];
            }
            function r(B) {
                if (B.length === 0) return null;
                var z = B[0], ee = B.pop();
                if (ee !== z) {
                    B[0] = ee;
                    e: for(var j = 0, ce = B.length, x = ce >>> 1; j < x;){
                        var Q = 2 * (j + 1) - 1, pe = B[Q], de = Q + 1, me = B[de];
                        if (0 > s(pe, ee)) de < ce && 0 > s(me, pe) ? (B[j] = me, B[de] = ee, j = de) : (B[j] = pe, B[Q] = ee, j = Q);
                        else if (de < ce && 0 > s(me, ee)) B[j] = me, B[de] = ee, j = de;
                        else break e;
                    }
                }
                return z;
            }
            function s(B, z) {
                var ee = B.sortIndex - z.sortIndex;
                return ee !== 0 ? ee : B.id - z.id;
            }
            if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
                var i = performance;
                n.unstable_now = function() {
                    return i.now();
                };
            } else {
                var l = Date, u = l.now();
                n.unstable_now = function() {
                    return l.now() - u;
                };
            }
            var h = [], f = [], p = 1, m = null, w = 3, A = !1, S = !1, _ = !1, I = !1, k = typeof setTimeout == "function" ? setTimeout : null, G = typeof clearTimeout == "function" ? clearTimeout : null, P = typeof setImmediate < "u" ? setImmediate : null;
            function J(B) {
                for(var z = t(f); z !== null;){
                    if (z.callback === null) r(f);
                    else if (z.startTime <= B) r(f), z.sortIndex = z.expirationTime, e(h, z);
                    else break;
                    z = t(f);
                }
            }
            function H(B) {
                if (_ = !1, J(B), !S) if (t(h) !== null) S = !0, F || (F = !0, oe());
                else {
                    var z = t(f);
                    z !== null && q(H, z.startTime - B);
                }
            }
            var F = !1, $ = -1, Y = 5, O = -1;
            function se() {
                return I ? !0 : !(n.unstable_now() - O < Y);
            }
            function ae() {
                if (I = !1, F) {
                    var B = n.unstable_now();
                    O = B;
                    var z = !0;
                    try {
                        e: {
                            S = !1, _ && (_ = !1, G($), $ = -1), A = !0;
                            var ee = w;
                            try {
                                t: {
                                    for(J(B), m = t(h); m !== null && !(m.expirationTime > B && se());){
                                        var j = m.callback;
                                        if (typeof j == "function") {
                                            m.callback = null, w = m.priorityLevel;
                                            var ce = j(m.expirationTime <= B);
                                            if (B = n.unstable_now(), typeof ce == "function") {
                                                m.callback = ce, J(B), z = !0;
                                                break t;
                                            }
                                            m === t(h) && r(h), J(B);
                                        } else r(h);
                                        m = t(h);
                                    }
                                    if (m !== null) z = !0;
                                    else {
                                        var x = t(f);
                                        x !== null && q(H, x.startTime - B), z = !1;
                                    }
                                }
                                break e;
                            } finally{
                                m = null, w = ee, A = !1;
                            }
                            z = void 0;
                        }
                    } finally{
                        z ? oe() : F = !1;
                    }
                }
            }
            var oe;
            if (typeof P == "function") oe = function() {
                P(ae);
            };
            else if (typeof MessageChannel < "u") {
                var K = new MessageChannel, V = K.port2;
                K.port1.onmessage = ae, oe = function() {
                    V.postMessage(null);
                };
            } else oe = function() {
                k(ae, 0);
            };
            function q(B, z) {
                $ = k(function() {
                    B(n.unstable_now());
                }, z);
            }
            n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(B) {
                B.callback = null;
            }, n.unstable_forceFrameRate = function(B) {
                0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Y = 0 < B ? Math.floor(1e3 / B) : 5;
            }, n.unstable_getCurrentPriorityLevel = function() {
                return w;
            }, n.unstable_next = function(B) {
                switch(w){
                    case 1:
                    case 2:
                    case 3:
                        var z = 3;
                        break;
                    default:
                        z = w;
                }
                var ee = w;
                w = z;
                try {
                    return B();
                } finally{
                    w = ee;
                }
            }, n.unstable_requestPaint = function() {
                I = !0;
            }, n.unstable_runWithPriority = function(B, z) {
                switch(B){
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        B = 3;
                }
                var ee = w;
                w = B;
                try {
                    return z();
                } finally{
                    w = ee;
                }
            }, n.unstable_scheduleCallback = function(B, z, ee) {
                var j = n.unstable_now();
                switch(typeof ee == "object" && ee !== null ? (ee = ee.delay, ee = typeof ee == "number" && 0 < ee ? j + ee : j) : ee = j, B){
                    case 1:
                        var ce = -1;
                        break;
                    case 2:
                        ce = 250;
                        break;
                    case 5:
                        ce = 1073741823;
                        break;
                    case 4:
                        ce = 1e4;
                        break;
                    default:
                        ce = 5e3;
                }
                return ce = ee + ce, B = {
                    id: p++,
                    callback: z,
                    priorityLevel: B,
                    startTime: ee,
                    expirationTime: ce,
                    sortIndex: -1
                }, ee > j ? (B.sortIndex = ee, e(f, B), t(h) === null && B === t(f) && (_ ? (G($), $ = -1) : _ = !0, q(H, ee - j))) : (B.sortIndex = ce, e(h, B), S || A || (S = !0, F || (F = !0, oe()))), B;
            }, n.unstable_shouldYield = se, n.unstable_wrapCallback = function(B) {
                var z = w;
                return function() {
                    var ee = w;
                    w = z;
                    try {
                        return B.apply(this, arguments);
                    } finally{
                        w = ee;
                    }
                };
            };
        })(l3)), l3;
    }
    var l9;
    function r$() {
        return l9 || (l9 = 1, a3.exports = n$()), a3.exports;
    }
    var c3 = {
        exports: {}
    }, Dn = {};
    var c9;
    function s$() {
        if (c9) return Dn;
        c9 = 1;
        var n = W4();
        function e(h) {
            var f = "https://react.dev/errors/" + h;
            if (1 < arguments.length) {
                f += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var p = 2; p < arguments.length; p++)f += "&args[]=" + encodeURIComponent(arguments[p]);
            }
            return "Minified React error #" + h + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function t() {}
        var r = {
            d: {
                f: t,
                r: function() {
                    throw Error(e(522));
                },
                D: t,
                C: t,
                L: t,
                m: t,
                X: t,
                S: t,
                M: t
            },
            p: 0,
            findDOMNode: null
        }, s = Symbol.for("react.portal");
        function i(h, f, p) {
            var m = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
                $$typeof: s,
                key: m == null ? null : "" + m,
                children: h,
                containerInfo: f,
                implementation: p
            };
        }
        var l = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        function u(h, f) {
            if (h === "font") return "";
            if (typeof f == "string") return f === "use-credentials" ? f : "";
        }
        return Dn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, Dn.createPortal = function(h, f) {
            var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
            if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11) throw Error(e(299));
            return i(h, f, null, p);
        }, Dn.flushSync = function(h) {
            var f = l.T, p = r.p;
            try {
                if (l.T = null, r.p = 2, h) return h();
            } finally{
                l.T = f, r.p = p, r.d.f();
            }
        }, Dn.preconnect = function(h, f) {
            typeof h == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, r.d.C(h, f));
        }, Dn.prefetchDNS = function(h) {
            typeof h == "string" && r.d.D(h);
        }, Dn.preinit = function(h, f) {
            if (typeof h == "string" && f && typeof f.as == "string") {
                var p = f.as, m = u(p, f.crossOrigin), w = typeof f.integrity == "string" ? f.integrity : void 0, A = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
                p === "style" ? r.d.S(h, typeof f.precedence == "string" ? f.precedence : void 0, {
                    crossOrigin: m,
                    integrity: w,
                    fetchPriority: A
                }) : p === "script" && r.d.X(h, {
                    crossOrigin: m,
                    integrity: w,
                    fetchPriority: A,
                    nonce: typeof f.nonce == "string" ? f.nonce : void 0
                });
            }
        }, Dn.preinitModule = function(h, f) {
            if (typeof h == "string") if (typeof f == "object" && f !== null) {
                if (f.as == null || f.as === "script") {
                    var p = u(f.as, f.crossOrigin);
                    r.d.M(h, {
                        crossOrigin: p,
                        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
                        nonce: typeof f.nonce == "string" ? f.nonce : void 0
                    });
                }
            } else f == null && r.d.M(h);
        }, Dn.preload = function(h, f) {
            if (typeof h == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
                var p = f.as, m = u(p, f.crossOrigin);
                r.d.L(h, p, {
                    crossOrigin: m,
                    integrity: typeof f.integrity == "string" ? f.integrity : void 0,
                    nonce: typeof f.nonce == "string" ? f.nonce : void 0,
                    type: typeof f.type == "string" ? f.type : void 0,
                    fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
                    referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
                    imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
                    imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
                    media: typeof f.media == "string" ? f.media : void 0
                });
            }
        }, Dn.preloadModule = function(h, f) {
            if (typeof h == "string") if (f) {
                var p = u(f.as, f.crossOrigin);
                r.d.m(h, {
                    as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
                    crossOrigin: p,
                    integrity: typeof f.integrity == "string" ? f.integrity : void 0
                });
            } else r.d.m(h);
        }, Dn.requestFormReset = function(h) {
            r.d.r(h);
        }, Dn.unstable_batchedUpdates = function(h, f) {
            return h(f);
        }, Dn.useFormState = function(h, f, p) {
            return l.H.useFormState(h, f, p);
        }, Dn.useFormStatus = function() {
            return l.H.useHostTransitionStatus();
        }, Dn.version = "19.2.4", Dn;
    }
    var u9;
    function i$() {
        if (u9) return c3.exports;
        u9 = 1;
        function n() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
            } catch (e) {
                console.error(e);
            }
        }
        return n(), c3.exports = s$(), c3.exports;
    }
    var h9;
    function o$() {
        if (h9) return vh;
        h9 = 1;
        var n = r$(), e = W4(), t = i$();
        function r(o) {
            var a = "https://react.dev/errors/" + o;
            if (1 < arguments.length) {
                a += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var c = 2; c < arguments.length; c++)a += "&args[]=" + encodeURIComponent(arguments[c]);
            }
            return "Minified React error #" + o + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function s(o) {
            return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
        }
        function i(o) {
            var a = o, c = o;
            if (o.alternate) for(; a.return;)a = a.return;
            else {
                o = a;
                do a = o, (a.flags & 4098) !== 0 && (c = a.return), o = a.return;
                while (o);
            }
            return a.tag === 3 ? c : null;
        }
        function l(o) {
            if (o.tag === 13) {
                var a = o.memoizedState;
                if (a === null && (o = o.alternate, o !== null && (a = o.memoizedState)), a !== null) return a.dehydrated;
            }
            return null;
        }
        function u(o) {
            if (o.tag === 31) {
                var a = o.memoizedState;
                if (a === null && (o = o.alternate, o !== null && (a = o.memoizedState)), a !== null) return a.dehydrated;
            }
            return null;
        }
        function h(o) {
            if (i(o) !== o) throw Error(r(188));
        }
        function f(o) {
            var a = o.alternate;
            if (!a) {
                if (a = i(o), a === null) throw Error(r(188));
                return a !== o ? null : o;
            }
            for(var c = o, d = a;;){
                var g = c.return;
                if (g === null) break;
                var y = g.alternate;
                if (y === null) {
                    if (d = g.return, d !== null) {
                        c = d;
                        continue;
                    }
                    break;
                }
                if (g.child === y.child) {
                    for(y = g.child; y;){
                        if (y === c) return h(g), o;
                        if (y === d) return h(g), a;
                        y = y.sibling;
                    }
                    throw Error(r(188));
                }
                if (c.return !== d.return) c = g, d = y;
                else {
                    for(var E = !1, C = g.child; C;){
                        if (C === c) {
                            E = !0, c = g, d = y;
                            break;
                        }
                        if (C === d) {
                            E = !0, d = g, c = y;
                            break;
                        }
                        C = C.sibling;
                    }
                    if (!E) {
                        for(C = y.child; C;){
                            if (C === c) {
                                E = !0, c = y, d = g;
                                break;
                            }
                            if (C === d) {
                                E = !0, d = y, c = g;
                                break;
                            }
                            C = C.sibling;
                        }
                        if (!E) throw Error(r(189));
                    }
                }
                if (c.alternate !== d) throw Error(r(190));
            }
            if (c.tag !== 3) throw Error(r(188));
            return c.stateNode.current === c ? o : a;
        }
        function p(o) {
            var a = o.tag;
            if (a === 5 || a === 26 || a === 27 || a === 6) return o;
            for(o = o.child; o !== null;){
                if (a = p(o), a !== null) return a;
                o = o.sibling;
            }
            return null;
        }
        var m = Object.assign, w = Symbol.for("react.element"), A = Symbol.for("react.transitional.element"), S = Symbol.for("react.portal"), _ = Symbol.for("react.fragment"), I = Symbol.for("react.strict_mode"), k = Symbol.for("react.profiler"), G = Symbol.for("react.consumer"), P = Symbol.for("react.context"), J = Symbol.for("react.forward_ref"), H = Symbol.for("react.suspense"), F = Symbol.for("react.suspense_list"), $ = Symbol.for("react.memo"), Y = Symbol.for("react.lazy"), O = Symbol.for("react.activity"), se = Symbol.for("react.memo_cache_sentinel"), ae = Symbol.iterator;
        function oe(o) {
            return o === null || typeof o != "object" ? null : (o = ae && o[ae] || o["@@iterator"], typeof o == "function" ? o : null);
        }
        var K = Symbol.for("react.client.reference");
        function V(o) {
            if (o == null) return null;
            if (typeof o == "function") return o.$$typeof === K ? null : o.displayName || o.name || null;
            if (typeof o == "string") return o;
            switch(o){
                case _:
                    return "Fragment";
                case k:
                    return "Profiler";
                case I:
                    return "StrictMode";
                case H:
                    return "Suspense";
                case F:
                    return "SuspenseList";
                case O:
                    return "Activity";
            }
            if (typeof o == "object") switch(o.$$typeof){
                case S:
                    return "Portal";
                case P:
                    return o.displayName || "Context";
                case G:
                    return (o._context.displayName || "Context") + ".Consumer";
                case J:
                    var a = o.render;
                    return o = o.displayName, o || (o = a.displayName || a.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
                case $:
                    return a = o.displayName || null, a !== null ? a : V(o.type) || "Memo";
                case Y:
                    a = o._payload, o = o._init;
                    try {
                        return V(o(a));
                    } catch  {}
            }
            return null;
        }
        var q = Array.isArray, B = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, z = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ee = {
            pending: !1,
            data: null,
            method: null,
            action: null
        }, j = [], ce = -1;
        function x(o) {
            return {
                current: o
            };
        }
        function Q(o) {
            0 > ce || (o.current = j[ce], j[ce] = null, ce--);
        }
        function pe(o, a) {
            ce++, j[ce] = o.current, o.current = a;
        }
        var de = x(null), me = x(null), Ae = x(null), Te = x(null);
        function Ve(o, a) {
            switch(pe(Ae, a), pe(me, o), pe(de, null), a.nodeType){
                case 9:
                case 11:
                    o = (o = a.documentElement) && (o = o.namespaceURI) ? T7(o) : 0;
                    break;
                default:
                    if (o = a.tagName, a = a.namespaceURI) a = T7(a), o = _7(a, o);
                    else switch(o){
                        case "svg":
                            o = 1;
                            break;
                        case "math":
                            o = 2;
                            break;
                        default:
                            o = 0;
                    }
            }
            Q(de), pe(de, o);
        }
        function De() {
            Q(de), Q(me), Q(Ae);
        }
        function mt(o) {
            o.memoizedState !== null && pe(Te, o);
            var a = de.current, c = _7(a, o.type);
            a !== c && (pe(me, o), pe(de, c));
        }
        function hn(o) {
            me.current === o && (Q(de), Q(me)), Te.current === o && (Q(Te), gh._currentValue = ee);
        }
        var Qr, Ts;
        function qr(o) {
            if (Qr === void 0) try {
                throw Error();
            } catch (c) {
                var a = c.stack.trim().match(/\n( *(at )?)/);
                Qr = a && a[1] || "", Ts = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
            return `
` + Qr + o + Ts;
        }
        var mi = !1;
        function Sr(o, a) {
            if (!o || mi) return "";
            mi = !0;
            var c = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
                var d = {
                    DetermineComponentFrameRoot: function() {
                        try {
                            if (a) {
                                var fe = function() {
                                    throw Error();
                                };
                                if (Object.defineProperty(fe.prototype, "props", {
                                    set: function() {
                                        throw Error();
                                    }
                                }), typeof Reflect == "object" && Reflect.construct) {
                                    try {
                                        Reflect.construct(fe, []);
                                    } catch (ie) {
                                        var te = ie;
                                    }
                                    Reflect.construct(o, [], fe);
                                } else {
                                    try {
                                        fe.call();
                                    } catch (ie) {
                                        te = ie;
                                    }
                                    o.call(fe.prototype);
                                }
                            } else {
                                try {
                                    throw Error();
                                } catch (ie) {
                                    te = ie;
                                }
                                (fe = o()) && typeof fe.catch == "function" && fe.catch(function() {});
                            }
                        } catch (ie) {
                            if (ie && te && typeof ie.stack == "string") return [
                                ie.stack,
                                te.stack
                            ];
                        }
                        return [
                            null,
                            null
                        ];
                    }
                };
                d.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                var g = Object.getOwnPropertyDescriptor(d.DetermineComponentFrameRoot, "name");
                g && g.configurable && Object.defineProperty(d.DetermineComponentFrameRoot, "name", {
                    value: "DetermineComponentFrameRoot"
                });
                var y = d.DetermineComponentFrameRoot(), E = y[0], C = y[1];
                if (E && C) {
                    var R = E.split(`
`), Z = C.split(`
`);
                    for(g = d = 0; d < R.length && !R[d].includes("DetermineComponentFrameRoot");)d++;
                    for(; g < Z.length && !Z[g].includes("DetermineComponentFrameRoot");)g++;
                    if (d === R.length || g === Z.length) for(d = R.length - 1, g = Z.length - 1; 1 <= d && 0 <= g && R[d] !== Z[g];)g--;
                    for(; 1 <= d && 0 <= g; d--, g--)if (R[d] !== Z[g]) {
                        if (d !== 1 || g !== 1) do if (d--, g--, 0 > g || R[d] !== Z[g]) {
                            var ue = `
` + R[d].replace(" at new ", " at ");
                            return o.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", o.displayName)), ue;
                        }
                        while (1 <= d && 0 <= g);
                        break;
                    }
                }
            } finally{
                mi = !1, Error.prepareStackTrace = c;
            }
            return (c = o ? o.displayName || o.name : "") ? qr(c) : "";
        }
        function Zo(o, a) {
            switch(o.tag){
                case 26:
                case 27:
                case 5:
                    return qr(o.type);
                case 16:
                    return qr("Lazy");
                case 13:
                    return o.child !== a && a !== null ? qr("Suspense Fallback") : qr("Suspense");
                case 19:
                    return qr("SuspenseList");
                case 0:
                case 15:
                    return Sr(o.type, !1);
                case 11:
                    return Sr(o.type.render, !1);
                case 1:
                    return Sr(o.type, !0);
                case 31:
                    return qr("Activity");
                default:
                    return "";
            }
        }
        function Lf(o) {
            try {
                var a = "", c = null;
                do a += Zo(o, c), c = o, o = o.return;
                while (o);
                return a;
            } catch (d) {
                return `
Error generating stack: ` + d.message + `
` + d.stack;
            }
        }
        var Tu = Object.prototype.hasOwnProperty, ea = n.unstable_scheduleCallback, _u = n.unstable_cancelCallback, Qg = n.unstable_shouldYield, Uf = n.unstable_requestPaint, dn = n.unstable_now, Kr = n.unstable_getCurrentPriorityLevel, tl = n.unstable_ImmediatePriority, zf = n.unstable_UserBlockingPriority, Ir = n.unstable_NormalPriority, qg = n.unstable_LowPriority, T = n.unstable_IdlePriority, b = n.log, v = n.unstable_setDisableYieldValue, D = null, N = null;
        function ne(o) {
            if (typeof b == "function" && v(o), N && typeof N.setStrictMode == "function") try {
                N.setStrictMode(D, o);
            } catch  {}
        }
        var le = Math.clz32 ? Math.clz32 : Ot, Qe = Math.log, zt = Math.LN2;
        function Ot(o) {
            return o >>>= 0, o === 0 ? 32 : 31 - (Qe(o) / zt | 0) | 0;
        }
        var It = 256, rt = 262144, Ff = 4194304;
        function ta(o) {
            var a = o & 42;
            if (a !== 0) return a;
            switch(o & -o){
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                    return 64;
                case 128:
                    return 128;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                    return o & 261888;
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return o & 3932160;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return o & 62914560;
                case 67108864:
                    return 67108864;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 0;
                default:
                    return o;
            }
        }
        function Vf(o, a, c) {
            var d = o.pendingLanes;
            if (d === 0) return 0;
            var g = 0, y = o.suspendedLanes, E = o.pingedLanes;
            o = o.warmLanes;
            var C = d & 134217727;
            return C !== 0 ? (d = C & ~y, d !== 0 ? g = ta(d) : (E &= C, E !== 0 ? g = ta(E) : c || (c = C & ~o, c !== 0 && (g = ta(c))))) : (C = d & ~y, C !== 0 ? g = ta(C) : E !== 0 ? g = ta(E) : c || (c = d & ~o, c !== 0 && (g = ta(c)))), g === 0 ? 0 : a !== 0 && a !== g && (a & y) === 0 && (y = g & -g, c = a & -a, y >= c || y === 32 && (c & 4194048) !== 0) ? a : g;
        }
        function xu(o, a) {
            return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & a) === 0;
        }
        function Mk(o, a) {
            switch(o){
                case 1:
                case 2:
                case 4:
                case 8:
                case 64:
                    return a + 250;
                case 16:
                case 32:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return a + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return -1;
                case 67108864:
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1;
            }
        }
        function a5() {
            var o = Ff;
            return Ff <<= 1, (Ff & 62914560) === 0 && (Ff = 4194304), o;
        }
        function Kg(o) {
            for(var a = [], c = 0; 31 > c; c++)a.push(o);
            return a;
        }
        function Du(o, a) {
            o.pendingLanes |= a, a !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
        }
        function Nk(o, a, c, d, g, y) {
            var E = o.pendingLanes;
            o.pendingLanes = c, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= c, o.entangledLanes &= c, o.errorRecoveryDisabledLanes &= c, o.shellSuspendCounter = 0;
            var C = o.entanglements, R = o.expirationTimes, Z = o.hiddenUpdates;
            for(c = E & ~c; 0 < c;){
                var ue = 31 - le(c), fe = 1 << ue;
                C[ue] = 0, R[ue] = -1;
                var te = Z[ue];
                if (te !== null) for(Z[ue] = null, ue = 0; ue < te.length; ue++){
                    var ie = te[ue];
                    ie !== null && (ie.lane &= -536870913);
                }
                c &= ~fe;
            }
            d !== 0 && l5(o, d, 0), y !== 0 && g === 0 && o.tag !== 0 && (o.suspendedLanes |= y & ~(E & ~a));
        }
        function l5(o, a, c) {
            o.pendingLanes |= a, o.suspendedLanes &= ~a;
            var d = 31 - le(a);
            o.entangledLanes |= a, o.entanglements[d] = o.entanglements[d] | 1073741824 | c & 261930;
        }
        function c5(o, a) {
            var c = o.entangledLanes |= a;
            for(o = o.entanglements; c;){
                var d = 31 - le(c), g = 1 << d;
                g & a | o[d] & a && (o[d] |= a), c &= ~g;
            }
        }
        function u5(o, a) {
            var c = a & -a;
            return c = (c & 42) !== 0 ? 1 : Gg(c), (c & (o.suspendedLanes | a)) !== 0 ? 0 : c;
        }
        function Gg(o) {
            switch(o){
                case 2:
                    o = 1;
                    break;
                case 8:
                    o = 4;
                    break;
                case 32:
                    o = 16;
                    break;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    o = 128;
                    break;
                case 268435456:
                    o = 134217728;
                    break;
                default:
                    o = 0;
            }
            return o;
        }
        function Yg(o) {
            return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
        }
        function h5() {
            var o = z.p;
            return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : j7(o.type));
        }
        function d5(o, a) {
            var c = z.p;
            try {
                return z.p = o, a();
            } finally{
                z.p = c;
            }
        }
        var eo = Math.random().toString(36).slice(2), wn = "__reactFiber$" + eo, or = "__reactProps$" + eo, nl = "__reactContainer$" + eo, Wg = "__reactEvents$" + eo, Lk = "__reactListeners$" + eo, Uk = "__reactHandles$" + eo, f5 = "__reactResources$" + eo, Bu = "__reactMarker$" + eo;
        function jg(o) {
            delete o[wn], delete o[or], delete o[Wg], delete o[Lk], delete o[Uk];
        }
        function rl(o) {
            var a = o[wn];
            if (a) return a;
            for(var c = o.parentNode; c;){
                if (a = c[nl] || c[wn]) {
                    if (c = a.alternate, a.child !== null || c !== null && c.child !== null) for(o = O7(o); o !== null;){
                        if (c = o[wn]) return c;
                        o = O7(o);
                    }
                    return a;
                }
                o = c, c = o.parentNode;
            }
            return null;
        }
        function sl(o) {
            if (o = o[wn] || o[nl]) {
                var a = o.tag;
                if (a === 5 || a === 6 || a === 13 || a === 31 || a === 26 || a === 27 || a === 3) return o;
            }
            return null;
        }
        function Pu(o) {
            var a = o.tag;
            if (a === 5 || a === 26 || a === 27 || a === 6) return o.stateNode;
            throw Error(r(33));
        }
        function il(o) {
            var a = o[f5];
            return a || (a = o[f5] = {
                hoistableStyles: new Map,
                hoistableScripts: new Map
            }), a;
        }
        function fn(o) {
            o[Bu] = !0;
        }
        var p5 = new Set, g5 = {};
        function na(o, a) {
            ol(o, a), ol(o + "Capture", a);
        }
        function ol(o, a) {
            for(g5[o] = a, o = 0; o < a.length; o++)p5.add(a[o]);
        }
        var zk = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), m5 = {}, y5 = {};
        function Fk(o) {
            return Tu.call(y5, o) ? !0 : Tu.call(m5, o) ? !1 : zk.test(o) ? y5[o] = !0 : (m5[o] = !0, !1);
        }
        function Hf(o, a, c) {
            if (Fk(a)) if (c === null) o.removeAttribute(a);
            else {
                switch(typeof c){
                    case "undefined":
                    case "function":
                    case "symbol":
                        o.removeAttribute(a);
                        return;
                    case "boolean":
                        var d = a.toLowerCase().slice(0, 5);
                        if (d !== "data-" && d !== "aria-") {
                            o.removeAttribute(a);
                            return;
                        }
                }
                o.setAttribute(a, "" + c);
            }
        }
        function Qf(o, a, c) {
            if (c === null) o.removeAttribute(a);
            else {
                switch(typeof c){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        o.removeAttribute(a);
                        return;
                }
                o.setAttribute(a, "" + c);
            }
        }
        function yi(o, a, c, d) {
            if (d === null) o.removeAttribute(c);
            else {
                switch(typeof d){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        o.removeAttribute(c);
                        return;
                }
                o.setAttributeNS(a, c, "" + d);
            }
        }
        function Gr(o) {
            switch(typeof o){
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                    return o;
                case "object":
                    return o;
                default:
                    return "";
            }
        }
        function w5(o) {
            var a = o.type;
            return (o = o.nodeName) && o.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
        }
        function Vk(o, a, c) {
            var d = Object.getOwnPropertyDescriptor(o.constructor.prototype, a);
            if (!o.hasOwnProperty(a) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
                var g = d.get, y = d.set;
                return Object.defineProperty(o, a, {
                    configurable: !0,
                    get: function() {
                        return g.call(this);
                    },
                    set: function(E) {
                        c = "" + E, y.call(this, E);
                    }
                }), Object.defineProperty(o, a, {
                    enumerable: d.enumerable
                }), {
                    getValue: function() {
                        return c;
                    },
                    setValue: function(E) {
                        c = "" + E;
                    },
                    stopTracking: function() {
                        o._valueTracker = null, delete o[a];
                    }
                };
            }
        }
        function Xg(o) {
            if (!o._valueTracker) {
                var a = w5(o) ? "checked" : "value";
                o._valueTracker = Vk(o, a, "" + o[a]);
            }
        }
        function b5(o) {
            if (!o) return !1;
            var a = o._valueTracker;
            if (!a) return !0;
            var c = a.getValue(), d = "";
            return o && (d = w5(o) ? o.checked ? "true" : "false" : o.value), o = d, o !== c ? (a.setValue(o), !0) : !1;
        }
        function qf(o) {
            if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
            try {
                return o.activeElement || o.body;
            } catch  {
                return o.body;
            }
        }
        var Hk = /[\n"\\]/g;
        function Yr(o) {
            return o.replace(Hk, function(a) {
                return "\\" + a.charCodeAt(0).toString(16) + " ";
            });
        }
        function Jg(o, a, c, d, g, y, E, C) {
            o.name = "", E != null && typeof E != "function" && typeof E != "symbol" && typeof E != "boolean" ? o.type = E : o.removeAttribute("type"), a != null ? E === "number" ? (a === 0 && o.value === "" || o.value != a) && (o.value = "" + Gr(a)) : o.value !== "" + Gr(a) && (o.value = "" + Gr(a)) : E !== "submit" && E !== "reset" || o.removeAttribute("value"), a != null ? Zg(o, E, Gr(a)) : c != null ? Zg(o, E, Gr(c)) : d != null && o.removeAttribute("value"), g == null && y != null && (o.defaultChecked = !!y), g != null && (o.checked = g && typeof g != "function" && typeof g != "symbol"), C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" ? o.name = "" + Gr(C) : o.removeAttribute("name");
        }
        function v5(o, a, c, d, g, y, E, C) {
            if (y != null && typeof y != "function" && typeof y != "symbol" && typeof y != "boolean" && (o.type = y), a != null || c != null) {
                if (!(y !== "submit" && y !== "reset" || a != null)) {
                    Xg(o);
                    return;
                }
                c = c != null ? "" + Gr(c) : "", a = a != null ? "" + Gr(a) : c, C || a === o.value || (o.value = a), o.defaultValue = a;
            }
            d = d ?? g, d = typeof d != "function" && typeof d != "symbol" && !!d, o.checked = C ? o.checked : !!d, o.defaultChecked = !!d, E != null && typeof E != "function" && typeof E != "symbol" && typeof E != "boolean" && (o.name = E), Xg(o);
        }
        function Zg(o, a, c) {
            a === "number" && qf(o.ownerDocument) === o || o.defaultValue === "" + c || (o.defaultValue = "" + c);
        }
        function al(o, a, c, d) {
            if (o = o.options, a) {
                a = {};
                for(var g = 0; g < c.length; g++)a["$" + c[g]] = !0;
                for(c = 0; c < o.length; c++)g = a.hasOwnProperty("$" + o[c].value), o[c].selected !== g && (o[c].selected = g), g && d && (o[c].defaultSelected = !0);
            } else {
                for(c = "" + Gr(c), a = null, g = 0; g < o.length; g++){
                    if (o[g].value === c) {
                        o[g].selected = !0, d && (o[g].defaultSelected = !0);
                        return;
                    }
                    a !== null || o[g].disabled || (a = o[g]);
                }
                a !== null && (a.selected = !0);
            }
        }
        function E5(o, a, c) {
            if (a != null && (a = "" + Gr(a), a !== o.value && (o.value = a), c == null)) {
                o.defaultValue !== a && (o.defaultValue = a);
                return;
            }
            o.defaultValue = c != null ? "" + Gr(c) : "";
        }
        function A5(o, a, c, d) {
            if (a == null) {
                if (d != null) {
                    if (c != null) throw Error(r(92));
                    if (q(d)) {
                        if (1 < d.length) throw Error(r(93));
                        d = d[0];
                    }
                    c = d;
                }
                c == null && (c = ""), a = c;
            }
            c = Gr(a), o.defaultValue = c, d = o.textContent, d === c && d !== "" && d !== null && (o.value = d), Xg(o);
        }
        function ll(o, a) {
            if (a) {
                var c = o.firstChild;
                if (c && c === o.lastChild && c.nodeType === 3) {
                    c.nodeValue = a;
                    return;
                }
            }
            o.textContent = a;
        }
        var Qk = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
        function S5(o, a, c) {
            var d = a.indexOf("--") === 0;
            c == null || typeof c == "boolean" || c === "" ? d ? o.setProperty(a, "") : a === "float" ? o.cssFloat = "" : o[a] = "" : d ? o.setProperty(a, c) : typeof c != "number" || c === 0 || Qk.has(a) ? a === "float" ? o.cssFloat = c : o[a] = ("" + c).trim() : o[a] = c + "px";
        }
        function I5(o, a, c) {
            if (a != null && typeof a != "object") throw Error(r(62));
            if (o = o.style, c != null) {
                for(var d in c)!c.hasOwnProperty(d) || a != null && a.hasOwnProperty(d) || (d.indexOf("--") === 0 ? o.setProperty(d, "") : d === "float" ? o.cssFloat = "" : o[d] = "");
                for(var g in a)d = a[g], a.hasOwnProperty(g) && c[g] !== d && S5(o, g, d);
            } else for(var y in a)a.hasOwnProperty(y) && S5(o, y, a[y]);
        }
        function e2(o) {
            if (o.indexOf("-") === -1) return !1;
            switch(o){
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return !1;
                default:
                    return !0;
            }
        }
        var qk = new Map([
            [
                "acceptCharset",
                "accept-charset"
            ],
            [
                "htmlFor",
                "for"
            ],
            [
                "httpEquiv",
                "http-equiv"
            ],
            [
                "crossOrigin",
                "crossorigin"
            ],
            [
                "accentHeight",
                "accent-height"
            ],
            [
                "alignmentBaseline",
                "alignment-baseline"
            ],
            [
                "arabicForm",
                "arabic-form"
            ],
            [
                "baselineShift",
                "baseline-shift"
            ],
            [
                "capHeight",
                "cap-height"
            ],
            [
                "clipPath",
                "clip-path"
            ],
            [
                "clipRule",
                "clip-rule"
            ],
            [
                "colorInterpolation",
                "color-interpolation"
            ],
            [
                "colorInterpolationFilters",
                "color-interpolation-filters"
            ],
            [
                "colorProfile",
                "color-profile"
            ],
            [
                "colorRendering",
                "color-rendering"
            ],
            [
                "dominantBaseline",
                "dominant-baseline"
            ],
            [
                "enableBackground",
                "enable-background"
            ],
            [
                "fillOpacity",
                "fill-opacity"
            ],
            [
                "fillRule",
                "fill-rule"
            ],
            [
                "floodColor",
                "flood-color"
            ],
            [
                "floodOpacity",
                "flood-opacity"
            ],
            [
                "fontFamily",
                "font-family"
            ],
            [
                "fontSize",
                "font-size"
            ],
            [
                "fontSizeAdjust",
                "font-size-adjust"
            ],
            [
                "fontStretch",
                "font-stretch"
            ],
            [
                "fontStyle",
                "font-style"
            ],
            [
                "fontVariant",
                "font-variant"
            ],
            [
                "fontWeight",
                "font-weight"
            ],
            [
                "glyphName",
                "glyph-name"
            ],
            [
                "glyphOrientationHorizontal",
                "glyph-orientation-horizontal"
            ],
            [
                "glyphOrientationVertical",
                "glyph-orientation-vertical"
            ],
            [
                "horizAdvX",
                "horiz-adv-x"
            ],
            [
                "horizOriginX",
                "horiz-origin-x"
            ],
            [
                "imageRendering",
                "image-rendering"
            ],
            [
                "letterSpacing",
                "letter-spacing"
            ],
            [
                "lightingColor",
                "lighting-color"
            ],
            [
                "markerEnd",
                "marker-end"
            ],
            [
                "markerMid",
                "marker-mid"
            ],
            [
                "markerStart",
                "marker-start"
            ],
            [
                "overlinePosition",
                "overline-position"
            ],
            [
                "overlineThickness",
                "overline-thickness"
            ],
            [
                "paintOrder",
                "paint-order"
            ],
            [
                "panose-1",
                "panose-1"
            ],
            [
                "pointerEvents",
                "pointer-events"
            ],
            [
                "renderingIntent",
                "rendering-intent"
            ],
            [
                "shapeRendering",
                "shape-rendering"
            ],
            [
                "stopColor",
                "stop-color"
            ],
            [
                "stopOpacity",
                "stop-opacity"
            ],
            [
                "strikethroughPosition",
                "strikethrough-position"
            ],
            [
                "strikethroughThickness",
                "strikethrough-thickness"
            ],
            [
                "strokeDasharray",
                "stroke-dasharray"
            ],
            [
                "strokeDashoffset",
                "stroke-dashoffset"
            ],
            [
                "strokeLinecap",
                "stroke-linecap"
            ],
            [
                "strokeLinejoin",
                "stroke-linejoin"
            ],
            [
                "strokeMiterlimit",
                "stroke-miterlimit"
            ],
            [
                "strokeOpacity",
                "stroke-opacity"
            ],
            [
                "strokeWidth",
                "stroke-width"
            ],
            [
                "textAnchor",
                "text-anchor"
            ],
            [
                "textDecoration",
                "text-decoration"
            ],
            [
                "textRendering",
                "text-rendering"
            ],
            [
                "transformOrigin",
                "transform-origin"
            ],
            [
                "underlinePosition",
                "underline-position"
            ],
            [
                "underlineThickness",
                "underline-thickness"
            ],
            [
                "unicodeBidi",
                "unicode-bidi"
            ],
            [
                "unicodeRange",
                "unicode-range"
            ],
            [
                "unitsPerEm",
                "units-per-em"
            ],
            [
                "vAlphabetic",
                "v-alphabetic"
            ],
            [
                "vHanging",
                "v-hanging"
            ],
            [
                "vIdeographic",
                "v-ideographic"
            ],
            [
                "vMathematical",
                "v-mathematical"
            ],
            [
                "vectorEffect",
                "vector-effect"
            ],
            [
                "vertAdvY",
                "vert-adv-y"
            ],
            [
                "vertOriginX",
                "vert-origin-x"
            ],
            [
                "vertOriginY",
                "vert-origin-y"
            ],
            [
                "wordSpacing",
                "word-spacing"
            ],
            [
                "writingMode",
                "writing-mode"
            ],
            [
                "xmlnsXlink",
                "xmlns:xlink"
            ],
            [
                "xHeight",
                "x-height"
            ]
        ]), Kk = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
        function Kf(o) {
            return Kk.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
        }
        function wi() {}
        var t2 = null;
        function n2(o) {
            return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
        }
        var cl = null, ul = null;
        function C5(o) {
            var a = sl(o);
            if (a && (o = a.stateNode)) {
                var c = o[or] || null;
                e: switch(o = a.stateNode, a.type){
                    case "input":
                        if (Jg(o, c.value, c.defaultValue, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name), a = c.name, c.type === "radio" && a != null) {
                            for(c = o; c.parentNode;)c = c.parentNode;
                            for(c = c.querySelectorAll('input[name="' + Yr("" + a) + '"][type="radio"]'), a = 0; a < c.length; a++){
                                var d = c[a];
                                if (d !== o && d.form === o.form) {
                                    var g = d[or] || null;
                                    if (!g) throw Error(r(90));
                                    Jg(d, g.value, g.defaultValue, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name);
                                }
                            }
                            for(a = 0; a < c.length; a++)d = c[a], d.form === o.form && b5(d);
                        }
                        break e;
                    case "textarea":
                        E5(o, c.value, c.defaultValue);
                        break e;
                    case "select":
                        a = c.value, a != null && al(o, !!c.multiple, a, !1);
                }
            }
        }
        var r2 = !1;
        function T5(o, a, c) {
            if (r2) return o(a, c);
            r2 = !0;
            try {
                var d = o(a);
                return d;
            } finally{
                if (r2 = !1, (cl !== null || ul !== null) && (R1(), cl && (a = cl, o = ul, ul = cl = null, C5(a), o))) for(a = 0; a < o.length; a++)C5(o[a]);
            }
        }
        function ku(o, a) {
            var c = o.stateNode;
            if (c === null) return null;
            var d = c[or] || null;
            if (d === null) return null;
            c = d[a];
            e: switch(a){
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (d = !d.disabled) || (o = o.type, d = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !d;
                    break e;
                default:
                    o = !1;
            }
            if (o) return null;
            if (c && typeof c != "function") throw Error(r(231, a, typeof c));
            return c;
        }
        var bi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), s2 = !1;
        if (bi) try {
            var Ru = {};
            Object.defineProperty(Ru, "passive", {
                get: function() {
                    s2 = !0;
                }
            }), window.addEventListener("test", Ru, Ru), window.removeEventListener("test", Ru, Ru);
        } catch  {
            s2 = !1;
        }
        var to = null, i2 = null, Gf = null;
        function _5() {
            if (Gf) return Gf;
            var o, a = i2, c = a.length, d, g = "value" in to ? to.value : to.textContent, y = g.length;
            for(o = 0; o < c && a[o] === g[o]; o++);
            var E = c - o;
            for(d = 1; d <= E && a[c - d] === g[y - d]; d++);
            return Gf = g.slice(o, 1 < d ? 1 - d : void 0);
        }
        function Yf(o) {
            var a = o.keyCode;
            return "charCode" in o ? (o = o.charCode, o === 0 && a === 13 && (o = 13)) : o = a, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
        }
        function Wf() {
            return !0;
        }
        function x5() {
            return !1;
        }
        function ar(o) {
            function a(c, d, g, y, E) {
                this._reactName = c, this._targetInst = g, this.type = d, this.nativeEvent = y, this.target = E, this.currentTarget = null;
                for(var C in o)o.hasOwnProperty(C) && (c = o[C], this[C] = c ? c(y) : y[C]);
                return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1) ? Wf : x5, this.isPropagationStopped = x5, this;
            }
            return m(a.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                    var c = this.nativeEvent;
                    c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = Wf);
                },
                stopPropagation: function() {
                    var c = this.nativeEvent;
                    c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = Wf);
                },
                persist: function() {},
                isPersistent: Wf
            }), a;
        }
        var ra = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(o) {
                return o.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        }, jf = ar(ra), Ou = m({}, ra, {
            view: 0,
            detail: 0
        }), Gk = ar(Ou), o2, a2, $u, Xf = m({}, Ou, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: c2,
            button: 0,
            buttons: 0,
            relatedTarget: function(o) {
                return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
            },
            movementX: function(o) {
                return "movementX" in o ? o.movementX : (o !== $u && ($u && o.type === "mousemove" ? (o2 = o.screenX - $u.screenX, a2 = o.screenY - $u.screenY) : a2 = o2 = 0, $u = o), o2);
            },
            movementY: function(o) {
                return "movementY" in o ? o.movementY : a2;
            }
        }), D5 = ar(Xf), Yk = m({}, Xf, {
            dataTransfer: 0
        }), Wk = ar(Yk), jk = m({}, Ou, {
            relatedTarget: 0
        }), l2 = ar(jk), Xk = m({}, ra, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), Jk = ar(Xk), Zk = m({}, ra, {
            clipboardData: function(o) {
                return "clipboardData" in o ? o.clipboardData : window.clipboardData;
            }
        }), eR = ar(Zk), tR = m({}, ra, {
            data: 0
        }), B5 = ar(tR), nR = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, rR = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, sR = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function iR(o) {
            var a = this.nativeEvent;
            return a.getModifierState ? a.getModifierState(o) : (o = sR[o]) ? !!a[o] : !1;
        }
        function c2() {
            return iR;
        }
        var oR = m({}, Ou, {
            key: function(o) {
                if (o.key) {
                    var a = nR[o.key] || o.key;
                    if (a !== "Unidentified") return a;
                }
                return o.type === "keypress" ? (o = Yf(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? rR[o.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: c2,
            charCode: function(o) {
                return o.type === "keypress" ? Yf(o) : 0;
            },
            keyCode: function(o) {
                return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
            },
            which: function(o) {
                return o.type === "keypress" ? Yf(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
            }
        }), aR = ar(oR), lR = m({}, Xf, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }), P5 = ar(lR), cR = m({}, Ou, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: c2
        }), uR = ar(cR), hR = m({}, ra, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), dR = ar(hR), fR = m({}, Xf, {
            deltaX: function(o) {
                return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
            },
            deltaY: function(o) {
                return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
        }), pR = ar(fR), gR = m({}, ra, {
            newState: 0,
            oldState: 0
        }), mR = ar(gR), yR = [
            9,
            13,
            27,
            32
        ], u2 = bi && "CompositionEvent" in window, Mu = null;
        bi && "documentMode" in document && (Mu = document.documentMode);
        var wR = bi && "TextEvent" in window && !Mu, k5 = bi && (!u2 || Mu && 8 < Mu && 11 >= Mu), R5 = " ", O5 = !1;
        function $5(o, a) {
            switch(o){
                case "keyup":
                    return yR.indexOf(a.keyCode) !== -1;
                case "keydown":
                    return a.keyCode !== 229;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return !0;
                default:
                    return !1;
            }
        }
        function M5(o) {
            return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
        }
        var hl = !1;
        function bR(o, a) {
            switch(o){
                case "compositionend":
                    return M5(a);
                case "keypress":
                    return a.which !== 32 ? null : (O5 = !0, R5);
                case "textInput":
                    return o = a.data, o === R5 && O5 ? null : o;
                default:
                    return null;
            }
        }
        function vR(o, a) {
            if (hl) return o === "compositionend" || !u2 && $5(o, a) ? (o = _5(), Gf = i2 = to = null, hl = !1, o) : null;
            switch(o){
                case "paste":
                    return null;
                case "keypress":
                    if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
                        if (a.char && 1 < a.char.length) return a.char;
                        if (a.which) return String.fromCharCode(a.which);
                    }
                    return null;
                case "compositionend":
                    return k5 && a.locale !== "ko" ? null : a.data;
                default:
                    return null;
            }
        }
        var ER = {
            color: !0,
            date: !0,
            datetime: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0
        };
        function N5(o) {
            var a = o && o.nodeName && o.nodeName.toLowerCase();
            return a === "input" ? !!ER[o.type] : a === "textarea";
        }
        function L5(o, a, c, d) {
            cl ? ul ? ul.push(d) : ul = [
                d
            ] : cl = d, a = z1(a, "onChange"), 0 < a.length && (c = new jf("onChange", "change", null, c, d), o.push({
                event: c,
                listeners: a
            }));
        }
        var Nu = null, Lu = null;
        function AR(o) {
            v7(o, 0);
        }
        function Jf(o) {
            var a = Pu(o);
            if (b5(a)) return o;
        }
        function U5(o, a) {
            if (o === "change") return a;
        }
        var z5 = !1;
        if (bi) {
            var h2;
            if (bi) {
                var d2 = "oninput" in document;
                if (!d2) {
                    var F5 = document.createElement("div");
                    F5.setAttribute("oninput", "return;"), d2 = typeof F5.oninput == "function";
                }
                h2 = d2;
            } else h2 = !1;
            z5 = h2 && (!document.documentMode || 9 < document.documentMode);
        }
        function V5() {
            Nu && (Nu.detachEvent("onpropertychange", H5), Lu = Nu = null);
        }
        function H5(o) {
            if (o.propertyName === "value" && Jf(Lu)) {
                var a = [];
                L5(a, Lu, o, n2(o)), T5(AR, a);
            }
        }
        function SR(o, a, c) {
            o === "focusin" ? (V5(), Nu = a, Lu = c, Nu.attachEvent("onpropertychange", H5)) : o === "focusout" && V5();
        }
        function IR(o) {
            if (o === "selectionchange" || o === "keyup" || o === "keydown") return Jf(Lu);
        }
        function CR(o, a) {
            if (o === "click") return Jf(a);
        }
        function TR(o, a) {
            if (o === "input" || o === "change") return Jf(a);
        }
        function _R(o, a) {
            return o === a && (o !== 0 || 1 / o === 1 / a) || o !== o && a !== a;
        }
        var Cr = typeof Object.is == "function" ? Object.is : _R;
        function Uu(o, a) {
            if (Cr(o, a)) return !0;
            if (typeof o != "object" || o === null || typeof a != "object" || a === null) return !1;
            var c = Object.keys(o), d = Object.keys(a);
            if (c.length !== d.length) return !1;
            for(d = 0; d < c.length; d++){
                var g = c[d];
                if (!Tu.call(a, g) || !Cr(o[g], a[g])) return !1;
            }
            return !0;
        }
        function Q5(o) {
            for(; o && o.firstChild;)o = o.firstChild;
            return o;
        }
        function q5(o, a) {
            var c = Q5(o);
            o = 0;
            for(var d; c;){
                if (c.nodeType === 3) {
                    if (d = o + c.textContent.length, o <= a && d >= a) return {
                        node: c,
                        offset: a - o
                    };
                    o = d;
                }
                e: {
                    for(; c;){
                        if (c.nextSibling) {
                            c = c.nextSibling;
                            break e;
                        }
                        c = c.parentNode;
                    }
                    c = void 0;
                }
                c = Q5(c);
            }
        }
        function K5(o, a) {
            return o && a ? o === a ? !0 : o && o.nodeType === 3 ? !1 : a && a.nodeType === 3 ? K5(o, a.parentNode) : "contains" in o ? o.contains(a) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(a) & 16) : !1 : !1;
        }
        function G5(o) {
            o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
            for(var a = qf(o.document); a instanceof o.HTMLIFrameElement;){
                try {
                    var c = typeof a.contentWindow.location.href == "string";
                } catch  {
                    c = !1;
                }
                if (c) o = a.contentWindow;
                else break;
                a = qf(o.document);
            }
            return a;
        }
        function f2(o) {
            var a = o && o.nodeName && o.nodeName.toLowerCase();
            return a && (a === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || a === "textarea" || o.contentEditable === "true");
        }
        var xR = bi && "documentMode" in document && 11 >= document.documentMode, dl = null, p2 = null, zu = null, g2 = !1;
        function Y5(o, a, c) {
            var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
            g2 || dl == null || dl !== qf(d) || (d = dl, "selectionStart" in d && f2(d) ? d = {
                start: d.selectionStart,
                end: d.selectionEnd
            } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
                anchorNode: d.anchorNode,
                anchorOffset: d.anchorOffset,
                focusNode: d.focusNode,
                focusOffset: d.focusOffset
            }), zu && Uu(zu, d) || (zu = d, d = z1(p2, "onSelect"), 0 < d.length && (a = new jf("onSelect", "select", null, a, c), o.push({
                event: a,
                listeners: d
            }), a.target = dl)));
        }
        function sa(o, a) {
            var c = {};
            return c[o.toLowerCase()] = a.toLowerCase(), c["Webkit" + o] = "webkit" + a, c["Moz" + o] = "moz" + a, c;
        }
        var fl = {
            animationend: sa("Animation", "AnimationEnd"),
            animationiteration: sa("Animation", "AnimationIteration"),
            animationstart: sa("Animation", "AnimationStart"),
            transitionrun: sa("Transition", "TransitionRun"),
            transitionstart: sa("Transition", "TransitionStart"),
            transitioncancel: sa("Transition", "TransitionCancel"),
            transitionend: sa("Transition", "TransitionEnd")
        }, m2 = {}, W5 = {};
        bi && (W5 = document.createElement("div").style, "AnimationEvent" in window || (delete fl.animationend.animation, delete fl.animationiteration.animation, delete fl.animationstart.animation), "TransitionEvent" in window || delete fl.transitionend.transition);
        function ia(o) {
            if (m2[o]) return m2[o];
            if (!fl[o]) return o;
            var a = fl[o], c;
            for(c in a)if (a.hasOwnProperty(c) && c in W5) return m2[o] = a[c];
            return o;
        }
        var j5 = ia("animationend"), X5 = ia("animationiteration"), J5 = ia("animationstart"), DR = ia("transitionrun"), BR = ia("transitionstart"), PR = ia("transitioncancel"), Z5 = ia("transitionend"), ew = new Map, y2 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        y2.push("scrollEnd");
        function _s(o, a) {
            ew.set(o, a), na(a, [
                o
            ]);
        }
        var Zf = typeof reportError == "function" ? reportError : function(o) {
            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                var a = new window.ErrorEvent("error", {
                    bubbles: !0,
                    cancelable: !0,
                    message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
                    error: o
                });
                if (!window.dispatchEvent(a)) return;
            } else if (typeof ai == "object" && typeof ai.emit == "function") {
                ai.emit("uncaughtException", o);
                return;
            }
            console.error(o);
        }, Wr = [], pl = 0, w2 = 0;
        function e1() {
            for(var o = pl, a = w2 = pl = 0; a < o;){
                var c = Wr[a];
                Wr[a++] = null;
                var d = Wr[a];
                Wr[a++] = null;
                var g = Wr[a];
                Wr[a++] = null;
                var y = Wr[a];
                if (Wr[a++] = null, d !== null && g !== null) {
                    var E = d.pending;
                    E === null ? g.next = g : (g.next = E.next, E.next = g), d.pending = g;
                }
                y !== 0 && tw(c, g, y);
            }
        }
        function t1(o, a, c, d) {
            Wr[pl++] = o, Wr[pl++] = a, Wr[pl++] = c, Wr[pl++] = d, w2 |= d, o.lanes |= d, o = o.alternate, o !== null && (o.lanes |= d);
        }
        function b2(o, a, c, d) {
            return t1(o, a, c, d), n1(o);
        }
        function oa(o, a) {
            return t1(o, null, null, a), n1(o);
        }
        function tw(o, a, c) {
            o.lanes |= c;
            var d = o.alternate;
            d !== null && (d.lanes |= c);
            for(var g = !1, y = o.return; y !== null;)y.childLanes |= c, d = y.alternate, d !== null && (d.childLanes |= c), y.tag === 22 && (o = y.stateNode, o === null || o._visibility & 1 || (g = !0)), o = y, y = y.return;
            return o.tag === 3 ? (y = o.stateNode, g && a !== null && (g = 31 - le(c), o = y.hiddenUpdates, d = o[g], d === null ? o[g] = [
                a
            ] : d.push(a), a.lane = c | 536870912), y) : null;
        }
        function n1(o) {
            if (50 < lh) throw lh = 0, xm = null, Error(r(185));
            for(var a = o.return; a !== null;)o = a, a = o.return;
            return o.tag === 3 ? o.stateNode : null;
        }
        var gl = {};
        function kR(o, a, c, d) {
            this.tag = o, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
        }
        function Tr(o, a, c, d) {
            return new kR(o, a, c, d);
        }
        function v2(o) {
            return o = o.prototype, !(!o || !o.isReactComponent);
        }
        function vi(o, a) {
            var c = o.alternate;
            return c === null ? (c = Tr(o.tag, a, o.key, o.mode), c.elementType = o.elementType, c.type = o.type, c.stateNode = o.stateNode, c.alternate = o, o.alternate = c) : (c.pendingProps = a, c.type = o.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = o.flags & 65011712, c.childLanes = o.childLanes, c.lanes = o.lanes, c.child = o.child, c.memoizedProps = o.memoizedProps, c.memoizedState = o.memoizedState, c.updateQueue = o.updateQueue, a = o.dependencies, c.dependencies = a === null ? null : {
                lanes: a.lanes,
                firstContext: a.firstContext
            }, c.sibling = o.sibling, c.index = o.index, c.ref = o.ref, c.refCleanup = o.refCleanup, c;
        }
        function nw(o, a) {
            o.flags &= 65011714;
            var c = o.alternate;
            return c === null ? (o.childLanes = 0, o.lanes = a, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = c.childLanes, o.lanes = c.lanes, o.child = c.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = c.memoizedProps, o.memoizedState = c.memoizedState, o.updateQueue = c.updateQueue, o.type = c.type, a = c.dependencies, o.dependencies = a === null ? null : {
                lanes: a.lanes,
                firstContext: a.firstContext
            }), o;
        }
        function r1(o, a, c, d, g, y) {
            var E = 0;
            if (d = o, typeof o == "function") v2(o) && (E = 1);
            else if (typeof o == "string") E = NO(o, c, de.current) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
            else e: switch(o){
                case O:
                    return o = Tr(31, c, a, g), o.elementType = O, o.lanes = y, o;
                case _:
                    return aa(c.children, g, y, a);
                case I:
                    E = 8, g |= 24;
                    break;
                case k:
                    return o = Tr(12, c, a, g | 2), o.elementType = k, o.lanes = y, o;
                case H:
                    return o = Tr(13, c, a, g), o.elementType = H, o.lanes = y, o;
                case F:
                    return o = Tr(19, c, a, g), o.elementType = F, o.lanes = y, o;
                default:
                    if (typeof o == "object" && o !== null) switch(o.$$typeof){
                        case P:
                            E = 10;
                            break e;
                        case G:
                            E = 9;
                            break e;
                        case J:
                            E = 11;
                            break e;
                        case $:
                            E = 14;
                            break e;
                        case Y:
                            E = 16, d = null;
                            break e;
                    }
                    E = 29, c = Error(r(130, o === null ? "null" : typeof o, "")), d = null;
            }
            return a = Tr(E, c, a, g), a.elementType = o, a.type = d, a.lanes = y, a;
        }
        function aa(o, a, c, d) {
            return o = Tr(7, o, d, a), o.lanes = c, o;
        }
        function E2(o, a, c) {
            return o = Tr(6, o, null, a), o.lanes = c, o;
        }
        function rw(o) {
            var a = Tr(18, null, null, 0);
            return a.stateNode = o, a;
        }
        function A2(o, a, c) {
            return a = Tr(4, o.children !== null ? o.children : [], o.key, a), a.lanes = c, a.stateNode = {
                containerInfo: o.containerInfo,
                pendingChildren: null,
                implementation: o.implementation
            }, a;
        }
        var sw = new WeakMap;
        function jr(o, a) {
            if (typeof o == "object" && o !== null) {
                var c = sw.get(o);
                return c !== void 0 ? c : (a = {
                    value: o,
                    source: a,
                    stack: Lf(a)
                }, sw.set(o, a), a);
            }
            return {
                value: o,
                source: a,
                stack: Lf(a)
            };
        }
        var ml = [], yl = 0, s1 = null, Fu = 0, Xr = [], Jr = 0, no = null, qs = 1, Ks = "";
        function Ei(o, a) {
            ml[yl++] = Fu, ml[yl++] = s1, s1 = o, Fu = a;
        }
        function iw(o, a, c) {
            Xr[Jr++] = qs, Xr[Jr++] = Ks, Xr[Jr++] = no, no = o;
            var d = qs;
            o = Ks;
            var g = 32 - le(d) - 1;
            d &= ~(1 << g), c += 1;
            var y = 32 - le(a) + g;
            if (30 < y) {
                var E = g - g % 5;
                y = (d & (1 << E) - 1).toString(32), d >>= E, g -= E, qs = 1 << 32 - le(a) + g | c << g | d, Ks = y + o;
            } else qs = 1 << y | c << g | d, Ks = o;
        }
        function S2(o) {
            o.return !== null && (Ei(o, 1), iw(o, 1, 0));
        }
        function I2(o) {
            for(; o === s1;)s1 = ml[--yl], ml[yl] = null, Fu = ml[--yl], ml[yl] = null;
            for(; o === no;)no = Xr[--Jr], Xr[Jr] = null, Ks = Xr[--Jr], Xr[Jr] = null, qs = Xr[--Jr], Xr[Jr] = null;
        }
        function ow(o, a) {
            Xr[Jr++] = qs, Xr[Jr++] = Ks, Xr[Jr++] = no, qs = a.id, Ks = a.overflow, no = o;
        }
        var bn = null, $t = null, Ze = !1, ro = null, Zr = !1, C2 = Error(r(519));
        function so(o) {
            var a = Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
            throw Vu(jr(a, o)), C2;
        }
        function aw(o) {
            var a = o.stateNode, c = o.type, d = o.memoizedProps;
            switch(a[wn] = o, a[or] = d, c){
                case "dialog":
                    Ke("cancel", a), Ke("close", a);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Ke("load", a);
                    break;
                case "video":
                case "audio":
                    for(c = 0; c < uh.length; c++)Ke(uh[c], a);
                    break;
                case "source":
                    Ke("error", a);
                    break;
                case "img":
                case "image":
                case "link":
                    Ke("error", a), Ke("load", a);
                    break;
                case "details":
                    Ke("toggle", a);
                    break;
                case "input":
                    Ke("invalid", a), v5(a, d.value, d.defaultValue, d.checked, d.defaultChecked, d.type, d.name, !0);
                    break;
                case "select":
                    Ke("invalid", a);
                    break;
                case "textarea":
                    Ke("invalid", a), A5(a, d.value, d.defaultValue, d.children);
            }
            c = d.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || a.textContent === "" + c || d.suppressHydrationWarning === !0 || I7(a.textContent, c) ? (d.popover != null && (Ke("beforetoggle", a), Ke("toggle", a)), d.onScroll != null && Ke("scroll", a), d.onScrollEnd != null && Ke("scrollend", a), d.onClick != null && (a.onclick = wi), a = !0) : a = !1, a || so(o, !0);
        }
        function lw(o) {
            for(bn = o.return; bn;)switch(bn.tag){
                case 5:
                case 31:
                case 13:
                    Zr = !1;
                    return;
                case 27:
                case 3:
                    Zr = !0;
                    return;
                default:
                    bn = bn.return;
            }
        }
        function wl(o) {
            if (o !== bn) return !1;
            if (!Ze) return lw(o), Ze = !0, !1;
            var a = o.tag, c;
            if ((c = a !== 3 && a !== 27) && ((c = a === 5) && (c = o.type, c = !(c !== "form" && c !== "button") || Hm(o.type, o.memoizedProps)), c = !c), c && $t && so(o), lw(o), a === 13) {
                if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
                $t = R7(o);
            } else if (a === 31) {
                if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
                $t = R7(o);
            } else a === 27 ? (a = $t, bo(o.type) ? (o = Ym, Ym = null, $t = o) : $t = a) : $t = bn ? ts(o.stateNode.nextSibling) : null;
            return !0;
        }
        function la() {
            $t = bn = null, Ze = !1;
        }
        function T2() {
            var o = ro;
            return o !== null && (hr === null ? hr = o : hr.push.apply(hr, o), ro = null), o;
        }
        function Vu(o) {
            ro === null ? ro = [
                o
            ] : ro.push(o);
        }
        var _2 = x(null), ca = null, Ai = null;
        function io(o, a, c) {
            pe(_2, a._currentValue), a._currentValue = c;
        }
        function Si(o) {
            o._currentValue = _2.current, Q(_2);
        }
        function x2(o, a, c) {
            for(; o !== null;){
                var d = o.alternate;
                if ((o.childLanes & a) !== a ? (o.childLanes |= a, d !== null && (d.childLanes |= a)) : d !== null && (d.childLanes & a) !== a && (d.childLanes |= a), o === c) break;
                o = o.return;
            }
        }
        function D2(o, a, c, d) {
            var g = o.child;
            for(g !== null && (g.return = o); g !== null;){
                var y = g.dependencies;
                if (y !== null) {
                    var E = g.child;
                    y = y.firstContext;
                    e: for(; y !== null;){
                        var C = y;
                        y = g;
                        for(var R = 0; R < a.length; R++)if (C.context === a[R]) {
                            y.lanes |= c, C = y.alternate, C !== null && (C.lanes |= c), x2(y.return, c, o), d || (E = null);
                            break e;
                        }
                        y = C.next;
                    }
                } else if (g.tag === 18) {
                    if (E = g.return, E === null) throw Error(r(341));
                    E.lanes |= c, y = E.alternate, y !== null && (y.lanes |= c), x2(E, c, o), E = null;
                } else E = g.child;
                if (E !== null) E.return = g;
                else for(E = g; E !== null;){
                    if (E === o) {
                        E = null;
                        break;
                    }
                    if (g = E.sibling, g !== null) {
                        g.return = E.return, E = g;
                        break;
                    }
                    E = E.return;
                }
                g = E;
            }
        }
        function bl(o, a, c, d) {
            o = null;
            for(var g = a, y = !1; g !== null;){
                if (!y) {
                    if ((g.flags & 524288) !== 0) y = !0;
                    else if ((g.flags & 262144) !== 0) break;
                }
                if (g.tag === 10) {
                    var E = g.alternate;
                    if (E === null) throw Error(r(387));
                    if (E = E.memoizedProps, E !== null) {
                        var C = g.type;
                        Cr(g.pendingProps.value, E.value) || (o !== null ? o.push(C) : o = [
                            C
                        ]);
                    }
                } else if (g === Te.current) {
                    if (E = g.alternate, E === null) throw Error(r(387));
                    E.memoizedState.memoizedState !== g.memoizedState.memoizedState && (o !== null ? o.push(gh) : o = [
                        gh
                    ]);
                }
                g = g.return;
            }
            o !== null && D2(a, o, c, d), a.flags |= 262144;
        }
        function i1(o) {
            for(o = o.firstContext; o !== null;){
                if (!Cr(o.context._currentValue, o.memoizedValue)) return !0;
                o = o.next;
            }
            return !1;
        }
        function ua(o) {
            ca = o, Ai = null, o = o.dependencies, o !== null && (o.firstContext = null);
        }
        function vn(o) {
            return cw(ca, o);
        }
        function o1(o, a) {
            return ca === null && ua(o), cw(o, a);
        }
        function cw(o, a) {
            var c = a._currentValue;
            if (a = {
                context: a,
                memoizedValue: c,
                next: null
            }, Ai === null) {
                if (o === null) throw Error(r(308));
                Ai = a, o.dependencies = {
                    lanes: 0,
                    firstContext: a
                }, o.flags |= 524288;
            } else Ai = Ai.next = a;
            return c;
        }
        var RR = typeof AbortController < "u" ? AbortController : function() {
            var o = [], a = this.signal = {
                aborted: !1,
                addEventListener: function(c, d) {
                    o.push(d);
                }
            };
            this.abort = function() {
                a.aborted = !0, o.forEach(function(c) {
                    return c();
                });
            };
        }, OR = n.unstable_scheduleCallback, $R = n.unstable_NormalPriority, en = {
            $$typeof: P,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0
        };
        function B2() {
            return {
                controller: new RR,
                data: new Map,
                refCount: 0
            };
        }
        function Hu(o) {
            o.refCount--, o.refCount === 0 && OR($R, function() {
                o.controller.abort();
            });
        }
        var Qu = null, P2 = 0, vl = 0, El = null;
        function MR(o, a) {
            if (Qu === null) {
                var c = Qu = [];
                P2 = 0, vl = Om(), El = {
                    status: "pending",
                    value: void 0,
                    then: function(d) {
                        c.push(d);
                    }
                };
            }
            return P2++, a.then(uw, uw), a;
        }
        function uw() {
            if (--P2 === 0 && Qu !== null) {
                El !== null && (El.status = "fulfilled");
                var o = Qu;
                Qu = null, vl = 0, El = null;
                for(var a = 0; a < o.length; a++)(0, o[a])();
            }
        }
        function NR(o, a) {
            var c = [], d = {
                status: "pending",
                value: null,
                reason: null,
                then: function(g) {
                    c.push(g);
                }
            };
            return o.then(function() {
                d.status = "fulfilled", d.value = a;
                for(var g = 0; g < c.length; g++)(0, c[g])(a);
            }, function(g) {
                for(d.status = "rejected", d.reason = g, g = 0; g < c.length; g++)(0, c[g])(void 0);
            }), d;
        }
        var hw = B.S;
        B.S = function(o, a) {
            Yb = dn(), typeof a == "object" && a !== null && typeof a.then == "function" && MR(o, a), hw !== null && hw(o, a);
        };
        var ha = x(null);
        function k2() {
            var o = ha.current;
            return o !== null ? o : Ct.pooledCache;
        }
        function a1(o, a) {
            a === null ? pe(ha, ha.current) : pe(ha, a.pool);
        }
        function dw() {
            var o = k2();
            return o === null ? null : {
                parent: en._currentValue,
                pool: o
            };
        }
        var Al = Error(r(460)), R2 = Error(r(474)), l1 = Error(r(542)), c1 = {
            then: function() {}
        };
        function fw(o) {
            return o = o.status, o === "fulfilled" || o === "rejected";
        }
        function pw(o, a, c) {
            switch(c = o[c], c === void 0 ? o.push(a) : c !== a && (a.then(wi, wi), a = c), a.status){
                case "fulfilled":
                    return a.value;
                case "rejected":
                    throw o = a.reason, mw(o), o;
                default:
                    if (typeof a.status == "string") a.then(wi, wi);
                    else {
                        if (o = Ct, o !== null && 100 < o.shellSuspendCounter) throw Error(r(482));
                        o = a, o.status = "pending", o.then(function(d) {
                            if (a.status === "pending") {
                                var g = a;
                                g.status = "fulfilled", g.value = d;
                            }
                        }, function(d) {
                            if (a.status === "pending") {
                                var g = a;
                                g.status = "rejected", g.reason = d;
                            }
                        });
                    }
                    switch(a.status){
                        case "fulfilled":
                            return a.value;
                        case "rejected":
                            throw o = a.reason, mw(o), o;
                    }
                    throw fa = a, Al;
            }
        }
        function da(o) {
            try {
                var a = o._init;
                return a(o._payload);
            } catch (c) {
                throw c !== null && typeof c == "object" && typeof c.then == "function" ? (fa = c, Al) : c;
            }
        }
        var fa = null;
        function gw() {
            if (fa === null) throw Error(r(459));
            var o = fa;
            return fa = null, o;
        }
        function mw(o) {
            if (o === Al || o === l1) throw Error(r(483));
        }
        var Sl = null, qu = 0;
        function u1(o) {
            var a = qu;
            return qu += 1, Sl === null && (Sl = []), pw(Sl, o, a);
        }
        function Ku(o, a) {
            a = a.props.ref, o.ref = a !== void 0 ? a : null;
        }
        function h1(o, a) {
            throw a.$$typeof === w ? Error(r(525)) : (o = Object.prototype.toString.call(a), Error(r(31, o === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : o)));
        }
        function yw(o) {
            function a(W, M) {
                if (o) {
                    var X = W.deletions;
                    X === null ? (W.deletions = [
                        M
                    ], W.flags |= 16) : X.push(M);
                }
            }
            function c(W, M) {
                if (!o) return null;
                for(; M !== null;)a(W, M), M = M.sibling;
                return null;
            }
            function d(W) {
                for(var M = new Map; W !== null;)W.key !== null ? M.set(W.key, W) : M.set(W.index, W), W = W.sibling;
                return M;
            }
            function g(W, M) {
                return W = vi(W, M), W.index = 0, W.sibling = null, W;
            }
            function y(W, M, X) {
                return W.index = X, o ? (X = W.alternate, X !== null ? (X = X.index, X < M ? (W.flags |= 67108866, M) : X) : (W.flags |= 67108866, M)) : (W.flags |= 1048576, M);
            }
            function E(W) {
                return o && W.alternate === null && (W.flags |= 67108866), W;
            }
            function C(W, M, X, he) {
                return M === null || M.tag !== 6 ? (M = E2(X, W.mode, he), M.return = W, M) : (M = g(M, X), M.return = W, M);
            }
            function R(W, M, X, he) {
                var Pe = X.type;
                return Pe === _ ? ue(W, M, X.props.children, he, X.key) : M !== null && (M.elementType === Pe || typeof Pe == "object" && Pe !== null && Pe.$$typeof === Y && da(Pe) === M.type) ? (M = g(M, X.props), Ku(M, X), M.return = W, M) : (M = r1(X.type, X.key, X.props, null, W.mode, he), Ku(M, X), M.return = W, M);
            }
            function Z(W, M, X, he) {
                return M === null || M.tag !== 4 || M.stateNode.containerInfo !== X.containerInfo || M.stateNode.implementation !== X.implementation ? (M = A2(X, W.mode, he), M.return = W, M) : (M = g(M, X.children || []), M.return = W, M);
            }
            function ue(W, M, X, he, Pe) {
                return M === null || M.tag !== 7 ? (M = aa(X, W.mode, he, Pe), M.return = W, M) : (M = g(M, X), M.return = W, M);
            }
            function fe(W, M, X) {
                if (typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint") return M = E2("" + M, W.mode, X), M.return = W, M;
                if (typeof M == "object" && M !== null) {
                    switch(M.$$typeof){
                        case A:
                            return X = r1(M.type, M.key, M.props, null, W.mode, X), Ku(X, M), X.return = W, X;
                        case S:
                            return M = A2(M, W.mode, X), M.return = W, M;
                        case Y:
                            return M = da(M), fe(W, M, X);
                    }
                    if (q(M) || oe(M)) return M = aa(M, W.mode, X, null), M.return = W, M;
                    if (typeof M.then == "function") return fe(W, u1(M), X);
                    if (M.$$typeof === P) return fe(W, o1(W, M), X);
                    h1(W, M);
                }
                return null;
            }
            function te(W, M, X, he) {
                var Pe = M !== null ? M.key : null;
                if (typeof X == "string" && X !== "" || typeof X == "number" || typeof X == "bigint") return Pe !== null ? null : C(W, M, "" + X, he);
                if (typeof X == "object" && X !== null) {
                    switch(X.$$typeof){
                        case A:
                            return X.key === Pe ? R(W, M, X, he) : null;
                        case S:
                            return X.key === Pe ? Z(W, M, X, he) : null;
                        case Y:
                            return X = da(X), te(W, M, X, he);
                    }
                    if (q(X) || oe(X)) return Pe !== null ? null : ue(W, M, X, he, null);
                    if (typeof X.then == "function") return te(W, M, u1(X), he);
                    if (X.$$typeof === P) return te(W, M, o1(W, X), he);
                    h1(W, X);
                }
                return null;
            }
            function ie(W, M, X, he, Pe) {
                if (typeof he == "string" && he !== "" || typeof he == "number" || typeof he == "bigint") return W = W.get(X) || null, C(M, W, "" + he, Pe);
                if (typeof he == "object" && he !== null) {
                    switch(he.$$typeof){
                        case A:
                            return W = W.get(he.key === null ? X : he.key) || null, R(M, W, he, Pe);
                        case S:
                            return W = W.get(he.key === null ? X : he.key) || null, Z(M, W, he, Pe);
                        case Y:
                            return he = da(he), ie(W, M, X, he, Pe);
                    }
                    if (q(he) || oe(he)) return W = W.get(X) || null, ue(M, W, he, Pe, null);
                    if (typeof he.then == "function") return ie(W, M, X, u1(he), Pe);
                    if (he.$$typeof === P) return ie(W, M, X, o1(M, he), Pe);
                    h1(M, he);
                }
                return null;
            }
            function Ie(W, M, X, he) {
                for(var Pe = null, st = null, _e = M, Fe = M = 0, We = null; _e !== null && Fe < X.length; Fe++){
                    _e.index > Fe ? (We = _e, _e = null) : We = _e.sibling;
                    var it = te(W, _e, X[Fe], he);
                    if (it === null) {
                        _e === null && (_e = We);
                        break;
                    }
                    o && _e && it.alternate === null && a(W, _e), M = y(it, M, Fe), st === null ? Pe = it : st.sibling = it, st = it, _e = We;
                }
                if (Fe === X.length) return c(W, _e), Ze && Ei(W, Fe), Pe;
                if (_e === null) {
                    for(; Fe < X.length; Fe++)_e = fe(W, X[Fe], he), _e !== null && (M = y(_e, M, Fe), st === null ? Pe = _e : st.sibling = _e, st = _e);
                    return Ze && Ei(W, Fe), Pe;
                }
                for(_e = d(_e); Fe < X.length; Fe++)We = ie(_e, W, Fe, X[Fe], he), We !== null && (o && We.alternate !== null && _e.delete(We.key === null ? Fe : We.key), M = y(We, M, Fe), st === null ? Pe = We : st.sibling = We, st = We);
                return o && _e.forEach(function(Io) {
                    return a(W, Io);
                }), Ze && Ei(W, Fe), Pe;
            }
            function Oe(W, M, X, he) {
                if (X == null) throw Error(r(151));
                for(var Pe = null, st = null, _e = M, Fe = M = 0, We = null, it = X.next(); _e !== null && !it.done; Fe++, it = X.next()){
                    _e.index > Fe ? (We = _e, _e = null) : We = _e.sibling;
                    var Io = te(W, _e, it.value, he);
                    if (Io === null) {
                        _e === null && (_e = We);
                        break;
                    }
                    o && _e && Io.alternate === null && a(W, _e), M = y(Io, M, Fe), st === null ? Pe = Io : st.sibling = Io, st = Io, _e = We;
                }
                if (it.done) return c(W, _e), Ze && Ei(W, Fe), Pe;
                if (_e === null) {
                    for(; !it.done; Fe++, it = X.next())it = fe(W, it.value, he), it !== null && (M = y(it, M, Fe), st === null ? Pe = it : st.sibling = it, st = it);
                    return Ze && Ei(W, Fe), Pe;
                }
                for(_e = d(_e); !it.done; Fe++, it = X.next())it = ie(_e, W, Fe, it.value, he), it !== null && (o && it.alternate !== null && _e.delete(it.key === null ? Fe : it.key), M = y(it, M, Fe), st === null ? Pe = it : st.sibling = it, st = it);
                return o && _e.forEach(function(YO) {
                    return a(W, YO);
                }), Ze && Ei(W, Fe), Pe;
            }
            function bt(W, M, X, he) {
                if (typeof X == "object" && X !== null && X.type === _ && X.key === null && (X = X.props.children), typeof X == "object" && X !== null) {
                    switch(X.$$typeof){
                        case A:
                            e: {
                                for(var Pe = X.key; M !== null;){
                                    if (M.key === Pe) {
                                        if (Pe = X.type, Pe === _) {
                                            if (M.tag === 7) {
                                                c(W, M.sibling), he = g(M, X.props.children), he.return = W, W = he;
                                                break e;
                                            }
                                        } else if (M.elementType === Pe || typeof Pe == "object" && Pe !== null && Pe.$$typeof === Y && da(Pe) === M.type) {
                                            c(W, M.sibling), he = g(M, X.props), Ku(he, X), he.return = W, W = he;
                                            break e;
                                        }
                                        c(W, M);
                                        break;
                                    } else a(W, M);
                                    M = M.sibling;
                                }
                                X.type === _ ? (he = aa(X.props.children, W.mode, he, X.key), he.return = W, W = he) : (he = r1(X.type, X.key, X.props, null, W.mode, he), Ku(he, X), he.return = W, W = he);
                            }
                            return E(W);
                        case S:
                            e: {
                                for(Pe = X.key; M !== null;){
                                    if (M.key === Pe) if (M.tag === 4 && M.stateNode.containerInfo === X.containerInfo && M.stateNode.implementation === X.implementation) {
                                        c(W, M.sibling), he = g(M, X.children || []), he.return = W, W = he;
                                        break e;
                                    } else {
                                        c(W, M);
                                        break;
                                    }
                                    else a(W, M);
                                    M = M.sibling;
                                }
                                he = A2(X, W.mode, he), he.return = W, W = he;
                            }
                            return E(W);
                        case Y:
                            return X = da(X), bt(W, M, X, he);
                    }
                    if (q(X)) return Ie(W, M, X, he);
                    if (oe(X)) {
                        if (Pe = oe(X), typeof Pe != "function") throw Error(r(150));
                        return X = Pe.call(X), Oe(W, M, X, he);
                    }
                    if (typeof X.then == "function") return bt(W, M, u1(X), he);
                    if (X.$$typeof === P) return bt(W, M, o1(W, X), he);
                    h1(W, X);
                }
                return typeof X == "string" && X !== "" || typeof X == "number" || typeof X == "bigint" ? (X = "" + X, M !== null && M.tag === 6 ? (c(W, M.sibling), he = g(M, X), he.return = W, W = he) : (c(W, M), he = E2(X, W.mode, he), he.return = W, W = he), E(W)) : c(W, M);
            }
            return function(W, M, X, he) {
                try {
                    qu = 0;
                    var Pe = bt(W, M, X, he);
                    return Sl = null, Pe;
                } catch (_e) {
                    if (_e === Al || _e === l1) throw _e;
                    var st = Tr(29, _e, null, W.mode);
                    return st.lanes = he, st.return = W, st;
                }
            };
        }
        var pa = yw(!0), ww = yw(!1), oo = !1;
        function O2(o) {
            o.updateQueue = {
                baseState: o.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    lanes: 0,
                    hiddenCallbacks: null
                },
                callbacks: null
            };
        }
        function $2(o, a) {
            o = o.updateQueue, a.updateQueue === o && (a.updateQueue = {
                baseState: o.baseState,
                firstBaseUpdate: o.firstBaseUpdate,
                lastBaseUpdate: o.lastBaseUpdate,
                shared: o.shared,
                callbacks: null
            });
        }
        function ao(o) {
            return {
                lane: o,
                tag: 0,
                payload: null,
                callback: null,
                next: null
            };
        }
        function lo(o, a, c) {
            var d = o.updateQueue;
            if (d === null) return null;
            if (d = d.shared, (lt & 2) !== 0) {
                var g = d.pending;
                return g === null ? a.next = a : (a.next = g.next, g.next = a), d.pending = a, a = n1(o), tw(o, null, c), a;
            }
            return t1(o, d, a, c), n1(o);
        }
        function Gu(o, a, c) {
            if (a = a.updateQueue, a !== null && (a = a.shared, (c & 4194048) !== 0)) {
                var d = a.lanes;
                d &= o.pendingLanes, c |= d, a.lanes = c, c5(o, c);
            }
        }
        function M2(o, a) {
            var c = o.updateQueue, d = o.alternate;
            if (d !== null && (d = d.updateQueue, c === d)) {
                var g = null, y = null;
                if (c = c.firstBaseUpdate, c !== null) {
                    do {
                        var E = {
                            lane: c.lane,
                            tag: c.tag,
                            payload: c.payload,
                            callback: null,
                            next: null
                        };
                        y === null ? g = y = E : y = y.next = E, c = c.next;
                    }while (c !== null);
                    y === null ? g = y = a : y = y.next = a;
                } else g = y = a;
                c = {
                    baseState: d.baseState,
                    firstBaseUpdate: g,
                    lastBaseUpdate: y,
                    shared: d.shared,
                    callbacks: d.callbacks
                }, o.updateQueue = c;
                return;
            }
            o = c.lastBaseUpdate, o === null ? c.firstBaseUpdate = a : o.next = a, c.lastBaseUpdate = a;
        }
        var N2 = !1;
        function Yu() {
            if (N2) {
                var o = El;
                if (o !== null) throw o;
            }
        }
        function Wu(o, a, c, d) {
            N2 = !1;
            var g = o.updateQueue;
            oo = !1;
            var y = g.firstBaseUpdate, E = g.lastBaseUpdate, C = g.shared.pending;
            if (C !== null) {
                g.shared.pending = null;
                var R = C, Z = R.next;
                R.next = null, E === null ? y = Z : E.next = Z, E = R;
                var ue = o.alternate;
                ue !== null && (ue = ue.updateQueue, C = ue.lastBaseUpdate, C !== E && (C === null ? ue.firstBaseUpdate = Z : C.next = Z, ue.lastBaseUpdate = R));
            }
            if (y !== null) {
                var fe = g.baseState;
                E = 0, ue = Z = R = null, C = y;
                do {
                    var te = C.lane & -536870913, ie = te !== C.lane;
                    if (ie ? (Ye & te) === te : (d & te) === te) {
                        te !== 0 && te === vl && (N2 = !0), ue !== null && (ue = ue.next = {
                            lane: 0,
                            tag: C.tag,
                            payload: C.payload,
                            callback: null,
                            next: null
                        });
                        e: {
                            var Ie = o, Oe = C;
                            te = a;
                            var bt = c;
                            switch(Oe.tag){
                                case 1:
                                    if (Ie = Oe.payload, typeof Ie == "function") {
                                        fe = Ie.call(bt, fe, te);
                                        break e;
                                    }
                                    fe = Ie;
                                    break e;
                                case 3:
                                    Ie.flags = Ie.flags & -65537 | 128;
                                case 0:
                                    if (Ie = Oe.payload, te = typeof Ie == "function" ? Ie.call(bt, fe, te) : Ie, te == null) break e;
                                    fe = m({}, fe, te);
                                    break e;
                                case 2:
                                    oo = !0;
                            }
                        }
                        te = C.callback, te !== null && (o.flags |= 64, ie && (o.flags |= 8192), ie = g.callbacks, ie === null ? g.callbacks = [
                            te
                        ] : ie.push(te));
                    } else ie = {
                        lane: te,
                        tag: C.tag,
                        payload: C.payload,
                        callback: C.callback,
                        next: null
                    }, ue === null ? (Z = ue = ie, R = fe) : ue = ue.next = ie, E |= te;
                    if (C = C.next, C === null) {
                        if (C = g.shared.pending, C === null) break;
                        ie = C, C = ie.next, ie.next = null, g.lastBaseUpdate = ie, g.shared.pending = null;
                    }
                }while (!0);
                ue === null && (R = fe), g.baseState = R, g.firstBaseUpdate = Z, g.lastBaseUpdate = ue, y === null && (g.shared.lanes = 0), po |= E, o.lanes = E, o.memoizedState = fe;
            }
        }
        function bw(o, a) {
            if (typeof o != "function") throw Error(r(191, o));
            o.call(a);
        }
        function vw(o, a) {
            var c = o.callbacks;
            if (c !== null) for(o.callbacks = null, o = 0; o < c.length; o++)bw(c[o], a);
        }
        var Il = x(null), d1 = x(0);
        function Ew(o, a) {
            o = ki, pe(d1, o), pe(Il, a), ki = o | a.baseLanes;
        }
        function L2() {
            pe(d1, ki), pe(Il, Il.current);
        }
        function U2() {
            ki = d1.current, Q(Il), Q(d1);
        }
        var _r = x(null), es = null;
        function co(o) {
            var a = o.alternate;
            pe(Xt, Xt.current & 1), pe(_r, o), es === null && (a === null || Il.current !== null || a.memoizedState !== null) && (es = o);
        }
        function z2(o) {
            pe(Xt, Xt.current), pe(_r, o), es === null && (es = o);
        }
        function Aw(o) {
            o.tag === 22 ? (pe(Xt, Xt.current), pe(_r, o), es === null && (es = o)) : uo();
        }
        function uo() {
            pe(Xt, Xt.current), pe(_r, _r.current);
        }
        function xr(o) {
            Q(_r), es === o && (es = null), Q(Xt);
        }
        var Xt = x(0);
        function f1(o) {
            for(var a = o; a !== null;){
                if (a.tag === 13) {
                    var c = a.memoizedState;
                    if (c !== null && (c = c.dehydrated, c === null || Km(c) || Gm(c))) return a;
                } else if (a.tag === 19 && (a.memoizedProps.revealOrder === "forwards" || a.memoizedProps.revealOrder === "backwards" || a.memoizedProps.revealOrder === "unstable_legacy-backwards" || a.memoizedProps.revealOrder === "together")) {
                    if ((a.flags & 128) !== 0) return a;
                } else if (a.child !== null) {
                    a.child.return = a, a = a.child;
                    continue;
                }
                if (a === o) break;
                for(; a.sibling === null;){
                    if (a.return === null || a.return === o) return null;
                    a = a.return;
                }
                a.sibling.return = a.return, a = a.sibling;
            }
            return null;
        }
        var Ii = 0, ze = null, yt = null, tn = null, p1 = !1, Cl = !1, ga = !1, g1 = 0, ju = 0, Tl = null, LR = 0;
        function Gt() {
            throw Error(r(321));
        }
        function F2(o, a) {
            if (a === null) return !1;
            for(var c = 0; c < a.length && c < o.length; c++)if (!Cr(o[c], a[c])) return !1;
            return !0;
        }
        function V2(o, a, c, d, g, y) {
            return Ii = y, ze = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, B.H = o === null || o.memoizedState === null ? ib : rm, ga = !1, y = c(d, g), ga = !1, Cl && (y = Iw(a, c, d, g)), Sw(o), y;
        }
        function Sw(o) {
            B.H = Zu;
            var a = yt !== null && yt.next !== null;
            if (Ii = 0, tn = yt = ze = null, p1 = !1, ju = 0, Tl = null, a) throw Error(r(300));
            o === null || nn || (o = o.dependencies, o !== null && i1(o) && (nn = !0));
        }
        function Iw(o, a, c, d) {
            ze = o;
            var g = 0;
            do {
                if (Cl && (Tl = null), ju = 0, Cl = !1, 25 <= g) throw Error(r(301));
                if (g += 1, tn = yt = null, o.updateQueue != null) {
                    var y = o.updateQueue;
                    y.lastEffect = null, y.events = null, y.stores = null, y.memoCache != null && (y.memoCache.index = 0);
                }
                B.H = ob, y = a(c, d);
            }while (Cl);
            return y;
        }
        function UR() {
            var o = B.H, a = o.useState()[0];
            return a = typeof a.then == "function" ? Xu(a) : a, o = o.useState()[0], (yt !== null ? yt.memoizedState : null) !== o && (ze.flags |= 1024), a;
        }
        function H2() {
            var o = g1 !== 0;
            return g1 = 0, o;
        }
        function Q2(o, a, c) {
            a.updateQueue = o.updateQueue, a.flags &= -2053, o.lanes &= ~c;
        }
        function q2(o) {
            if (p1) {
                for(o = o.memoizedState; o !== null;){
                    var a = o.queue;
                    a !== null && (a.pending = null), o = o.next;
                }
                p1 = !1;
            }
            Ii = 0, tn = yt = ze = null, Cl = !1, ju = g1 = 0, Tl = null;
        }
        function Zn() {
            var o = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            return tn === null ? ze.memoizedState = tn = o : tn = tn.next = o, tn;
        }
        function Jt() {
            if (yt === null) {
                var o = ze.alternate;
                o = o !== null ? o.memoizedState : null;
            } else o = yt.next;
            var a = tn === null ? ze.memoizedState : tn.next;
            if (a !== null) tn = a, yt = o;
            else {
                if (o === null) throw ze.alternate === null ? Error(r(467)) : Error(r(310));
                yt = o, o = {
                    memoizedState: yt.memoizedState,
                    baseState: yt.baseState,
                    baseQueue: yt.baseQueue,
                    queue: yt.queue,
                    next: null
                }, tn === null ? ze.memoizedState = tn = o : tn = tn.next = o;
            }
            return tn;
        }
        function m1() {
            return {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null
            };
        }
        function Xu(o) {
            var a = ju;
            return ju += 1, Tl === null && (Tl = []), o = pw(Tl, o, a), a = ze, (tn === null ? a.memoizedState : tn.next) === null && (a = a.alternate, B.H = a === null || a.memoizedState === null ? ib : rm), o;
        }
        function y1(o) {
            if (o !== null && typeof o == "object") {
                if (typeof o.then == "function") return Xu(o);
                if (o.$$typeof === P) return vn(o);
            }
            throw Error(r(438, String(o)));
        }
        function K2(o) {
            var a = null, c = ze.updateQueue;
            if (c !== null && (a = c.memoCache), a == null) {
                var d = ze.alternate;
                d !== null && (d = d.updateQueue, d !== null && (d = d.memoCache, d != null && (a = {
                    data: d.data.map(function(g) {
                        return g.slice();
                    }),
                    index: 0
                })));
            }
            if (a == null && (a = {
                data: [],
                index: 0
            }), c === null && (c = m1(), ze.updateQueue = c), c.memoCache = a, c = a.data[a.index], c === void 0) for(c = a.data[a.index] = Array(o), d = 0; d < o; d++)c[d] = se;
            return a.index++, c;
        }
        function Ci(o, a) {
            return typeof a == "function" ? a(o) : a;
        }
        function w1(o) {
            var a = Jt();
            return G2(a, yt, o);
        }
        function G2(o, a, c) {
            var d = o.queue;
            if (d === null) throw Error(r(311));
            d.lastRenderedReducer = c;
            var g = o.baseQueue, y = d.pending;
            if (y !== null) {
                if (g !== null) {
                    var E = g.next;
                    g.next = y.next, y.next = E;
                }
                a.baseQueue = g = y, d.pending = null;
            }
            if (y = o.baseState, g === null) o.memoizedState = y;
            else {
                a = g.next;
                var C = E = null, R = null, Z = a, ue = !1;
                do {
                    var fe = Z.lane & -536870913;
                    if (fe !== Z.lane ? (Ye & fe) === fe : (Ii & fe) === fe) {
                        var te = Z.revertLane;
                        if (te === 0) R !== null && (R = R.next = {
                            lane: 0,
                            revertLane: 0,
                            gesture: null,
                            action: Z.action,
                            hasEagerState: Z.hasEagerState,
                            eagerState: Z.eagerState,
                            next: null
                        }), fe === vl && (ue = !0);
                        else if ((Ii & te) === te) {
                            Z = Z.next, te === vl && (ue = !0);
                            continue;
                        } else fe = {
                            lane: 0,
                            revertLane: Z.revertLane,
                            gesture: null,
                            action: Z.action,
                            hasEagerState: Z.hasEagerState,
                            eagerState: Z.eagerState,
                            next: null
                        }, R === null ? (C = R = fe, E = y) : R = R.next = fe, ze.lanes |= te, po |= te;
                        fe = Z.action, ga && c(y, fe), y = Z.hasEagerState ? Z.eagerState : c(y, fe);
                    } else te = {
                        lane: fe,
                        revertLane: Z.revertLane,
                        gesture: Z.gesture,
                        action: Z.action,
                        hasEagerState: Z.hasEagerState,
                        eagerState: Z.eagerState,
                        next: null
                    }, R === null ? (C = R = te, E = y) : R = R.next = te, ze.lanes |= fe, po |= fe;
                    Z = Z.next;
                }while (Z !== null && Z !== a);
                if (R === null ? E = y : R.next = C, !Cr(y, o.memoizedState) && (nn = !0, ue && (c = El, c !== null))) throw c;
                o.memoizedState = y, o.baseState = E, o.baseQueue = R, d.lastRenderedState = y;
            }
            return g === null && (d.lanes = 0), [
                o.memoizedState,
                d.dispatch
            ];
        }
        function Y2(o) {
            var a = Jt(), c = a.queue;
            if (c === null) throw Error(r(311));
            c.lastRenderedReducer = o;
            var d = c.dispatch, g = c.pending, y = a.memoizedState;
            if (g !== null) {
                c.pending = null;
                var E = g = g.next;
                do y = o(y, E.action), E = E.next;
                while (E !== g);
                Cr(y, a.memoizedState) || (nn = !0), a.memoizedState = y, a.baseQueue === null && (a.baseState = y), c.lastRenderedState = y;
            }
            return [
                y,
                d
            ];
        }
        function Cw(o, a, c) {
            var d = ze, g = Jt(), y = Ze;
            if (y) {
                if (c === void 0) throw Error(r(407));
                c = c();
            } else c = a();
            var E = !Cr((yt || g).memoizedState, c);
            if (E && (g.memoizedState = c, nn = !0), g = g.queue, X2(xw.bind(null, d, g, o), [
                o
            ]), g.getSnapshot !== a || E || tn !== null && tn.memoizedState.tag & 1) {
                if (d.flags |= 2048, _l(9, {
                    destroy: void 0
                }, _w.bind(null, d, g, c, a), null), Ct === null) throw Error(r(349));
                y || (Ii & 127) !== 0 || Tw(d, a, c);
            }
            return c;
        }
        function Tw(o, a, c) {
            o.flags |= 16384, o = {
                getSnapshot: a,
                value: c
            }, a = ze.updateQueue, a === null ? (a = m1(), ze.updateQueue = a, a.stores = [
                o
            ]) : (c = a.stores, c === null ? a.stores = [
                o
            ] : c.push(o));
        }
        function _w(o, a, c, d) {
            a.value = c, a.getSnapshot = d, Dw(a) && Bw(o);
        }
        function xw(o, a, c) {
            return c(function() {
                Dw(a) && Bw(o);
            });
        }
        function Dw(o) {
            var a = o.getSnapshot;
            o = o.value;
            try {
                var c = a();
                return !Cr(o, c);
            } catch  {
                return !0;
            }
        }
        function Bw(o) {
            var a = oa(o, 2);
            a !== null && dr(a, o, 2);
        }
        function W2(o) {
            var a = Zn();
            if (typeof o == "function") {
                var c = o;
                if (o = c(), ga) {
                    ne(!0);
                    try {
                        c();
                    } finally{
                        ne(!1);
                    }
                }
            }
            return a.memoizedState = a.baseState = o, a.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ci,
                lastRenderedState: o
            }, a;
        }
        function Pw(o, a, c, d) {
            return o.baseState = c, G2(o, yt, typeof d == "function" ? d : Ci);
        }
        function zR(o, a, c, d, g) {
            if (E1(o)) throw Error(r(485));
            if (o = a.action, o !== null) {
                var y = {
                    payload: g,
                    action: o,
                    next: null,
                    isTransition: !0,
                    status: "pending",
                    value: null,
                    reason: null,
                    listeners: [],
                    then: function(E) {
                        y.listeners.push(E);
                    }
                };
                B.T !== null ? c(!0) : y.isTransition = !1, d(y), c = a.pending, c === null ? (y.next = a.pending = y, kw(a, y)) : (y.next = c.next, a.pending = c.next = y);
            }
        }
        function kw(o, a) {
            var c = a.action, d = a.payload, g = o.state;
            if (a.isTransition) {
                var y = B.T, E = {};
                B.T = E;
                try {
                    var C = c(g, d), R = B.S;
                    R !== null && R(E, C), Rw(o, a, C);
                } catch (Z) {
                    j2(o, a, Z);
                } finally{
                    y !== null && E.types !== null && (y.types = E.types), B.T = y;
                }
            } else try {
                y = c(g, d), Rw(o, a, y);
            } catch (Z) {
                j2(o, a, Z);
            }
        }
        function Rw(o, a, c) {
            c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(function(d) {
                Ow(o, a, d);
            }, function(d) {
                return j2(o, a, d);
            }) : Ow(o, a, c);
        }
        function Ow(o, a, c) {
            a.status = "fulfilled", a.value = c, $w(a), o.state = c, a = o.pending, a !== null && (c = a.next, c === a ? o.pending = null : (c = c.next, a.next = c, kw(o, c)));
        }
        function j2(o, a, c) {
            var d = o.pending;
            if (o.pending = null, d !== null) {
                d = d.next;
                do a.status = "rejected", a.reason = c, $w(a), a = a.next;
                while (a !== d);
            }
            o.action = null;
        }
        function $w(o) {
            o = o.listeners;
            for(var a = 0; a < o.length; a++)(0, o[a])();
        }
        function Mw(o, a) {
            return a;
        }
        function Nw(o, a) {
            if (Ze) {
                var c = Ct.formState;
                if (c !== null) {
                    e: {
                        var d = ze;
                        if (Ze) {
                            if ($t) {
                                t: {
                                    for(var g = $t, y = Zr; g.nodeType !== 8;){
                                        if (!y) {
                                            g = null;
                                            break t;
                                        }
                                        if (g = ts(g.nextSibling), g === null) {
                                            g = null;
                                            break t;
                                        }
                                    }
                                    y = g.data, g = y === "F!" || y === "F" ? g : null;
                                }
                                if (g) {
                                    $t = ts(g.nextSibling), d = g.data === "F!";
                                    break e;
                                }
                            }
                            so(d);
                        }
                        d = !1;
                    }
                    d && (a = c[0]);
                }
            }
            return c = Zn(), c.memoizedState = c.baseState = a, d = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Mw,
                lastRenderedState: a
            }, c.queue = d, c = nb.bind(null, ze, d), d.dispatch = c, d = W2(!1), y = nm.bind(null, ze, !1, d.queue), d = Zn(), g = {
                state: a,
                dispatch: null,
                action: o,
                pending: null
            }, d.queue = g, c = zR.bind(null, ze, g, y, c), g.dispatch = c, d.memoizedState = o, [
                a,
                c,
                !1
            ];
        }
        function Lw(o) {
            var a = Jt();
            return Uw(a, yt, o);
        }
        function Uw(o, a, c) {
            if (a = G2(o, a, Mw)[0], o = w1(Ci)[0], typeof a == "object" && a !== null && typeof a.then == "function") try {
                var d = Xu(a);
            } catch (E) {
                throw E === Al ? l1 : E;
            }
            else d = a;
            a = Jt();
            var g = a.queue, y = g.dispatch;
            return c !== a.memoizedState && (ze.flags |= 2048, _l(9, {
                destroy: void 0
            }, FR.bind(null, g, c), null)), [
                d,
                y,
                o
            ];
        }
        function FR(o, a) {
            o.action = a;
        }
        function zw(o) {
            var a = Jt(), c = yt;
            if (c !== null) return Uw(a, c, o);
            Jt(), a = a.memoizedState, c = Jt();
            var d = c.queue.dispatch;
            return c.memoizedState = o, [
                a,
                d,
                !1
            ];
        }
        function _l(o, a, c, d) {
            return o = {
                tag: o,
                create: c,
                deps: d,
                inst: a,
                next: null
            }, a = ze.updateQueue, a === null && (a = m1(), ze.updateQueue = a), c = a.lastEffect, c === null ? a.lastEffect = o.next = o : (d = c.next, c.next = o, o.next = d, a.lastEffect = o), o;
        }
        function Fw() {
            return Jt().memoizedState;
        }
        function b1(o, a, c, d) {
            var g = Zn();
            ze.flags |= o, g.memoizedState = _l(1 | a, {
                destroy: void 0
            }, c, d === void 0 ? null : d);
        }
        function v1(o, a, c, d) {
            var g = Jt();
            d = d === void 0 ? null : d;
            var y = g.memoizedState.inst;
            yt !== null && d !== null && F2(d, yt.memoizedState.deps) ? g.memoizedState = _l(a, y, c, d) : (ze.flags |= o, g.memoizedState = _l(1 | a, y, c, d));
        }
        function Vw(o, a) {
            b1(8390656, 8, o, a);
        }
        function X2(o, a) {
            v1(2048, 8, o, a);
        }
        function VR(o) {
            ze.flags |= 4;
            var a = ze.updateQueue;
            if (a === null) a = m1(), ze.updateQueue = a, a.events = [
                o
            ];
            else {
                var c = a.events;
                c === null ? a.events = [
                    o
                ] : c.push(o);
            }
        }
        function Hw(o) {
            var a = Jt().memoizedState;
            return VR({
                ref: a,
                nextImpl: o
            }), function() {
                if ((lt & 2) !== 0) throw Error(r(440));
                return a.impl.apply(void 0, arguments);
            };
        }
        function Qw(o, a) {
            return v1(4, 2, o, a);
        }
        function qw(o, a) {
            return v1(4, 4, o, a);
        }
        function Kw(o, a) {
            if (typeof a == "function") {
                o = o();
                var c = a(o);
                return function() {
                    typeof c == "function" ? c() : a(null);
                };
            }
            if (a != null) return o = o(), a.current = o, function() {
                a.current = null;
            };
        }
        function Gw(o, a, c) {
            c = c != null ? c.concat([
                o
            ]) : null, v1(4, 4, Kw.bind(null, a, o), c);
        }
        function J2() {}
        function Yw(o, a) {
            var c = Jt();
            a = a === void 0 ? null : a;
            var d = c.memoizedState;
            return a !== null && F2(a, d[1]) ? d[0] : (c.memoizedState = [
                o,
                a
            ], o);
        }
        function Ww(o, a) {
            var c = Jt();
            a = a === void 0 ? null : a;
            var d = c.memoizedState;
            if (a !== null && F2(a, d[1])) return d[0];
            if (d = o(), ga) {
                ne(!0);
                try {
                    o();
                } finally{
                    ne(!1);
                }
            }
            return c.memoizedState = [
                d,
                a
            ], d;
        }
        function Z2(o, a, c) {
            return c === void 0 || (Ii & 1073741824) !== 0 && (Ye & 261930) === 0 ? o.memoizedState = a : (o.memoizedState = c, o = jb(), ze.lanes |= o, po |= o, c);
        }
        function jw(o, a, c, d) {
            return Cr(c, a) ? c : Il.current !== null ? (o = Z2(o, c, d), Cr(o, a) || (nn = !0), o) : (Ii & 42) === 0 || (Ii & 1073741824) !== 0 && (Ye & 261930) === 0 ? (nn = !0, o.memoizedState = c) : (o = jb(), ze.lanes |= o, po |= o, a);
        }
        function Xw(o, a, c, d, g) {
            var y = z.p;
            z.p = y !== 0 && 8 > y ? y : 8;
            var E = B.T, C = {};
            B.T = C, nm(o, !1, a, c);
            try {
                var R = g(), Z = B.S;
                if (Z !== null && Z(C, R), R !== null && typeof R == "object" && typeof R.then == "function") {
                    var ue = NR(R, d);
                    Ju(o, a, ue, Pr(o));
                } else Ju(o, a, d, Pr(o));
            } catch (fe) {
                Ju(o, a, {
                    then: function() {},
                    status: "rejected",
                    reason: fe
                }, Pr());
            } finally{
                z.p = y, E !== null && C.types !== null && (E.types = C.types), B.T = E;
            }
        }
        function HR() {}
        function em(o, a, c, d) {
            if (o.tag !== 5) throw Error(r(476));
            var g = Jw(o).queue;
            Xw(o, g, a, ee, c === null ? HR : function() {
                return Zw(o), c(d);
            });
        }
        function Jw(o) {
            var a = o.memoizedState;
            if (a !== null) return a;
            a = {
                memoizedState: ee,
                baseState: ee,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Ci,
                    lastRenderedState: ee
                },
                next: null
            };
            var c = {};
            return a.next = {
                memoizedState: c,
                baseState: c,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Ci,
                    lastRenderedState: c
                },
                next: null
            }, o.memoizedState = a, o = o.alternate, o !== null && (o.memoizedState = a), a;
        }
        function Zw(o) {
            var a = Jw(o);
            a.next === null && (a = o.alternate.memoizedState), Ju(o, a.next.queue, {}, Pr());
        }
        function tm() {
            return vn(gh);
        }
        function eb() {
            return Jt().memoizedState;
        }
        function tb() {
            return Jt().memoizedState;
        }
        function QR(o) {
            for(var a = o.return; a !== null;){
                switch(a.tag){
                    case 24:
                    case 3:
                        var c = Pr();
                        o = ao(c);
                        var d = lo(a, o, c);
                        d !== null && (dr(d, a, c), Gu(d, a, c)), a = {
                            cache: B2()
                        }, o.payload = a;
                        return;
                }
                a = a.return;
            }
        }
        function qR(o, a, c) {
            var d = Pr();
            c = {
                lane: d,
                revertLane: 0,
                gesture: null,
                action: c,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, E1(o) ? rb(a, c) : (c = b2(o, a, c, d), c !== null && (dr(c, o, d), sb(c, a, d)));
        }
        function nb(o, a, c) {
            var d = Pr();
            Ju(o, a, c, d);
        }
        function Ju(o, a, c, d) {
            var g = {
                lane: d,
                revertLane: 0,
                gesture: null,
                action: c,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
            if (E1(o)) rb(a, g);
            else {
                var y = o.alternate;
                if (o.lanes === 0 && (y === null || y.lanes === 0) && (y = a.lastRenderedReducer, y !== null)) try {
                    var E = a.lastRenderedState, C = y(E, c);
                    if (g.hasEagerState = !0, g.eagerState = C, Cr(C, E)) return t1(o, a, g, 0), Ct === null && e1(), !1;
                } catch  {}
                if (c = b2(o, a, g, d), c !== null) return dr(c, o, d), sb(c, a, d), !0;
            }
            return !1;
        }
        function nm(o, a, c, d) {
            if (d = {
                lane: 2,
                revertLane: Om(),
                gesture: null,
                action: d,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, E1(o)) {
                if (a) throw Error(r(479));
            } else a = b2(o, c, d, 2), a !== null && dr(a, o, 2);
        }
        function E1(o) {
            var a = o.alternate;
            return o === ze || a !== null && a === ze;
        }
        function rb(o, a) {
            Cl = p1 = !0;
            var c = o.pending;
            c === null ? a.next = a : (a.next = c.next, c.next = a), o.pending = a;
        }
        function sb(o, a, c) {
            if ((c & 4194048) !== 0) {
                var d = a.lanes;
                d &= o.pendingLanes, c |= d, a.lanes = c, c5(o, c);
            }
        }
        var Zu = {
            readContext: vn,
            use: y1,
            useCallback: Gt,
            useContext: Gt,
            useEffect: Gt,
            useImperativeHandle: Gt,
            useLayoutEffect: Gt,
            useInsertionEffect: Gt,
            useMemo: Gt,
            useReducer: Gt,
            useRef: Gt,
            useState: Gt,
            useDebugValue: Gt,
            useDeferredValue: Gt,
            useTransition: Gt,
            useSyncExternalStore: Gt,
            useId: Gt,
            useHostTransitionStatus: Gt,
            useFormState: Gt,
            useActionState: Gt,
            useOptimistic: Gt,
            useMemoCache: Gt,
            useCacheRefresh: Gt
        };
        Zu.useEffectEvent = Gt;
        var ib = {
            readContext: vn,
            use: y1,
            useCallback: function(o, a) {
                return Zn().memoizedState = [
                    o,
                    a === void 0 ? null : a
                ], o;
            },
            useContext: vn,
            useEffect: Vw,
            useImperativeHandle: function(o, a, c) {
                c = c != null ? c.concat([
                    o
                ]) : null, b1(4194308, 4, Kw.bind(null, a, o), c);
            },
            useLayoutEffect: function(o, a) {
                return b1(4194308, 4, o, a);
            },
            useInsertionEffect: function(o, a) {
                b1(4, 2, o, a);
            },
            useMemo: function(o, a) {
                var c = Zn();
                a = a === void 0 ? null : a;
                var d = o();
                if (ga) {
                    ne(!0);
                    try {
                        o();
                    } finally{
                        ne(!1);
                    }
                }
                return c.memoizedState = [
                    d,
                    a
                ], d;
            },
            useReducer: function(o, a, c) {
                var d = Zn();
                if (c !== void 0) {
                    var g = c(a);
                    if (ga) {
                        ne(!0);
                        try {
                            c(a);
                        } finally{
                            ne(!1);
                        }
                    }
                } else g = a;
                return d.memoizedState = d.baseState = g, o = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: o,
                    lastRenderedState: g
                }, d.queue = o, o = o.dispatch = qR.bind(null, ze, o), [
                    d.memoizedState,
                    o
                ];
            },
            useRef: function(o) {
                var a = Zn();
                return o = {
                    current: o
                }, a.memoizedState = o;
            },
            useState: function(o) {
                o = W2(o);
                var a = o.queue, c = nb.bind(null, ze, a);
                return a.dispatch = c, [
                    o.memoizedState,
                    c
                ];
            },
            useDebugValue: J2,
            useDeferredValue: function(o, a) {
                var c = Zn();
                return Z2(c, o, a);
            },
            useTransition: function() {
                var o = W2(!1);
                return o = Xw.bind(null, ze, o.queue, !0, !1), Zn().memoizedState = o, [
                    !1,
                    o
                ];
            },
            useSyncExternalStore: function(o, a, c) {
                var d = ze, g = Zn();
                if (Ze) {
                    if (c === void 0) throw Error(r(407));
                    c = c();
                } else {
                    if (c = a(), Ct === null) throw Error(r(349));
                    (Ye & 127) !== 0 || Tw(d, a, c);
                }
                g.memoizedState = c;
                var y = {
                    value: c,
                    getSnapshot: a
                };
                return g.queue = y, Vw(xw.bind(null, d, y, o), [
                    o
                ]), d.flags |= 2048, _l(9, {
                    destroy: void 0
                }, _w.bind(null, d, y, c, a), null), c;
            },
            useId: function() {
                var o = Zn(), a = Ct.identifierPrefix;
                if (Ze) {
                    var c = Ks, d = qs;
                    c = (d & ~(1 << 32 - le(d) - 1)).toString(32) + c, a = "_" + a + "R_" + c, c = g1++, 0 < c && (a += "H" + c.toString(32)), a += "_";
                } else c = LR++, a = "_" + a + "r_" + c.toString(32) + "_";
                return o.memoizedState = a;
            },
            useHostTransitionStatus: tm,
            useFormState: Nw,
            useActionState: Nw,
            useOptimistic: function(o) {
                var a = Zn();
                a.memoizedState = a.baseState = o;
                var c = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: null,
                    lastRenderedState: null
                };
                return a.queue = c, a = nm.bind(null, ze, !0, c), c.dispatch = a, [
                    o,
                    a
                ];
            },
            useMemoCache: K2,
            useCacheRefresh: function() {
                return Zn().memoizedState = QR.bind(null, ze);
            },
            useEffectEvent: function(o) {
                var a = Zn(), c = {
                    impl: o
                };
                return a.memoizedState = c, function() {
                    if ((lt & 2) !== 0) throw Error(r(440));
                    return c.impl.apply(void 0, arguments);
                };
            }
        }, rm = {
            readContext: vn,
            use: y1,
            useCallback: Yw,
            useContext: vn,
            useEffect: X2,
            useImperativeHandle: Gw,
            useInsertionEffect: Qw,
            useLayoutEffect: qw,
            useMemo: Ww,
            useReducer: w1,
            useRef: Fw,
            useState: function() {
                return w1(Ci);
            },
            useDebugValue: J2,
            useDeferredValue: function(o, a) {
                var c = Jt();
                return jw(c, yt.memoizedState, o, a);
            },
            useTransition: function() {
                var o = w1(Ci)[0], a = Jt().memoizedState;
                return [
                    typeof o == "boolean" ? o : Xu(o),
                    a
                ];
            },
            useSyncExternalStore: Cw,
            useId: eb,
            useHostTransitionStatus: tm,
            useFormState: Lw,
            useActionState: Lw,
            useOptimistic: function(o, a) {
                var c = Jt();
                return Pw(c, yt, o, a);
            },
            useMemoCache: K2,
            useCacheRefresh: tb
        };
        rm.useEffectEvent = Hw;
        var ob = {
            readContext: vn,
            use: y1,
            useCallback: Yw,
            useContext: vn,
            useEffect: X2,
            useImperativeHandle: Gw,
            useInsertionEffect: Qw,
            useLayoutEffect: qw,
            useMemo: Ww,
            useReducer: Y2,
            useRef: Fw,
            useState: function() {
                return Y2(Ci);
            },
            useDebugValue: J2,
            useDeferredValue: function(o, a) {
                var c = Jt();
                return yt === null ? Z2(c, o, a) : jw(c, yt.memoizedState, o, a);
            },
            useTransition: function() {
                var o = Y2(Ci)[0], a = Jt().memoizedState;
                return [
                    typeof o == "boolean" ? o : Xu(o),
                    a
                ];
            },
            useSyncExternalStore: Cw,
            useId: eb,
            useHostTransitionStatus: tm,
            useFormState: zw,
            useActionState: zw,
            useOptimistic: function(o, a) {
                var c = Jt();
                return yt !== null ? Pw(c, yt, o, a) : (c.baseState = o, [
                    o,
                    c.queue.dispatch
                ]);
            },
            useMemoCache: K2,
            useCacheRefresh: tb
        };
        ob.useEffectEvent = Hw;
        function sm(o, a, c, d) {
            a = o.memoizedState, c = c(d, a), c = c == null ? a : m({}, a, c), o.memoizedState = c, o.lanes === 0 && (o.updateQueue.baseState = c);
        }
        var im = {
            enqueueSetState: function(o, a, c) {
                o = o._reactInternals;
                var d = Pr(), g = ao(d);
                g.payload = a, c != null && (g.callback = c), a = lo(o, g, d), a !== null && (dr(a, o, d), Gu(a, o, d));
            },
            enqueueReplaceState: function(o, a, c) {
                o = o._reactInternals;
                var d = Pr(), g = ao(d);
                g.tag = 1, g.payload = a, c != null && (g.callback = c), a = lo(o, g, d), a !== null && (dr(a, o, d), Gu(a, o, d));
            },
            enqueueForceUpdate: function(o, a) {
                o = o._reactInternals;
                var c = Pr(), d = ao(c);
                d.tag = 2, a != null && (d.callback = a), a = lo(o, d, c), a !== null && (dr(a, o, c), Gu(a, o, c));
            }
        };
        function ab(o, a, c, d, g, y, E) {
            return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(d, y, E) : a.prototype && a.prototype.isPureReactComponent ? !Uu(c, d) || !Uu(g, y) : !0;
        }
        function lb(o, a, c, d) {
            o = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(c, d), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(c, d), a.state !== o && im.enqueueReplaceState(a, a.state, null);
        }
        function ma(o, a) {
            var c = a;
            if ("ref" in a) {
                c = {};
                for(var d in a)d !== "ref" && (c[d] = a[d]);
            }
            if (o = o.defaultProps) {
                c === a && (c = m({}, c));
                for(var g in o)c[g] === void 0 && (c[g] = o[g]);
            }
            return c;
        }
        function cb(o) {
            Zf(o);
        }
        function ub(o) {
            console.error(o);
        }
        function hb(o) {
            Zf(o);
        }
        function A1(o, a) {
            try {
                var c = o.onUncaughtError;
                c(a.value, {
                    componentStack: a.stack
                });
            } catch (d) {
                setTimeout(function() {
                    throw d;
                });
            }
        }
        function db(o, a, c) {
            try {
                var d = o.onCaughtError;
                d(c.value, {
                    componentStack: c.stack,
                    errorBoundary: a.tag === 1 ? a.stateNode : null
                });
            } catch (g) {
                setTimeout(function() {
                    throw g;
                });
            }
        }
        function om(o, a, c) {
            return c = ao(c), c.tag = 3, c.payload = {
                element: null
            }, c.callback = function() {
                A1(o, a);
            }, c;
        }
        function fb(o) {
            return o = ao(o), o.tag = 3, o;
        }
        function pb(o, a, c, d) {
            var g = c.type.getDerivedStateFromError;
            if (typeof g == "function") {
                var y = d.value;
                o.payload = function() {
                    return g(y);
                }, o.callback = function() {
                    db(a, c, d);
                };
            }
            var E = c.stateNode;
            E !== null && typeof E.componentDidCatch == "function" && (o.callback = function() {
                db(a, c, d), typeof g != "function" && (go === null ? go = new Set([
                    this
                ]) : go.add(this));
                var C = d.stack;
                this.componentDidCatch(d.value, {
                    componentStack: C !== null ? C : ""
                });
            });
        }
        function KR(o, a, c, d, g) {
            if (c.flags |= 32768, d !== null && typeof d == "object" && typeof d.then == "function") {
                if (a = c.alternate, a !== null && bl(a, c, g, !0), c = _r.current, c !== null) {
                    switch(c.tag){
                        case 31:
                        case 13:
                            return es === null ? O1() : c.alternate === null && Yt === 0 && (Yt = 3), c.flags &= -257, c.flags |= 65536, c.lanes = g, d === c1 ? c.flags |= 16384 : (a = c.updateQueue, a === null ? c.updateQueue = new Set([
                                d
                            ]) : a.add(d), Pm(o, d, g)), !1;
                        case 22:
                            return c.flags |= 65536, d === c1 ? c.flags |= 16384 : (a = c.updateQueue, a === null ? (a = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([
                                    d
                                ])
                            }, c.updateQueue = a) : (c = a.retryQueue, c === null ? a.retryQueue = new Set([
                                d
                            ]) : c.add(d)), Pm(o, d, g)), !1;
                    }
                    throw Error(r(435, c.tag));
                }
                return Pm(o, d, g), O1(), !1;
            }
            if (Ze) return a = _r.current, a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256), a.flags |= 65536, a.lanes = g, d !== C2 && (o = Error(r(422), {
                cause: d
            }), Vu(jr(o, c)))) : (d !== C2 && (a = Error(r(423), {
                cause: d
            }), Vu(jr(a, c))), o = o.current.alternate, o.flags |= 65536, g &= -g, o.lanes |= g, d = jr(d, c), g = om(o.stateNode, d, g), M2(o, g), Yt !== 4 && (Yt = 2)), !1;
            var y = Error(r(520), {
                cause: d
            });
            if (y = jr(y, c), ah === null ? ah = [
                y
            ] : ah.push(y), Yt !== 4 && (Yt = 2), a === null) return !0;
            d = jr(d, c), c = a;
            do {
                switch(c.tag){
                    case 3:
                        return c.flags |= 65536, o = g & -g, c.lanes |= o, o = om(c.stateNode, d, o), M2(c, o), !1;
                    case 1:
                        if (a = c.type, y = c.stateNode, (c.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (go === null || !go.has(y)))) return c.flags |= 65536, g &= -g, c.lanes |= g, g = fb(g), pb(g, o, c, d), M2(c, g), !1;
                }
                c = c.return;
            }while (c !== null);
            return !1;
        }
        var am = Error(r(461)), nn = !1;
        function En(o, a, c, d) {
            a.child = o === null ? ww(a, null, c, d) : pa(a, o.child, c, d);
        }
        function gb(o, a, c, d, g) {
            c = c.render;
            var y = a.ref;
            if ("ref" in d) {
                var E = {};
                for(var C in d)C !== "ref" && (E[C] = d[C]);
            } else E = d;
            return ua(a), d = V2(o, a, c, E, y, g), C = H2(), o !== null && !nn ? (Q2(o, a, g), Ti(o, a, g)) : (Ze && C && S2(a), a.flags |= 1, En(o, a, d, g), a.child);
        }
        function mb(o, a, c, d, g) {
            if (o === null) {
                var y = c.type;
                return typeof y == "function" && !v2(y) && y.defaultProps === void 0 && c.compare === null ? (a.tag = 15, a.type = y, yb(o, a, y, d, g)) : (o = r1(c.type, null, d, a, a.mode, g), o.ref = a.ref, o.return = a, a.child = o);
            }
            if (y = o.child, !gm(o, g)) {
                var E = y.memoizedProps;
                if (c = c.compare, c = c !== null ? c : Uu, c(E, d) && o.ref === a.ref) return Ti(o, a, g);
            }
            return a.flags |= 1, o = vi(y, d), o.ref = a.ref, o.return = a, a.child = o;
        }
        function yb(o, a, c, d, g) {
            if (o !== null) {
                var y = o.memoizedProps;
                if (Uu(y, d) && o.ref === a.ref) if (nn = !1, a.pendingProps = d = y, gm(o, g)) (o.flags & 131072) !== 0 && (nn = !0);
                else return a.lanes = o.lanes, Ti(o, a, g);
            }
            return lm(o, a, c, d, g);
        }
        function wb(o, a, c, d) {
            var g = d.children, y = o !== null ? o.memoizedState : null;
            if (o === null && a.stateNode === null && (a.stateNode = {
                _visibility: 1,
                _pendingMarkers: null,
                _retryCache: null,
                _transitions: null
            }), d.mode === "hidden") {
                if ((a.flags & 128) !== 0) {
                    if (y = y !== null ? y.baseLanes | c : c, o !== null) {
                        for(d = a.child = o.child, g = 0; d !== null;)g = g | d.lanes | d.childLanes, d = d.sibling;
                        d = g & ~y;
                    } else d = 0, a.child = null;
                    return bb(o, a, y, c, d);
                }
                if ((c & 536870912) !== 0) a.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                }, o !== null && a1(a, y !== null ? y.cachePool : null), y !== null ? Ew(a, y) : L2(), Aw(a);
                else return d = a.lanes = 536870912, bb(o, a, y !== null ? y.baseLanes | c : c, c, d);
            } else y !== null ? (a1(a, y.cachePool), Ew(a, y), uo(), a.memoizedState = null) : (o !== null && a1(a, null), L2(), uo());
            return En(o, a, g, c), a.child;
        }
        function eh(o, a) {
            return o !== null && o.tag === 22 || a.stateNode !== null || (a.stateNode = {
                _visibility: 1,
                _pendingMarkers: null,
                _retryCache: null,
                _transitions: null
            }), a.sibling;
        }
        function bb(o, a, c, d, g) {
            var y = k2();
            return y = y === null ? null : {
                parent: en._currentValue,
                pool: y
            }, a.memoizedState = {
                baseLanes: c,
                cachePool: y
            }, o !== null && a1(a, null), L2(), Aw(a), o !== null && bl(o, a, d, !0), a.childLanes = g, null;
        }
        function S1(o, a) {
            return a = C1({
                mode: a.mode,
                children: a.children
            }, o.mode), a.ref = o.ref, o.child = a, a.return = o, a;
        }
        function vb(o, a, c) {
            return pa(a, o.child, null, c), o = S1(a, a.pendingProps), o.flags |= 2, xr(a), a.memoizedState = null, o;
        }
        function GR(o, a, c) {
            var d = a.pendingProps, g = (a.flags & 128) !== 0;
            if (a.flags &= -129, o === null) {
                if (Ze) {
                    if (d.mode === "hidden") return o = S1(a, d), a.lanes = 536870912, eh(null, o);
                    if (z2(a), (o = $t) ? (o = k7(o, Zr), o = o !== null && o.data === "&" ? o : null, o !== null && (a.memoizedState = {
                        dehydrated: o,
                        treeContext: no !== null ? {
                            id: qs,
                            overflow: Ks
                        } : null,
                        retryLane: 536870912,
                        hydrationErrors: null
                    }, c = rw(o), c.return = a, a.child = c, bn = a, $t = null)) : o = null, o === null) throw so(a);
                    return a.lanes = 536870912, null;
                }
                return S1(a, d);
            }
            var y = o.memoizedState;
            if (y !== null) {
                var E = y.dehydrated;
                if (z2(a), g) if (a.flags & 256) a.flags &= -257, a = vb(o, a, c);
                else if (a.memoizedState !== null) a.child = o.child, a.flags |= 128, a = null;
                else throw Error(r(558));
                else if (nn || bl(o, a, c, !1), g = (c & o.childLanes) !== 0, nn || g) {
                    if (d = Ct, d !== null && (E = u5(d, c), E !== 0 && E !== y.retryLane)) throw y.retryLane = E, oa(o, E), dr(d, o, E), am;
                    O1(), a = vb(o, a, c);
                } else o = y.treeContext, $t = ts(E.nextSibling), bn = a, Ze = !0, ro = null, Zr = !1, o !== null && ow(a, o), a = S1(a, d), a.flags |= 4096;
                return a;
            }
            return o = vi(o.child, {
                mode: d.mode,
                children: d.children
            }), o.ref = a.ref, a.child = o, o.return = a, o;
        }
        function I1(o, a) {
            var c = a.ref;
            if (c === null) o !== null && o.ref !== null && (a.flags |= 4194816);
            else {
                if (typeof c != "function" && typeof c != "object") throw Error(r(284));
                (o === null || o.ref !== c) && (a.flags |= 4194816);
            }
        }
        function lm(o, a, c, d, g) {
            return ua(a), c = V2(o, a, c, d, void 0, g), d = H2(), o !== null && !nn ? (Q2(o, a, g), Ti(o, a, g)) : (Ze && d && S2(a), a.flags |= 1, En(o, a, c, g), a.child);
        }
        function Eb(o, a, c, d, g, y) {
            return ua(a), a.updateQueue = null, c = Iw(a, d, c, g), Sw(o), d = H2(), o !== null && !nn ? (Q2(o, a, y), Ti(o, a, y)) : (Ze && d && S2(a), a.flags |= 1, En(o, a, c, y), a.child);
        }
        function Ab(o, a, c, d, g) {
            if (ua(a), a.stateNode === null) {
                var y = gl, E = c.contextType;
                typeof E == "object" && E !== null && (y = vn(E)), y = new c(d, y), a.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, y.updater = im, a.stateNode = y, y._reactInternals = a, y = a.stateNode, y.props = d, y.state = a.memoizedState, y.refs = {}, O2(a), E = c.contextType, y.context = typeof E == "object" && E !== null ? vn(E) : gl, y.state = a.memoizedState, E = c.getDerivedStateFromProps, typeof E == "function" && (sm(a, c, E, d), y.state = a.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function" || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (E = y.state, typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount(), E !== y.state && im.enqueueReplaceState(y, y.state, null), Wu(a, d, y, g), Yu(), y.state = a.memoizedState), typeof y.componentDidMount == "function" && (a.flags |= 4194308), d = !0;
            } else if (o === null) {
                y = a.stateNode;
                var C = a.memoizedProps, R = ma(c, C);
                y.props = R;
                var Z = y.context, ue = c.contextType;
                E = gl, typeof ue == "object" && ue !== null && (E = vn(ue));
                var fe = c.getDerivedStateFromProps;
                ue = typeof fe == "function" || typeof y.getSnapshotBeforeUpdate == "function", C = a.pendingProps !== C, ue || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (C || Z !== E) && lb(a, y, d, E), oo = !1;
                var te = a.memoizedState;
                y.state = te, Wu(a, d, y, g), Yu(), Z = a.memoizedState, C || te !== Z || oo ? (typeof fe == "function" && (sm(a, c, fe, d), Z = a.memoizedState), (R = oo || ab(a, c, R, d, te, Z, E)) ? (ue || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof y.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = d, a.memoizedState = Z), y.props = d, y.state = Z, y.context = E, d = R) : (typeof y.componentDidMount == "function" && (a.flags |= 4194308), d = !1);
            } else {
                y = a.stateNode, $2(o, a), E = a.memoizedProps, ue = ma(c, E), y.props = ue, fe = a.pendingProps, te = y.context, Z = c.contextType, R = gl, typeof Z == "object" && Z !== null && (R = vn(Z)), C = c.getDerivedStateFromProps, (Z = typeof C == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (E !== fe || te !== R) && lb(a, y, d, R), oo = !1, te = a.memoizedState, y.state = te, Wu(a, d, y, g), Yu();
                var ie = a.memoizedState;
                E !== fe || te !== ie || oo || o !== null && o.dependencies !== null && i1(o.dependencies) ? (typeof C == "function" && (sm(a, c, C, d), ie = a.memoizedState), (ue = oo || ab(a, c, ue, d, te, ie, R) || o !== null && o.dependencies !== null && i1(o.dependencies)) ? (Z || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(d, ie, R), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(d, ie, R)), typeof y.componentDidUpdate == "function" && (a.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || E === o.memoizedProps && te === o.memoizedState || (a.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || E === o.memoizedProps && te === o.memoizedState || (a.flags |= 1024), a.memoizedProps = d, a.memoizedState = ie), y.props = d, y.state = ie, y.context = R, d = ue) : (typeof y.componentDidUpdate != "function" || E === o.memoizedProps && te === o.memoizedState || (a.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || E === o.memoizedProps && te === o.memoizedState || (a.flags |= 1024), d = !1);
            }
            return y = d, I1(o, a), d = (a.flags & 128) !== 0, y || d ? (y = a.stateNode, c = d && typeof c.getDerivedStateFromError != "function" ? null : y.render(), a.flags |= 1, o !== null && d ? (a.child = pa(a, o.child, null, g), a.child = pa(a, null, c, g)) : En(o, a, c, g), a.memoizedState = y.state, o = a.child) : o = Ti(o, a, g), o;
        }
        function Sb(o, a, c, d) {
            return la(), a.flags |= 256, En(o, a, c, d), a.child;
        }
        var cm = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0,
            hydrationErrors: null
        };
        function um(o) {
            return {
                baseLanes: o,
                cachePool: dw()
            };
        }
        function hm(o, a, c) {
            return o = o !== null ? o.childLanes & ~c : 0, a && (o |= Br), o;
        }
        function Ib(o, a, c) {
            var d = a.pendingProps, g = !1, y = (a.flags & 128) !== 0, E;
            if ((E = y) || (E = o !== null && o.memoizedState === null ? !1 : (Xt.current & 2) !== 0), E && (g = !0, a.flags &= -129), E = (a.flags & 32) !== 0, a.flags &= -33, o === null) {
                if (Ze) {
                    if (g ? co(a) : uo(), (o = $t) ? (o = k7(o, Zr), o = o !== null && o.data !== "&" ? o : null, o !== null && (a.memoizedState = {
                        dehydrated: o,
                        treeContext: no !== null ? {
                            id: qs,
                            overflow: Ks
                        } : null,
                        retryLane: 536870912,
                        hydrationErrors: null
                    }, c = rw(o), c.return = a, a.child = c, bn = a, $t = null)) : o = null, o === null) throw so(a);
                    return Gm(o) ? a.lanes = 32 : a.lanes = 536870912, null;
                }
                var C = d.children;
                return d = d.fallback, g ? (uo(), g = a.mode, C = C1({
                    mode: "hidden",
                    children: C
                }, g), d = aa(d, g, c, null), C.return = a, d.return = a, C.sibling = d, a.child = C, d = a.child, d.memoizedState = um(c), d.childLanes = hm(o, E, c), a.memoizedState = cm, eh(null, d)) : (co(a), dm(a, C));
            }
            var R = o.memoizedState;
            if (R !== null && (C = R.dehydrated, C !== null)) {
                if (y) a.flags & 256 ? (co(a), a.flags &= -257, a = fm(o, a, c)) : a.memoizedState !== null ? (uo(), a.child = o.child, a.flags |= 128, a = null) : (uo(), C = d.fallback, g = a.mode, d = C1({
                    mode: "visible",
                    children: d.children
                }, g), C = aa(C, g, c, null), C.flags |= 2, d.return = a, C.return = a, d.sibling = C, a.child = d, pa(a, o.child, null, c), d = a.child, d.memoizedState = um(c), d.childLanes = hm(o, E, c), a.memoizedState = cm, a = eh(null, d));
                else if (co(a), Gm(C)) {
                    if (E = C.nextSibling && C.nextSibling.dataset, E) var Z = E.dgst;
                    E = Z, d = Error(r(419)), d.stack = "", d.digest = E, Vu({
                        value: d,
                        source: null,
                        stack: null
                    }), a = fm(o, a, c);
                } else if (nn || bl(o, a, c, !1), E = (c & o.childLanes) !== 0, nn || E) {
                    if (E = Ct, E !== null && (d = u5(E, c), d !== 0 && d !== R.retryLane)) throw R.retryLane = d, oa(o, d), dr(E, o, d), am;
                    Km(C) || O1(), a = fm(o, a, c);
                } else Km(C) ? (a.flags |= 192, a.child = o.child, a = null) : (o = R.treeContext, $t = ts(C.nextSibling), bn = a, Ze = !0, ro = null, Zr = !1, o !== null && ow(a, o), a = dm(a, d.children), a.flags |= 4096);
                return a;
            }
            return g ? (uo(), C = d.fallback, g = a.mode, R = o.child, Z = R.sibling, d = vi(R, {
                mode: "hidden",
                children: d.children
            }), d.subtreeFlags = R.subtreeFlags & 65011712, Z !== null ? C = vi(Z, C) : (C = aa(C, g, c, null), C.flags |= 2), C.return = a, d.return = a, d.sibling = C, a.child = d, eh(null, d), d = a.child, C = o.child.memoizedState, C === null ? C = um(c) : (g = C.cachePool, g !== null ? (R = en._currentValue, g = g.parent !== R ? {
                parent: R,
                pool: R
            } : g) : g = dw(), C = {
                baseLanes: C.baseLanes | c,
                cachePool: g
            }), d.memoizedState = C, d.childLanes = hm(o, E, c), a.memoizedState = cm, eh(o.child, d)) : (co(a), c = o.child, o = c.sibling, c = vi(c, {
                mode: "visible",
                children: d.children
            }), c.return = a, c.sibling = null, o !== null && (E = a.deletions, E === null ? (a.deletions = [
                o
            ], a.flags |= 16) : E.push(o)), a.child = c, a.memoizedState = null, c);
        }
        function dm(o, a) {
            return a = C1({
                mode: "visible",
                children: a
            }, o.mode), a.return = o, o.child = a;
        }
        function C1(o, a) {
            return o = Tr(22, o, null, a), o.lanes = 0, o;
        }
        function fm(o, a, c) {
            return pa(a, o.child, null, c), o = dm(a, a.pendingProps.children), o.flags |= 2, a.memoizedState = null, o;
        }
        function Cb(o, a, c) {
            o.lanes |= a;
            var d = o.alternate;
            d !== null && (d.lanes |= a), x2(o.return, a, c);
        }
        function pm(o, a, c, d, g, y) {
            var E = o.memoizedState;
            E === null ? o.memoizedState = {
                isBackwards: a,
                rendering: null,
                renderingStartTime: 0,
                last: d,
                tail: c,
                tailMode: g,
                treeForkCount: y
            } : (E.isBackwards = a, E.rendering = null, E.renderingStartTime = 0, E.last = d, E.tail = c, E.tailMode = g, E.treeForkCount = y);
        }
        function Tb(o, a, c) {
            var d = a.pendingProps, g = d.revealOrder, y = d.tail;
            d = d.children;
            var E = Xt.current, C = (E & 2) !== 0;
            if (C ? (E = E & 1 | 2, a.flags |= 128) : E &= 1, pe(Xt, E), En(o, a, d, c), d = Ze ? Fu : 0, !C && o !== null && (o.flags & 128) !== 0) e: for(o = a.child; o !== null;){
                if (o.tag === 13) o.memoizedState !== null && Cb(o, c, a);
                else if (o.tag === 19) Cb(o, c, a);
                else if (o.child !== null) {
                    o.child.return = o, o = o.child;
                    continue;
                }
                if (o === a) break e;
                for(; o.sibling === null;){
                    if (o.return === null || o.return === a) break e;
                    o = o.return;
                }
                o.sibling.return = o.return, o = o.sibling;
            }
            switch(g){
                case "forwards":
                    for(c = a.child, g = null; c !== null;)o = c.alternate, o !== null && f1(o) === null && (g = c), c = c.sibling;
                    c = g, c === null ? (g = a.child, a.child = null) : (g = c.sibling, c.sibling = null), pm(a, !1, g, c, y, d);
                    break;
                case "backwards":
                case "unstable_legacy-backwards":
                    for(c = null, g = a.child, a.child = null; g !== null;){
                        if (o = g.alternate, o !== null && f1(o) === null) {
                            a.child = g;
                            break;
                        }
                        o = g.sibling, g.sibling = c, c = g, g = o;
                    }
                    pm(a, !0, c, null, y, d);
                    break;
                case "together":
                    pm(a, !1, null, null, void 0, d);
                    break;
                default:
                    a.memoizedState = null;
            }
            return a.child;
        }
        function Ti(o, a, c) {
            if (o !== null && (a.dependencies = o.dependencies), po |= a.lanes, (c & a.childLanes) === 0) if (o !== null) {
                if (bl(o, a, c, !1), (c & a.childLanes) === 0) return null;
            } else return null;
            if (o !== null && a.child !== o.child) throw Error(r(153));
            if (a.child !== null) {
                for(o = a.child, c = vi(o, o.pendingProps), a.child = c, c.return = a; o.sibling !== null;)o = o.sibling, c = c.sibling = vi(o, o.pendingProps), c.return = a;
                c.sibling = null;
            }
            return a.child;
        }
        function gm(o, a) {
            return (o.lanes & a) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && i1(o)));
        }
        function YR(o, a, c) {
            switch(a.tag){
                case 3:
                    Ve(a, a.stateNode.containerInfo), io(a, en, o.memoizedState.cache), la();
                    break;
                case 27:
                case 5:
                    mt(a);
                    break;
                case 4:
                    Ve(a, a.stateNode.containerInfo);
                    break;
                case 10:
                    io(a, a.type, a.memoizedProps.value);
                    break;
                case 31:
                    if (a.memoizedState !== null) return a.flags |= 128, z2(a), null;
                    break;
                case 13:
                    var d = a.memoizedState;
                    if (d !== null) return d.dehydrated !== null ? (co(a), a.flags |= 128, null) : (c & a.child.childLanes) !== 0 ? Ib(o, a, c) : (co(a), o = Ti(o, a, c), o !== null ? o.sibling : null);
                    co(a);
                    break;
                case 19:
                    var g = (o.flags & 128) !== 0;
                    if (d = (c & a.childLanes) !== 0, d || (bl(o, a, c, !1), d = (c & a.childLanes) !== 0), g) {
                        if (d) return Tb(o, a, c);
                        a.flags |= 128;
                    }
                    if (g = a.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), pe(Xt, Xt.current), d) break;
                    return null;
                case 22:
                    return a.lanes = 0, wb(o, a, c, a.pendingProps);
                case 24:
                    io(a, en, o.memoizedState.cache);
            }
            return Ti(o, a, c);
        }
        function _b(o, a, c) {
            if (o !== null) if (o.memoizedProps !== a.pendingProps) nn = !0;
            else {
                if (!gm(o, c) && (a.flags & 128) === 0) return nn = !1, YR(o, a, c);
                nn = (o.flags & 131072) !== 0;
            }
            else nn = !1, Ze && (a.flags & 1048576) !== 0 && iw(a, Fu, a.index);
            switch(a.lanes = 0, a.tag){
                case 16:
                    e: {
                        var d = a.pendingProps;
                        if (o = da(a.elementType), a.type = o, typeof o == "function") v2(o) ? (d = ma(o, d), a.tag = 1, a = Ab(null, a, o, d, c)) : (a.tag = 0, a = lm(null, a, o, d, c));
                        else {
                            if (o != null) {
                                var g = o.$$typeof;
                                if (g === J) {
                                    a.tag = 11, a = gb(null, a, o, d, c);
                                    break e;
                                } else if (g === $) {
                                    a.tag = 14, a = mb(null, a, o, d, c);
                                    break e;
                                }
                            }
                            throw a = V(o) || o, Error(r(306, a, ""));
                        }
                    }
                    return a;
                case 0:
                    return lm(o, a, a.type, a.pendingProps, c);
                case 1:
                    return d = a.type, g = ma(d, a.pendingProps), Ab(o, a, d, g, c);
                case 3:
                    e: {
                        if (Ve(a, a.stateNode.containerInfo), o === null) throw Error(r(387));
                        d = a.pendingProps;
                        var y = a.memoizedState;
                        g = y.element, $2(o, a), Wu(a, d, null, c);
                        var E = a.memoizedState;
                        if (d = E.cache, io(a, en, d), d !== y.cache && D2(a, [
                            en
                        ], c, !0), Yu(), d = E.element, y.isDehydrated) if (y = {
                            element: d,
                            isDehydrated: !1,
                            cache: E.cache
                        }, a.updateQueue.baseState = y, a.memoizedState = y, a.flags & 256) {
                            a = Sb(o, a, d, c);
                            break e;
                        } else if (d !== g) {
                            g = jr(Error(r(424)), a), Vu(g), a = Sb(o, a, d, c);
                            break e;
                        } else for(o = a.stateNode.containerInfo, o.nodeType === 9 ? o = o.body : o = o.nodeName === "HTML" ? o.ownerDocument.body : o, $t = ts(o.firstChild), bn = a, Ze = !0, ro = null, Zr = !0, c = ww(a, null, d, c), a.child = c; c;)c.flags = c.flags & -3 | 4096, c = c.sibling;
                        else {
                            if (la(), d === g) {
                                a = Ti(o, a, c);
                                break e;
                            }
                            En(o, a, d, c);
                        }
                        a = a.child;
                    }
                    return a;
                case 26:
                    return I1(o, a), o === null ? (c = L7(a.type, null, a.pendingProps, null)) ? a.memoizedState = c : Ze || (c = a.type, o = a.pendingProps, d = F1(Ae.current).createElement(c), d[wn] = a, d[or] = o, An(d, c, o), fn(d), a.stateNode = d) : a.memoizedState = L7(a.type, o.memoizedProps, a.pendingProps, o.memoizedState), null;
                case 27:
                    return mt(a), o === null && Ze && (d = a.stateNode = $7(a.type, a.pendingProps, Ae.current), bn = a, Zr = !0, g = $t, bo(a.type) ? (Ym = g, $t = ts(d.firstChild)) : $t = g), En(o, a, a.pendingProps.children, c), I1(o, a), o === null && (a.flags |= 4194304), a.child;
                case 5:
                    return o === null && Ze && ((g = d = $t) && (d = IO(d, a.type, a.pendingProps, Zr), d !== null ? (a.stateNode = d, bn = a, $t = ts(d.firstChild), Zr = !1, g = !0) : g = !1), g || so(a)), mt(a), g = a.type, y = a.pendingProps, E = o !== null ? o.memoizedProps : null, d = y.children, Hm(g, y) ? d = null : E !== null && Hm(g, E) && (a.flags |= 32), a.memoizedState !== null && (g = V2(o, a, UR, null, null, c), gh._currentValue = g), I1(o, a), En(o, a, d, c), a.child;
                case 6:
                    return o === null && Ze && ((o = c = $t) && (c = CO(c, a.pendingProps, Zr), c !== null ? (a.stateNode = c, bn = a, $t = null, o = !0) : o = !1), o || so(a)), null;
                case 13:
                    return Ib(o, a, c);
                case 4:
                    return Ve(a, a.stateNode.containerInfo), d = a.pendingProps, o === null ? a.child = pa(a, null, d, c) : En(o, a, d, c), a.child;
                case 11:
                    return gb(o, a, a.type, a.pendingProps, c);
                case 7:
                    return En(o, a, a.pendingProps, c), a.child;
                case 8:
                    return En(o, a, a.pendingProps.children, c), a.child;
                case 12:
                    return En(o, a, a.pendingProps.children, c), a.child;
                case 10:
                    return d = a.pendingProps, io(a, a.type, d.value), En(o, a, d.children, c), a.child;
                case 9:
                    return g = a.type._context, d = a.pendingProps.children, ua(a), g = vn(g), d = d(g), a.flags |= 1, En(o, a, d, c), a.child;
                case 14:
                    return mb(o, a, a.type, a.pendingProps, c);
                case 15:
                    return yb(o, a, a.type, a.pendingProps, c);
                case 19:
                    return Tb(o, a, c);
                case 31:
                    return GR(o, a, c);
                case 22:
                    return wb(o, a, c, a.pendingProps);
                case 24:
                    return ua(a), d = vn(en), o === null ? (g = k2(), g === null && (g = Ct, y = B2(), g.pooledCache = y, y.refCount++, y !== null && (g.pooledCacheLanes |= c), g = y), a.memoizedState = {
                        parent: d,
                        cache: g
                    }, O2(a), io(a, en, g)) : ((o.lanes & c) !== 0 && ($2(o, a), Wu(a, null, null, c), Yu()), g = o.memoizedState, y = a.memoizedState, g.parent !== d ? (g = {
                        parent: d,
                        cache: d
                    }, a.memoizedState = g, a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = g), io(a, en, d)) : (d = y.cache, io(a, en, d), d !== g.cache && D2(a, [
                        en
                    ], c, !0))), En(o, a, a.pendingProps.children, c), a.child;
                case 29:
                    throw a.pendingProps;
            }
            throw Error(r(156, a.tag));
        }
        function _i(o) {
            o.flags |= 4;
        }
        function mm(o, a, c, d, g) {
            if ((a = (o.mode & 32) !== 0) && (a = !1), a) {
                if (o.flags |= 16777216, (g & 335544128) === g) if (o.stateNode.complete) o.flags |= 8192;
                else if (e7()) o.flags |= 8192;
                else throw fa = c1, R2;
            } else o.flags &= -16777217;
        }
        function xb(o, a) {
            if (a.type !== "stylesheet" || (a.state.loading & 4) !== 0) o.flags &= -16777217;
            else if (o.flags |= 16777216, !H7(a)) if (e7()) o.flags |= 8192;
            else throw fa = c1, R2;
        }
        function T1(o, a) {
            a !== null && (o.flags |= 4), o.flags & 16384 && (a = o.tag !== 22 ? a5() : 536870912, o.lanes |= a, Pl |= a);
        }
        function th(o, a) {
            if (!Ze) switch(o.tailMode){
                case "hidden":
                    a = o.tail;
                    for(var c = null; a !== null;)a.alternate !== null && (c = a), a = a.sibling;
                    c === null ? o.tail = null : c.sibling = null;
                    break;
                case "collapsed":
                    c = o.tail;
                    for(var d = null; c !== null;)c.alternate !== null && (d = c), c = c.sibling;
                    d === null ? a || o.tail === null ? o.tail = null : o.tail.sibling = null : d.sibling = null;
            }
        }
        function Mt(o) {
            var a = o.alternate !== null && o.alternate.child === o.child, c = 0, d = 0;
            if (a) for(var g = o.child; g !== null;)c |= g.lanes | g.childLanes, d |= g.subtreeFlags & 65011712, d |= g.flags & 65011712, g.return = o, g = g.sibling;
            else for(g = o.child; g !== null;)c |= g.lanes | g.childLanes, d |= g.subtreeFlags, d |= g.flags, g.return = o, g = g.sibling;
            return o.subtreeFlags |= d, o.childLanes = c, a;
        }
        function WR(o, a, c) {
            var d = a.pendingProps;
            switch(I2(a), a.tag){
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return Mt(a), null;
                case 1:
                    return Mt(a), null;
                case 3:
                    return c = a.stateNode, d = null, o !== null && (d = o.memoizedState.cache), a.memoizedState.cache !== d && (a.flags |= 2048), Si(en), De(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (o === null || o.child === null) && (wl(a) ? _i(a) : o === null || o.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, T2())), Mt(a), null;
                case 26:
                    var g = a.type, y = a.memoizedState;
                    return o === null ? (_i(a), y !== null ? (Mt(a), xb(a, y)) : (Mt(a), mm(a, g, null, d, c))) : y ? y !== o.memoizedState ? (_i(a), Mt(a), xb(a, y)) : (Mt(a), a.flags &= -16777217) : (o = o.memoizedProps, o !== d && _i(a), Mt(a), mm(a, g, o, d, c)), null;
                case 27:
                    if (hn(a), c = Ae.current, g = a.type, o !== null && a.stateNode != null) o.memoizedProps !== d && _i(a);
                    else {
                        if (!d) {
                            if (a.stateNode === null) throw Error(r(166));
                            return Mt(a), null;
                        }
                        o = de.current, wl(a) ? aw(a) : (o = $7(g, d, c), a.stateNode = o, _i(a));
                    }
                    return Mt(a), null;
                case 5:
                    if (hn(a), g = a.type, o !== null && a.stateNode != null) o.memoizedProps !== d && _i(a);
                    else {
                        if (!d) {
                            if (a.stateNode === null) throw Error(r(166));
                            return Mt(a), null;
                        }
                        if (y = de.current, wl(a)) aw(a);
                        else {
                            var E = F1(Ae.current);
                            switch(y){
                                case 1:
                                    y = E.createElementNS("http://www.w3.org/2000/svg", g);
                                    break;
                                case 2:
                                    y = E.createElementNS("http://www.w3.org/1998/Math/MathML", g);
                                    break;
                                default:
                                    switch(g){
                                        case "svg":
                                            y = E.createElementNS("http://www.w3.org/2000/svg", g);
                                            break;
                                        case "math":
                                            y = E.createElementNS("http://www.w3.org/1998/Math/MathML", g);
                                            break;
                                        case "script":
                                            y = E.createElement("div"), y.innerHTML = "<script><\/script>", y = y.removeChild(y.firstChild);
                                            break;
                                        case "select":
                                            y = typeof d.is == "string" ? E.createElement("select", {
                                                is: d.is
                                            }) : E.createElement("select"), d.multiple ? y.multiple = !0 : d.size && (y.size = d.size);
                                            break;
                                        default:
                                            y = typeof d.is == "string" ? E.createElement(g, {
                                                is: d.is
                                            }) : E.createElement(g);
                                    }
                            }
                            y[wn] = a, y[or] = d;
                            e: for(E = a.child; E !== null;){
                                if (E.tag === 5 || E.tag === 6) y.appendChild(E.stateNode);
                                else if (E.tag !== 4 && E.tag !== 27 && E.child !== null) {
                                    E.child.return = E, E = E.child;
                                    continue;
                                }
                                if (E === a) break e;
                                for(; E.sibling === null;){
                                    if (E.return === null || E.return === a) break e;
                                    E = E.return;
                                }
                                E.sibling.return = E.return, E = E.sibling;
                            }
                            a.stateNode = y;
                            e: switch(An(y, g, d), g){
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    d = !!d.autoFocus;
                                    break e;
                                case "img":
                                    d = !0;
                                    break e;
                                default:
                                    d = !1;
                            }
                            d && _i(a);
                        }
                    }
                    return Mt(a), mm(a, a.type, o === null ? null : o.memoizedProps, a.pendingProps, c), null;
                case 6:
                    if (o && a.stateNode != null) o.memoizedProps !== d && _i(a);
                    else {
                        if (typeof d != "string" && a.stateNode === null) throw Error(r(166));
                        if (o = Ae.current, wl(a)) {
                            if (o = a.stateNode, c = a.memoizedProps, d = null, g = bn, g !== null) switch(g.tag){
                                case 27:
                                case 5:
                                    d = g.memoizedProps;
                            }
                            o[wn] = a, o = !!(o.nodeValue === c || d !== null && d.suppressHydrationWarning === !0 || I7(o.nodeValue, c)), o || so(a, !0);
                        } else o = F1(o).createTextNode(d), o[wn] = a, a.stateNode = o;
                    }
                    return Mt(a), null;
                case 31:
                    if (c = a.memoizedState, o === null || o.memoizedState !== null) {
                        if (d = wl(a), c !== null) {
                            if (o === null) {
                                if (!d) throw Error(r(318));
                                if (o = a.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(557));
                                o[wn] = a;
                            } else la(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
                            Mt(a), o = !1;
                        } else c = T2(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = c), o = !0;
                        if (!o) return a.flags & 256 ? (xr(a), a) : (xr(a), null);
                        if ((a.flags & 128) !== 0) throw Error(r(558));
                    }
                    return Mt(a), null;
                case 13:
                    if (d = a.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
                        if (g = wl(a), d !== null && d.dehydrated !== null) {
                            if (o === null) {
                                if (!g) throw Error(r(318));
                                if (g = a.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(r(317));
                                g[wn] = a;
                            } else la(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
                            Mt(a), g = !1;
                        } else g = T2(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = g), g = !0;
                        if (!g) return a.flags & 256 ? (xr(a), a) : (xr(a), null);
                    }
                    return xr(a), (a.flags & 128) !== 0 ? (a.lanes = c, a) : (c = d !== null, o = o !== null && o.memoizedState !== null, c && (d = a.child, g = null, d.alternate !== null && d.alternate.memoizedState !== null && d.alternate.memoizedState.cachePool !== null && (g = d.alternate.memoizedState.cachePool.pool), y = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (y = d.memoizedState.cachePool.pool), y !== g && (d.flags |= 2048)), c !== o && c && (a.child.flags |= 8192), T1(a, a.updateQueue), Mt(a), null);
                case 4:
                    return De(), o === null && Lm(a.stateNode.containerInfo), Mt(a), null;
                case 10:
                    return Si(a.type), Mt(a), null;
                case 19:
                    if (Q(Xt), d = a.memoizedState, d === null) return Mt(a), null;
                    if (g = (a.flags & 128) !== 0, y = d.rendering, y === null) if (g) th(d, !1);
                    else {
                        if (Yt !== 0 || o !== null && (o.flags & 128) !== 0) for(o = a.child; o !== null;){
                            if (y = f1(o), y !== null) {
                                for(a.flags |= 128, th(d, !1), o = y.updateQueue, a.updateQueue = o, T1(a, o), a.subtreeFlags = 0, o = c, c = a.child; c !== null;)nw(c, o), c = c.sibling;
                                return pe(Xt, Xt.current & 1 | 2), Ze && Ei(a, d.treeForkCount), a.child;
                            }
                            o = o.sibling;
                        }
                        d.tail !== null && dn() > P1 && (a.flags |= 128, g = !0, th(d, !1), a.lanes = 4194304);
                    }
                    else {
                        if (!g) if (o = f1(y), o !== null) {
                            if (a.flags |= 128, g = !0, o = o.updateQueue, a.updateQueue = o, T1(a, o), th(d, !0), d.tail === null && d.tailMode === "hidden" && !y.alternate && !Ze) return Mt(a), null;
                        } else 2 * dn() - d.renderingStartTime > P1 && c !== 536870912 && (a.flags |= 128, g = !0, th(d, !1), a.lanes = 4194304);
                        d.isBackwards ? (y.sibling = a.child, a.child = y) : (o = d.last, o !== null ? o.sibling = y : a.child = y, d.last = y);
                    }
                    return d.tail !== null ? (o = d.tail, d.rendering = o, d.tail = o.sibling, d.renderingStartTime = dn(), o.sibling = null, c = Xt.current, pe(Xt, g ? c & 1 | 2 : c & 1), Ze && Ei(a, d.treeForkCount), o) : (Mt(a), null);
                case 22:
                case 23:
                    return xr(a), U2(), d = a.memoizedState !== null, o !== null ? o.memoizedState !== null !== d && (a.flags |= 8192) : d && (a.flags |= 8192), d ? (c & 536870912) !== 0 && (a.flags & 128) === 0 && (Mt(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : Mt(a), c = a.updateQueue, c !== null && T1(a, c.retryQueue), c = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (c = o.memoizedState.cachePool.pool), d = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (d = a.memoizedState.cachePool.pool), d !== c && (a.flags |= 2048), o !== null && Q(ha), null;
                case 24:
                    return c = null, o !== null && (c = o.memoizedState.cache), a.memoizedState.cache !== c && (a.flags |= 2048), Si(en), Mt(a), null;
                case 25:
                    return null;
                case 30:
                    return null;
            }
            throw Error(r(156, a.tag));
        }
        function jR(o, a) {
            switch(I2(a), a.tag){
                case 1:
                    return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
                case 3:
                    return Si(en), De(), o = a.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (a.flags = o & -65537 | 128, a) : null;
                case 26:
                case 27:
                case 5:
                    return hn(a), null;
                case 31:
                    if (a.memoizedState !== null) {
                        if (xr(a), a.alternate === null) throw Error(r(340));
                        la();
                    }
                    return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
                case 13:
                    if (xr(a), o = a.memoizedState, o !== null && o.dehydrated !== null) {
                        if (a.alternate === null) throw Error(r(340));
                        la();
                    }
                    return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
                case 19:
                    return Q(Xt), null;
                case 4:
                    return De(), null;
                case 10:
                    return Si(a.type), null;
                case 22:
                case 23:
                    return xr(a), U2(), o !== null && Q(ha), o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
                case 24:
                    return Si(en), null;
                case 25:
                    return null;
                default:
                    return null;
            }
        }
        function Db(o, a) {
            switch(I2(a), a.tag){
                case 3:
                    Si(en), De();
                    break;
                case 26:
                case 27:
                case 5:
                    hn(a);
                    break;
                case 4:
                    De();
                    break;
                case 31:
                    a.memoizedState !== null && xr(a);
                    break;
                case 13:
                    xr(a);
                    break;
                case 19:
                    Q(Xt);
                    break;
                case 10:
                    Si(a.type);
                    break;
                case 22:
                case 23:
                    xr(a), U2(), o !== null && Q(ha);
                    break;
                case 24:
                    Si(en);
            }
        }
        function nh(o, a) {
            try {
                var c = a.updateQueue, d = c !== null ? c.lastEffect : null;
                if (d !== null) {
                    var g = d.next;
                    c = g;
                    do {
                        if ((c.tag & o) === o) {
                            d = void 0;
                            var y = c.create, E = c.inst;
                            d = y(), E.destroy = d;
                        }
                        c = c.next;
                    }while (c !== g);
                }
            } catch (C) {
                pt(a, a.return, C);
            }
        }
        function ho(o, a, c) {
            try {
                var d = a.updateQueue, g = d !== null ? d.lastEffect : null;
                if (g !== null) {
                    var y = g.next;
                    d = y;
                    do {
                        if ((d.tag & o) === o) {
                            var E = d.inst, C = E.destroy;
                            if (C !== void 0) {
                                E.destroy = void 0, g = a;
                                var R = c, Z = C;
                                try {
                                    Z();
                                } catch (ue) {
                                    pt(g, R, ue);
                                }
                            }
                        }
                        d = d.next;
                    }while (d !== y);
                }
            } catch (ue) {
                pt(a, a.return, ue);
            }
        }
        function Bb(o) {
            var a = o.updateQueue;
            if (a !== null) {
                var c = o.stateNode;
                try {
                    vw(a, c);
                } catch (d) {
                    pt(o, o.return, d);
                }
            }
        }
        function Pb(o, a, c) {
            c.props = ma(o.type, o.memoizedProps), c.state = o.memoizedState;
            try {
                c.componentWillUnmount();
            } catch (d) {
                pt(o, a, d);
            }
        }
        function rh(o, a) {
            try {
                var c = o.ref;
                if (c !== null) {
                    switch(o.tag){
                        case 26:
                        case 27:
                        case 5:
                            var d = o.stateNode;
                            break;
                        case 30:
                            d = o.stateNode;
                            break;
                        default:
                            d = o.stateNode;
                    }
                    typeof c == "function" ? o.refCleanup = c(d) : c.current = d;
                }
            } catch (g) {
                pt(o, a, g);
            }
        }
        function Gs(o, a) {
            var c = o.ref, d = o.refCleanup;
            if (c !== null) if (typeof d == "function") try {
                d();
            } catch (g) {
                pt(o, a, g);
            } finally{
                o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
            }
            else if (typeof c == "function") try {
                c(null);
            } catch (g) {
                pt(o, a, g);
            }
            else c.current = null;
        }
        function kb(o) {
            var a = o.type, c = o.memoizedProps, d = o.stateNode;
            try {
                e: switch(a){
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        c.autoFocus && d.focus();
                        break e;
                    case "img":
                        c.src ? d.src = c.src : c.srcSet && (d.srcset = c.srcSet);
                }
            } catch (g) {
                pt(o, o.return, g);
            }
        }
        function ym(o, a, c) {
            try {
                var d = o.stateNode;
                wO(d, o.type, c, a), d[or] = a;
            } catch (g) {
                pt(o, o.return, g);
            }
        }
        function Rb(o) {
            return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && bo(o.type) || o.tag === 4;
        }
        function wm(o) {
            e: for(;;){
                for(; o.sibling === null;){
                    if (o.return === null || Rb(o.return)) return null;
                    o = o.return;
                }
                for(o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18;){
                    if (o.tag === 27 && bo(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
                    o.child.return = o, o = o.child;
                }
                if (!(o.flags & 2)) return o.stateNode;
            }
        }
        function bm(o, a, c) {
            var d = o.tag;
            if (d === 5 || d === 6) o = o.stateNode, a ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(o, a) : (a = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, a.appendChild(o), c = c._reactRootContainer, c != null || a.onclick !== null || (a.onclick = wi));
            else if (d !== 4 && (d === 27 && bo(o.type) && (c = o.stateNode, a = null), o = o.child, o !== null)) for(bm(o, a, c), o = o.sibling; o !== null;)bm(o, a, c), o = o.sibling;
        }
        function _1(o, a, c) {
            var d = o.tag;
            if (d === 5 || d === 6) o = o.stateNode, a ? c.insertBefore(o, a) : c.appendChild(o);
            else if (d !== 4 && (d === 27 && bo(o.type) && (c = o.stateNode), o = o.child, o !== null)) for(_1(o, a, c), o = o.sibling; o !== null;)_1(o, a, c), o = o.sibling;
        }
        function Ob(o) {
            var a = o.stateNode, c = o.memoizedProps;
            try {
                for(var d = o.type, g = a.attributes; g.length;)a.removeAttributeNode(g[0]);
                An(a, d, c), a[wn] = o, a[or] = c;
            } catch (y) {
                pt(o, o.return, y);
            }
        }
        var xi = !1, rn = !1, vm = !1, $b = typeof WeakSet == "function" ? WeakSet : Set, pn = null;
        function XR(o, a) {
            if (o = o.containerInfo, Fm = Y1, o = G5(o), f2(o)) {
                if ("selectionStart" in o) var c = {
                    start: o.selectionStart,
                    end: o.selectionEnd
                };
                else e: {
                    c = (c = o.ownerDocument) && c.defaultView || window;
                    var d = c.getSelection && c.getSelection();
                    if (d && d.rangeCount !== 0) {
                        c = d.anchorNode;
                        var g = d.anchorOffset, y = d.focusNode;
                        d = d.focusOffset;
                        try {
                            c.nodeType, y.nodeType;
                        } catch  {
                            c = null;
                            break e;
                        }
                        var E = 0, C = -1, R = -1, Z = 0, ue = 0, fe = o, te = null;
                        t: for(;;){
                            for(var ie; fe !== c || g !== 0 && fe.nodeType !== 3 || (C = E + g), fe !== y || d !== 0 && fe.nodeType !== 3 || (R = E + d), fe.nodeType === 3 && (E += fe.nodeValue.length), (ie = fe.firstChild) !== null;)te = fe, fe = ie;
                            for(;;){
                                if (fe === o) break t;
                                if (te === c && ++Z === g && (C = E), te === y && ++ue === d && (R = E), (ie = fe.nextSibling) !== null) break;
                                fe = te, te = fe.parentNode;
                            }
                            fe = ie;
                        }
                        c = C === -1 || R === -1 ? null : {
                            start: C,
                            end: R
                        };
                    } else c = null;
                }
                c = c || {
                    start: 0,
                    end: 0
                };
            } else c = null;
            for(Vm = {
                focusedElem: o,
                selectionRange: c
            }, Y1 = !1, pn = a; pn !== null;)if (a = pn, o = a.child, (a.subtreeFlags & 1028) !== 0 && o !== null) o.return = a, pn = o;
            else for(; pn !== null;){
                switch(a = pn, y = a.alternate, o = a.flags, a.tag){
                    case 0:
                        if ((o & 4) !== 0 && (o = a.updateQueue, o = o !== null ? o.events : null, o !== null)) for(c = 0; c < o.length; c++)g = o[c], g.ref.impl = g.nextImpl;
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((o & 1024) !== 0 && y !== null) {
                            o = void 0, c = a, g = y.memoizedProps, y = y.memoizedState, d = c.stateNode;
                            try {
                                var Ie = ma(c.type, g);
                                o = d.getSnapshotBeforeUpdate(Ie, y), d.__reactInternalSnapshotBeforeUpdate = o;
                            } catch (Oe) {
                                pt(c, c.return, Oe);
                            }
                        }
                        break;
                    case 3:
                        if ((o & 1024) !== 0) {
                            if (o = a.stateNode.containerInfo, c = o.nodeType, c === 9) qm(o);
                            else if (c === 1) switch(o.nodeName){
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    qm(o);
                                    break;
                                default:
                                    o.textContent = "";
                            }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((o & 1024) !== 0) throw Error(r(163));
                }
                if (o = a.sibling, o !== null) {
                    o.return = a.return, pn = o;
                    break;
                }
                pn = a.return;
            }
        }
        function Mb(o, a, c) {
            var d = c.flags;
            switch(c.tag){
                case 0:
                case 11:
                case 15:
                    Bi(o, c), d & 4 && nh(5, c);
                    break;
                case 1:
                    if (Bi(o, c), d & 4) if (o = c.stateNode, a === null) try {
                        o.componentDidMount();
                    } catch (E) {
                        pt(c, c.return, E);
                    }
                    else {
                        var g = ma(c.type, a.memoizedProps);
                        a = a.memoizedState;
                        try {
                            o.componentDidUpdate(g, a, o.__reactInternalSnapshotBeforeUpdate);
                        } catch (E) {
                            pt(c, c.return, E);
                        }
                    }
                    d & 64 && Bb(c), d & 512 && rh(c, c.return);
                    break;
                case 3:
                    if (Bi(o, c), d & 64 && (o = c.updateQueue, o !== null)) {
                        if (a = null, c.child !== null) switch(c.child.tag){
                            case 27:
                            case 5:
                                a = c.child.stateNode;
                                break;
                            case 1:
                                a = c.child.stateNode;
                        }
                        try {
                            vw(o, a);
                        } catch (E) {
                            pt(c, c.return, E);
                        }
                    }
                    break;
                case 27:
                    a === null && d & 4 && Ob(c);
                case 26:
                case 5:
                    Bi(o, c), a === null && d & 4 && kb(c), d & 512 && rh(c, c.return);
                    break;
                case 12:
                    Bi(o, c);
                    break;
                case 31:
                    Bi(o, c), d & 4 && Ub(o, c);
                    break;
                case 13:
                    Bi(o, c), d & 4 && zb(o, c), d & 64 && (o = c.memoizedState, o !== null && (o = o.dehydrated, o !== null && (c = oO.bind(null, c), TO(o, c))));
                    break;
                case 22:
                    if (d = c.memoizedState !== null || xi, !d) {
                        a = a !== null && a.memoizedState !== null || rn, g = xi;
                        var y = rn;
                        xi = d, (rn = a) && !y ? Pi(o, c, (c.subtreeFlags & 8772) !== 0) : Bi(o, c), xi = g, rn = y;
                    }
                    break;
                case 30:
                    break;
                default:
                    Bi(o, c);
            }
        }
        function Nb(o) {
            var a = o.alternate;
            a !== null && (o.alternate = null, Nb(a)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (a = o.stateNode, a !== null && jg(a)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
        }
        var Ft = null, lr = !1;
        function Di(o, a, c) {
            for(c = c.child; c !== null;)Lb(o, a, c), c = c.sibling;
        }
        function Lb(o, a, c) {
            if (N && typeof N.onCommitFiberUnmount == "function") try {
                N.onCommitFiberUnmount(D, c);
            } catch  {}
            switch(c.tag){
                case 26:
                    rn || Gs(c, a), Di(o, a, c), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
                    break;
                case 27:
                    rn || Gs(c, a);
                    var d = Ft, g = lr;
                    bo(c.type) && (Ft = c.stateNode, lr = !1), Di(o, a, c), dh(c.stateNode), Ft = d, lr = g;
                    break;
                case 5:
                    rn || Gs(c, a);
                case 6:
                    if (d = Ft, g = lr, Ft = null, Di(o, a, c), Ft = d, lr = g, Ft !== null) if (lr) try {
                        (Ft.nodeType === 9 ? Ft.body : Ft.nodeName === "HTML" ? Ft.ownerDocument.body : Ft).removeChild(c.stateNode);
                    } catch (y) {
                        pt(c, a, y);
                    }
                    else try {
                        Ft.removeChild(c.stateNode);
                    } catch (y) {
                        pt(c, a, y);
                    }
                    break;
                case 18:
                    Ft !== null && (lr ? (o = Ft, B7(o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, c.stateNode), Ul(o)) : B7(Ft, c.stateNode));
                    break;
                case 4:
                    d = Ft, g = lr, Ft = c.stateNode.containerInfo, lr = !0, Di(o, a, c), Ft = d, lr = g;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    ho(2, c, a), rn || ho(4, c, a), Di(o, a, c);
                    break;
                case 1:
                    rn || (Gs(c, a), d = c.stateNode, typeof d.componentWillUnmount == "function" && Pb(c, a, d)), Di(o, a, c);
                    break;
                case 21:
                    Di(o, a, c);
                    break;
                case 22:
                    rn = (d = rn) || c.memoizedState !== null, Di(o, a, c), rn = d;
                    break;
                default:
                    Di(o, a, c);
            }
        }
        function Ub(o, a) {
            if (a.memoizedState === null && (o = a.alternate, o !== null && (o = o.memoizedState, o !== null))) {
                o = o.dehydrated;
                try {
                    Ul(o);
                } catch (c) {
                    pt(a, a.return, c);
                }
            }
        }
        function zb(o, a) {
            if (a.memoizedState === null && (o = a.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null)))) try {
                Ul(o);
            } catch (c) {
                pt(a, a.return, c);
            }
        }
        function JR(o) {
            switch(o.tag){
                case 31:
                case 13:
                case 19:
                    var a = o.stateNode;
                    return a === null && (a = o.stateNode = new $b), a;
                case 22:
                    return o = o.stateNode, a = o._retryCache, a === null && (a = o._retryCache = new $b), a;
                default:
                    throw Error(r(435, o.tag));
            }
        }
        function x1(o, a) {
            var c = JR(o);
            a.forEach(function(d) {
                if (!c.has(d)) {
                    c.add(d);
                    var g = aO.bind(null, o, d);
                    d.then(g, g);
                }
            });
        }
        function cr(o, a) {
            var c = a.deletions;
            if (c !== null) for(var d = 0; d < c.length; d++){
                var g = c[d], y = o, E = a, C = E;
                e: for(; C !== null;){
                    switch(C.tag){
                        case 27:
                            if (bo(C.type)) {
                                Ft = C.stateNode, lr = !1;
                                break e;
                            }
                            break;
                        case 5:
                            Ft = C.stateNode, lr = !1;
                            break e;
                        case 3:
                        case 4:
                            Ft = C.stateNode.containerInfo, lr = !0;
                            break e;
                    }
                    C = C.return;
                }
                if (Ft === null) throw Error(r(160));
                Lb(y, E, g), Ft = null, lr = !1, y = g.alternate, y !== null && (y.return = null), g.return = null;
            }
            if (a.subtreeFlags & 13886) for(a = a.child; a !== null;)Fb(a, o), a = a.sibling;
        }
        var xs = null;
        function Fb(o, a) {
            var c = o.alternate, d = o.flags;
            switch(o.tag){
                case 0:
                case 11:
                case 14:
                case 15:
                    cr(a, o), ur(o), d & 4 && (ho(3, o, o.return), nh(3, o), ho(5, o, o.return));
                    break;
                case 1:
                    cr(a, o), ur(o), d & 512 && (rn || c === null || Gs(c, c.return)), d & 64 && xi && (o = o.updateQueue, o !== null && (d = o.callbacks, d !== null && (c = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = c === null ? d : c.concat(d))));
                    break;
                case 26:
                    var g = xs;
                    if (cr(a, o), ur(o), d & 512 && (rn || c === null || Gs(c, c.return)), d & 4) {
                        var y = c !== null ? c.memoizedState : null;
                        if (d = o.memoizedState, c === null) if (d === null) if (o.stateNode === null) {
                            e: {
                                d = o.type, c = o.memoizedProps, g = g.ownerDocument || g;
                                t: switch(d){
                                    case "title":
                                        y = g.getElementsByTagName("title")[0], (!y || y[Bu] || y[wn] || y.namespaceURI === "http://www.w3.org/2000/svg" || y.hasAttribute("itemprop")) && (y = g.createElement(d), g.head.insertBefore(y, g.querySelector("head > title"))), An(y, d, c), y[wn] = o, fn(y), d = y;
                                        break e;
                                    case "link":
                                        var E = F7("link", "href", g).get(d + (c.href || ""));
                                        if (E) {
                                            for(var C = 0; C < E.length; C++)if (y = E[C], y.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && y.getAttribute("rel") === (c.rel == null ? null : c.rel) && y.getAttribute("title") === (c.title == null ? null : c.title) && y.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                                                E.splice(C, 1);
                                                break t;
                                            }
                                        }
                                        y = g.createElement(d), An(y, d, c), g.head.appendChild(y);
                                        break;
                                    case "meta":
                                        if (E = F7("meta", "content", g).get(d + (c.content || ""))) {
                                            for(C = 0; C < E.length; C++)if (y = E[C], y.getAttribute("content") === (c.content == null ? null : "" + c.content) && y.getAttribute("name") === (c.name == null ? null : c.name) && y.getAttribute("property") === (c.property == null ? null : c.property) && y.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && y.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                                                E.splice(C, 1);
                                                break t;
                                            }
                                        }
                                        y = g.createElement(d), An(y, d, c), g.head.appendChild(y);
                                        break;
                                    default:
                                        throw Error(r(468, d));
                                }
                                y[wn] = o, fn(y), d = y;
                            }
                            o.stateNode = d;
                        } else V7(g, o.type, o.stateNode);
                        else o.stateNode = z7(g, d, o.memoizedProps);
                        else y !== d ? (y === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : y.count--, d === null ? V7(g, o.type, o.stateNode) : z7(g, d, o.memoizedProps)) : d === null && o.stateNode !== null && ym(o, o.memoizedProps, c.memoizedProps);
                    }
                    break;
                case 27:
                    cr(a, o), ur(o), d & 512 && (rn || c === null || Gs(c, c.return)), c !== null && d & 4 && ym(o, o.memoizedProps, c.memoizedProps);
                    break;
                case 5:
                    if (cr(a, o), ur(o), d & 512 && (rn || c === null || Gs(c, c.return)), o.flags & 32) {
                        g = o.stateNode;
                        try {
                            ll(g, "");
                        } catch (Ie) {
                            pt(o, o.return, Ie);
                        }
                    }
                    d & 4 && o.stateNode != null && (g = o.memoizedProps, ym(o, g, c !== null ? c.memoizedProps : g)), d & 1024 && (vm = !0);
                    break;
                case 6:
                    if (cr(a, o), ur(o), d & 4) {
                        if (o.stateNode === null) throw Error(r(162));
                        d = o.memoizedProps, c = o.stateNode;
                        try {
                            c.nodeValue = d;
                        } catch (Ie) {
                            pt(o, o.return, Ie);
                        }
                    }
                    break;
                case 3:
                    if (Q1 = null, g = xs, xs = V1(a.containerInfo), cr(a, o), xs = g, ur(o), d & 4 && c !== null && c.memoizedState.isDehydrated) try {
                        Ul(a.containerInfo);
                    } catch (Ie) {
                        pt(o, o.return, Ie);
                    }
                    vm && (vm = !1, Vb(o));
                    break;
                case 4:
                    d = xs, xs = V1(o.stateNode.containerInfo), cr(a, o), ur(o), xs = d;
                    break;
                case 12:
                    cr(a, o), ur(o);
                    break;
                case 31:
                    cr(a, o), ur(o), d & 4 && (d = o.updateQueue, d !== null && (o.updateQueue = null, x1(o, d)));
                    break;
                case 13:
                    cr(a, o), ur(o), o.child.flags & 8192 && o.memoizedState !== null != (c !== null && c.memoizedState !== null) && (B1 = dn()), d & 4 && (d = o.updateQueue, d !== null && (o.updateQueue = null, x1(o, d)));
                    break;
                case 22:
                    g = o.memoizedState !== null;
                    var R = c !== null && c.memoizedState !== null, Z = xi, ue = rn;
                    if (xi = Z || g, rn = ue || R, cr(a, o), rn = ue, xi = Z, ur(o), d & 8192) e: for(a = o.stateNode, a._visibility = g ? a._visibility & -2 : a._visibility | 1, g && (c === null || R || xi || rn || ya(o)), c = null, a = o;;){
                        if (a.tag === 5 || a.tag === 26) {
                            if (c === null) {
                                R = c = a;
                                try {
                                    if (y = R.stateNode, g) E = y.style, typeof E.setProperty == "function" ? E.setProperty("display", "none", "important") : E.display = "none";
                                    else {
                                        C = R.stateNode;
                                        var fe = R.memoizedProps.style, te = fe != null && fe.hasOwnProperty("display") ? fe.display : null;
                                        C.style.display = te == null || typeof te == "boolean" ? "" : ("" + te).trim();
                                    }
                                } catch (Ie) {
                                    pt(R, R.return, Ie);
                                }
                            }
                        } else if (a.tag === 6) {
                            if (c === null) {
                                R = a;
                                try {
                                    R.stateNode.nodeValue = g ? "" : R.memoizedProps;
                                } catch (Ie) {
                                    pt(R, R.return, Ie);
                                }
                            }
                        } else if (a.tag === 18) {
                            if (c === null) {
                                R = a;
                                try {
                                    var ie = R.stateNode;
                                    g ? P7(ie, !0) : P7(R.stateNode, !1);
                                } catch (Ie) {
                                    pt(R, R.return, Ie);
                                }
                            }
                        } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === o) && a.child !== null) {
                            a.child.return = a, a = a.child;
                            continue;
                        }
                        if (a === o) break e;
                        for(; a.sibling === null;){
                            if (a.return === null || a.return === o) break e;
                            c === a && (c = null), a = a.return;
                        }
                        c === a && (c = null), a.sibling.return = a.return, a = a.sibling;
                    }
                    d & 4 && (d = o.updateQueue, d !== null && (c = d.retryQueue, c !== null && (d.retryQueue = null, x1(o, c))));
                    break;
                case 19:
                    cr(a, o), ur(o), d & 4 && (d = o.updateQueue, d !== null && (o.updateQueue = null, x1(o, d)));
                    break;
                case 30:
                    break;
                case 21:
                    break;
                default:
                    cr(a, o), ur(o);
            }
        }
        function ur(o) {
            var a = o.flags;
            if (a & 2) {
                try {
                    for(var c, d = o.return; d !== null;){
                        if (Rb(d)) {
                            c = d;
                            break;
                        }
                        d = d.return;
                    }
                    if (c == null) throw Error(r(160));
                    switch(c.tag){
                        case 27:
                            var g = c.stateNode, y = wm(o);
                            _1(o, y, g);
                            break;
                        case 5:
                            var E = c.stateNode;
                            c.flags & 32 && (ll(E, ""), c.flags &= -33);
                            var C = wm(o);
                            _1(o, C, E);
                            break;
                        case 3:
                        case 4:
                            var R = c.stateNode.containerInfo, Z = wm(o);
                            bm(o, Z, R);
                            break;
                        default:
                            throw Error(r(161));
                    }
                } catch (ue) {
                    pt(o, o.return, ue);
                }
                o.flags &= -3;
            }
            a & 4096 && (o.flags &= -4097);
        }
        function Vb(o) {
            if (o.subtreeFlags & 1024) for(o = o.child; o !== null;){
                var a = o;
                Vb(a), a.tag === 5 && a.flags & 1024 && a.stateNode.reset(), o = o.sibling;
            }
        }
        function Bi(o, a) {
            if (a.subtreeFlags & 8772) for(a = a.child; a !== null;)Mb(o, a.alternate, a), a = a.sibling;
        }
        function ya(o) {
            for(o = o.child; o !== null;){
                var a = o;
                switch(a.tag){
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        ho(4, a, a.return), ya(a);
                        break;
                    case 1:
                        Gs(a, a.return);
                        var c = a.stateNode;
                        typeof c.componentWillUnmount == "function" && Pb(a, a.return, c), ya(a);
                        break;
                    case 27:
                        dh(a.stateNode);
                    case 26:
                    case 5:
                        Gs(a, a.return), ya(a);
                        break;
                    case 22:
                        a.memoizedState === null && ya(a);
                        break;
                    case 30:
                        ya(a);
                        break;
                    default:
                        ya(a);
                }
                o = o.sibling;
            }
        }
        function Pi(o, a, c) {
            for(c = c && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null;){
                var d = a.alternate, g = o, y = a, E = y.flags;
                switch(y.tag){
                    case 0:
                    case 11:
                    case 15:
                        Pi(g, y, c), nh(4, y);
                        break;
                    case 1:
                        if (Pi(g, y, c), d = y, g = d.stateNode, typeof g.componentDidMount == "function") try {
                            g.componentDidMount();
                        } catch (Z) {
                            pt(d, d.return, Z);
                        }
                        if (d = y, g = d.updateQueue, g !== null) {
                            var C = d.stateNode;
                            try {
                                var R = g.shared.hiddenCallbacks;
                                if (R !== null) for(g.shared.hiddenCallbacks = null, g = 0; g < R.length; g++)bw(R[g], C);
                            } catch (Z) {
                                pt(d, d.return, Z);
                            }
                        }
                        c && E & 64 && Bb(y), rh(y, y.return);
                        break;
                    case 27:
                        Ob(y);
                    case 26:
                    case 5:
                        Pi(g, y, c), c && d === null && E & 4 && kb(y), rh(y, y.return);
                        break;
                    case 12:
                        Pi(g, y, c);
                        break;
                    case 31:
                        Pi(g, y, c), c && E & 4 && Ub(g, y);
                        break;
                    case 13:
                        Pi(g, y, c), c && E & 4 && zb(g, y);
                        break;
                    case 22:
                        y.memoizedState === null && Pi(g, y, c), rh(y, y.return);
                        break;
                    case 30:
                        break;
                    default:
                        Pi(g, y, c);
                }
                a = a.sibling;
            }
        }
        function Em(o, a) {
            var c = null;
            o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (c = o.memoizedState.cachePool.pool), o = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (o = a.memoizedState.cachePool.pool), o !== c && (o != null && o.refCount++, c != null && Hu(c));
        }
        function Am(o, a) {
            o = null, a.alternate !== null && (o = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== o && (a.refCount++, o != null && Hu(o));
        }
        function Ds(o, a, c, d) {
            if (a.subtreeFlags & 10256) for(a = a.child; a !== null;)Hb(o, a, c, d), a = a.sibling;
        }
        function Hb(o, a, c, d) {
            var g = a.flags;
            switch(a.tag){
                case 0:
                case 11:
                case 15:
                    Ds(o, a, c, d), g & 2048 && nh(9, a);
                    break;
                case 1:
                    Ds(o, a, c, d);
                    break;
                case 3:
                    Ds(o, a, c, d), g & 2048 && (o = null, a.alternate !== null && (o = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== o && (a.refCount++, o != null && Hu(o)));
                    break;
                case 12:
                    if (g & 2048) {
                        Ds(o, a, c, d), o = a.stateNode;
                        try {
                            var y = a.memoizedProps, E = y.id, C = y.onPostCommit;
                            typeof C == "function" && C(E, a.alternate === null ? "mount" : "update", o.passiveEffectDuration, -0);
                        } catch (R) {
                            pt(a, a.return, R);
                        }
                    } else Ds(o, a, c, d);
                    break;
                case 31:
                    Ds(o, a, c, d);
                    break;
                case 13:
                    Ds(o, a, c, d);
                    break;
                case 23:
                    break;
                case 22:
                    y = a.stateNode, E = a.alternate, a.memoizedState !== null ? y._visibility & 2 ? Ds(o, a, c, d) : sh(o, a) : y._visibility & 2 ? Ds(o, a, c, d) : (y._visibility |= 2, xl(o, a, c, d, (a.subtreeFlags & 10256) !== 0 || !1)), g & 2048 && Em(E, a);
                    break;
                case 24:
                    Ds(o, a, c, d), g & 2048 && Am(a.alternate, a);
                    break;
                default:
                    Ds(o, a, c, d);
            }
        }
        function xl(o, a, c, d, g) {
            for(g = g && ((a.subtreeFlags & 10256) !== 0 || !1), a = a.child; a !== null;){
                var y = o, E = a, C = c, R = d, Z = E.flags;
                switch(E.tag){
                    case 0:
                    case 11:
                    case 15:
                        xl(y, E, C, R, g), nh(8, E);
                        break;
                    case 23:
                        break;
                    case 22:
                        var ue = E.stateNode;
                        E.memoizedState !== null ? ue._visibility & 2 ? xl(y, E, C, R, g) : sh(y, E) : (ue._visibility |= 2, xl(y, E, C, R, g)), g && Z & 2048 && Em(E.alternate, E);
                        break;
                    case 24:
                        xl(y, E, C, R, g), g && Z & 2048 && Am(E.alternate, E);
                        break;
                    default:
                        xl(y, E, C, R, g);
                }
                a = a.sibling;
            }
        }
        function sh(o, a) {
            if (a.subtreeFlags & 10256) for(a = a.child; a !== null;){
                var c = o, d = a, g = d.flags;
                switch(d.tag){
                    case 22:
                        sh(c, d), g & 2048 && Em(d.alternate, d);
                        break;
                    case 24:
                        sh(c, d), g & 2048 && Am(d.alternate, d);
                        break;
                    default:
                        sh(c, d);
                }
                a = a.sibling;
            }
        }
        var ih = 8192;
        function Dl(o, a, c) {
            if (o.subtreeFlags & ih) for(o = o.child; o !== null;)Qb(o, a, c), o = o.sibling;
        }
        function Qb(o, a, c) {
            switch(o.tag){
                case 26:
                    Dl(o, a, c), o.flags & ih && o.memoizedState !== null && LO(c, xs, o.memoizedState, o.memoizedProps);
                    break;
                case 5:
                    Dl(o, a, c);
                    break;
                case 3:
                case 4:
                    var d = xs;
                    xs = V1(o.stateNode.containerInfo), Dl(o, a, c), xs = d;
                    break;
                case 22:
                    o.memoizedState === null && (d = o.alternate, d !== null && d.memoizedState !== null ? (d = ih, ih = 16777216, Dl(o, a, c), ih = d) : Dl(o, a, c));
                    break;
                default:
                    Dl(o, a, c);
            }
        }
        function qb(o) {
            var a = o.alternate;
            if (a !== null && (o = a.child, o !== null)) {
                a.child = null;
                do a = o.sibling, o.sibling = null, o = a;
                while (o !== null);
            }
        }
        function oh(o) {
            var a = o.deletions;
            if ((o.flags & 16) !== 0) {
                if (a !== null) for(var c = 0; c < a.length; c++){
                    var d = a[c];
                    pn = d, Gb(d, o);
                }
                qb(o);
            }
            if (o.subtreeFlags & 10256) for(o = o.child; o !== null;)Kb(o), o = o.sibling;
        }
        function Kb(o) {
            switch(o.tag){
                case 0:
                case 11:
                case 15:
                    oh(o), o.flags & 2048 && ho(9, o, o.return);
                    break;
                case 3:
                    oh(o);
                    break;
                case 12:
                    oh(o);
                    break;
                case 22:
                    var a = o.stateNode;
                    o.memoizedState !== null && a._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (a._visibility &= -3, D1(o)) : oh(o);
                    break;
                default:
                    oh(o);
            }
        }
        function D1(o) {
            var a = o.deletions;
            if ((o.flags & 16) !== 0) {
                if (a !== null) for(var c = 0; c < a.length; c++){
                    var d = a[c];
                    pn = d, Gb(d, o);
                }
                qb(o);
            }
            for(o = o.child; o !== null;){
                switch(a = o, a.tag){
                    case 0:
                    case 11:
                    case 15:
                        ho(8, a, a.return), D1(a);
                        break;
                    case 22:
                        c = a.stateNode, c._visibility & 2 && (c._visibility &= -3, D1(a));
                        break;
                    default:
                        D1(a);
                }
                o = o.sibling;
            }
        }
        function Gb(o, a) {
            for(; pn !== null;){
                var c = pn;
                switch(c.tag){
                    case 0:
                    case 11:
                    case 15:
                        ho(8, c, a);
                        break;
                    case 23:
                    case 22:
                        if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
                            var d = c.memoizedState.cachePool.pool;
                            d != null && d.refCount++;
                        }
                        break;
                    case 24:
                        Hu(c.memoizedState.cache);
                }
                if (d = c.child, d !== null) d.return = c, pn = d;
                else e: for(c = o; pn !== null;){
                    d = pn;
                    var g = d.sibling, y = d.return;
                    if (Nb(d), d === c) {
                        pn = null;
                        break e;
                    }
                    if (g !== null) {
                        g.return = y, pn = g;
                        break e;
                    }
                    pn = y;
                }
            }
        }
        var ZR = {
            getCacheForType: function(o) {
                var a = vn(en), c = a.data.get(o);
                return c === void 0 && (c = o(), a.data.set(o, c)), c;
            },
            cacheSignal: function() {
                return vn(en).controller.signal;
            }
        }, eO = typeof WeakMap == "function" ? WeakMap : Map, lt = 0, Ct = null, qe = null, Ye = 0, ft = 0, Dr = null, fo = !1, Bl = !1, Sm = !1, ki = 0, Yt = 0, po = 0, wa = 0, Im = 0, Br = 0, Pl = 0, ah = null, hr = null, Cm = !1, B1 = 0, Yb = 0, P1 = 1 / 0, k1 = null, go = null, ln = 0, mo = null, kl = null, Ri = 0, Tm = 0, _m = null, Wb = null, lh = 0, xm = null;
        function Pr() {
            return (lt & 2) !== 0 && Ye !== 0 ? Ye & -Ye : B.T !== null ? Om() : h5();
        }
        function jb() {
            if (Br === 0) if ((Ye & 536870912) === 0 || Ze) {
                var o = rt;
                rt <<= 1, (rt & 3932160) === 0 && (rt = 262144), Br = o;
            } else Br = 536870912;
            return o = _r.current, o !== null && (o.flags |= 32), Br;
        }
        function dr(o, a, c) {
            (o === Ct && (ft === 2 || ft === 9) || o.cancelPendingCommit !== null) && (Rl(o, 0), yo(o, Ye, Br, !1)), Du(o, c), ((lt & 2) === 0 || o !== Ct) && (o === Ct && ((lt & 2) === 0 && (wa |= c), Yt === 4 && yo(o, Ye, Br, !1)), Ys(o));
        }
        function Xb(o, a, c) {
            if ((lt & 6) !== 0) throw Error(r(327));
            var d = !c && (a & 127) === 0 && (a & o.expiredLanes) === 0 || xu(o, a), g = d ? rO(o, a) : Bm(o, a, !0), y = d;
            do {
                if (g === 0) {
                    Bl && !d && yo(o, a, 0, !1);
                    break;
                } else {
                    if (c = o.current.alternate, y && !tO(c)) {
                        g = Bm(o, a, !1), y = !1;
                        continue;
                    }
                    if (g === 2) {
                        if (y = a, o.errorRecoveryDisabledLanes & y) var E = 0;
                        else E = o.pendingLanes & -536870913, E = E !== 0 ? E : E & 536870912 ? 536870912 : 0;
                        if (E !== 0) {
                            a = E;
                            e: {
                                var C = o;
                                g = ah;
                                var R = C.current.memoizedState.isDehydrated;
                                if (R && (Rl(C, E).flags |= 256), E = Bm(C, E, !1), E !== 2) {
                                    if (Sm && !R) {
                                        C.errorRecoveryDisabledLanes |= y, wa |= y, g = 4;
                                        break e;
                                    }
                                    y = hr, hr = g, y !== null && (hr === null ? hr = y : hr.push.apply(hr, y));
                                }
                                g = E;
                            }
                            if (y = !1, g !== 2) continue;
                        }
                    }
                    if (g === 1) {
                        Rl(o, 0), yo(o, a, 0, !0);
                        break;
                    }
                    e: {
                        switch(d = o, y = g, y){
                            case 0:
                            case 1:
                                throw Error(r(345));
                            case 4:
                                if ((a & 4194048) !== a) break;
                            case 6:
                                yo(d, a, Br, !fo);
                                break e;
                            case 2:
                                hr = null;
                                break;
                            case 3:
                            case 5:
                                break;
                            default:
                                throw Error(r(329));
                        }
                        if ((a & 62914560) === a && (g = B1 + 300 - dn(), 10 < g)) {
                            if (yo(d, a, Br, !fo), Vf(d, 0, !0) !== 0) break e;
                            Ri = a, d.timeoutHandle = x7(Jb.bind(null, d, c, hr, k1, Cm, a, Br, wa, Pl, fo, y, "Throttled", -0, 0), g);
                            break e;
                        }
                        Jb(d, c, hr, k1, Cm, a, Br, wa, Pl, fo, y, null, -0, 0);
                    }
                }
                break;
            }while (!0);
            Ys(o);
        }
        function Jb(o, a, c, d, g, y, E, C, R, Z, ue, fe, te, ie) {
            if (o.timeoutHandle = -1, fe = a.subtreeFlags, fe & 8192 || (fe & 16785408) === 16785408) {
                fe = {
                    stylesheets: null,
                    count: 0,
                    imgCount: 0,
                    imgBytes: 0,
                    suspenseyImages: [],
                    waitingForImages: !0,
                    waitingForViewTransition: !1,
                    unsuspend: wi
                }, Qb(a, y, fe);
                var Ie = (y & 62914560) === y ? B1 - dn() : (y & 4194048) === y ? Yb - dn() : 0;
                if (Ie = UO(fe, Ie), Ie !== null) {
                    Ri = y, o.cancelPendingCommit = Ie(o7.bind(null, o, a, y, c, d, g, E, C, R, ue, fe, null, te, ie)), yo(o, y, E, !Z);
                    return;
                }
            }
            o7(o, a, y, c, d, g, E, C, R);
        }
        function tO(o) {
            for(var a = o;;){
                var c = a.tag;
                if ((c === 0 || c === 11 || c === 15) && a.flags & 16384 && (c = a.updateQueue, c !== null && (c = c.stores, c !== null))) for(var d = 0; d < c.length; d++){
                    var g = c[d], y = g.getSnapshot;
                    g = g.value;
                    try {
                        if (!Cr(y(), g)) return !1;
                    } catch  {
                        return !1;
                    }
                }
                if (c = a.child, a.subtreeFlags & 16384 && c !== null) c.return = a, a = c;
                else {
                    if (a === o) break;
                    for(; a.sibling === null;){
                        if (a.return === null || a.return === o) return !0;
                        a = a.return;
                    }
                    a.sibling.return = a.return, a = a.sibling;
                }
            }
            return !0;
        }
        function yo(o, a, c, d) {
            a &= ~Im, a &= ~wa, o.suspendedLanes |= a, o.pingedLanes &= ~a, d && (o.warmLanes |= a), d = o.expirationTimes;
            for(var g = a; 0 < g;){
                var y = 31 - le(g), E = 1 << y;
                d[y] = -1, g &= ~E;
            }
            c !== 0 && l5(o, c, a);
        }
        function R1() {
            return (lt & 6) === 0 ? (ch(0), !1) : !0;
        }
        function Dm() {
            if (qe !== null) {
                if (ft === 0) var o = qe.return;
                else o = qe, Ai = ca = null, q2(o), Sl = null, qu = 0, o = qe;
                for(; o !== null;)Db(o.alternate, o), o = o.return;
                qe = null;
            }
        }
        function Rl(o, a) {
            var c = o.timeoutHandle;
            c !== -1 && (o.timeoutHandle = -1, EO(c)), c = o.cancelPendingCommit, c !== null && (o.cancelPendingCommit = null, c()), Ri = 0, Dm(), Ct = o, qe = c = vi(o.current, null), Ye = a, ft = 0, Dr = null, fo = !1, Bl = xu(o, a), Sm = !1, Pl = Br = Im = wa = po = Yt = 0, hr = ah = null, Cm = !1, (a & 8) !== 0 && (a |= a & 32);
            var d = o.entangledLanes;
            if (d !== 0) for(o = o.entanglements, d &= a; 0 < d;){
                var g = 31 - le(d), y = 1 << g;
                a |= o[g], d &= ~y;
            }
            return ki = a, e1(), c;
        }
        function Zb(o, a) {
            ze = null, B.H = Zu, a === Al || a === l1 ? (a = gw(), ft = 3) : a === R2 ? (a = gw(), ft = 4) : ft = a === am ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1, Dr = a, qe === null && (Yt = 1, A1(o, jr(a, o.current)));
        }
        function e7() {
            var o = _r.current;
            return o === null ? !0 : (Ye & 4194048) === Ye ? es === null : (Ye & 62914560) === Ye || (Ye & 536870912) !== 0 ? o === es : !1;
        }
        function t7() {
            var o = B.H;
            return B.H = Zu, o === null ? Zu : o;
        }
        function n7() {
            var o = B.A;
            return B.A = ZR, o;
        }
        function O1() {
            Yt = 4, fo || (Ye & 4194048) !== Ye && _r.current !== null || (Bl = !0), (po & 134217727) === 0 && (wa & 134217727) === 0 || Ct === null || yo(Ct, Ye, Br, !1);
        }
        function Bm(o, a, c) {
            var d = lt;
            lt |= 2;
            var g = t7(), y = n7();
            (Ct !== o || Ye !== a) && (k1 = null, Rl(o, a)), a = !1;
            var E = Yt;
            e: do try {
                if (ft !== 0 && qe !== null) {
                    var C = qe, R = Dr;
                    switch(ft){
                        case 8:
                            Dm(), E = 6;
                            break e;
                        case 3:
                        case 2:
                        case 9:
                        case 6:
                            _r.current === null && (a = !0);
                            var Z = ft;
                            if (ft = 0, Dr = null, Ol(o, C, R, Z), c && Bl) {
                                E = 0;
                                break e;
                            }
                            break;
                        default:
                            Z = ft, ft = 0, Dr = null, Ol(o, C, R, Z);
                    }
                }
                nO(), E = Yt;
                break;
            } catch (ue) {
                Zb(o, ue);
            }
            while (!0);
            return a && o.shellSuspendCounter++, Ai = ca = null, lt = d, B.H = g, B.A = y, qe === null && (Ct = null, Ye = 0, e1()), E;
        }
        function nO() {
            for(; qe !== null;)r7(qe);
        }
        function rO(o, a) {
            var c = lt;
            lt |= 2;
            var d = t7(), g = n7();
            Ct !== o || Ye !== a ? (k1 = null, P1 = dn() + 500, Rl(o, a)) : Bl = xu(o, a);
            e: do try {
                if (ft !== 0 && qe !== null) {
                    a = qe;
                    var y = Dr;
                    t: switch(ft){
                        case 1:
                            ft = 0, Dr = null, Ol(o, a, y, 1);
                            break;
                        case 2:
                        case 9:
                            if (fw(y)) {
                                ft = 0, Dr = null, s7(a);
                                break;
                            }
                            a = function() {
                                ft !== 2 && ft !== 9 || Ct !== o || (ft = 7), Ys(o);
                            }, y.then(a, a);
                            break e;
                        case 3:
                            ft = 7;
                            break e;
                        case 4:
                            ft = 5;
                            break e;
                        case 7:
                            fw(y) ? (ft = 0, Dr = null, s7(a)) : (ft = 0, Dr = null, Ol(o, a, y, 7));
                            break;
                        case 5:
                            var E = null;
                            switch(qe.tag){
                                case 26:
                                    E = qe.memoizedState;
                                case 5:
                                case 27:
                                    var C = qe;
                                    if (E ? H7(E) : C.stateNode.complete) {
                                        ft = 0, Dr = null;
                                        var R = C.sibling;
                                        if (R !== null) qe = R;
                                        else {
                                            var Z = C.return;
                                            Z !== null ? (qe = Z, $1(Z)) : qe = null;
                                        }
                                        break t;
                                    }
                            }
                            ft = 0, Dr = null, Ol(o, a, y, 5);
                            break;
                        case 6:
                            ft = 0, Dr = null, Ol(o, a, y, 6);
                            break;
                        case 8:
                            Dm(), Yt = 6;
                            break e;
                        default:
                            throw Error(r(462));
                    }
                }
                sO();
                break;
            } catch (ue) {
                Zb(o, ue);
            }
            while (!0);
            return Ai = ca = null, B.H = d, B.A = g, lt = c, qe !== null ? 0 : (Ct = null, Ye = 0, e1(), Yt);
        }
        function sO() {
            for(; qe !== null && !Qg();)r7(qe);
        }
        function r7(o) {
            var a = _b(o.alternate, o, ki);
            o.memoizedProps = o.pendingProps, a === null ? $1(o) : qe = a;
        }
        function s7(o) {
            var a = o, c = a.alternate;
            switch(a.tag){
                case 15:
                case 0:
                    a = Eb(c, a, a.pendingProps, a.type, void 0, Ye);
                    break;
                case 11:
                    a = Eb(c, a, a.pendingProps, a.type.render, a.ref, Ye);
                    break;
                case 5:
                    q2(a);
                default:
                    Db(c, a), a = qe = nw(a, ki), a = _b(c, a, ki);
            }
            o.memoizedProps = o.pendingProps, a === null ? $1(o) : qe = a;
        }
        function Ol(o, a, c, d) {
            Ai = ca = null, q2(a), Sl = null, qu = 0;
            var g = a.return;
            try {
                if (KR(o, g, a, c, Ye)) {
                    Yt = 1, A1(o, jr(c, o.current)), qe = null;
                    return;
                }
            } catch (y) {
                if (g !== null) throw qe = g, y;
                Yt = 1, A1(o, jr(c, o.current)), qe = null;
                return;
            }
            a.flags & 32768 ? (Ze || d === 1 ? o = !0 : Bl || (Ye & 536870912) !== 0 ? o = !1 : (fo = o = !0, (d === 2 || d === 9 || d === 3 || d === 6) && (d = _r.current, d !== null && d.tag === 13 && (d.flags |= 16384))), i7(a, o)) : $1(a);
        }
        function $1(o) {
            var a = o;
            do {
                if ((a.flags & 32768) !== 0) {
                    i7(a, fo);
                    return;
                }
                o = a.return;
                var c = WR(a.alternate, a, ki);
                if (c !== null) {
                    qe = c;
                    return;
                }
                if (a = a.sibling, a !== null) {
                    qe = a;
                    return;
                }
                qe = a = o;
            }while (a !== null);
            Yt === 0 && (Yt = 5);
        }
        function i7(o, a) {
            do {
                var c = jR(o.alternate, o);
                if (c !== null) {
                    c.flags &= 32767, qe = c;
                    return;
                }
                if (c = o.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !a && (o = o.sibling, o !== null)) {
                    qe = o;
                    return;
                }
                qe = o = c;
            }while (o !== null);
            Yt = 6, qe = null;
        }
        function o7(o, a, c, d, g, y, E, C, R) {
            o.cancelPendingCommit = null;
            do M1();
            while (ln !== 0);
            if ((lt & 6) !== 0) throw Error(r(327));
            if (a !== null) {
                if (a === o.current) throw Error(r(177));
                if (y = a.lanes | a.childLanes, y |= w2, Nk(o, c, y, E, C, R), o === Ct && (qe = Ct = null, Ye = 0), kl = a, mo = o, Ri = c, Tm = y, _m = g, Wb = d, (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, lO(Ir, function() {
                    return h7(), null;
                })) : (o.callbackNode = null, o.callbackPriority = 0), d = (a.flags & 13878) !== 0, (a.subtreeFlags & 13878) !== 0 || d) {
                    d = B.T, B.T = null, g = z.p, z.p = 2, E = lt, lt |= 4;
                    try {
                        XR(o, a, c);
                    } finally{
                        lt = E, z.p = g, B.T = d;
                    }
                }
                ln = 1, a7(), l7(), c7();
            }
        }
        function a7() {
            if (ln === 1) {
                ln = 0;
                var o = mo, a = kl, c = (a.flags & 13878) !== 0;
                if ((a.subtreeFlags & 13878) !== 0 || c) {
                    c = B.T, B.T = null;
                    var d = z.p;
                    z.p = 2;
                    var g = lt;
                    lt |= 4;
                    try {
                        Fb(a, o);
                        var y = Vm, E = G5(o.containerInfo), C = y.focusedElem, R = y.selectionRange;
                        if (E !== C && C && C.ownerDocument && K5(C.ownerDocument.documentElement, C)) {
                            if (R !== null && f2(C)) {
                                var Z = R.start, ue = R.end;
                                if (ue === void 0 && (ue = Z), "selectionStart" in C) C.selectionStart = Z, C.selectionEnd = Math.min(ue, C.value.length);
                                else {
                                    var fe = C.ownerDocument || document, te = fe && fe.defaultView || window;
                                    if (te.getSelection) {
                                        var ie = te.getSelection(), Ie = C.textContent.length, Oe = Math.min(R.start, Ie), bt = R.end === void 0 ? Oe : Math.min(R.end, Ie);
                                        !ie.extend && Oe > bt && (E = bt, bt = Oe, Oe = E);
                                        var W = q5(C, Oe), M = q5(C, bt);
                                        if (W && M && (ie.rangeCount !== 1 || ie.anchorNode !== W.node || ie.anchorOffset !== W.offset || ie.focusNode !== M.node || ie.focusOffset !== M.offset)) {
                                            var X = fe.createRange();
                                            X.setStart(W.node, W.offset), ie.removeAllRanges(), Oe > bt ? (ie.addRange(X), ie.extend(M.node, M.offset)) : (X.setEnd(M.node, M.offset), ie.addRange(X));
                                        }
                                    }
                                }
                            }
                            for(fe = [], ie = C; ie = ie.parentNode;)ie.nodeType === 1 && fe.push({
                                element: ie,
                                left: ie.scrollLeft,
                                top: ie.scrollTop
                            });
                            for(typeof C.focus == "function" && C.focus(), C = 0; C < fe.length; C++){
                                var he = fe[C];
                                he.element.scrollLeft = he.left, he.element.scrollTop = he.top;
                            }
                        }
                        Y1 = !!Fm, Vm = Fm = null;
                    } finally{
                        lt = g, z.p = d, B.T = c;
                    }
                }
                o.current = a, ln = 2;
            }
        }
        function l7() {
            if (ln === 2) {
                ln = 0;
                var o = mo, a = kl, c = (a.flags & 8772) !== 0;
                if ((a.subtreeFlags & 8772) !== 0 || c) {
                    c = B.T, B.T = null;
                    var d = z.p;
                    z.p = 2;
                    var g = lt;
                    lt |= 4;
                    try {
                        Mb(o, a.alternate, a);
                    } finally{
                        lt = g, z.p = d, B.T = c;
                    }
                }
                ln = 3;
            }
        }
        function c7() {
            if (ln === 4 || ln === 3) {
                ln = 0, Uf();
                var o = mo, a = kl, c = Ri, d = Wb;
                (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? ln = 5 : (ln = 0, kl = mo = null, u7(o, o.pendingLanes));
                var g = o.pendingLanes;
                if (g === 0 && (go = null), Yg(c), a = a.stateNode, N && typeof N.onCommitFiberRoot == "function") try {
                    N.onCommitFiberRoot(D, a, void 0, (a.current.flags & 128) === 128);
                } catch  {}
                if (d !== null) {
                    a = B.T, g = z.p, z.p = 2, B.T = null;
                    try {
                        for(var y = o.onRecoverableError, E = 0; E < d.length; E++){
                            var C = d[E];
                            y(C.value, {
                                componentStack: C.stack
                            });
                        }
                    } finally{
                        B.T = a, z.p = g;
                    }
                }
                (Ri & 3) !== 0 && M1(), Ys(o), g = o.pendingLanes, (c & 261930) !== 0 && (g & 42) !== 0 ? o === xm ? lh++ : (lh = 0, xm = o) : lh = 0, ch(0);
            }
        }
        function u7(o, a) {
            (o.pooledCacheLanes &= a) === 0 && (a = o.pooledCache, a != null && (o.pooledCache = null, Hu(a)));
        }
        function M1() {
            return a7(), l7(), c7(), h7();
        }
        function h7() {
            if (ln !== 5) return !1;
            var o = mo, a = Tm;
            Tm = 0;
            var c = Yg(Ri), d = B.T, g = z.p;
            try {
                z.p = 32 > c ? 32 : c, B.T = null, c = _m, _m = null;
                var y = mo, E = Ri;
                if (ln = 0, kl = mo = null, Ri = 0, (lt & 6) !== 0) throw Error(r(331));
                var C = lt;
                if (lt |= 4, Kb(y.current), Hb(y, y.current, E, c), lt = C, ch(0, !1), N && typeof N.onPostCommitFiberRoot == "function") try {
                    N.onPostCommitFiberRoot(D, y);
                } catch  {}
                return !0;
            } finally{
                z.p = g, B.T = d, u7(o, a);
            }
        }
        function d7(o, a, c) {
            a = jr(c, a), a = om(o.stateNode, a, 2), o = lo(o, a, 2), o !== null && (Du(o, 2), Ys(o));
        }
        function pt(o, a, c) {
            if (o.tag === 3) d7(o, o, c);
            else for(; a !== null;){
                if (a.tag === 3) {
                    d7(a, o, c);
                    break;
                } else if (a.tag === 1) {
                    var d = a.stateNode;
                    if (typeof a.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (go === null || !go.has(d))) {
                        o = jr(c, o), c = fb(2), d = lo(a, c, 2), d !== null && (pb(c, d, a, o), Du(d, 2), Ys(d));
                        break;
                    }
                }
                a = a.return;
            }
        }
        function Pm(o, a, c) {
            var d = o.pingCache;
            if (d === null) {
                d = o.pingCache = new eO;
                var g = new Set;
                d.set(a, g);
            } else g = d.get(a), g === void 0 && (g = new Set, d.set(a, g));
            g.has(c) || (Sm = !0, g.add(c), o = iO.bind(null, o, a, c), a.then(o, o));
        }
        function iO(o, a, c) {
            var d = o.pingCache;
            d !== null && d.delete(a), o.pingedLanes |= o.suspendedLanes & c, o.warmLanes &= ~c, Ct === o && (Ye & c) === c && (Yt === 4 || Yt === 3 && (Ye & 62914560) === Ye && 300 > dn() - B1 ? (lt & 2) === 0 && Rl(o, 0) : Im |= c, Pl === Ye && (Pl = 0)), Ys(o);
        }
        function f7(o, a) {
            a === 0 && (a = a5()), o = oa(o, a), o !== null && (Du(o, a), Ys(o));
        }
        function oO(o) {
            var a = o.memoizedState, c = 0;
            a !== null && (c = a.retryLane), f7(o, c);
        }
        function aO(o, a) {
            var c = 0;
            switch(o.tag){
                case 31:
                case 13:
                    var d = o.stateNode, g = o.memoizedState;
                    g !== null && (c = g.retryLane);
                    break;
                case 19:
                    d = o.stateNode;
                    break;
                case 22:
                    d = o.stateNode._retryCache;
                    break;
                default:
                    throw Error(r(314));
            }
            d !== null && d.delete(a), f7(o, c);
        }
        function lO(o, a) {
            return ea(o, a);
        }
        var N1 = null, $l = null, km = !1, L1 = !1, Rm = !1, wo = 0;
        function Ys(o) {
            o !== $l && o.next === null && ($l === null ? N1 = $l = o : $l = $l.next = o), L1 = !0, km || (km = !0, uO());
        }
        function ch(o, a) {
            if (!Rm && L1) {
                Rm = !0;
                do for(var c = !1, d = N1; d !== null;){
                    if (o !== 0) {
                        var g = d.pendingLanes;
                        if (g === 0) var y = 0;
                        else {
                            var E = d.suspendedLanes, C = d.pingedLanes;
                            y = (1 << 31 - le(42 | o) + 1) - 1, y &= g & ~(E & ~C), y = y & 201326741 ? y & 201326741 | 1 : y ? y | 2 : 0;
                        }
                        y !== 0 && (c = !0, y7(d, y));
                    } else y = Ye, y = Vf(d, d === Ct ? y : 0, d.cancelPendingCommit !== null || d.timeoutHandle !== -1), (y & 3) === 0 || xu(d, y) || (c = !0, y7(d, y));
                    d = d.next;
                }
                while (c);
                Rm = !1;
            }
        }
        function cO() {
            p7();
        }
        function p7() {
            L1 = km = !1;
            var o = 0;
            wo !== 0 && vO() && (o = wo);
            for(var a = dn(), c = null, d = N1; d !== null;){
                var g = d.next, y = g7(d, a);
                y === 0 ? (d.next = null, c === null ? N1 = g : c.next = g, g === null && ($l = c)) : (c = d, (o !== 0 || (y & 3) !== 0) && (L1 = !0)), d = g;
            }
            ln !== 0 && ln !== 5 || ch(o), wo !== 0 && (wo = 0);
        }
        function g7(o, a) {
            for(var c = o.suspendedLanes, d = o.pingedLanes, g = o.expirationTimes, y = o.pendingLanes & -62914561; 0 < y;){
                var E = 31 - le(y), C = 1 << E, R = g[E];
                R === -1 ? ((C & c) === 0 || (C & d) !== 0) && (g[E] = Mk(C, a)) : R <= a && (o.expiredLanes |= C), y &= ~C;
            }
            if (a = Ct, c = Ye, c = Vf(o, o === a ? c : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1), d = o.callbackNode, c === 0 || o === a && (ft === 2 || ft === 9) || o.cancelPendingCommit !== null) return d !== null && d !== null && _u(d), o.callbackNode = null, o.callbackPriority = 0;
            if ((c & 3) === 0 || xu(o, c)) {
                if (a = c & -c, a === o.callbackPriority) return a;
                switch(d !== null && _u(d), Yg(c)){
                    case 2:
                    case 8:
                        c = zf;
                        break;
                    case 32:
                        c = Ir;
                        break;
                    case 268435456:
                        c = T;
                        break;
                    default:
                        c = Ir;
                }
                return d = m7.bind(null, o), c = ea(c, d), o.callbackPriority = a, o.callbackNode = c, a;
            }
            return d !== null && d !== null && _u(d), o.callbackPriority = 2, o.callbackNode = null, 2;
        }
        function m7(o, a) {
            if (ln !== 0 && ln !== 5) return o.callbackNode = null, o.callbackPriority = 0, null;
            var c = o.callbackNode;
            if (M1() && o.callbackNode !== c) return null;
            var d = Ye;
            return d = Vf(o, o === Ct ? d : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1), d === 0 ? null : (Xb(o, d, a), g7(o, dn()), o.callbackNode != null && o.callbackNode === c ? m7.bind(null, o) : null);
        }
        function y7(o, a) {
            if (M1()) return null;
            Xb(o, a, !0);
        }
        function uO() {
            AO(function() {
                (lt & 6) !== 0 ? ea(tl, cO) : p7();
            });
        }
        function Om() {
            if (wo === 0) {
                var o = vl;
                o === 0 && (o = It, It <<= 1, (It & 261888) === 0 && (It = 256)), wo = o;
            }
            return wo;
        }
        function w7(o) {
            return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Kf("" + o);
        }
        function b7(o, a) {
            var c = a.ownerDocument.createElement("input");
            return c.name = a.name, c.value = a.value, o.id && c.setAttribute("form", o.id), a.parentNode.insertBefore(c, a), o = new FormData(o), c.parentNode.removeChild(c), o;
        }
        function hO(o, a, c, d, g) {
            if (a === "submit" && c && c.stateNode === g) {
                var y = w7((g[or] || null).action), E = d.submitter;
                E && (a = (a = E[or] || null) ? w7(a.formAction) : E.getAttribute("formAction"), a !== null && (y = a, E = null));
                var C = new jf("action", "action", null, d, g);
                o.push({
                    event: C,
                    listeners: [
                        {
                            instance: null,
                            listener: function() {
                                if (d.defaultPrevented) {
                                    if (wo !== 0) {
                                        var R = E ? b7(g, E) : new FormData(g);
                                        em(c, {
                                            pending: !0,
                                            data: R,
                                            method: g.method,
                                            action: y
                                        }, null, R);
                                    }
                                } else typeof y == "function" && (C.preventDefault(), R = E ? b7(g, E) : new FormData(g), em(c, {
                                    pending: !0,
                                    data: R,
                                    method: g.method,
                                    action: y
                                }, y, R));
                            },
                            currentTarget: g
                        }
                    ]
                });
            }
        }
        for(var $m = 0; $m < y2.length; $m++){
            var Mm = y2[$m], dO = Mm.toLowerCase(), fO = Mm[0].toUpperCase() + Mm.slice(1);
            _s(dO, "on" + fO);
        }
        _s(j5, "onAnimationEnd"), _s(X5, "onAnimationIteration"), _s(J5, "onAnimationStart"), _s("dblclick", "onDoubleClick"), _s("focusin", "onFocus"), _s("focusout", "onBlur"), _s(DR, "onTransitionRun"), _s(BR, "onTransitionStart"), _s(PR, "onTransitionCancel"), _s(Z5, "onTransitionEnd"), ol("onMouseEnter", [
            "mouseout",
            "mouseover"
        ]), ol("onMouseLeave", [
            "mouseout",
            "mouseover"
        ]), ol("onPointerEnter", [
            "pointerout",
            "pointerover"
        ]), ol("onPointerLeave", [
            "pointerout",
            "pointerover"
        ]), na("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), na("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), na("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste"
        ]), na("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), na("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), na("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var uh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), pO = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(uh));
        function v7(o, a) {
            a = (a & 4) !== 0;
            for(var c = 0; c < o.length; c++){
                var d = o[c], g = d.event;
                d = d.listeners;
                e: {
                    var y = void 0;
                    if (a) for(var E = d.length - 1; 0 <= E; E--){
                        var C = d[E], R = C.instance, Z = C.currentTarget;
                        if (C = C.listener, R !== y && g.isPropagationStopped()) break e;
                        y = C, g.currentTarget = Z;
                        try {
                            y(g);
                        } catch (ue) {
                            Zf(ue);
                        }
                        g.currentTarget = null, y = R;
                    }
                    else for(E = 0; E < d.length; E++){
                        if (C = d[E], R = C.instance, Z = C.currentTarget, C = C.listener, R !== y && g.isPropagationStopped()) break e;
                        y = C, g.currentTarget = Z;
                        try {
                            y(g);
                        } catch (ue) {
                            Zf(ue);
                        }
                        g.currentTarget = null, y = R;
                    }
                }
            }
        }
        function Ke(o, a) {
            var c = a[Wg];
            c === void 0 && (c = a[Wg] = new Set);
            var d = o + "__bubble";
            c.has(d) || (E7(a, o, 2, !1), c.add(d));
        }
        function Nm(o, a, c) {
            var d = 0;
            a && (d |= 4), E7(c, o, d, a);
        }
        var U1 = "_reactListening" + Math.random().toString(36).slice(2);
        function Lm(o) {
            if (!o[U1]) {
                o[U1] = !0, p5.forEach(function(c) {
                    c !== "selectionchange" && (pO.has(c) || Nm(c, !1, o), Nm(c, !0, o));
                });
                var a = o.nodeType === 9 ? o : o.ownerDocument;
                a === null || a[U1] || (a[U1] = !0, Nm("selectionchange", !1, a));
            }
        }
        function E7(o, a, c, d) {
            switch(j7(a)){
                case 2:
                    var g = VO;
                    break;
                case 8:
                    g = HO;
                    break;
                default:
                    g = Zm;
            }
            c = g.bind(null, a, c, o), g = void 0, !s2 || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (g = !0), d ? g !== void 0 ? o.addEventListener(a, c, {
                capture: !0,
                passive: g
            }) : o.addEventListener(a, c, !0) : g !== void 0 ? o.addEventListener(a, c, {
                passive: g
            }) : o.addEventListener(a, c, !1);
        }
        function Um(o, a, c, d, g) {
            var y = d;
            if ((a & 1) === 0 && (a & 2) === 0 && d !== null) e: for(;;){
                if (d === null) return;
                var E = d.tag;
                if (E === 3 || E === 4) {
                    var C = d.stateNode.containerInfo;
                    if (C === g) break;
                    if (E === 4) for(E = d.return; E !== null;){
                        var R = E.tag;
                        if ((R === 3 || R === 4) && E.stateNode.containerInfo === g) return;
                        E = E.return;
                    }
                    for(; C !== null;){
                        if (E = rl(C), E === null) return;
                        if (R = E.tag, R === 5 || R === 6 || R === 26 || R === 27) {
                            d = y = E;
                            continue e;
                        }
                        C = C.parentNode;
                    }
                }
                d = d.return;
            }
            T5(function() {
                var Z = y, ue = n2(c), fe = [];
                e: {
                    var te = ew.get(o);
                    if (te !== void 0) {
                        var ie = jf, Ie = o;
                        switch(o){
                            case "keypress":
                                if (Yf(c) === 0) break e;
                            case "keydown":
                            case "keyup":
                                ie = aR;
                                break;
                            case "focusin":
                                Ie = "focus", ie = l2;
                                break;
                            case "focusout":
                                Ie = "blur", ie = l2;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                ie = l2;
                                break;
                            case "click":
                                if (c.button === 2) break e;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                ie = D5;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                ie = Wk;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                ie = uR;
                                break;
                            case j5:
                            case X5:
                            case J5:
                                ie = Jk;
                                break;
                            case Z5:
                                ie = dR;
                                break;
                            case "scroll":
                            case "scrollend":
                                ie = Gk;
                                break;
                            case "wheel":
                                ie = pR;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                ie = eR;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                ie = P5;
                                break;
                            case "toggle":
                            case "beforetoggle":
                                ie = mR;
                        }
                        var Oe = (a & 4) !== 0, bt = !Oe && (o === "scroll" || o === "scrollend"), W = Oe ? te !== null ? te + "Capture" : null : te;
                        Oe = [];
                        for(var M = Z, X; M !== null;){
                            var he = M;
                            if (X = he.stateNode, he = he.tag, he !== 5 && he !== 26 && he !== 27 || X === null || W === null || (he = ku(M, W), he != null && Oe.push(hh(M, he, X))), bt) break;
                            M = M.return;
                        }
                        0 < Oe.length && (te = new ie(te, Ie, null, c, ue), fe.push({
                            event: te,
                            listeners: Oe
                        }));
                    }
                }
                if ((a & 7) === 0) {
                    e: {
                        if (te = o === "mouseover" || o === "pointerover", ie = o === "mouseout" || o === "pointerout", te && c !== t2 && (Ie = c.relatedTarget || c.fromElement) && (rl(Ie) || Ie[nl])) break e;
                        if ((ie || te) && (te = ue.window === ue ? ue : (te = ue.ownerDocument) ? te.defaultView || te.parentWindow : window, ie ? (Ie = c.relatedTarget || c.toElement, ie = Z, Ie = Ie ? rl(Ie) : null, Ie !== null && (bt = i(Ie), Oe = Ie.tag, Ie !== bt || Oe !== 5 && Oe !== 27 && Oe !== 6) && (Ie = null)) : (ie = null, Ie = Z), ie !== Ie)) {
                            if (Oe = D5, he = "onMouseLeave", W = "onMouseEnter", M = "mouse", (o === "pointerout" || o === "pointerover") && (Oe = P5, he = "onPointerLeave", W = "onPointerEnter", M = "pointer"), bt = ie == null ? te : Pu(ie), X = Ie == null ? te : Pu(Ie), te = new Oe(he, M + "leave", ie, c, ue), te.target = bt, te.relatedTarget = X, he = null, rl(ue) === Z && (Oe = new Oe(W, M + "enter", Ie, c, ue), Oe.target = X, Oe.relatedTarget = bt, he = Oe), bt = he, ie && Ie) t: {
                                for(Oe = gO, W = ie, M = Ie, X = 0, he = W; he; he = Oe(he))X++;
                                he = 0;
                                for(var Pe = M; Pe; Pe = Oe(Pe))he++;
                                for(; 0 < X - he;)W = Oe(W), X--;
                                for(; 0 < he - X;)M = Oe(M), he--;
                                for(; X--;){
                                    if (W === M || M !== null && W === M.alternate) {
                                        Oe = W;
                                        break t;
                                    }
                                    W = Oe(W), M = Oe(M);
                                }
                                Oe = null;
                            }
                            else Oe = null;
                            ie !== null && A7(fe, te, ie, Oe, !1), Ie !== null && bt !== null && A7(fe, bt, Ie, Oe, !0);
                        }
                    }
                    e: {
                        if (te = Z ? Pu(Z) : window, ie = te.nodeName && te.nodeName.toLowerCase(), ie === "select" || ie === "input" && te.type === "file") var st = U5;
                        else if (N5(te)) if (z5) st = TR;
                        else {
                            st = IR;
                            var _e = SR;
                        }
                        else ie = te.nodeName, !ie || ie.toLowerCase() !== "input" || te.type !== "checkbox" && te.type !== "radio" ? Z && e2(Z.elementType) && (st = U5) : st = CR;
                        if (st && (st = st(o, Z))) {
                            L5(fe, st, c, ue);
                            break e;
                        }
                        _e && _e(o, te, Z), o === "focusout" && Z && te.type === "number" && Z.memoizedProps.value != null && Zg(te, "number", te.value);
                    }
                    switch(_e = Z ? Pu(Z) : window, o){
                        case "focusin":
                            (N5(_e) || _e.contentEditable === "true") && (dl = _e, p2 = Z, zu = null);
                            break;
                        case "focusout":
                            zu = p2 = dl = null;
                            break;
                        case "mousedown":
                            g2 = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            g2 = !1, Y5(fe, c, ue);
                            break;
                        case "selectionchange":
                            if (xR) break;
                        case "keydown":
                        case "keyup":
                            Y5(fe, c, ue);
                    }
                    var Fe;
                    if (u2) e: {
                        switch(o){
                            case "compositionstart":
                                var We = "onCompositionStart";
                                break e;
                            case "compositionend":
                                We = "onCompositionEnd";
                                break e;
                            case "compositionupdate":
                                We = "onCompositionUpdate";
                                break e;
                        }
                        We = void 0;
                    }
                    else hl ? $5(o, c) && (We = "onCompositionEnd") : o === "keydown" && c.keyCode === 229 && (We = "onCompositionStart");
                    We && (k5 && c.locale !== "ko" && (hl || We !== "onCompositionStart" ? We === "onCompositionEnd" && hl && (Fe = _5()) : (to = ue, i2 = "value" in to ? to.value : to.textContent, hl = !0)), _e = z1(Z, We), 0 < _e.length && (We = new B5(We, o, null, c, ue), fe.push({
                        event: We,
                        listeners: _e
                    }), Fe ? We.data = Fe : (Fe = M5(c), Fe !== null && (We.data = Fe)))), (Fe = wR ? bR(o, c) : vR(o, c)) && (We = z1(Z, "onBeforeInput"), 0 < We.length && (_e = new B5("onBeforeInput", "beforeinput", null, c, ue), fe.push({
                        event: _e,
                        listeners: We
                    }), _e.data = Fe)), hO(fe, o, Z, c, ue);
                }
                v7(fe, a);
            });
        }
        function hh(o, a, c) {
            return {
                instance: o,
                listener: a,
                currentTarget: c
            };
        }
        function z1(o, a) {
            for(var c = a + "Capture", d = []; o !== null;){
                var g = o, y = g.stateNode;
                if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || y === null || (g = ku(o, c), g != null && d.unshift(hh(o, g, y)), g = ku(o, a), g != null && d.push(hh(o, g, y))), o.tag === 3) return d;
                o = o.return;
            }
            return [];
        }
        function gO(o) {
            if (o === null) return null;
            do o = o.return;
            while (o && o.tag !== 5 && o.tag !== 27);
            return o || null;
        }
        function A7(o, a, c, d, g) {
            for(var y = a._reactName, E = []; c !== null && c !== d;){
                var C = c, R = C.alternate, Z = C.stateNode;
                if (C = C.tag, R !== null && R === d) break;
                C !== 5 && C !== 26 && C !== 27 || Z === null || (R = Z, g ? (Z = ku(c, y), Z != null && E.unshift(hh(c, Z, R))) : g || (Z = ku(c, y), Z != null && E.push(hh(c, Z, R)))), c = c.return;
            }
            E.length !== 0 && o.push({
                event: a,
                listeners: E
            });
        }
        var mO = /\r\n?/g, yO = /\u0000|\uFFFD/g;
        function S7(o) {
            return (typeof o == "string" ? o : "" + o).replace(mO, `
`).replace(yO, "");
        }
        function I7(o, a) {
            return a = S7(a), S7(o) === a;
        }
        function wt(o, a, c, d, g, y) {
            switch(c){
                case "children":
                    typeof d == "string" ? a === "body" || a === "textarea" && d === "" || ll(o, d) : (typeof d == "number" || typeof d == "bigint") && a !== "body" && ll(o, "" + d);
                    break;
                case "className":
                    Qf(o, "class", d);
                    break;
                case "tabIndex":
                    Qf(o, "tabindex", d);
                    break;
                case "dir":
                case "role":
                case "viewBox":
                case "width":
                case "height":
                    Qf(o, c, d);
                    break;
                case "style":
                    I5(o, d, y);
                    break;
                case "data":
                    if (a !== "object") {
                        Qf(o, "data", d);
                        break;
                    }
                case "src":
                case "href":
                    if (d === "" && (a !== "a" || c !== "href")) {
                        o.removeAttribute(c);
                        break;
                    }
                    if (d == null || typeof d == "function" || typeof d == "symbol" || typeof d == "boolean") {
                        o.removeAttribute(c);
                        break;
                    }
                    d = Kf("" + d), o.setAttribute(c, d);
                    break;
                case "action":
                case "formAction":
                    if (typeof d == "function") {
                        o.setAttribute(c, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                        break;
                    } else typeof y == "function" && (c === "formAction" ? (a !== "input" && wt(o, a, "name", g.name, g, null), wt(o, a, "formEncType", g.formEncType, g, null), wt(o, a, "formMethod", g.formMethod, g, null), wt(o, a, "formTarget", g.formTarget, g, null)) : (wt(o, a, "encType", g.encType, g, null), wt(o, a, "method", g.method, g, null), wt(o, a, "target", g.target, g, null)));
                    if (d == null || typeof d == "symbol" || typeof d == "boolean") {
                        o.removeAttribute(c);
                        break;
                    }
                    d = Kf("" + d), o.setAttribute(c, d);
                    break;
                case "onClick":
                    d != null && (o.onclick = wi);
                    break;
                case "onScroll":
                    d != null && Ke("scroll", o);
                    break;
                case "onScrollEnd":
                    d != null && Ke("scrollend", o);
                    break;
                case "dangerouslySetInnerHTML":
                    if (d != null) {
                        if (typeof d != "object" || !("__html" in d)) throw Error(r(61));
                        if (c = d.__html, c != null) {
                            if (g.children != null) throw Error(r(60));
                            o.innerHTML = c;
                        }
                    }
                    break;
                case "multiple":
                    o.multiple = d && typeof d != "function" && typeof d != "symbol";
                    break;
                case "muted":
                    o.muted = d && typeof d != "function" && typeof d != "symbol";
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                    break;
                case "autoFocus":
                    break;
                case "xlinkHref":
                    if (d == null || typeof d == "function" || typeof d == "boolean" || typeof d == "symbol") {
                        o.removeAttribute("xlink:href");
                        break;
                    }
                    c = Kf("" + d), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", c);
                    break;
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                    d != null && typeof d != "function" && typeof d != "symbol" ? o.setAttribute(c, "" + d) : o.removeAttribute(c);
                    break;
                case "inert":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                    d && typeof d != "function" && typeof d != "symbol" ? o.setAttribute(c, "") : o.removeAttribute(c);
                    break;
                case "capture":
                case "download":
                    d === !0 ? o.setAttribute(c, "") : d !== !1 && d != null && typeof d != "function" && typeof d != "symbol" ? o.setAttribute(c, d) : o.removeAttribute(c);
                    break;
                case "cols":
                case "rows":
                case "size":
                case "span":
                    d != null && typeof d != "function" && typeof d != "symbol" && !isNaN(d) && 1 <= d ? o.setAttribute(c, d) : o.removeAttribute(c);
                    break;
                case "rowSpan":
                case "start":
                    d == null || typeof d == "function" || typeof d == "symbol" || isNaN(d) ? o.removeAttribute(c) : o.setAttribute(c, d);
                    break;
                case "popover":
                    Ke("beforetoggle", o), Ke("toggle", o), Hf(o, "popover", d);
                    break;
                case "xlinkActuate":
                    yi(o, "http://www.w3.org/1999/xlink", "xlink:actuate", d);
                    break;
                case "xlinkArcrole":
                    yi(o, "http://www.w3.org/1999/xlink", "xlink:arcrole", d);
                    break;
                case "xlinkRole":
                    yi(o, "http://www.w3.org/1999/xlink", "xlink:role", d);
                    break;
                case "xlinkShow":
                    yi(o, "http://www.w3.org/1999/xlink", "xlink:show", d);
                    break;
                case "xlinkTitle":
                    yi(o, "http://www.w3.org/1999/xlink", "xlink:title", d);
                    break;
                case "xlinkType":
                    yi(o, "http://www.w3.org/1999/xlink", "xlink:type", d);
                    break;
                case "xmlBase":
                    yi(o, "http://www.w3.org/XML/1998/namespace", "xml:base", d);
                    break;
                case "xmlLang":
                    yi(o, "http://www.w3.org/XML/1998/namespace", "xml:lang", d);
                    break;
                case "xmlSpace":
                    yi(o, "http://www.w3.org/XML/1998/namespace", "xml:space", d);
                    break;
                case "is":
                    Hf(o, "is", d);
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = qk.get(c) || c, Hf(o, c, d));
            }
        }
        function zm(o, a, c, d, g, y) {
            switch(c){
                case "style":
                    I5(o, d, y);
                    break;
                case "dangerouslySetInnerHTML":
                    if (d != null) {
                        if (typeof d != "object" || !("__html" in d)) throw Error(r(61));
                        if (c = d.__html, c != null) {
                            if (g.children != null) throw Error(r(60));
                            o.innerHTML = c;
                        }
                    }
                    break;
                case "children":
                    typeof d == "string" ? ll(o, d) : (typeof d == "number" || typeof d == "bigint") && ll(o, "" + d);
                    break;
                case "onScroll":
                    d != null && Ke("scroll", o);
                    break;
                case "onScrollEnd":
                    d != null && Ke("scrollend", o);
                    break;
                case "onClick":
                    d != null && (o.onclick = wi);
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "innerHTML":
                case "ref":
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    if (!g5.hasOwnProperty(c)) e: {
                        if (c[0] === "o" && c[1] === "n" && (g = c.endsWith("Capture"), a = c.slice(2, g ? c.length - 7 : void 0), y = o[or] || null, y = y != null ? y[c] : null, typeof y == "function" && o.removeEventListener(a, y, g), typeof d == "function")) {
                            typeof y != "function" && y !== null && (c in o ? o[c] = null : o.hasAttribute(c) && o.removeAttribute(c)), o.addEventListener(a, d, g);
                            break e;
                        }
                        c in o ? o[c] = d : d === !0 ? o.setAttribute(c, "") : Hf(o, c, d);
                    }
            }
        }
        function An(o, a, c) {
            switch(a){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "img":
                    Ke("error", o), Ke("load", o);
                    var d = !1, g = !1, y;
                    for(y in c)if (c.hasOwnProperty(y)) {
                        var E = c[y];
                        if (E != null) switch(y){
                            case "src":
                                d = !0;
                                break;
                            case "srcSet":
                                g = !0;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                throw Error(r(137, a));
                            default:
                                wt(o, a, y, E, c, null);
                        }
                    }
                    g && wt(o, a, "srcSet", c.srcSet, c, null), d && wt(o, a, "src", c.src, c, null);
                    return;
                case "input":
                    Ke("invalid", o);
                    var C = y = E = g = null, R = null, Z = null;
                    for(d in c)if (c.hasOwnProperty(d)) {
                        var ue = c[d];
                        if (ue != null) switch(d){
                            case "name":
                                g = ue;
                                break;
                            case "type":
                                E = ue;
                                break;
                            case "checked":
                                R = ue;
                                break;
                            case "defaultChecked":
                                Z = ue;
                                break;
                            case "value":
                                y = ue;
                                break;
                            case "defaultValue":
                                C = ue;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (ue != null) throw Error(r(137, a));
                                break;
                            default:
                                wt(o, a, d, ue, c, null);
                        }
                    }
                    v5(o, y, C, R, Z, E, g, !1);
                    return;
                case "select":
                    Ke("invalid", o), d = E = y = null;
                    for(g in c)if (c.hasOwnProperty(g) && (C = c[g], C != null)) switch(g){
                        case "value":
                            y = C;
                            break;
                        case "defaultValue":
                            E = C;
                            break;
                        case "multiple":
                            d = C;
                        default:
                            wt(o, a, g, C, c, null);
                    }
                    a = y, c = E, o.multiple = !!d, a != null ? al(o, !!d, a, !1) : c != null && al(o, !!d, c, !0);
                    return;
                case "textarea":
                    Ke("invalid", o), y = g = d = null;
                    for(E in c)if (c.hasOwnProperty(E) && (C = c[E], C != null)) switch(E){
                        case "value":
                            d = C;
                            break;
                        case "defaultValue":
                            g = C;
                            break;
                        case "children":
                            y = C;
                            break;
                        case "dangerouslySetInnerHTML":
                            if (C != null) throw Error(r(91));
                            break;
                        default:
                            wt(o, a, E, C, c, null);
                    }
                    A5(o, d, g, y);
                    return;
                case "option":
                    for(R in c)c.hasOwnProperty(R) && (d = c[R], d != null) && (R === "selected" ? o.selected = d && typeof d != "function" && typeof d != "symbol" : wt(o, a, R, d, c, null));
                    return;
                case "dialog":
                    Ke("beforetoggle", o), Ke("toggle", o), Ke("cancel", o), Ke("close", o);
                    break;
                case "iframe":
                case "object":
                    Ke("load", o);
                    break;
                case "video":
                case "audio":
                    for(d = 0; d < uh.length; d++)Ke(uh[d], o);
                    break;
                case "image":
                    Ke("error", o), Ke("load", o);
                    break;
                case "details":
                    Ke("toggle", o);
                    break;
                case "embed":
                case "source":
                case "link":
                    Ke("error", o), Ke("load", o);
                case "area":
                case "base":
                case "br":
                case "col":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "track":
                case "wbr":
                case "menuitem":
                    for(Z in c)if (c.hasOwnProperty(Z) && (d = c[Z], d != null)) switch(Z){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(r(137, a));
                        default:
                            wt(o, a, Z, d, c, null);
                    }
                    return;
                default:
                    if (e2(a)) {
                        for(ue in c)c.hasOwnProperty(ue) && (d = c[ue], d !== void 0 && zm(o, a, ue, d, c, void 0));
                        return;
                    }
            }
            for(C in c)c.hasOwnProperty(C) && (d = c[C], d != null && wt(o, a, C, d, c, null));
        }
        function wO(o, a, c, d) {
            switch(a){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "input":
                    var g = null, y = null, E = null, C = null, R = null, Z = null, ue = null;
                    for(ie in c){
                        var fe = c[ie];
                        if (c.hasOwnProperty(ie) && fe != null) switch(ie){
                            case "checked":
                                break;
                            case "value":
                                break;
                            case "defaultValue":
                                R = fe;
                            default:
                                d.hasOwnProperty(ie) || wt(o, a, ie, null, d, fe);
                        }
                    }
                    for(var te in d){
                        var ie = d[te];
                        if (fe = c[te], d.hasOwnProperty(te) && (ie != null || fe != null)) switch(te){
                            case "type":
                                y = ie;
                                break;
                            case "name":
                                g = ie;
                                break;
                            case "checked":
                                Z = ie;
                                break;
                            case "defaultChecked":
                                ue = ie;
                                break;
                            case "value":
                                E = ie;
                                break;
                            case "defaultValue":
                                C = ie;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (ie != null) throw Error(r(137, a));
                                break;
                            default:
                                ie !== fe && wt(o, a, te, ie, d, fe);
                        }
                    }
                    Jg(o, E, C, R, Z, ue, y, g);
                    return;
                case "select":
                    ie = E = C = te = null;
                    for(y in c)if (R = c[y], c.hasOwnProperty(y) && R != null) switch(y){
                        case "value":
                            break;
                        case "multiple":
                            ie = R;
                        default:
                            d.hasOwnProperty(y) || wt(o, a, y, null, d, R);
                    }
                    for(g in d)if (y = d[g], R = c[g], d.hasOwnProperty(g) && (y != null || R != null)) switch(g){
                        case "value":
                            te = y;
                            break;
                        case "defaultValue":
                            C = y;
                            break;
                        case "multiple":
                            E = y;
                        default:
                            y !== R && wt(o, a, g, y, d, R);
                    }
                    a = C, c = E, d = ie, te != null ? al(o, !!c, te, !1) : !!d != !!c && (a != null ? al(o, !!c, a, !0) : al(o, !!c, c ? [] : "", !1));
                    return;
                case "textarea":
                    ie = te = null;
                    for(C in c)if (g = c[C], c.hasOwnProperty(C) && g != null && !d.hasOwnProperty(C)) switch(C){
                        case "value":
                            break;
                        case "children":
                            break;
                        default:
                            wt(o, a, C, null, d, g);
                    }
                    for(E in d)if (g = d[E], y = c[E], d.hasOwnProperty(E) && (g != null || y != null)) switch(E){
                        case "value":
                            te = g;
                            break;
                        case "defaultValue":
                            ie = g;
                            break;
                        case "children":
                            break;
                        case "dangerouslySetInnerHTML":
                            if (g != null) throw Error(r(91));
                            break;
                        default:
                            g !== y && wt(o, a, E, g, d, y);
                    }
                    E5(o, te, ie);
                    return;
                case "option":
                    for(var Ie in c)te = c[Ie], c.hasOwnProperty(Ie) && te != null && !d.hasOwnProperty(Ie) && (Ie === "selected" ? o.selected = !1 : wt(o, a, Ie, null, d, te));
                    for(R in d)te = d[R], ie = c[R], d.hasOwnProperty(R) && te !== ie && (te != null || ie != null) && (R === "selected" ? o.selected = te && typeof te != "function" && typeof te != "symbol" : wt(o, a, R, te, d, ie));
                    return;
                case "img":
                case "link":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                case "menuitem":
                    for(var Oe in c)te = c[Oe], c.hasOwnProperty(Oe) && te != null && !d.hasOwnProperty(Oe) && wt(o, a, Oe, null, d, te);
                    for(Z in d)if (te = d[Z], ie = c[Z], d.hasOwnProperty(Z) && te !== ie && (te != null || ie != null)) switch(Z){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (te != null) throw Error(r(137, a));
                            break;
                        default:
                            wt(o, a, Z, te, d, ie);
                    }
                    return;
                default:
                    if (e2(a)) {
                        for(var bt in c)te = c[bt], c.hasOwnProperty(bt) && te !== void 0 && !d.hasOwnProperty(bt) && zm(o, a, bt, void 0, d, te);
                        for(ue in d)te = d[ue], ie = c[ue], !d.hasOwnProperty(ue) || te === ie || te === void 0 && ie === void 0 || zm(o, a, ue, te, d, ie);
                        return;
                    }
            }
            for(var W in c)te = c[W], c.hasOwnProperty(W) && te != null && !d.hasOwnProperty(W) && wt(o, a, W, null, d, te);
            for(fe in d)te = d[fe], ie = c[fe], !d.hasOwnProperty(fe) || te === ie || te == null && ie == null || wt(o, a, fe, te, d, ie);
        }
        function C7(o) {
            switch(o){
                case "css":
                case "script":
                case "font":
                case "img":
                case "image":
                case "input":
                case "link":
                    return !0;
                default:
                    return !1;
            }
        }
        function bO() {
            if (typeof performance.getEntriesByType == "function") {
                for(var o = 0, a = 0, c = performance.getEntriesByType("resource"), d = 0; d < c.length; d++){
                    var g = c[d], y = g.transferSize, E = g.initiatorType, C = g.duration;
                    if (y && C && C7(E)) {
                        for(E = 0, C = g.responseEnd, d += 1; d < c.length; d++){
                            var R = c[d], Z = R.startTime;
                            if (Z > C) break;
                            var ue = R.transferSize, fe = R.initiatorType;
                            ue && C7(fe) && (R = R.responseEnd, E += ue * (R < C ? 1 : (C - Z) / (R - Z)));
                        }
                        if (--d, a += 8 * (y + E) / (g.duration / 1e3), o++, 10 < o) break;
                    }
                }
                if (0 < o) return a / o / 1e6;
            }
            return navigator.connection && (o = navigator.connection.downlink, typeof o == "number") ? o : 5;
        }
        var Fm = null, Vm = null;
        function F1(o) {
            return o.nodeType === 9 ? o : o.ownerDocument;
        }
        function T7(o) {
            switch(o){
                case "http://www.w3.org/2000/svg":
                    return 1;
                case "http://www.w3.org/1998/Math/MathML":
                    return 2;
                default:
                    return 0;
            }
        }
        function _7(o, a) {
            if (o === 0) switch(a){
                case "svg":
                    return 1;
                case "math":
                    return 2;
                default:
                    return 0;
            }
            return o === 1 && a === "foreignObject" ? 0 : o;
        }
        function Hm(o, a) {
            return o === "textarea" || o === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.children == "bigint" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
        }
        var Qm = null;
        function vO() {
            var o = window.event;
            return o && o.type === "popstate" ? o === Qm ? !1 : (Qm = o, !0) : (Qm = null, !1);
        }
        var x7 = typeof setTimeout == "function" ? setTimeout : void 0, EO = typeof clearTimeout == "function" ? clearTimeout : void 0, D7 = typeof Promise == "function" ? Promise : void 0, AO = typeof queueMicrotask == "function" ? queueMicrotask : typeof D7 < "u" ? function(o) {
            return D7.resolve(null).then(o).catch(SO);
        } : x7;
        function SO(o) {
            setTimeout(function() {
                throw o;
            });
        }
        function bo(o) {
            return o === "head";
        }
        function B7(o, a) {
            var c = a, d = 0;
            do {
                var g = c.nextSibling;
                if (o.removeChild(c), g && g.nodeType === 8) if (c = g.data, c === "/$" || c === "/&") {
                    if (d === 0) {
                        o.removeChild(g), Ul(a);
                        return;
                    }
                    d--;
                } else if (c === "$" || c === "$?" || c === "$~" || c === "$!" || c === "&") d++;
                else if (c === "html") dh(o.ownerDocument.documentElement);
                else if (c === "head") {
                    c = o.ownerDocument.head, dh(c);
                    for(var y = c.firstChild; y;){
                        var E = y.nextSibling, C = y.nodeName;
                        y[Bu] || C === "SCRIPT" || C === "STYLE" || C === "LINK" && y.rel.toLowerCase() === "stylesheet" || c.removeChild(y), y = E;
                    }
                } else c === "body" && dh(o.ownerDocument.body);
                c = g;
            }while (c);
            Ul(a);
        }
        function P7(o, a) {
            var c = o;
            o = 0;
            do {
                var d = c.nextSibling;
                if (c.nodeType === 1 ? a ? (c._stashedDisplay = c.style.display, c.style.display = "none") : (c.style.display = c._stashedDisplay || "", c.getAttribute("style") === "" && c.removeAttribute("style")) : c.nodeType === 3 && (a ? (c._stashedText = c.nodeValue, c.nodeValue = "") : c.nodeValue = c._stashedText || ""), d && d.nodeType === 8) if (c = d.data, c === "/$") {
                    if (o === 0) break;
                    o--;
                } else c !== "$" && c !== "$?" && c !== "$~" && c !== "$!" || o++;
                c = d;
            }while (c);
        }
        function qm(o) {
            var a = o.firstChild;
            for(a && a.nodeType === 10 && (a = a.nextSibling); a;){
                var c = a;
                switch(a = a.nextSibling, c.nodeName){
                    case "HTML":
                    case "HEAD":
                    case "BODY":
                        qm(c), jg(c);
                        continue;
                    case "SCRIPT":
                    case "STYLE":
                        continue;
                    case "LINK":
                        if (c.rel.toLowerCase() === "stylesheet") continue;
                }
                o.removeChild(c);
            }
        }
        function IO(o, a, c, d) {
            for(; o.nodeType === 1;){
                var g = c;
                if (o.nodeName.toLowerCase() !== a.toLowerCase()) {
                    if (!d && (o.nodeName !== "INPUT" || o.type !== "hidden")) break;
                } else if (d) {
                    if (!o[Bu]) switch(a){
                        case "meta":
                            if (!o.hasAttribute("itemprop")) break;
                            return o;
                        case "link":
                            if (y = o.getAttribute("rel"), y === "stylesheet" && o.hasAttribute("data-precedence")) break;
                            if (y !== g.rel || o.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || o.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || o.getAttribute("title") !== (g.title == null ? null : g.title)) break;
                            return o;
                        case "style":
                            if (o.hasAttribute("data-precedence")) break;
                            return o;
                        case "script":
                            if (y = o.getAttribute("src"), (y !== (g.src == null ? null : g.src) || o.getAttribute("type") !== (g.type == null ? null : g.type) || o.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && y && o.hasAttribute("async") && !o.hasAttribute("itemprop")) break;
                            return o;
                        default:
                            return o;
                    }
                } else if (a === "input" && o.type === "hidden") {
                    var y = g.name == null ? null : "" + g.name;
                    if (g.type === "hidden" && o.getAttribute("name") === y) return o;
                } else return o;
                if (o = ts(o.nextSibling), o === null) break;
            }
            return null;
        }
        function CO(o, a, c) {
            if (a === "") return null;
            for(; o.nodeType !== 3;)if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !c || (o = ts(o.nextSibling), o === null)) return null;
            return o;
        }
        function k7(o, a) {
            for(; o.nodeType !== 8;)if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !a || (o = ts(o.nextSibling), o === null)) return null;
            return o;
        }
        function Km(o) {
            return o.data === "$?" || o.data === "$~";
        }
        function Gm(o) {
            return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState !== "loading";
        }
        function TO(o, a) {
            var c = o.ownerDocument;
            if (o.data === "$~") o._reactRetry = a;
            else if (o.data !== "$?" || c.readyState !== "loading") a();
            else {
                var d = function() {
                    a(), c.removeEventListener("DOMContentLoaded", d);
                };
                c.addEventListener("DOMContentLoaded", d), o._reactRetry = d;
            }
        }
        function ts(o) {
            for(; o != null; o = o.nextSibling){
                var a = o.nodeType;
                if (a === 1 || a === 3) break;
                if (a === 8) {
                    if (a = o.data, a === "$" || a === "$!" || a === "$?" || a === "$~" || a === "&" || a === "F!" || a === "F") break;
                    if (a === "/$" || a === "/&") return null;
                }
            }
            return o;
        }
        var Ym = null;
        function R7(o) {
            o = o.nextSibling;
            for(var a = 0; o;){
                if (o.nodeType === 8) {
                    var c = o.data;
                    if (c === "/$" || c === "/&") {
                        if (a === 0) return ts(o.nextSibling);
                        a--;
                    } else c !== "$" && c !== "$!" && c !== "$?" && c !== "$~" && c !== "&" || a++;
                }
                o = o.nextSibling;
            }
            return null;
        }
        function O7(o) {
            o = o.previousSibling;
            for(var a = 0; o;){
                if (o.nodeType === 8) {
                    var c = o.data;
                    if (c === "$" || c === "$!" || c === "$?" || c === "$~" || c === "&") {
                        if (a === 0) return o;
                        a--;
                    } else c !== "/$" && c !== "/&" || a++;
                }
                o = o.previousSibling;
            }
            return null;
        }
        function $7(o, a, c) {
            switch(a = F1(c), o){
                case "html":
                    if (o = a.documentElement, !o) throw Error(r(452));
                    return o;
                case "head":
                    if (o = a.head, !o) throw Error(r(453));
                    return o;
                case "body":
                    if (o = a.body, !o) throw Error(r(454));
                    return o;
                default:
                    throw Error(r(451));
            }
        }
        function dh(o) {
            for(var a = o.attributes; a.length;)o.removeAttributeNode(a[0]);
            jg(o);
        }
        var ns = new Map, M7 = new Set;
        function V1(o) {
            return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument;
        }
        var Oi = z.d;
        z.d = {
            f: _O,
            r: xO,
            D: DO,
            C: BO,
            L: PO,
            m: kO,
            X: OO,
            S: RO,
            M: $O
        };
        function _O() {
            var o = Oi.f(), a = R1();
            return o || a;
        }
        function xO(o) {
            var a = sl(o);
            a !== null && a.tag === 5 && a.type === "form" ? Zw(a) : Oi.r(o);
        }
        var Ml = typeof document > "u" ? null : document;
        function N7(o, a, c) {
            var d = Ml;
            if (d && typeof a == "string" && a) {
                var g = Yr(a);
                g = 'link[rel="' + o + '"][href="' + g + '"]', typeof c == "string" && (g += '[crossorigin="' + c + '"]'), M7.has(g) || (M7.add(g), o = {
                    rel: o,
                    crossOrigin: c,
                    href: a
                }, d.querySelector(g) === null && (a = d.createElement("link"), An(a, "link", o), fn(a), d.head.appendChild(a)));
            }
        }
        function DO(o) {
            Oi.D(o), N7("dns-prefetch", o, null);
        }
        function BO(o, a) {
            Oi.C(o, a), N7("preconnect", o, a);
        }
        function PO(o, a, c) {
            Oi.L(o, a, c);
            var d = Ml;
            if (d && o && a) {
                var g = 'link[rel="preload"][as="' + Yr(a) + '"]';
                a === "image" && c && c.imageSrcSet ? (g += '[imagesrcset="' + Yr(c.imageSrcSet) + '"]', typeof c.imageSizes == "string" && (g += '[imagesizes="' + Yr(c.imageSizes) + '"]')) : g += '[href="' + Yr(o) + '"]';
                var y = g;
                switch(a){
                    case "style":
                        y = Nl(o);
                        break;
                    case "script":
                        y = Ll(o);
                }
                ns.has(y) || (o = m({
                    rel: "preload",
                    href: a === "image" && c && c.imageSrcSet ? void 0 : o,
                    as: a
                }, c), ns.set(y, o), d.querySelector(g) !== null || a === "style" && d.querySelector(fh(y)) || a === "script" && d.querySelector(ph(y)) || (a = d.createElement("link"), An(a, "link", o), fn(a), d.head.appendChild(a)));
            }
        }
        function kO(o, a) {
            Oi.m(o, a);
            var c = Ml;
            if (c && o) {
                var d = a && typeof a.as == "string" ? a.as : "script", g = 'link[rel="modulepreload"][as="' + Yr(d) + '"][href="' + Yr(o) + '"]', y = g;
                switch(d){
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                        y = Ll(o);
                }
                if (!ns.has(y) && (o = m({
                    rel: "modulepreload",
                    href: o
                }, a), ns.set(y, o), c.querySelector(g) === null)) {
                    switch(d){
                        case "audioworklet":
                        case "paintworklet":
                        case "serviceworker":
                        case "sharedworker":
                        case "worker":
                        case "script":
                            if (c.querySelector(ph(y))) return;
                    }
                    d = c.createElement("link"), An(d, "link", o), fn(d), c.head.appendChild(d);
                }
            }
        }
        function RO(o, a, c) {
            Oi.S(o, a, c);
            var d = Ml;
            if (d && o) {
                var g = il(d).hoistableStyles, y = Nl(o);
                a = a || "default";
                var E = g.get(y);
                if (!E) {
                    var C = {
                        loading: 0,
                        preload: null
                    };
                    if (E = d.querySelector(fh(y))) C.loading = 5;
                    else {
                        o = m({
                            rel: "stylesheet",
                            href: o,
                            "data-precedence": a
                        }, c), (c = ns.get(y)) && Wm(o, c);
                        var R = E = d.createElement("link");
                        fn(R), An(R, "link", o), R._p = new Promise(function(Z, ue) {
                            R.onload = Z, R.onerror = ue;
                        }), R.addEventListener("load", function() {
                            C.loading |= 1;
                        }), R.addEventListener("error", function() {
                            C.loading |= 2;
                        }), C.loading |= 4, H1(E, a, d);
                    }
                    E = {
                        type: "stylesheet",
                        instance: E,
                        count: 1,
                        state: C
                    }, g.set(y, E);
                }
            }
        }
        function OO(o, a) {
            Oi.X(o, a);
            var c = Ml;
            if (c && o) {
                var d = il(c).hoistableScripts, g = Ll(o), y = d.get(g);
                y || (y = c.querySelector(ph(g)), y || (o = m({
                    src: o,
                    async: !0
                }, a), (a = ns.get(g)) && jm(o, a), y = c.createElement("script"), fn(y), An(y, "link", o), c.head.appendChild(y)), y = {
                    type: "script",
                    instance: y,
                    count: 1,
                    state: null
                }, d.set(g, y));
            }
        }
        function $O(o, a) {
            Oi.M(o, a);
            var c = Ml;
            if (c && o) {
                var d = il(c).hoistableScripts, g = Ll(o), y = d.get(g);
                y || (y = c.querySelector(ph(g)), y || (o = m({
                    src: o,
                    async: !0,
                    type: "module"
                }, a), (a = ns.get(g)) && jm(o, a), y = c.createElement("script"), fn(y), An(y, "link", o), c.head.appendChild(y)), y = {
                    type: "script",
                    instance: y,
                    count: 1,
                    state: null
                }, d.set(g, y));
            }
        }
        function L7(o, a, c, d) {
            var g = (g = Ae.current) ? V1(g) : null;
            if (!g) throw Error(r(446));
            switch(o){
                case "meta":
                case "title":
                    return null;
                case "style":
                    return typeof c.precedence == "string" && typeof c.href == "string" ? (a = Nl(c.href), c = il(g).hoistableStyles, d = c.get(a), d || (d = {
                        type: "style",
                        instance: null,
                        count: 0,
                        state: null
                    }, c.set(a, d)), d) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                case "link":
                    if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
                        o = Nl(c.href);
                        var y = il(g).hoistableStyles, E = y.get(o);
                        if (E || (g = g.ownerDocument || g, E = {
                            type: "stylesheet",
                            instance: null,
                            count: 0,
                            state: {
                                loading: 0,
                                preload: null
                            }
                        }, y.set(o, E), (y = g.querySelector(fh(o))) && !y._p && (E.instance = y, E.state.loading = 5), ns.has(o) || (c = {
                            rel: "preload",
                            as: "style",
                            href: c.href,
                            crossOrigin: c.crossOrigin,
                            integrity: c.integrity,
                            media: c.media,
                            hrefLang: c.hrefLang,
                            referrerPolicy: c.referrerPolicy
                        }, ns.set(o, c), y || MO(g, o, c, E.state))), a && d === null) throw Error(r(528, ""));
                        return E;
                    }
                    if (a && d !== null) throw Error(r(529, ""));
                    return null;
                case "script":
                    return a = c.async, c = c.src, typeof c == "string" && a && typeof a != "function" && typeof a != "symbol" ? (a = Ll(c), c = il(g).hoistableScripts, d = c.get(a), d || (d = {
                        type: "script",
                        instance: null,
                        count: 0,
                        state: null
                    }, c.set(a, d)), d) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                default:
                    throw Error(r(444, o));
            }
        }
        function Nl(o) {
            return 'href="' + Yr(o) + '"';
        }
        function fh(o) {
            return 'link[rel="stylesheet"][' + o + "]";
        }
        function U7(o) {
            return m({}, o, {
                "data-precedence": o.precedence,
                precedence: null
            });
        }
        function MO(o, a, c, d) {
            o.querySelector('link[rel="preload"][as="style"][' + a + "]") ? d.loading = 1 : (a = o.createElement("link"), d.preload = a, a.addEventListener("load", function() {
                return d.loading |= 1;
            }), a.addEventListener("error", function() {
                return d.loading |= 2;
            }), An(a, "link", c), fn(a), o.head.appendChild(a));
        }
        function Ll(o) {
            return '[src="' + Yr(o) + '"]';
        }
        function ph(o) {
            return "script[async]" + o;
        }
        function z7(o, a, c) {
            if (a.count++, a.instance === null) switch(a.type){
                case "style":
                    var d = o.querySelector('style[data-href~="' + Yr(c.href) + '"]');
                    if (d) return a.instance = d, fn(d), d;
                    var g = m({}, c, {
                        "data-href": c.href,
                        "data-precedence": c.precedence,
                        href: null,
                        precedence: null
                    });
                    return d = (o.ownerDocument || o).createElement("style"), fn(d), An(d, "style", g), H1(d, c.precedence, o), a.instance = d;
                case "stylesheet":
                    g = Nl(c.href);
                    var y = o.querySelector(fh(g));
                    if (y) return a.state.loading |= 4, a.instance = y, fn(y), y;
                    d = U7(c), (g = ns.get(g)) && Wm(d, g), y = (o.ownerDocument || o).createElement("link"), fn(y);
                    var E = y;
                    return E._p = new Promise(function(C, R) {
                        E.onload = C, E.onerror = R;
                    }), An(y, "link", d), a.state.loading |= 4, H1(y, c.precedence, o), a.instance = y;
                case "script":
                    return y = Ll(c.src), (g = o.querySelector(ph(y))) ? (a.instance = g, fn(g), g) : (d = c, (g = ns.get(y)) && (d = m({}, c), jm(d, g)), o = o.ownerDocument || o, g = o.createElement("script"), fn(g), An(g, "link", d), o.head.appendChild(g), a.instance = g);
                case "void":
                    return null;
                default:
                    throw Error(r(443, a.type));
            }
            else a.type === "stylesheet" && (a.state.loading & 4) === 0 && (d = a.instance, a.state.loading |= 4, H1(d, c.precedence, o));
            return a.instance;
        }
        function H1(o, a, c) {
            for(var d = c.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), g = d.length ? d[d.length - 1] : null, y = g, E = 0; E < d.length; E++){
                var C = d[E];
                if (C.dataset.precedence === a) y = C;
                else if (y !== g) break;
            }
            y ? y.parentNode.insertBefore(o, y.nextSibling) : (a = c.nodeType === 9 ? c.head : c, a.insertBefore(o, a.firstChild));
        }
        function Wm(o, a) {
            o.crossOrigin == null && (o.crossOrigin = a.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = a.referrerPolicy), o.title == null && (o.title = a.title);
        }
        function jm(o, a) {
            o.crossOrigin == null && (o.crossOrigin = a.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = a.referrerPolicy), o.integrity == null && (o.integrity = a.integrity);
        }
        var Q1 = null;
        function F7(o, a, c) {
            if (Q1 === null) {
                var d = new Map, g = Q1 = new Map;
                g.set(c, d);
            } else g = Q1, d = g.get(c), d || (d = new Map, g.set(c, d));
            if (d.has(o)) return d;
            for(d.set(o, null), c = c.getElementsByTagName(o), g = 0; g < c.length; g++){
                var y = c[g];
                if (!(y[Bu] || y[wn] || o === "link" && y.getAttribute("rel") === "stylesheet") && y.namespaceURI !== "http://www.w3.org/2000/svg") {
                    var E = y.getAttribute(a) || "";
                    E = o + E;
                    var C = d.get(E);
                    C ? C.push(y) : d.set(E, [
                        y
                    ]);
                }
            }
            return d;
        }
        function V7(o, a, c) {
            o = o.ownerDocument || o, o.head.insertBefore(c, a === "title" ? o.querySelector("head > title") : null);
        }
        function NO(o, a, c) {
            if (c === 1 || a.itemProp != null) return !1;
            switch(o){
                case "meta":
                case "title":
                    return !0;
                case "style":
                    if (typeof a.precedence != "string" || typeof a.href != "string" || a.href === "") break;
                    return !0;
                case "link":
                    if (typeof a.rel != "string" || typeof a.href != "string" || a.href === "" || a.onLoad || a.onError) break;
                    return a.rel === "stylesheet" ? (o = a.disabled, typeof a.precedence == "string" && o == null) : !0;
                case "script":
                    if (a.async && typeof a.async != "function" && typeof a.async != "symbol" && !a.onLoad && !a.onError && a.src && typeof a.src == "string") return !0;
            }
            return !1;
        }
        function H7(o) {
            return !(o.type === "stylesheet" && (o.state.loading & 3) === 0);
        }
        function LO(o, a, c, d) {
            if (c.type === "stylesheet" && (typeof d.media != "string" || matchMedia(d.media).matches !== !1) && (c.state.loading & 4) === 0) {
                if (c.instance === null) {
                    var g = Nl(d.href), y = a.querySelector(fh(g));
                    if (y) {
                        a = y._p, a !== null && typeof a == "object" && typeof a.then == "function" && (o.count++, o = q1.bind(o), a.then(o, o)), c.state.loading |= 4, c.instance = y, fn(y);
                        return;
                    }
                    y = a.ownerDocument || a, d = U7(d), (g = ns.get(g)) && Wm(d, g), y = y.createElement("link"), fn(y);
                    var E = y;
                    E._p = new Promise(function(C, R) {
                        E.onload = C, E.onerror = R;
                    }), An(y, "link", d), c.instance = y;
                }
                o.stylesheets === null && (o.stylesheets = new Map), o.stylesheets.set(c, a), (a = c.state.preload) && (c.state.loading & 3) === 0 && (o.count++, c = q1.bind(o), a.addEventListener("load", c), a.addEventListener("error", c));
            }
        }
        var Xm = 0;
        function UO(o, a) {
            return o.stylesheets && o.count === 0 && G1(o, o.stylesheets), 0 < o.count || 0 < o.imgCount ? function(c) {
                var d = setTimeout(function() {
                    if (o.stylesheets && G1(o, o.stylesheets), o.unsuspend) {
                        var y = o.unsuspend;
                        o.unsuspend = null, y();
                    }
                }, 6e4 + a);
                0 < o.imgBytes && Xm === 0 && (Xm = 62500 * bO());
                var g = setTimeout(function() {
                    if (o.waitingForImages = !1, o.count === 0 && (o.stylesheets && G1(o, o.stylesheets), o.unsuspend)) {
                        var y = o.unsuspend;
                        o.unsuspend = null, y();
                    }
                }, (o.imgBytes > Xm ? 50 : 800) + a);
                return o.unsuspend = c, function() {
                    o.unsuspend = null, clearTimeout(d), clearTimeout(g);
                };
            } : null;
        }
        function q1() {
            if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
                if (this.stylesheets) G1(this, this.stylesheets);
                else if (this.unsuspend) {
                    var o = this.unsuspend;
                    this.unsuspend = null, o();
                }
            }
        }
        var K1 = null;
        function G1(o, a) {
            o.stylesheets = null, o.unsuspend !== null && (o.count++, K1 = new Map, a.forEach(zO, o), K1 = null, q1.call(o));
        }
        function zO(o, a) {
            if (!(a.state.loading & 4)) {
                var c = K1.get(o);
                if (c) var d = c.get(null);
                else {
                    c = new Map, K1.set(o, c);
                    for(var g = o.querySelectorAll("link[data-precedence],style[data-precedence]"), y = 0; y < g.length; y++){
                        var E = g[y];
                        (E.nodeName === "LINK" || E.getAttribute("media") !== "not all") && (c.set(E.dataset.precedence, E), d = E);
                    }
                    d && c.set(null, d);
                }
                g = a.instance, E = g.getAttribute("data-precedence"), y = c.get(E) || d, y === d && c.set(null, g), c.set(E, g), this.count++, d = q1.bind(this), g.addEventListener("load", d), g.addEventListener("error", d), y ? y.parentNode.insertBefore(g, y.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(g, o.firstChild)), a.state.loading |= 4;
            }
        }
        var gh = {
            $$typeof: P,
            Provider: null,
            Consumer: null,
            _currentValue: ee,
            _currentValue2: ee,
            _threadCount: 0
        };
        function FO(o, a, c, d, g, y, E, C, R) {
            this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Kg(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Kg(0), this.hiddenUpdates = Kg(null), this.identifierPrefix = d, this.onUncaughtError = g, this.onCaughtError = y, this.onRecoverableError = E, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = R, this.incompleteTransitions = new Map;
        }
        function Q7(o, a, c, d, g, y, E, C, R, Z, ue, fe) {
            return o = new FO(o, a, c, E, R, Z, ue, fe, C), a = 1, y === !0 && (a |= 24), y = Tr(3, null, null, a), o.current = y, y.stateNode = o, a = B2(), a.refCount++, o.pooledCache = a, a.refCount++, y.memoizedState = {
                element: d,
                isDehydrated: c,
                cache: a
            }, O2(y), o;
        }
        function q7(o) {
            return o ? (o = gl, o) : gl;
        }
        function K7(o, a, c, d, g, y) {
            g = q7(g), d.context === null ? d.context = g : d.pendingContext = g, d = ao(a), d.payload = {
                element: c
            }, y = y === void 0 ? null : y, y !== null && (d.callback = y), c = lo(o, d, a), c !== null && (dr(c, o, a), Gu(c, o, a));
        }
        function G7(o, a) {
            if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
                var c = o.retryLane;
                o.retryLane = c !== 0 && c < a ? c : a;
            }
        }
        function Jm(o, a) {
            G7(o, a), (o = o.alternate) && G7(o, a);
        }
        function Y7(o) {
            if (o.tag === 13 || o.tag === 31) {
                var a = oa(o, 67108864);
                a !== null && dr(a, o, 67108864), Jm(o, 67108864);
            }
        }
        function W7(o) {
            if (o.tag === 13 || o.tag === 31) {
                var a = Pr();
                a = Gg(a);
                var c = oa(o, a);
                c !== null && dr(c, o, a), Jm(o, a);
            }
        }
        var Y1 = !0;
        function VO(o, a, c, d) {
            var g = B.T;
            B.T = null;
            var y = z.p;
            try {
                z.p = 2, Zm(o, a, c, d);
            } finally{
                z.p = y, B.T = g;
            }
        }
        function HO(o, a, c, d) {
            var g = B.T;
            B.T = null;
            var y = z.p;
            try {
                z.p = 8, Zm(o, a, c, d);
            } finally{
                z.p = y, B.T = g;
            }
        }
        function Zm(o, a, c, d) {
            if (Y1) {
                var g = e3(d);
                if (g === null) Um(o, a, d, W1, c), X7(o, d);
                else if (qO(g, o, a, c, d)) d.stopPropagation();
                else if (X7(o, d), a & 4 && -1 < QO.indexOf(o)) {
                    for(; g !== null;){
                        var y = sl(g);
                        if (y !== null) switch(y.tag){
                            case 3:
                                if (y = y.stateNode, y.current.memoizedState.isDehydrated) {
                                    var E = ta(y.pendingLanes);
                                    if (E !== 0) {
                                        var C = y;
                                        for(C.pendingLanes |= 2, C.entangledLanes |= 2; E;){
                                            var R = 1 << 31 - le(E);
                                            C.entanglements[1] |= R, E &= ~R;
                                        }
                                        Ys(y), (lt & 6) === 0 && (P1 = dn() + 500, ch(0));
                                    }
                                }
                                break;
                            case 31:
                            case 13:
                                C = oa(y, 2), C !== null && dr(C, y, 2), R1(), Jm(y, 2);
                        }
                        if (y = e3(d), y === null && Um(o, a, d, W1, c), y === g) break;
                        g = y;
                    }
                    g !== null && d.stopPropagation();
                } else Um(o, a, d, null, c);
            }
        }
        function e3(o) {
            return o = n2(o), t3(o);
        }
        var W1 = null;
        function t3(o) {
            if (W1 = null, o = rl(o), o !== null) {
                var a = i(o);
                if (a === null) o = null;
                else {
                    var c = a.tag;
                    if (c === 13) {
                        if (o = l(a), o !== null) return o;
                        o = null;
                    } else if (c === 31) {
                        if (o = u(a), o !== null) return o;
                        o = null;
                    } else if (c === 3) {
                        if (a.stateNode.current.memoizedState.isDehydrated) return a.tag === 3 ? a.stateNode.containerInfo : null;
                        o = null;
                    } else a !== o && (o = null);
                }
            }
            return W1 = o, null;
        }
        function j7(o) {
            switch(o){
                case "beforetoggle":
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "toggle":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 2;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 8;
                case "message":
                    switch(Kr()){
                        case tl:
                            return 2;
                        case zf:
                            return 8;
                        case Ir:
                        case qg:
                            return 32;
                        case T:
                            return 268435456;
                        default:
                            return 32;
                    }
                default:
                    return 32;
            }
        }
        var n3 = !1, vo = null, Eo = null, Ao = null, mh = new Map, yh = new Map, So = [], QO = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
        function X7(o, a) {
            switch(o){
                case "focusin":
                case "focusout":
                    vo = null;
                    break;
                case "dragenter":
                case "dragleave":
                    Eo = null;
                    break;
                case "mouseover":
                case "mouseout":
                    Ao = null;
                    break;
                case "pointerover":
                case "pointerout":
                    mh.delete(a.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    yh.delete(a.pointerId);
            }
        }
        function wh(o, a, c, d, g, y) {
            return o === null || o.nativeEvent !== y ? (o = {
                blockedOn: a,
                domEventName: c,
                eventSystemFlags: d,
                nativeEvent: y,
                targetContainers: [
                    g
                ]
            }, a !== null && (a = sl(a), a !== null && Y7(a)), o) : (o.eventSystemFlags |= d, a = o.targetContainers, g !== null && a.indexOf(g) === -1 && a.push(g), o);
        }
        function qO(o, a, c, d, g) {
            switch(a){
                case "focusin":
                    return vo = wh(vo, o, a, c, d, g), !0;
                case "dragenter":
                    return Eo = wh(Eo, o, a, c, d, g), !0;
                case "mouseover":
                    return Ao = wh(Ao, o, a, c, d, g), !0;
                case "pointerover":
                    var y = g.pointerId;
                    return mh.set(y, wh(mh.get(y) || null, o, a, c, d, g)), !0;
                case "gotpointercapture":
                    return y = g.pointerId, yh.set(y, wh(yh.get(y) || null, o, a, c, d, g)), !0;
            }
            return !1;
        }
        function J7(o) {
            var a = rl(o.target);
            if (a !== null) {
                var c = i(a);
                if (c !== null) {
                    if (a = c.tag, a === 13) {
                        if (a = l(c), a !== null) {
                            o.blockedOn = a, d5(o.priority, function() {
                                W7(c);
                            });
                            return;
                        }
                    } else if (a === 31) {
                        if (a = u(c), a !== null) {
                            o.blockedOn = a, d5(o.priority, function() {
                                W7(c);
                            });
                            return;
                        }
                    } else if (a === 3 && c.stateNode.current.memoizedState.isDehydrated) {
                        o.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
                        return;
                    }
                }
            }
            o.blockedOn = null;
        }
        function j1(o) {
            if (o.blockedOn !== null) return !1;
            for(var a = o.targetContainers; 0 < a.length;){
                var c = e3(o.nativeEvent);
                if (c === null) {
                    c = o.nativeEvent;
                    var d = new c.constructor(c.type, c);
                    t2 = d, c.target.dispatchEvent(d), t2 = null;
                } else return a = sl(c), a !== null && Y7(a), o.blockedOn = c, !1;
                a.shift();
            }
            return !0;
        }
        function Z7(o, a, c) {
            j1(o) && c.delete(a);
        }
        function KO() {
            n3 = !1, vo !== null && j1(vo) && (vo = null), Eo !== null && j1(Eo) && (Eo = null), Ao !== null && j1(Ao) && (Ao = null), mh.forEach(Z7), yh.forEach(Z7);
        }
        function X1(o, a) {
            o.blockedOn === a && (o.blockedOn = null, n3 || (n3 = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, KO)));
        }
        var J1 = null;
        function e9(o) {
            J1 !== o && (J1 = o, n.unstable_scheduleCallback(n.unstable_NormalPriority, function() {
                J1 === o && (J1 = null);
                for(var a = 0; a < o.length; a += 3){
                    var c = o[a], d = o[a + 1], g = o[a + 2];
                    if (typeof d != "function") {
                        if (t3(d || c) === null) continue;
                        break;
                    }
                    var y = sl(c);
                    y !== null && (o.splice(a, 3), a -= 3, em(y, {
                        pending: !0,
                        data: g,
                        method: c.method,
                        action: d
                    }, d, g));
                }
            }));
        }
        function Ul(o) {
            function a(R) {
                return X1(R, o);
            }
            vo !== null && X1(vo, o), Eo !== null && X1(Eo, o), Ao !== null && X1(Ao, o), mh.forEach(a), yh.forEach(a);
            for(var c = 0; c < So.length; c++){
                var d = So[c];
                d.blockedOn === o && (d.blockedOn = null);
            }
            for(; 0 < So.length && (c = So[0], c.blockedOn === null);)J7(c), c.blockedOn === null && So.shift();
            if (c = (o.ownerDocument || o).$$reactFormReplay, c != null) for(d = 0; d < c.length; d += 3){
                var g = c[d], y = c[d + 1], E = g[or] || null;
                if (typeof y == "function") E || e9(c);
                else if (E) {
                    var C = null;
                    if (y && y.hasAttribute("formAction")) {
                        if (g = y, E = y[or] || null) C = E.formAction;
                        else if (t3(g) !== null) continue;
                    } else C = E.action;
                    typeof C == "function" ? c[d + 1] = C : (c.splice(d, 3), d -= 3), e9(c);
                }
            }
        }
        function t9() {
            function o(y) {
                y.canIntercept && y.info === "react-transition" && y.intercept({
                    handler: function() {
                        return new Promise(function(E) {
                            return g = E;
                        });
                    },
                    focusReset: "manual",
                    scroll: "manual"
                });
            }
            function a() {
                g !== null && (g(), g = null), d || setTimeout(c, 20);
            }
            function c() {
                if (!d && !navigation.transition) {
                    var y = navigation.currentEntry;
                    y && y.url != null && navigation.navigate(y.url, {
                        state: y.getState(),
                        info: "react-transition",
                        history: "replace"
                    });
                }
            }
            if (typeof navigation == "object") {
                var d = !1, g = null;
                return navigation.addEventListener("navigate", o), navigation.addEventListener("navigatesuccess", a), navigation.addEventListener("navigateerror", a), setTimeout(c, 100), function() {
                    d = !0, navigation.removeEventListener("navigate", o), navigation.removeEventListener("navigatesuccess", a), navigation.removeEventListener("navigateerror", a), g !== null && (g(), g = null);
                };
            }
        }
        function r3(o) {
            this._internalRoot = o;
        }
        Z1.prototype.render = r3.prototype.render = function(o) {
            var a = this._internalRoot;
            if (a === null) throw Error(r(409));
            var c = a.current, d = Pr();
            K7(c, d, o, a, null, null);
        }, Z1.prototype.unmount = r3.prototype.unmount = function() {
            var o = this._internalRoot;
            if (o !== null) {
                this._internalRoot = null;
                var a = o.containerInfo;
                K7(o.current, 2, null, o, null, null), R1(), a[nl] = null;
            }
        };
        function Z1(o) {
            this._internalRoot = o;
        }
        Z1.prototype.unstable_scheduleHydration = function(o) {
            if (o) {
                var a = h5();
                o = {
                    blockedOn: null,
                    target: o,
                    priority: a
                };
                for(var c = 0; c < So.length && a !== 0 && a < So[c].priority; c++);
                So.splice(c, 0, o), c === 0 && J7(o);
            }
        };
        var n9 = e.version;
        if (n9 !== "19.2.4") throw Error(r(527, n9, "19.2.4"));
        z.findDOMNode = function(o) {
            var a = o._reactInternals;
            if (a === void 0) throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o)));
            return o = f(a), o = o !== null ? p(o) : null, o = o === null ? null : o.stateNode, o;
        };
        var GO = {
            bundleType: 0,
            version: "19.2.4",
            rendererPackageName: "react-dom",
            currentDispatcherRef: B,
            reconcilerVersion: "19.2.4"
        };
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
            var e0 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (!e0.isDisabled && e0.supportsFiber) try {
                D = e0.inject(GO), N = e0;
            } catch  {}
        }
        return vh.createRoot = function(o, a) {
            if (!s(o)) throw Error(r(299));
            var c = !1, d = "", g = cb, y = ub, E = hb;
            return a != null && (a.unstable_strictMode === !0 && (c = !0), a.identifierPrefix !== void 0 && (d = a.identifierPrefix), a.onUncaughtError !== void 0 && (g = a.onUncaughtError), a.onCaughtError !== void 0 && (y = a.onCaughtError), a.onRecoverableError !== void 0 && (E = a.onRecoverableError)), a = Q7(o, 1, !1, null, null, c, d, null, g, y, E, t9), o[nl] = a.current, Lm(o), new r3(a);
        }, vh.hydrateRoot = function(o, a, c) {
            if (!s(o)) throw Error(r(299));
            var d = !1, g = "", y = cb, E = ub, C = hb, R = null;
            return c != null && (c.unstable_strictMode === !0 && (d = !0), c.identifierPrefix !== void 0 && (g = c.identifierPrefix), c.onUncaughtError !== void 0 && (y = c.onUncaughtError), c.onCaughtError !== void 0 && (E = c.onCaughtError), c.onRecoverableError !== void 0 && (C = c.onRecoverableError), c.formState !== void 0 && (R = c.formState)), a = Q7(o, 1, !0, a, c ?? null, d, g, R, y, E, C, t9), a.context = q7(null), c = a.current, d = Pr(), d = Gg(d), g = ao(d), g.callback = null, lo(c, g, d), c = d, a.current.lanes = c, Du(a, c), Ys(a), o[nl] = a.current, Lm(o), new Z1(a);
        }, vh.version = "19.2.4", vh;
    }
    var d9;
    function a$() {
        if (d9) return o3.exports;
        d9 = 1;
        function n() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
            } catch (e) {
                console.error(e);
            }
        }
        return n(), o3.exports = o$(), o3.exports;
    }
    var l$ = a$();
    const c$ = Symbol.for("@libp2p/content-routing");
    let u$ = class extends Error {
        static name = "AbortError";
        constructor(e = "The operation was aborted"){
            super(e), this.name = "AbortError";
        }
    }, jS = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, h$ = class extends Error {
        static name = "NotFoundError";
        constructor(e = "Not found"){
            super(e), this.name = "NotFoundError";
        }
    }, d$ = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const f$ = Symbol.for("@libp2p/peer-routing");
    function XS(n) {
        return n != null && typeof n.start == "function" && typeof n.stop == "function";
    }
    async function ag(...n) {
        const e = [];
        for (const t of n)XS(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStart != null && await t.beforeStart();
        })), await Promise.all(e.map(async (t)=>{
            await t.start();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStart != null && await t.afterStart();
        }));
    }
    async function lg(...n) {
        const e = [];
        for (const t of n)XS(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStop != null && await t.beforeStop();
        })), await Promise.all(e.map(async (t)=>{
            await t.stop();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStop != null && await t.afterStop();
        }));
    }
    class Lt extends EventTarget {
        #e = new Map;
        constructor(){
            super();
        }
        listenerCount(e) {
            const t = this.#e.get(e);
            return t == null ? 0 : t.length;
        }
        addEventListener(e, t, r) {
            super.addEventListener(e, t, r);
            let s = this.#e.get(e);
            s == null && (s = [], this.#e.set(e, s)), s.push({
                callback: t,
                once: (r !== !0 && r !== !1 && r?.once) ?? !1
            });
        }
        removeEventListener(e, t, r) {
            super.removeEventListener(e.toString(), t ?? null, r);
            let s = this.#e.get(e);
            s != null && (s = s.filter(({ callback: i })=>i !== t), this.#e.set(e, s));
        }
        dispatchEvent(e) {
            const t = super.dispatchEvent(e);
            let r = this.#e.get(e.type);
            return r == null || (r = r.filter(({ once: s })=>!s), this.#e.set(e.type, r)), t;
        }
        safeDispatchEvent(e, t = {}) {
            return this.dispatchEvent(new CustomEvent(e, t));
        }
    }
    class Be extends Event {
        type;
        detail;
        constructor(e, t){
            super(e), this.type = e, this.detail = t;
        }
    }
    class p$ extends AggregateError {
        static name = "DNSQueryFailedError";
        name = "DNSQueryFailedError";
    }
    var u3 = {
        exports: {}
    }, f9;
    function g$() {
        return f9 || (f9 = 1, (function(n) {
            var e = Object.prototype.hasOwnProperty, t = "~";
            function r() {}
            Object.create && (r.prototype = Object.create(null), new r().__proto__ || (t = !1));
            function s(h, f, p) {
                this.fn = h, this.context = f, this.once = p || !1;
            }
            function i(h, f, p, m, w) {
                if (typeof p != "function") throw new TypeError("The listener must be a function");
                var A = new s(p, m || h, w), S = t ? t + f : f;
                return h._events[S] ? h._events[S].fn ? h._events[S] = [
                    h._events[S],
                    A
                ] : h._events[S].push(A) : (h._events[S] = A, h._eventsCount++), h;
            }
            function l(h, f) {
                --h._eventsCount === 0 ? h._events = new r : delete h._events[f];
            }
            function u() {
                this._events = new r, this._eventsCount = 0;
            }
            u.prototype.eventNames = function() {
                var f = [], p, m;
                if (this._eventsCount === 0) return f;
                for(m in p = this._events)e.call(p, m) && f.push(t ? m.slice(1) : m);
                return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(p)) : f;
            }, u.prototype.listeners = function(f) {
                var p = t ? t + f : f, m = this._events[p];
                if (!m) return [];
                if (m.fn) return [
                    m.fn
                ];
                for(var w = 0, A = m.length, S = new Array(A); w < A; w++)S[w] = m[w].fn;
                return S;
            }, u.prototype.listenerCount = function(f) {
                var p = t ? t + f : f, m = this._events[p];
                return m ? m.fn ? 1 : m.length : 0;
            }, u.prototype.emit = function(f, p, m, w, A, S) {
                var _ = t ? t + f : f;
                if (!this._events[_]) return !1;
                var I = this._events[_], k = arguments.length, G, P;
                if (I.fn) {
                    switch(I.once && this.removeListener(f, I.fn, void 0, !0), k){
                        case 1:
                            return I.fn.call(I.context), !0;
                        case 2:
                            return I.fn.call(I.context, p), !0;
                        case 3:
                            return I.fn.call(I.context, p, m), !0;
                        case 4:
                            return I.fn.call(I.context, p, m, w), !0;
                        case 5:
                            return I.fn.call(I.context, p, m, w, A), !0;
                        case 6:
                            return I.fn.call(I.context, p, m, w, A, S), !0;
                    }
                    for(P = 1, G = new Array(k - 1); P < k; P++)G[P - 1] = arguments[P];
                    I.fn.apply(I.context, G);
                } else {
                    var J = I.length, H;
                    for(P = 0; P < J; P++)switch(I[P].once && this.removeListener(f, I[P].fn, void 0, !0), k){
                        case 1:
                            I[P].fn.call(I[P].context);
                            break;
                        case 2:
                            I[P].fn.call(I[P].context, p);
                            break;
                        case 3:
                            I[P].fn.call(I[P].context, p, m);
                            break;
                        case 4:
                            I[P].fn.call(I[P].context, p, m, w);
                            break;
                        default:
                            if (!G) for(H = 1, G = new Array(k - 1); H < k; H++)G[H - 1] = arguments[H];
                            I[P].fn.apply(I[P].context, G);
                    }
                }
                return !0;
            }, u.prototype.on = function(f, p, m) {
                return i(this, f, p, m, !1);
            }, u.prototype.once = function(f, p, m) {
                return i(this, f, p, m, !0);
            }, u.prototype.removeListener = function(f, p, m, w) {
                var A = t ? t + f : f;
                if (!this._events[A]) return this;
                if (!p) return l(this, A), this;
                var S = this._events[A];
                if (S.fn) S.fn === p && (!w || S.once) && (!m || S.context === m) && l(this, A);
                else {
                    for(var _ = 0, I = [], k = S.length; _ < k; _++)(S[_].fn !== p || w && !S[_].once || m && S[_].context !== m) && I.push(S[_]);
                    I.length ? this._events[A] = I.length === 1 ? I[0] : I : l(this, A);
                }
                return this;
            }, u.prototype.removeAllListeners = function(f) {
                var p;
                return f ? (p = t ? t + f : f, this._events[p] && l(this, p)) : (this._events = new r, this._eventsCount = 0), this;
            }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = t, u.EventEmitter = u, n.exports = u;
        })(u3)), u3.exports;
    }
    var m$ = g$();
    JS = Zc(m$);
    let y$ = class ZS extends Error {
        name = "TimeoutError";
        constructor(e, t){
            super(e, t), Error.captureStackTrace?.(this, ZS);
        }
    };
    const p9 = (n)=>n.reason ?? new DOMException("This operation was aborted.", "AbortError");
    function j4(n, e) {
        const { milliseconds: t, fallback: r, message: s, customTimers: i = {
            setTimeout,
            clearTimeout
        }, signal: l } = e;
        let u, h;
        const p = new Promise((m, w)=>{
            if (typeof t != "number" || Math.sign(t) !== 1) throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);
            if (l?.aborted) {
                w(p9(l));
                return;
            }
            if (l && (h = ()=>{
                w(p9(l));
            }, l.addEventListener("abort", h, {
                once: !0
            })), n.then(m, w), t === Number.POSITIVE_INFINITY) return;
            const A = new y$;
            u = i.setTimeout.call(void 0, ()=>{
                if (r) {
                    try {
                        m(r());
                    } catch (S) {
                        w(S);
                    }
                    return;
                }
                typeof n.cancel == "function" && n.cancel(), s === !1 ? m() : s instanceof Error ? w(s) : (A.message = s ?? `Promise timed out after ${t} milliseconds`, w(A));
            }, t);
        }).finally(()=>{
            p.clear(), h && l && l.removeEventListener("abort", h);
        });
        return p.clear = ()=>{
            i.clearTimeout.call(void 0, u), u = void 0;
        }, p;
    }
    function w$(n, e, t) {
        let r = 0, s = n.length;
        for(; s > 0;){
            const i = Math.trunc(s / 2);
            let l = r + i;
            t(n[l], e) <= 0 ? (r = ++l, s -= i + 1) : s = i;
        }
        return r;
    }
    let b$ = class {
        #e = [];
        enqueue(e, t) {
            const { priority: r = 0, id: s } = t ?? {}, i = {
                priority: r,
                id: s,
                run: e
            };
            if (this.size === 0 || this.#e[this.size - 1].priority >= r) {
                this.#e.push(i);
                return;
            }
            const l = w$(this.#e, i, (u, h)=>h.priority - u.priority);
            this.#e.splice(l, 0, i);
        }
        setPriority(e, t) {
            const r = this.#e.findIndex((i)=>i.id === e);
            if (r === -1) throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);
            const [s] = this.#e.splice(r, 1);
            this.enqueue(s.run, {
                priority: t,
                id: e
            });
        }
        dequeue() {
            return this.#e.shift()?.run;
        }
        filter(e) {
            return this.#e.filter((t)=>t.priority === e.priority).map((t)=>t.run);
        }
        get size() {
            return this.#e.length;
        }
    }, v$ = class extends JS {
        #e;
        #t;
        #n = 0;
        #l;
        #h = !1;
        #m = !1;
        #c;
        #T = 0;
        #b = 0;
        #u;
        #d;
        #a;
        #o = [];
        #i = 0;
        #r;
        #_;
        #s = 0;
        #y;
        #f;
        #k = 1n;
        #w = new Map;
        timeout;
        constructor(e){
            if (super(), e = {
                carryoverIntervalCount: !1,
                intervalCap: Number.POSITIVE_INFINITY,
                interval: 0,
                concurrency: Number.POSITIVE_INFINITY,
                autoStart: !0,
                queueClass: b$,
                strict: !1,
                ...e
            }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString() ?? ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString() ?? ""}\` (${typeof e.interval})`);
            if (e.strict && e.interval === 0) throw new TypeError("The `strict` option requires a non-zero `interval`");
            if (e.strict && e.intervalCap === Number.POSITIVE_INFINITY) throw new TypeError("The `strict` option requires a finite `intervalCap`");
            if (this.#e = e.carryoverIntervalCount ?? e.carryoverConcurrencyCount ?? !1, this.#t = e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, this.#l = e.intervalCap, this.#c = e.interval, this.#a = e.strict, this.#r = new e.queueClass, this.#_ = e.queueClass, this.concurrency = e.concurrency, e.timeout !== void 0 && !(Number.isFinite(e.timeout) && e.timeout > 0)) throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${e.timeout}\` (${typeof e.timeout})`);
            this.timeout = e.timeout, this.#f = e.autoStart === !1, this.#z();
        }
        #v(e) {
            for(; this.#i < this.#o.length;){
                const r = this.#o[this.#i];
                if (r !== void 0 && e - r >= this.#c) this.#i++;
                else break;
            }
            (this.#i > 100 && this.#i > this.#o.length / 2 || this.#i === this.#o.length) && (this.#o = this.#o.slice(this.#i), this.#i = 0);
        }
        #R(e) {
            this.#a ? this.#o.push(e) : this.#n++;
        }
        #O() {
            this.#a ? this.#o.length > this.#i && this.#o.pop() : this.#n > 0 && this.#n--;
        }
        #E() {
            return this.#o.length - this.#i;
        }
        get #$() {
            return this.#t ? !0 : this.#a ? this.#E() < this.#l : this.#n < this.#l;
        }
        get #M() {
            return this.#s < this.#y;
        }
        #N() {
            this.#s--, this.#s === 0 && this.emit("pendingZero"), this.#I(), this.emit("next");
        }
        #L() {
            this.#d = void 0, this.#B(), this.#D();
        }
        #U(e) {
            if (this.#a) {
                if (this.#v(e), this.#E() >= this.#l) {
                    const r = this.#o[this.#i], s = this.#c - (e - r);
                    return this.#A(s), !0;
                }
                return !1;
            }
            if (this.#u === void 0) {
                const t = this.#T - e;
                if (t < 0) {
                    if (this.#b > 0) {
                        const r = e - this.#b;
                        if (r < this.#c) return this.#A(this.#c - r), !0;
                    }
                    this.#n = this.#e ? this.#s : 0;
                } else return this.#A(t), !0;
            }
            return !1;
        }
        #A(e) {
            this.#d === void 0 && (this.#d = setTimeout(()=>{
                this.#L();
            }, e));
        }
        #S() {
            this.#u && (clearInterval(this.#u), this.#u = void 0);
        }
        #x() {
            this.#d && (clearTimeout(this.#d), this.#d = void 0);
        }
        #I() {
            if (this.#r.size === 0) {
                if (this.#S(), this.emit("empty"), this.#s === 0) {
                    if (this.#x(), this.#a && this.#i > 0) {
                        const t = Date.now();
                        this.#v(t);
                    }
                    this.emit("idle");
                }
                return !1;
            }
            let e = !1;
            if (!this.#f) {
                const t = Date.now(), r = !this.#U(t);
                if (this.#$ && this.#M) {
                    const s = this.#r.dequeue();
                    this.#t || (this.#R(t), this.#g()), this.emit("active"), s(), r && this.#D(), e = !0;
                }
            }
            return e;
        }
        #D() {
            this.#t || this.#u !== void 0 || this.#a || (this.#u = setInterval(()=>{
                this.#B();
            }, this.#c), this.#T = Date.now() + this.#c);
        }
        #B() {
            this.#a || (this.#n === 0 && this.#s === 0 && this.#u && this.#S(), this.#n = this.#e ? this.#s : 0), this.#C(), this.#g();
        }
        #C() {
            for(; this.#I(););
        }
        get concurrency() {
            return this.#y;
        }
        set concurrency(e) {
            if (!(typeof e == "number" && e >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            this.#y = e, this.#C();
        }
        setPriority(e, t) {
            if (typeof t != "number" || !Number.isFinite(t)) throw new TypeError(`Expected \`priority\` to be a finite number, got \`${t}\` (${typeof t})`);
            this.#r.setPriority(e, t);
        }
        async add(e, t = {}) {
            return t = {
                timeout: this.timeout,
                ...t,
                id: t.id ?? (this.#k++).toString()
            }, new Promise((r, s)=>{
                const i = Symbol(`task-${t.id}`);
                this.#r.enqueue(async ()=>{
                    this.#s++, this.#w.set(i, {
                        id: t.id,
                        priority: t.priority ?? 0,
                        startTime: Date.now(),
                        timeout: t.timeout
                    });
                    let l;
                    try {
                        try {
                            t.signal?.throwIfAborted();
                        } catch (f) {
                            throw this.#F(), this.#w.delete(i), f;
                        }
                        this.#b = Date.now();
                        let u = e({
                            signal: t.signal
                        });
                        if (t.timeout && (u = j4(Promise.resolve(u), {
                            milliseconds: t.timeout,
                            message: `Task timed out after ${t.timeout}ms (queue has ${this.#s} running, ${this.#r.size} waiting)`
                        })), t.signal) {
                            const { signal: f } = t;
                            u = Promise.race([
                                u,
                                new Promise((p, m)=>{
                                    l = ()=>{
                                        m(f.reason);
                                    }, f.addEventListener("abort", l, {
                                        once: !0
                                    });
                                })
                            ]);
                        }
                        const h = await u;
                        r(h), this.emit("completed", h);
                    } catch (u) {
                        s(u), this.emit("error", u);
                    } finally{
                        l && t.signal?.removeEventListener("abort", l), this.#w.delete(i), queueMicrotask(()=>{
                            this.#N();
                        });
                    }
                }, t), this.emit("add"), this.#I();
            });
        }
        async addAll(e, t) {
            return Promise.all(e.map(async (r)=>this.add(r, t)));
        }
        start() {
            return this.#f ? (this.#f = !1, this.#C(), this) : this;
        }
        pause() {
            this.#f = !0;
        }
        clear() {
            this.#r = new this.#_, this.#S(), this.#P(), this.emit("empty"), this.#s === 0 && (this.#x(), this.emit("idle")), this.emit("next");
        }
        async onEmpty() {
            this.#r.size !== 0 && await this.#p("empty");
        }
        async onSizeLessThan(e) {
            this.#r.size < e || await this.#p("next", ()=>this.#r.size < e);
        }
        async onIdle() {
            this.#s === 0 && this.#r.size === 0 || await this.#p("idle");
        }
        async onPendingZero() {
            this.#s !== 0 && await this.#p("pendingZero");
        }
        async onRateLimit() {
            this.isRateLimited || await this.#p("rateLimit");
        }
        async onRateLimitCleared() {
            this.isRateLimited && await this.#p("rateLimitCleared");
        }
        onError() {
            return new Promise((e, t)=>{
                const r = (s)=>{
                    this.off("error", r), t(s);
                };
                this.on("error", r);
            });
        }
        async #p(e, t) {
            return new Promise((r)=>{
                const s = ()=>{
                    t && !t() || (this.off(e, s), r());
                };
                this.on(e, s);
            });
        }
        get size() {
            return this.#r.size;
        }
        sizeBy(e) {
            return this.#r.filter(e).length;
        }
        get pending() {
            return this.#s;
        }
        get isPaused() {
            return this.#f;
        }
        #z() {
            this.#t || (this.on("add", ()=>{
                this.#r.size > 0 && this.#g();
            }), this.on("next", ()=>{
                this.#g();
            }));
        }
        #g() {
            this.#t || this.#m || (this.#m = !0, queueMicrotask(()=>{
                this.#m = !1, this.#P();
            }));
        }
        #F() {
            this.#t || (this.#O(), this.#g());
        }
        #P() {
            const e = this.#h;
            if (this.#t || this.#r.size === 0) {
                e && (this.#h = !1, this.emit("rateLimitCleared"));
                return;
            }
            let t;
            if (this.#a) {
                const s = Date.now();
                this.#v(s), t = this.#E();
            } else t = this.#n;
            const r = t >= this.#l;
            r !== e && (this.#h = r, this.emit(r ? "rateLimit" : "rateLimitCleared"));
        }
        get isRateLimited() {
            return this.#h;
        }
        get isSaturated() {
            return this.#s === this.#y && this.#r.size > 0 || this.isRateLimited && this.#r.size > 0;
        }
        get runningTasks() {
            return [
                ...this.#w.values()
            ].map((e)=>({
                    ...e
                }));
        }
    };
    function eI(n) {
        const e = [
            Qo.A
        ];
        return n == null ? e : Array.isArray(n) ? n.length === 0 ? e : n : [
            n
        ];
    }
    function E$(n, e) {
        if (n === e) return !0;
        if (n.byteLength !== e.byteLength) return !1;
        for(let t = 0; t < n.byteLength; t++)if (n[t] !== e[t]) return !1;
        return !0;
    }
    function eu(n) {
        if (n instanceof Uint8Array && n.constructor.name === "Uint8Array") return n;
        if (n instanceof ArrayBuffer) return new Uint8Array(n);
        if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
        throw new Error("Unknown type, must be binary type");
    }
    function A$(n) {
        return new TextEncoder().encode(n);
    }
    function S$(n) {
        return new TextDecoder().decode(n);
    }
    function I$(n, e) {
        if (n.length >= 255) throw new TypeError("Alphabet too long");
        for(var t = new Uint8Array(256), r = 0; r < t.length; r++)t[r] = 255;
        for(var s = 0; s < n.length; s++){
            var i = n.charAt(s), l = i.charCodeAt(0);
            if (t[l] !== 255) throw new TypeError(i + " is ambiguous");
            t[l] = s;
        }
        var u = n.length, h = n.charAt(0), f = Math.log(u) / Math.log(256), p = Math.log(256) / Math.log(u);
        function m(S) {
            if (S instanceof Uint8Array || (ArrayBuffer.isView(S) ? S = new Uint8Array(S.buffer, S.byteOffset, S.byteLength) : Array.isArray(S) && (S = Uint8Array.from(S))), !(S instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
            if (S.length === 0) return "";
            for(var _ = 0, I = 0, k = 0, G = S.length; k !== G && S[k] === 0;)k++, _++;
            for(var P = (G - k) * p + 1 >>> 0, J = new Uint8Array(P); k !== G;){
                for(var H = S[k], F = 0, $ = P - 1; (H !== 0 || F < I) && $ !== -1; $--, F++)H += 256 * J[$] >>> 0, J[$] = H % u >>> 0, H = H / u >>> 0;
                if (H !== 0) throw new Error("Non-zero carry");
                I = F, k++;
            }
            for(var Y = P - I; Y !== P && J[Y] === 0;)Y++;
            for(var O = h.repeat(_); Y < P; ++Y)O += n.charAt(J[Y]);
            return O;
        }
        function w(S) {
            if (typeof S != "string") throw new TypeError("Expected String");
            if (S.length === 0) return new Uint8Array;
            var _ = 0;
            if (S[_] !== " ") {
                for(var I = 0, k = 0; S[_] === h;)I++, _++;
                for(var G = (S.length - _) * f + 1 >>> 0, P = new Uint8Array(G); S[_];){
                    var J = t[S.charCodeAt(_)];
                    if (J === 255) return;
                    for(var H = 0, F = G - 1; (J !== 0 || H < k) && F !== -1; F--, H++)J += u * P[F] >>> 0, P[F] = J % 256 >>> 0, J = J / 256 >>> 0;
                    if (J !== 0) throw new Error("Non-zero carry");
                    k = H, _++;
                }
                if (S[_] !== " ") {
                    for(var $ = G - k; $ !== G && P[$] === 0;)$++;
                    for(var Y = new Uint8Array(I + (G - $)), O = I; $ !== G;)Y[O++] = P[$++];
                    return Y;
                }
            }
        }
        function A(S) {
            var _ = w(S);
            if (_) return _;
            throw new Error(`Non-${e} character`);
        }
        return {
            encode: m,
            decodeUnsafe: w,
            decode: A
        };
    }
    var C$ = I$, T$ = C$;
    let _$ = class {
        name;
        prefix;
        baseEncode;
        constructor(e, t, r){
            this.name = e, this.prefix = t, this.baseEncode = r;
        }
        encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
            throw Error("Unknown type, must be binary type");
        }
    }, x$ = class {
        name;
        prefix;
        baseDecode;
        prefixCodePoint;
        constructor(e, t, r){
            this.name = e, this.prefix = t;
            const s = t.codePointAt(0);
            if (s === void 0) throw new Error("Invalid prefix character");
            this.prefixCodePoint = s, this.baseDecode = r;
        }
        decode(e) {
            if (typeof e == "string") {
                if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                return this.baseDecode(e.slice(this.prefix.length));
            } else throw Error("Can only multibase decode strings");
        }
        or(e) {
            return tI(this, e);
        }
    };
    class D$ {
        decoders;
        constructor(e){
            this.decoders = e;
        }
        or(e) {
            return tI(this, e);
        }
        decode(e) {
            const t = e[0], r = this.decoders[t];
            if (r != null) return r.decode(e);
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
    function tI(n, e) {
        return new D$({
            ...n.decoders ?? {
                [n.prefix]: n
            },
            ...e.decoders ?? {
                [e.prefix]: e
            }
        });
    }
    class B$ {
        name;
        prefix;
        baseEncode;
        baseDecode;
        encoder;
        decoder;
        constructor(e, t, r, s){
            this.name = e, this.prefix = t, this.baseEncode = r, this.baseDecode = s, this.encoder = new _$(e, t, r), this.decoder = new x$(e, t, s);
        }
        encode(e) {
            return this.encoder.encode(e);
        }
        decode(e) {
            return this.decoder.decode(e);
        }
    }
    function cg({ name: n, prefix: e, encode: t, decode: r }) {
        return new B$(n, e, t, r);
    }
    function Ef({ name: n, prefix: e, alphabet: t }) {
        const { encode: r, decode: s } = T$(t, n);
        return cg({
            prefix: e,
            name: n,
            encode: r,
            decode: (i)=>eu(s(i))
        });
    }
    function P$(n, e, t, r) {
        let s = n.length;
        for(; n[s - 1] === "=";)--s;
        const i = new Uint8Array(s * t / 8 | 0);
        let l = 0, u = 0, h = 0;
        for(let f = 0; f < s; ++f){
            const p = e[n[f]];
            if (p === void 0) throw new SyntaxError(`Non-${r} character`);
            u = u << t | p, l += t, l >= 8 && (l -= 8, i[h++] = 255 & u >> l);
        }
        if (l >= t || (255 & u << 8 - l) !== 0) throw new SyntaxError("Unexpected end of data");
        return i;
    }
    function k$(n, e, t) {
        const r = e[e.length - 1] === "=", s = (1 << t) - 1;
        let i = "", l = 0, u = 0;
        for(let h = 0; h < n.length; ++h)for(u = u << 8 | n[h], l += 8; l > t;)l -= t, i += e[s & u >> l];
        if (l !== 0 && (i += e[s & u << t - l]), r) for(; (i.length * t & 7) !== 0;)i += "=";
        return i;
    }
    function R$(n) {
        const e = {};
        for(let t = 0; t < n.length; ++t)e[n[t]] = t;
        return e;
    }
    function _n({ name: n, prefix: e, bitsPerChar: t, alphabet: r }) {
        const s = R$(r);
        return cg({
            prefix: e,
            name: n,
            encode (i) {
                return k$(i, r, t);
            },
            decode (i) {
                return P$(i, s, t, n);
            }
        });
    }
    const O$ = Ef({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
    }), $$ = Object.freeze(Object.defineProperty({
        __proto__: null,
        base10: O$
    }, Symbol.toStringTag, {
        value: "Module"
    })), M$ = _n({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }), N$ = _n({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    }), L$ = Object.freeze(Object.defineProperty({
        __proto__: null,
        base16: M$,
        base16upper: N$
    }, Symbol.toStringTag, {
        value: "Module"
    })), U$ = _n({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
    }), z$ = Object.freeze(Object.defineProperty({
        __proto__: null,
        base2: U$
    }, Symbol.toStringTag, {
        value: "Module"
    })), nI = Array.from(""), F$ = nI.reduce((n, e, t)=>(n[t] = e, n), []), V$ = nI.reduce((n, e, t)=>{
        const r = e.codePointAt(0);
        if (r == null) throw new Error(`Invalid character: ${e}`);
        return n[r] = t, n;
    }, []);
    function H$(n) {
        return n.reduce((e, t)=>(e += F$[t], e), "");
    }
    function Q$(n) {
        const e = [];
        for (const t of n){
            const r = t.codePointAt(0);
            if (r == null) throw new Error(`Invalid character: ${t}`);
            const s = V$[r];
            if (s == null) throw new Error(`Non-base256emoji character: ${t}`);
            e.push(s);
        }
        return new Uint8Array(e);
    }
    const q$ = cg({
        prefix: "",
        name: "base256emoji",
        encode: H$,
        decode: Q$
    }), K$ = Object.freeze(Object.defineProperty({
        __proto__: null,
        base256emoji: q$
    }, Symbol.toStringTag, {
        value: "Module"
    })), At = _n({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }), G$ = _n({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }), Y$ = _n({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }), W$ = _n({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }), j$ = _n({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }), X$ = _n({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }), J$ = _n({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }), Z$ = _n({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }), eM = _n({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    }), tM = Object.freeze(Object.defineProperty({
        __proto__: null,
        base32: At,
        base32hex: j$,
        base32hexpad: J$,
        base32hexpadupper: Z$,
        base32hexupper: X$,
        base32pad: Y$,
        base32padupper: W$,
        base32upper: G$,
        base32z: eM
    }, Symbol.toStringTag, {
        value: "Module"
    })), No = Ef({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }), nM = Ef({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    }), rM = Object.freeze(Object.defineProperty({
        __proto__: null,
        base36: No,
        base36upper: nM
    }, Symbol.toStringTag, {
        value: "Module"
    })), He = Ef({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }), sM = Ef({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    }), iM = Object.freeze(Object.defineProperty({
        __proto__: null,
        base58btc: He,
        base58flickr: sM
    }, Symbol.toStringTag, {
        value: "Module"
    })), As = _n({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }), X4 = _n({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }), yn = _n({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }), oM = _n({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    }), aM = Object.freeze(Object.defineProperty({
        __proto__: null,
        base64: As,
        base64pad: X4,
        base64url: yn,
        base64urlpad: oM
    }, Symbol.toStringTag, {
        value: "Module"
    })), lM = _n({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
    }), cM = Object.freeze(Object.defineProperty({
        __proto__: null,
        base8: lM
    }, Symbol.toStringTag, {
        value: "Module"
    })), uM = cg({
        prefix: "\0",
        name: "identity",
        encode: (n)=>S$(n),
        decode: (n)=>A$(n)
    }), hM = Object.freeze(Object.defineProperty({
        __proto__: null,
        identity: uM
    }, Symbol.toStringTag, {
        value: "Module"
    })), dM = new TextEncoder, fM = new TextDecoder, pM = "json", rI = 512;
    function gM(n) {
        return dM.encode(JSON.stringify(n));
    }
    function mM(n) {
        return JSON.parse(fM.decode(n));
    }
    const yM = Object.freeze(Object.defineProperty({
        __proto__: null,
        code: rI,
        decode: mM,
        encode: gM,
        name: pM
    }, Symbol.toStringTag, {
        value: "Module"
    })), wM = "raw", Af = 85;
    function bM(n) {
        return eu(n);
    }
    function vM(n) {
        return eu(n);
    }
    const EM = Object.freeze(Object.defineProperty({
        __proto__: null,
        code: Af,
        decode: vM,
        encode: bM,
        name: wM
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var AM = sI, g9 = 128, SM = -128, IM = Math.pow(2, 31);
    function sI(n, e, t) {
        e = e || [], t = t || 0;
        for(var r = t; n >= IM;)e[t++] = n & 255 | g9, n /= 128;
        for(; n & SM;)e[t++] = n & 255 | g9, n >>>= 7;
        return e[t] = n | 0, sI.bytes = t - r + 1, e;
    }
    var CM = Py, TM = 128, m9 = 127;
    function Py(n, r) {
        var t = 0, r = r || 0, s = 0, i = r, l, u = n.length;
        do {
            if (i >= u) throw Py.bytes = 0, new RangeError("Could not decode varint");
            l = n[i++], t += s < 28 ? (l & m9) << s : (l & m9) * Math.pow(2, s), s += 7;
        }while (l >= TM);
        return Py.bytes = i - r, t;
    }
    var _M = Math.pow(2, 7), xM = Math.pow(2, 14), DM = Math.pow(2, 21), BM = Math.pow(2, 28), PM = Math.pow(2, 35), kM = Math.pow(2, 42), RM = Math.pow(2, 49), OM = Math.pow(2, 56), $M = Math.pow(2, 63), MM = function(n) {
        return n < _M ? 1 : n < xM ? 2 : n < DM ? 3 : n < BM ? 4 : n < PM ? 5 : n < kM ? 6 : n < RM ? 7 : n < OM ? 8 : n < $M ? 9 : 10;
    }, NM = {
        encode: AM,
        decode: CM,
        encodingLength: MM
    }, dp = NM;
    function ky(n, e = 0) {
        return [
            dp.decode(n, e),
            dp.decode.bytes
        ];
    }
    function fp(n, e, t = 0) {
        return dp.encode(n, e, t), e;
    }
    function pp(n) {
        return dp.encodingLength(n);
    }
    function jo(n, e) {
        const t = e.byteLength, r = pp(n), s = r + pp(t), i = new Uint8Array(s + t);
        return fp(n, i, 0), fp(t, i, r), i.set(e, s), new J4(n, t, e, i);
    }
    function kt(n) {
        const e = eu(n), [t, r] = ky(e), [s, i] = ky(e.subarray(r)), l = e.subarray(r + i);
        if (l.byteLength !== s) throw new Error("Incorrect length");
        return new J4(t, s, l, e);
    }
    function LM(n, e) {
        if (n === e) return !0;
        {
            const t = e;
            return n.code === t.code && n.size === t.size && t.bytes instanceof Uint8Array && E$(n.bytes, t.bytes);
        }
    }
    class J4 {
        code;
        size;
        digest;
        bytes;
        constructor(e, t, r, s){
            this.code = e, this.size = t, this.digest = r, this.bytes = s;
        }
    }
    const iI = 0, UM = "identity", oI = eu;
    function zM(n, e) {
        if (e?.truncate != null && e.truncate !== n.byteLength) {
            if (e.truncate < 0 || e.truncate > n.byteLength) throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);
            n = n.subarray(0, e.truncate);
        }
        return jo(iI, oI(n));
    }
    const nt = {
        code: iI,
        name: UM,
        encode: oI,
        digest: zM
    }, FM = 20;
    function Z4({ name: n, code: e, encode: t, minDigestLength: r, maxDigestLength: s }) {
        return new VM(n, e, t, r, s);
    }
    class VM {
        name;
        code;
        encode;
        minDigestLength;
        maxDigestLength;
        constructor(e, t, r, s, i){
            this.name = e, this.code = t, this.encode = r, this.minDigestLength = s ?? FM, this.maxDigestLength = i;
        }
        digest(e, t) {
            if (t?.truncate != null) {
                if (t.truncate < this.minDigestLength) throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
                if (this.maxDigestLength != null && t.truncate > this.maxDigestLength) throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
            }
            if (e instanceof Uint8Array) {
                const r = this.encode(e);
                return r instanceof Uint8Array ? y9(r, this.code, t?.truncate) : r.then((s)=>y9(s, this.code, t?.truncate));
            } else throw Error("Unknown type, must be binary type");
        }
    }
    function y9(n, e, t) {
        if (t != null && t !== n.byteLength) {
            if (t > n.byteLength) throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);
            n = n.subarray(0, t);
        }
        return jo(e, n);
    }
    function aI(n) {
        return async (e)=>new Uint8Array(await crypto.subtle.digest(n, e));
    }
    const Ut = Z4({
        name: "sha2-256",
        code: 18,
        encode: aI("SHA-256")
    }), w9 = Z4({
        name: "sha2-512",
        code: 19,
        encode: aI("SHA-512")
    });
    function b9(n, e) {
        const { bytes: t, version: r } = n;
        return r === 0 ? QM(t, Ry(n), e ?? He.encoder) : qM(t, Ry(n), e ?? At.encoder);
    }
    const v9 = new WeakMap;
    function Ry(n) {
        const e = v9.get(n);
        if (e == null) {
            const t = new Map;
            return v9.set(n, t), t;
        }
        return e;
    }
    class ge {
        code;
        version;
        multihash;
        bytes;
        "/";
        constructor(e, t, r, s){
            this.code = t, this.version = e, this.multihash = r, this.bytes = s, this["/"] = s;
        }
        get asCID() {
            return this;
        }
        get byteOffset() {
            return this.bytes.byteOffset;
        }
        get byteLength() {
            return this.bytes.byteLength;
        }
        toV0() {
            switch(this.version){
                case 0:
                    return this;
                case 1:
                    {
                        const { code: e, multihash: t } = this;
                        if (e !== Eh) throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                        if (t.code !== KM) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                        return ge.createV0(t);
                    }
                default:
                    throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
        }
        toV1() {
            switch(this.version){
                case 0:
                    {
                        const { code: e, digest: t } = this.multihash, r = jo(e, t);
                        return ge.createV1(this.code, r);
                    }
                case 1:
                    return this;
                default:
                    throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
            }
        }
        equals(e) {
            return ge.equals(this, e);
        }
        static equals(e, t) {
            const r = t;
            return r != null && e.code === r.code && e.version === r.version && LM(e.multihash, r.multihash);
        }
        toString(e) {
            return b9(this, e);
        }
        toJSON() {
            return {
                "/": b9(this)
            };
        }
        link() {
            return this;
        }
        [Symbol.toStringTag] = "CID";
        [Symbol.for("nodejs.util.inspect.custom")]() {
            return `CID(${this.toString()})`;
        }
        static asCID(e) {
            if (e == null) return null;
            const t = e;
            if (t instanceof ge) return t;
            if (t["/"] != null && t["/"] === t.bytes || t.asCID === t) {
                const { version: r, code: s, multihash: i, bytes: l } = t;
                return new ge(r, s, i, l ?? E9(r, s, i.bytes));
            } else if (t[GM] === !0) {
                const { version: r, multihash: s, code: i } = t, l = kt(s);
                return ge.create(r, i, l);
            } else return null;
        }
        static create(e, t, r) {
            if (typeof t != "number") throw new Error("String codecs are no longer supported");
            if (!(r.bytes instanceof Uint8Array)) throw new Error("Invalid digest");
            switch(e){
                case 0:
                    {
                        if (t !== Eh) throw new Error(`Version 0 CID must use dag-pb (code: ${Eh}) block encoding`);
                        return new ge(e, t, r, r.bytes);
                    }
                case 1:
                    {
                        const s = E9(e, t, r.bytes);
                        return new ge(e, t, r, s);
                    }
                default:
                    throw new Error("Invalid version");
            }
        }
        static createV0(e) {
            return ge.create(0, Eh, e);
        }
        static createV1(e, t) {
            return ge.create(1, e, t);
        }
        static decode(e) {
            const [t, r] = ge.decodeFirst(e);
            if (r.length !== 0) throw new Error("Incorrect length");
            return t;
        }
        static decodeFirst(e) {
            const t = ge.inspectBytes(e), r = t.size - t.multihashSize, s = eu(e.subarray(r, r + t.multihashSize));
            if (s.byteLength !== t.multihashSize) throw new Error("Incorrect length");
            const i = s.subarray(t.multihashSize - t.digestSize), l = new J4(t.multihashCode, t.digestSize, i, s);
            return [
                t.version === 0 ? ge.createV0(l) : ge.createV1(t.codec, l),
                e.subarray(t.size)
            ];
        }
        static inspectBytes(e) {
            let t = 0;
            const r = ()=>{
                const [m, w] = ky(e.subarray(t));
                return t += w, m;
            };
            let s = r(), i = Eh;
            if (s === 18 ? (s = 0, t = 0) : i = r(), s !== 0 && s !== 1) throw new RangeError(`Invalid CID version ${s}`);
            const l = t, u = r(), h = r(), f = t + h, p = f - l;
            return {
                version: s,
                codec: i,
                multihashCode: u,
                digestSize: h,
                multihashSize: p,
                size: f
            };
        }
        static parse(e, t) {
            const [r, s] = HM(e, t), i = ge.decode(s);
            if (i.version === 0 && e[0] !== "Q") throw Error("Version 0 CID string must not include multibase prefix");
            return Ry(i).set(r, e), i;
        }
    }
    function HM(n, e) {
        switch(n[0]){
            case "Q":
                {
                    const t = e ?? He;
                    return [
                        He.prefix,
                        t.decode(`${He.prefix}${n}`)
                    ];
                }
            case He.prefix:
                {
                    const t = e ?? He;
                    return [
                        He.prefix,
                        t.decode(n)
                    ];
                }
            case At.prefix:
                {
                    const t = e ?? At;
                    return [
                        At.prefix,
                        t.decode(n)
                    ];
                }
            case No.prefix:
                {
                    const t = e ?? No;
                    return [
                        No.prefix,
                        t.decode(n)
                    ];
                }
            default:
                {
                    if (e == null) throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
                    return [
                        n[0],
                        e.decode(n)
                    ];
                }
        }
    }
    function QM(n, e, t) {
        const { prefix: r } = t;
        if (r !== He.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`);
        const s = e.get(r);
        if (s == null) {
            const i = t.encode(n).slice(1);
            return e.set(r, i), i;
        } else return s;
    }
    function qM(n, e, t) {
        const { prefix: r } = t, s = e.get(r);
        if (s == null) {
            const i = t.encode(n);
            return e.set(r, i), i;
        } else return s;
    }
    const Eh = 112, KM = 18;
    function E9(n, e, t) {
        const r = pp(n), s = r + pp(e), i = new Uint8Array(s + t.byteLength);
        return fp(n, i, 0), fp(e, i, r), i.set(t, s), i;
    }
    const GM = Symbol.for("@ipld/js-cid/CID"), un = {
        ...hM,
        ...z$,
        ...cM,
        ...$$,
        ...L$,
        ...tM,
        ...rM,
        ...iM,
        ...aM,
        ...K$
    };
    function je(n = 0) {
        return new Uint8Array(n);
    }
    function Wn(n = 0) {
        return new Uint8Array(n);
    }
    function lI(n, e, t, r) {
        return {
            name: n,
            prefix: e,
            encoder: {
                name: n,
                prefix: e,
                encode: t
            },
            decoder: {
                decode: r
            }
        };
    }
    const A9 = lI("utf8", "u", (n)=>"u" + new TextDecoder("utf8").decode(n), (n)=>new TextEncoder().encode(n.substring(1))), h3 = lI("ascii", "a", (n)=>{
        let e = "a";
        for(let t = 0; t < n.length; t++)e += String.fromCharCode(n[t]);
        return e;
    }, (n)=>{
        n = n.substring(1);
        const e = Wn(n.length);
        for(let t = 0; t < n.length; t++)e[t] = n.charCodeAt(t);
        return e;
    }), cI = {
        utf8: A9,
        "utf-8": A9,
        hex: un.base16,
        latin1: h3,
        ascii: h3,
        binary: h3,
        ...un
    };
    L = function(n, e = "utf8") {
        const t = cI[e];
        if (t == null) throw new Error(`Unsupported encoding "${e}"`);
        return t.encoder.encode(n).substring(1);
    };
    const uI = 60;
    function hI(n) {
        return {
            Status: n.Status ?? 0,
            TC: n.TC ?? n.flag_tc ?? !1,
            RD: n.RD ?? n.flag_rd ?? !1,
            RA: n.RA ?? n.flag_ra ?? !1,
            AD: n.AD ?? n.flag_ad ?? !1,
            CD: n.CD ?? n.flag_cd ?? !1,
            Question: (n.Question ?? n.questions ?? []).map((e)=>({
                    name: e.name,
                    type: Qo[e.type]
                })),
            Answer: (n.Answer ?? n.answers ?? []).map((e)=>({
                    name: e.name,
                    type: Qo[e.type],
                    TTL: e.TTL ?? e.ttl ?? uI,
                    data: e.data instanceof Uint8Array ? L(e.data) : e.data
                }))
        };
    }
    const YM = 4;
    function S9(n, e = {}) {
        const t = new v$({
            concurrency: e.queryConcurrency ?? YM
        });
        return async (r, s = {})=>{
            const i = s?.logger?.forComponent("dns:dns-json-over-https"), l = new URLSearchParams;
            l.set("name", r), eI(s.types).forEach((h)=>{
                l.append("type", Qo[h]);
            }), s.onProgress?.(new Be("dns:query", r)), i?.("GET %s", `${n}?${l}`);
            const u = await t.add(async ()=>{
                const h = await fetch(`${n}?${l}`, {
                    headers: {
                        accept: "application/dns-json"
                    },
                    signal: s?.signal
                });
                if (i?.("GET %s %d", h.url, h.status), h.status !== 200) throw new Error(`Unexpected HTTP status: ${h.status} - ${h.statusText}`);
                const f = hI(await h.json());
                return s.onProgress?.(new Be("dns:response", f)), f;
            }, {
                signal: s.signal
            });
            if (u == null) throw new Error("No DNS response received");
            return u;
        };
    }
    function WM() {
        return [
            S9("https://cloudflare-dns.com/dns-query"),
            S9("https://dns.google/resolve")
        ];
    }
    var d3, I9;
    function jM() {
        return I9 || (I9 = 1, d3 = function(n) {
            if (!n) throw Error("hashlru must have a max value, of type number, greater than 0");
            var e = 0, t = Object.create(null), r = Object.create(null);
            function s(i, l) {
                t[i] = l, e++, e >= n && (e = 0, r = t, t = Object.create(null));
            }
            return {
                has: function(i) {
                    return t[i] !== void 0 || r[i] !== void 0;
                },
                remove: function(i) {
                    t[i] !== void 0 && (t[i] = void 0), r[i] !== void 0 && (r[i] = void 0);
                },
                get: function(i) {
                    var l = t[i];
                    if (l !== void 0) return l;
                    if ((l = r[i]) !== void 0) return s(i, l), l;
                },
                set: function(i, l) {
                    t[i] !== void 0 ? t[i] = l : s(i, l);
                },
                clear: function() {
                    t = Object.create(null), r = Object.create(null);
                }
            };
        }), d3;
    }
    var XM = jM();
    const JM = Zc(XM);
    class ZM {
        lru;
        constructor(e){
            this.lru = JM(e);
        }
        get(e, t) {
            let r = !0;
            const s = [];
            for (const i of t){
                const l = this.getAnswers(e, i);
                if (l.length === 0) {
                    r = !1;
                    break;
                }
                s.push(...l);
            }
            if (r) return hI({
                answers: s
            });
        }
        getAnswers(e, t) {
            const r = `${e.toLowerCase()}-${t}`, s = this.lru.get(r);
            if (s != null) {
                const i = s.filter((l)=>l.expires > Date.now()).map(({ expires: l, value: u })=>({
                        ...u,
                        TTL: Math.round((l - Date.now()) / 1e3),
                        type: Qo[u.type]
                    }));
                return i.length === 0 && this.lru.remove(r), i;
            }
            return [];
        }
        add(e, t) {
            const r = `${e.toLowerCase()}-${t.type}`, s = this.lru.get(r) ?? [];
            s.push({
                expires: Date.now() + (t.TTL ?? uI) * 1e3,
                value: t
            }), this.lru.set(r, s);
        }
        remove(e, t) {
            const r = `${e.toLowerCase()}-${t}`;
            this.lru.remove(r);
        }
        clear() {
            this.lru.clear();
        }
    }
    function eN(n) {
        return new ZM(n);
    }
    const tN = 1e3;
    let nN = class {
        resolvers;
        cache;
        logger;
        constructor(e){
            this.resolvers = {}, this.cache = eN(e.cacheSize ?? tN), this.logger = e.logger, Object.entries(e.resolvers ?? {}).forEach(([t, r])=>{
                Array.isArray(r) || (r = [
                    r
                ]), t.endsWith(".") || (t = `${t}.`), this.resolvers[t] = r;
            }), this.resolvers["."] == null && (this.resolvers["."] = WM());
        }
        async query(e, t = {}) {
            const r = eI(t.types), s = t.cached !== !1 ? this.cache.get(e, r) : void 0;
            if (s != null) return t.onProgress?.(new Be("dns:cache", s)), s;
            const i = `${e.split(".").pop()}.`, l = (this.resolvers[i] ?? this.resolvers["."]).sort(()=>Math.random() > .5 ? -1 : 1), u = [];
            for (const h of l){
                if (t.signal?.aborted === !0) break;
                try {
                    const f = await h(e, {
                        ...t,
                        logger: this.logger,
                        types: r
                    });
                    for (const p of f.Answer)this.cache.add(e, p);
                    return f;
                } catch (f) {
                    u.push(f), t.onProgress?.(new Be("dns:error", f));
                }
            }
            throw new p$(u, `DNS lookup of ${e} ${r} failed`);
        }
    };
    var Qo;
    (function(n) {
        n[n.A = 1] = "A", n[n.CNAME = 5] = "CNAME", n[n.TXT = 16] = "TXT", n[n.AAAA = 28] = "AAAA";
    })(Qo || (Qo = {}));
    function dI(n = {}) {
        return new nN(n);
    }
    function rN(n) {
        return n[Symbol.asyncIterator] != null;
    }
    qo = function(n) {
        if (rN(n)) return (async ()=>{
            for await (const e of n);
        })();
        for (const e of n);
    };
    class C9 extends Error {
        constructor(e = "An error occurred while signing a message"){
            super(e), this.name = "SigningError";
        }
    }
    class T9 extends Error {
        constructor(e = "An error occurred while verifying a message"){
            super(e), this.name = "VerificationError";
        }
    }
    class sN extends Error {
        constructor(e = "Missing Web Crypto API"){
            super(e), this.name = "WebCryptoMissingError";
        }
    }
    const nr = {
        get (n = globalThis) {
            const e = n.crypto;
            if (e?.subtle == null) throw new sN("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
            return e;
        }
    };
    let jn = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, fI = class extends Error {
        static name = "InvalidPublicKeyError";
        constructor(e = "Invalid public key"){
            super(e), this.name = "InvalidPublicKeyError";
        }
    };
    class pI extends Error {
        static name = "InvalidPrivateKeyError";
        constructor(e = "Invalid private key"){
            super(e), this.name = "InvalidPrivateKeyError";
        }
    }
    let Sf = class extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    };
    function Ee(n, e) {
        if (n === e) return !0;
        if (n.byteLength !== e.byteLength) return !1;
        for(let t = 0; t < n.byteLength; t++)if (n[t] !== e[t]) return !1;
        return !0;
    }
    function xe(n, e) {
        e == null && (e = n.reduce((s, i)=>s + i.length, 0));
        const t = Wn(e);
        let r = 0;
        for (const s of n)t.set(s, r), r += s.length;
        return t;
    }
    const gI = Symbol.for("@achingbrain/uint8arraylist");
    function _9(n, e) {
        if (e == null || e < 0) throw new RangeError("index is out of bounds");
        let t = 0;
        for (const r of n){
            const s = t + r.byteLength;
            if (e < s) return {
                buf: r,
                index: e - t
            };
            t = s;
        }
        throw new RangeError("index is out of bounds");
    }
    function Oh(n) {
        return !!n?.[gI];
    }
    class Re {
        bufs;
        length;
        [gI] = !0;
        constructor(...e){
            this.bufs = [], this.length = 0, e.length > 0 && this.appendAll(e);
        }
        *[Symbol.iterator]() {
            yield* this.bufs;
        }
        get byteLength() {
            return this.length;
        }
        append(...e) {
            this.appendAll(e);
        }
        appendAll(e) {
            let t = 0;
            for (const r of e)if (r instanceof Uint8Array) t += r.byteLength, this.bufs.push(r);
            else if (Oh(r)) t += r.byteLength, this.bufs.push(...r.bufs);
            else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
            this.length += t;
        }
        prepend(...e) {
            this.prependAll(e);
        }
        prependAll(e) {
            let t = 0;
            for (const r of e.reverse())if (r instanceof Uint8Array) t += r.byteLength, this.bufs.unshift(r);
            else if (Oh(r)) t += r.byteLength, this.bufs.unshift(...r.bufs);
            else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
            this.length += t;
        }
        get(e) {
            const t = _9(this.bufs, e);
            return t.buf[t.index];
        }
        set(e, t) {
            const r = _9(this.bufs, e);
            r.buf[r.index] = t;
        }
        write(e, t = 0) {
            if (e instanceof Uint8Array) for(let r = 0; r < e.length; r++)this.set(t + r, e[r]);
            else if (Oh(e)) for(let r = 0; r < e.length; r++)this.set(t + r, e.get(r));
            else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
        }
        consume(e) {
            if (e = Math.trunc(e), !(Number.isNaN(e) || e <= 0)) {
                if (e === this.byteLength) {
                    this.bufs = [], this.length = 0;
                    return;
                }
                for(; this.bufs.length > 0;)if (e >= this.bufs[0].byteLength) e -= this.bufs[0].byteLength, this.length -= this.bufs[0].byteLength, this.bufs.shift();
                else {
                    this.bufs[0] = this.bufs[0].subarray(e), this.length -= e;
                    break;
                }
            }
        }
        slice(e, t) {
            const { bufs: r, length: s } = this._subList(e, t);
            return xe(r, s);
        }
        subarray(e, t) {
            const { bufs: r, length: s } = this._subList(e, t);
            return r.length === 1 ? r[0] : xe(r, s);
        }
        sublist(e, t) {
            const { bufs: r, length: s } = this._subList(e, t), i = new Re;
            return i.length = s, i.bufs = [
                ...r
            ], i;
        }
        _subList(e, t) {
            if (e = e ?? 0, t = t ?? this.length, e < 0 && (e = this.length + e), t < 0 && (t = this.length + t), e < 0 || t > this.length) throw new RangeError("index is out of bounds");
            if (e === t) return {
                bufs: [],
                length: 0
            };
            if (e === 0 && t === this.length) return {
                bufs: this.bufs,
                length: this.length
            };
            const r = [];
            let s = 0;
            for(let i = 0; i < this.bufs.length; i++){
                const l = this.bufs[i], u = s, h = u + l.byteLength;
                if (s = h, e >= h) continue;
                const f = e >= u && e < h, p = t > u && t <= h;
                if (f && p) {
                    if (e === u && t === h) {
                        r.push(l);
                        break;
                    }
                    const m = e - u;
                    r.push(l.subarray(m, m + (t - e)));
                    break;
                }
                if (f) {
                    if (e === 0) {
                        r.push(l);
                        continue;
                    }
                    r.push(l.subarray(e - u));
                    continue;
                }
                if (p) {
                    if (t === h) {
                        r.push(l);
                        break;
                    }
                    r.push(l.subarray(0, t - u));
                    break;
                }
                r.push(l);
            }
            return {
                bufs: r,
                length: t - e
            };
        }
        indexOf(e, t = 0) {
            if (!Oh(e) && !(e instanceof Uint8Array)) throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
            const r = e instanceof Uint8Array ? e : e.subarray();
            if (t = Number(t ?? 0), isNaN(t) && (t = 0), t < 0 && (t = this.length + t), t < 0 && (t = 0), e.length === 0) return t > this.length ? this.length : t;
            const s = r.byteLength;
            if (s === 0) throw new TypeError("search must be at least 1 byte long");
            const i = 256, l = new Int32Array(i);
            for(let m = 0; m < i; m++)l[m] = -1;
            for(let m = 0; m < s; m++)l[r[m]] = m;
            const u = l, h = this.byteLength - r.byteLength, f = r.byteLength - 1;
            let p;
            for(let m = t; m <= h; m += p){
                p = 0;
                for(let w = f; w >= 0; w--){
                    const A = this.get(m + w);
                    if (r[w] !== A) {
                        p = Math.max(1, w - u[A]);
                        break;
                    }
                }
                if (p === 0) return m;
            }
            return -1;
        }
        getInt8(e) {
            const t = this.subarray(e, e + 1);
            return new DataView(t.buffer, t.byteOffset, t.byteLength).getInt8(0);
        }
        setInt8(e, t) {
            const r = Wn(1);
            new DataView(r.buffer, r.byteOffset, r.byteLength).setInt8(0, t), this.write(r, e);
        }
        getInt16(e, t) {
            const r = this.subarray(e, e + 2);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getInt16(0, t);
        }
        setInt16(e, t, r) {
            const s = je(2);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setInt16(0, t, r), this.write(s, e);
        }
        getInt32(e, t) {
            const r = this.subarray(e, e + 4);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getInt32(0, t);
        }
        setInt32(e, t, r) {
            const s = je(4);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setInt32(0, t, r), this.write(s, e);
        }
        getBigInt64(e, t) {
            const r = this.subarray(e, e + 8);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getBigInt64(0, t);
        }
        setBigInt64(e, t, r) {
            const s = je(8);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setBigInt64(0, t, r), this.write(s, e);
        }
        getUint8(e) {
            const t = this.subarray(e, e + 1);
            return new DataView(t.buffer, t.byteOffset, t.byteLength).getUint8(0);
        }
        setUint8(e, t) {
            const r = Wn(1);
            new DataView(r.buffer, r.byteOffset, r.byteLength).setUint8(0, t), this.write(r, e);
        }
        getUint16(e, t) {
            const r = this.subarray(e, e + 2);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getUint16(0, t);
        }
        setUint16(e, t, r) {
            const s = je(2);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setUint16(0, t, r), this.write(s, e);
        }
        getUint32(e, t) {
            const r = this.subarray(e, e + 4);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getUint32(0, t);
        }
        setUint32(e, t, r) {
            const s = je(4);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setUint32(0, t, r), this.write(s, e);
        }
        getBigUint64(e, t) {
            const r = this.subarray(e, e + 8);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getBigUint64(0, t);
        }
        setBigUint64(e, t, r) {
            const s = je(8);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setBigUint64(0, t, r), this.write(s, e);
        }
        getFloat32(e, t) {
            const r = this.subarray(e, e + 4);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getFloat32(0, t);
        }
        setFloat32(e, t, r) {
            const s = je(4);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setFloat32(0, t, r), this.write(s, e);
        }
        getFloat64(e, t) {
            const r = this.subarray(e, e + 8);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getFloat64(0, t);
        }
        setFloat64(e, t, r) {
            const s = je(8);
            new DataView(s.buffer, s.byteOffset, s.byteLength).setFloat64(0, t, r), this.write(s, e);
        }
        equals(e) {
            if (e == null || !(e instanceof Re) || e.bufs.length !== this.bufs.length) return !1;
            for(let t = 0; t < this.bufs.length; t++)if (!Ee(this.bufs[t], e.bufs[t])) return !1;
            return !0;
        }
        static fromUint8Arrays(e, t) {
            const r = new Re;
            return r.bufs = e, t == null && (t = e.reduce((s, i)=>s + i.byteLength, 0)), r.length = t, r;
        }
    }
    re = function(n, e = "utf8") {
        const t = cI[e];
        if (t == null) throw new Error(`Unsupported encoding "${e}"`);
        return t.decoder.decode(`${t.prefix}${n}`);
    };
    const iN = parseInt("11111", 2), Oy = parseInt("10000000", 2), oN = parseInt("01111111", 2), x9 = {
        0: Ah,
        1: Ah,
        2: aN,
        3: uN,
        4: hN,
        5: cN,
        6: lN,
        16: Ah,
        22: Ah,
        48: Ah
    };
    function Xo(n, e = {
        offset: 0
    }) {
        const t = n[e.offset] & iN;
        if (e.offset++, x9[t] != null) return x9[t](n, e);
        throw new Error("No decoder for tag " + t);
    }
    function If(n, e) {
        let t = 0;
        if ((n[e.offset] & Oy) === Oy) {
            const r = n[e.offset] & oN;
            let s = "0x";
            e.offset++;
            for(let i = 0; i < r; i++, e.offset++)s += n[e.offset].toString(16).padStart(2, "0");
            t = parseInt(s, 16);
        } else t = n[e.offset], e.offset++;
        return t;
    }
    function Ah(n, e) {
        If(n, e);
        const t = [];
        for(; !(e.offset >= n.byteLength);){
            const r = Xo(n, e);
            if (r === null) break;
            t.push(r);
        }
        return t;
    }
    function aN(n, e) {
        const t = If(n, e), r = e.offset, s = e.offset + t, i = [];
        for(let l = r; l < s; l++)l === r && n[l] === 0 || i.push(n[l]);
        return e.offset += t, Uint8Array.from(i);
    }
    function lN(n, e) {
        const t = If(n, e), r = e.offset + t, s = n[e.offset];
        e.offset++;
        let i = 0, l = 0;
        s < 40 ? (i = 0, l = s) : s < 80 ? (i = 1, l = s - 40) : (i = 2, l = s - 80);
        let u = `${i}.${l}`, h = [];
        for(; e.offset < r;){
            const f = n[e.offset];
            if (e.offset++, h.push(f & 127), f < 128) {
                h.reverse();
                let p = 0;
                for(let m = 0; m < h.length; m++)p += h[m] << m * 7;
                u += `.${p}`, h = [];
            }
        }
        return u;
    }
    function cN(n, e) {
        return e.offset++, null;
    }
    function uN(n, e) {
        const t = If(n, e), r = n[e.offset];
        e.offset++;
        const s = n.subarray(e.offset, e.offset + t - 1);
        if (e.offset += t, r !== 0) throw new Error("Unused bits in bit string is unimplemented");
        return s;
    }
    function hN(n, e) {
        const t = If(n, e), r = n.subarray(e.offset, e.offset + t);
        return e.offset += t, r;
    }
    function dN(n) {
        let e = n.toString(16);
        e.length % 2 === 1 && (e = "0" + e);
        const t = new Re;
        for(let r = 0; r < e.length; r += 2)t.append(Uint8Array.from([
            parseInt(`${e[r]}${e[r + 1]}`, 16)
        ]));
        return t;
    }
    function ug(n) {
        if (n.byteLength < 128) return Uint8Array.from([
            n.byteLength
        ]);
        const e = dN(n.byteLength);
        return new Re(Uint8Array.from([
            e.byteLength | Oy
        ]), e);
    }
    function $r(n) {
        const e = new Re, t = 128;
        return (n.subarray()[0] & t) === t && e.append(Uint8Array.from([
            0
        ])), e.append(n), new Re(Uint8Array.from([
            2
        ]), ug(e), e);
    }
    function e6(n) {
        const e = Uint8Array.from([
            0
        ]), t = new Re(e, n);
        return new Re(Uint8Array.from([
            3
        ]), ug(t), t);
    }
    function fN(n) {
        return new Re(Uint8Array.from([
            4
        ]), ug(n), n);
    }
    function Ki(n, e = 48) {
        const t = new Re;
        for (const r of n)t.append(r);
        return new Re(Uint8Array.from([
            e
        ]), ug(t), t);
    }
    const mI = "1.2.840.10045.3.1.7", yI = "1.3.132.0.34", wI = "1.3.132.0.35";
    async function pN(n = "P-256") {
        const e = await crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: n
        }, !0, [
            "sign",
            "verify"
        ]);
        return {
            publicKey: await crypto.subtle.exportKey("jwk", e.publicKey),
            privateKey: await crypto.subtle.exportKey("jwk", e.privateKey)
        };
    }
    async function gN(n, e, t) {
        const r = await crypto.subtle.importKey("jwk", n, {
            name: "ECDSA",
            namedCurve: n.crv ?? "P-256"
        }, !1, [
            "sign"
        ]);
        t?.signal?.throwIfAborted();
        const s = await crypto.subtle.sign({
            name: "ECDSA",
            hash: {
                name: "SHA-256"
            }
        }, r, e.subarray());
        return t?.signal?.throwIfAborted(), new Uint8Array(s, 0, s.byteLength);
    }
    async function mN(n, e, t, r) {
        const s = await crypto.subtle.importKey("jwk", n, {
            name: "ECDSA",
            namedCurve: n.crv ?? "P-256"
        }, !1, [
            "verify"
        ]);
        r?.signal?.throwIfAborted();
        const i = await crypto.subtle.verify({
            name: "ECDSA",
            hash: {
                name: "SHA-256"
            }
        }, s, e, t.subarray());
        return r?.signal?.throwIfAborted(), i;
    }
    const yN = Uint8Array.from([
        6,
        8,
        42,
        134,
        72,
        206,
        61,
        3,
        1,
        7
    ]), wN = Uint8Array.from([
        6,
        5,
        43,
        129,
        4,
        0,
        34
    ]), bN = Uint8Array.from([
        6,
        5,
        43,
        129,
        4,
        0,
        35
    ]), bI = {
        ext: !0,
        kty: "EC",
        crv: "P-256"
    }, vI = {
        ext: !0,
        kty: "EC",
        crv: "P-384"
    }, EI = {
        ext: !0,
        kty: "EC",
        crv: "P-521"
    }, bc = 32, vc = 48, Ec = 66;
    function vN(n) {
        const e = Xo(n);
        return AI(e);
    }
    function AI(n) {
        const e = n[1], t = L(e, "base64url"), r = n[2][1][0], s = 1;
        let i, l;
        if (e.byteLength === bc) return i = L(r.subarray(s, s + bc), "base64url"), l = L(r.subarray(s + bc), "base64url"), new tp({
            ...bI,
            key_ops: [
                "sign"
            ],
            d: t,
            x: i,
            y: l
        });
        if (e.byteLength === vc) return i = L(r.subarray(s, s + vc), "base64url"), l = L(r.subarray(s + vc), "base64url"), new tp({
            ...vI,
            key_ops: [
                "sign"
            ],
            d: t,
            x: i,
            y: l
        });
        if (e.byteLength === Ec) return i = L(r.subarray(s, s + Ec), "base64url"), l = L(r.subarray(s + Ec), "base64url"), new tp({
            ...EI,
            key_ops: [
                "sign"
            ],
            d: t,
            x: i,
            y: l
        });
        throw new jn(`Private key length was wrong length, got ${e.byteLength}, expected 32, 48 or 66`);
    }
    function SI(n) {
        const e = Xo(n);
        return II(e);
    }
    function II(n) {
        const e = n[1][1][0], t = 1;
        let r, s;
        if (e.byteLength === bc * 2 + 1) return r = L(e.subarray(t, t + bc), "base64url"), s = L(e.subarray(t + bc), "base64url"), new ep({
            ...bI,
            key_ops: [
                "verify"
            ],
            x: r,
            y: s
        });
        if (e.byteLength === vc * 2 + 1) return r = L(e.subarray(t, t + vc), "base64url"), s = L(e.subarray(t + vc), "base64url"), new ep({
            ...vI,
            key_ops: [
                "verify"
            ],
            x: r,
            y: s
        });
        if (e.byteLength === Ec * 2 + 1) return r = L(e.subarray(t, t + Ec), "base64url"), s = L(e.subarray(t + Ec), "base64url"), new ep({
            ...EI,
            key_ops: [
                "verify"
            ],
            x: r,
            y: s
        });
        throw new jn(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`);
    }
    function EN(n) {
        return Ki([
            $r(Uint8Array.from([
                1
            ])),
            fN(re(n.d ?? "", "base64url")),
            Ki([
                CI(n.crv)
            ], 160),
            Ki([
                e6(new Re(Uint8Array.from([
                    4
                ]), re(n.x ?? "", "base64url"), re(n.y ?? "", "base64url")))
            ], 161)
        ]).subarray();
    }
    function AN(n) {
        return Ki([
            $r(Uint8Array.from([
                1
            ])),
            Ki([
                CI(n.crv)
            ], 160),
            Ki([
                e6(new Re(Uint8Array.from([
                    4
                ]), re(n.x ?? "", "base64url"), re(n.y ?? "", "base64url")))
            ], 161)
        ]).subarray();
    }
    function CI(n) {
        if (n === "P-256") return yN;
        if (n === "P-384") return wN;
        if (n === "P-521") return bN;
        throw new jn(`Invalid curve ${n}`);
    }
    async function SN(n = "P-256") {
        const e = await pN(n);
        return new tp(e.privateKey);
    }
    class ep {
        type = "ECDSA";
        jwk;
        _raw;
        constructor(e){
            this.jwk = e;
        }
        get raw() {
            return this._raw == null && (this._raw = AN(this.jwk)), this._raw;
        }
        toMultihash() {
            return nt.digest(Fr(this));
        }
        toCID() {
            return ge.createV1(114, this.toMultihash());
        }
        toString() {
            return He.encode(this.toMultihash().bytes).substring(1);
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        async verify(e, t, r) {
            return mN(this.jwk, t, e, r);
        }
    }
    class tp {
        type = "ECDSA";
        jwk;
        publicKey;
        _raw;
        constructor(e){
            this.jwk = e, this.publicKey = new ep({
                crv: e.crv,
                ext: e.ext,
                key_ops: [
                    "verify"
                ],
                kty: "EC",
                x: e.x,
                y: e.y
            });
        }
        get raw() {
            return this._raw == null && (this._raw = EN(this.jwk)), this._raw;
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        async sign(e, t) {
            return gN(this.jwk, e, t);
        }
    }
    function hg(n) {
        return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array";
    }
    function Us(n, e = "") {
        if (!Number.isSafeInteger(n) || n < 0) {
            const t = e && `"${e}" `;
            throw new Error(`${t}expected integer >= 0, got ${n}`);
        }
    }
    function Ge(n, e, t = "") {
        const r = hg(n), s = n?.length, i = e !== void 0;
        if (!r || i && s !== e) {
            const l = t && `"${t}" `, u = i ? ` of length ${e}` : "", h = r ? `length=${s}` : `type=${typeof n}`;
            throw new Error(l + "expected Uint8Array" + u + ", got " + h);
        }
        return n;
    }
    function Cf(n) {
        if (typeof n != "function" || typeof n.create != "function") throw new Error("Hash must wrapped by utils.createHasher");
        Us(n.outputLen), Us(n.blockLen);
    }
    function gp(n, e = !0) {
        if (n.destroyed) throw new Error("Hash instance has been destroyed");
        if (e && n.finished) throw new Error("Hash#digest() has already been called");
    }
    function IN(n, e) {
        Ge(n, void 0, "digestInto() output");
        const t = e.outputLen;
        if (n.length < t) throw new Error('"digestInto() output" expected to be of length >=' + t);
    }
    function ui(...n) {
        for(let e = 0; e < n.length; e++)n[e].fill(0);
    }
    function pd(n) {
        return new DataView(n.buffer, n.byteOffset, n.byteLength);
    }
    function Ws(n, e) {
        return n << 32 - e | n >>> e;
    }
    function f3(n, e) {
        return n << e | n >>> 32 - e >>> 0;
    }
    const TI = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", CN = Array.from({
        length: 256
    }, (n, e)=>e.toString(16).padStart(2, "0"));
    function Tf(n) {
        if (Ge(n), TI) return n.toHex();
        let e = "";
        for(let t = 0; t < n.length; t++)e += CN[n[t]];
        return e;
    }
    const $i = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function D9(n) {
        if (n >= $i._0 && n <= $i._9) return n - $i._0;
        if (n >= $i.A && n <= $i.F) return n - ($i.A - 10);
        if (n >= $i.a && n <= $i.f) return n - ($i.a - 10);
    }
    function kd(n) {
        if (typeof n != "string") throw new Error("hex string expected, got " + typeof n);
        if (TI) return Uint8Array.fromHex(n);
        const e = n.length, t = e / 2;
        if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
        const r = new Uint8Array(t);
        for(let s = 0, i = 0; s < t; s++, i += 2){
            const l = D9(n.charCodeAt(i)), u = D9(n.charCodeAt(i + 1));
            if (l === void 0 || u === void 0) {
                const h = n[i] + n[i + 1];
                throw new Error('hex string expected, got non-hex character "' + h + '" at index ' + i);
            }
            r[s] = l * 16 + u;
        }
        return r;
    }
    const TN = async ()=>{};
    async function _N(n, e, t) {
        let r = Date.now();
        for(let s = 0; s < n; s++){
            t(s);
            const i = Date.now() - r;
            i >= 0 && i < e || (await TN(), r += i);
        }
    }
    function xN(n) {
        if (typeof n != "string") throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(n));
    }
    function B9(n, e = "") {
        return typeof n == "string" ? xN(n) : Ge(n, void 0, e);
    }
    function ri(...n) {
        let e = 0;
        for(let r = 0; r < n.length; r++){
            const s = n[r];
            Ge(s), e += s.length;
        }
        const t = new Uint8Array(e);
        for(let r = 0, s = 0; r < n.length; r++){
            const i = n[r];
            t.set(i, s), s += i.length;
        }
        return t;
    }
    function DN(n, e) {
        if (e !== void 0 && {}.toString.call(e) !== "[object Object]") throw new Error("options must be object or undefined");
        return Object.assign(n, e);
    }
    function t6(n, e = {}) {
        const t = (s, i)=>n(i).update(s).digest(), r = n(void 0);
        return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = (s)=>n(s), Object.assign(t, e), Object.freeze(t);
    }
    function _f(n = 32) {
        const e = typeof globalThis == "object" ? globalThis.crypto : null;
        if (typeof e?.getRandomValues != "function") throw new Error("crypto.getRandomValues must be defined");
        return e.getRandomValues(new Uint8Array(n));
    }
    const _I = (n)=>({
            oid: Uint8Array.from([
                6,
                9,
                96,
                134,
                72,
                1,
                101,
                3,
                4,
                2,
                n
            ])
        });
    function xI(n, e, t) {
        return n & e ^ ~n & t;
    }
    function DI(n, e, t) {
        return n & e ^ n & t ^ e & t;
    }
    class n6 {
        blockLen;
        outputLen;
        padOffset;
        isLE;
        buffer;
        view;
        finished = !1;
        length = 0;
        pos = 0;
        destroyed = !1;
        constructor(e, t, r, s){
            this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = s, this.buffer = new Uint8Array(e), this.view = pd(this.buffer);
        }
        update(e) {
            gp(this), Ge(e);
            const { view: t, buffer: r, blockLen: s } = this, i = e.length;
            for(let l = 0; l < i;){
                const u = Math.min(s - this.pos, i - l);
                if (u === s) {
                    const h = pd(e);
                    for(; s <= i - l; l += s)this.process(h, l);
                    continue;
                }
                r.set(e.subarray(l, l + u), this.pos), this.pos += u, l += u, this.pos === s && (this.process(t, 0), this.pos = 0);
            }
            return this.length += e.length, this.roundClean(), this;
        }
        digestInto(e) {
            gp(this), IN(e, this), this.finished = !0;
            const { buffer: t, view: r, blockLen: s, isLE: i } = this;
            let { pos: l } = this;
            t[l++] = 128, ui(this.buffer.subarray(l)), this.padOffset > s - l && (this.process(r, 0), l = 0);
            for(let m = l; m < s; m++)t[m] = 0;
            r.setBigUint64(s - 8, BigInt(this.length * 8), i), this.process(r, 0);
            const u = pd(e), h = this.outputLen;
            if (h % 4) throw new Error("_sha2: outputLen must be aligned to 32bit");
            const f = h / 4, p = this.get();
            if (f > p.length) throw new Error("_sha2: outputLen bigger than state");
            for(let m = 0; m < f; m++)u.setUint32(4 * m, p[m], i);
        }
        digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const r = e.slice(0, t);
            return this.destroy(), r;
        }
        _cloneInto(e) {
            e ||= new this.constructor, e.set(...this.get());
            const { blockLen: t, buffer: r, length: s, finished: i, destroyed: l, pos: u } = this;
            return e.destroyed = l, e.finished = i, e.length = s, e.pos = u, s % t && e.buffer.set(r), e;
        }
        clone() {
            return this._cloneInto();
        }
    }
    const Co = Uint32Array.from([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
    ]), Bn = Uint32Array.from([
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
    ]), t0 = BigInt(2 ** 32 - 1), P9 = BigInt(32);
    function BN(n, e = !1) {
        return e ? {
            h: Number(n & t0),
            l: Number(n >> P9 & t0)
        } : {
            h: Number(n >> P9 & t0) | 0,
            l: Number(n & t0) | 0
        };
    }
    function PN(n, e = !1) {
        const t = n.length;
        let r = new Uint32Array(t), s = new Uint32Array(t);
        for(let i = 0; i < t; i++){
            const { h: l, l: u } = BN(n[i], e);
            [r[i], s[i]] = [
                l,
                u
            ];
        }
        return [
            r,
            s
        ];
    }
    const k9 = (n, e, t)=>n >>> t, R9 = (n, e, t)=>n << 32 - t | e >>> t, zl = (n, e, t)=>n >>> t | e << 32 - t, Fl = (n, e, t)=>n << 32 - t | e >>> t, n0 = (n, e, t)=>n << 64 - t | e >>> t - 32, r0 = (n, e, t)=>n >>> t - 32 | e << 64 - t;
    function Mi(n, e, t, r) {
        const s = (e >>> 0) + (r >>> 0);
        return {
            h: n + t + (s / 2 ** 32 | 0) | 0,
            l: s | 0
        };
    }
    const kN = (n, e, t)=>(n >>> 0) + (e >>> 0) + (t >>> 0), RN = (n, e, t, r)=>e + t + r + (n / 2 ** 32 | 0) | 0, ON = (n, e, t, r)=>(n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0), $N = (n, e, t, r, s)=>e + t + r + s + (n / 2 ** 32 | 0) | 0, MN = (n, e, t, r, s)=>(n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0), NN = (n, e, t, r, s, i)=>e + t + r + s + i + (n / 2 ** 32 | 0) | 0, LN = Uint32Array.from([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ]), To = new Uint32Array(64);
    class UN extends n6 {
        constructor(e){
            super(64, e, 8, !1);
        }
        get() {
            const { A: e, B: t, C: r, D: s, E: i, F: l, G: u, H: h } = this;
            return [
                e,
                t,
                r,
                s,
                i,
                l,
                u,
                h
            ];
        }
        set(e, t, r, s, i, l, u, h) {
            this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = s | 0, this.E = i | 0, this.F = l | 0, this.G = u | 0, this.H = h | 0;
        }
        process(e, t) {
            for(let m = 0; m < 16; m++, t += 4)To[m] = e.getUint32(t, !1);
            for(let m = 16; m < 64; m++){
                const w = To[m - 15], A = To[m - 2], S = Ws(w, 7) ^ Ws(w, 18) ^ w >>> 3, _ = Ws(A, 17) ^ Ws(A, 19) ^ A >>> 10;
                To[m] = _ + To[m - 7] + S + To[m - 16] | 0;
            }
            let { A: r, B: s, C: i, D: l, E: u, F: h, G: f, H: p } = this;
            for(let m = 0; m < 64; m++){
                const w = Ws(u, 6) ^ Ws(u, 11) ^ Ws(u, 25), A = p + w + xI(u, h, f) + LN[m] + To[m] | 0, _ = (Ws(r, 2) ^ Ws(r, 13) ^ Ws(r, 22)) + DI(r, s, i) | 0;
                p = f, f = h, h = u, u = l + A | 0, l = i, i = s, s = r, r = A + _ | 0;
            }
            r = r + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, l = l + this.D | 0, u = u + this.E | 0, h = h + this.F | 0, f = f + this.G | 0, p = p + this.H | 0, this.set(r, s, i, l, u, h, f, p);
        }
        roundClean() {
            ui(To);
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), ui(this.buffer);
        }
    }
    class zN extends UN {
        A = Co[0] | 0;
        B = Co[1] | 0;
        C = Co[2] | 0;
        D = Co[3] | 0;
        E = Co[4] | 0;
        F = Co[5] | 0;
        G = Co[6] | 0;
        H = Co[7] | 0;
        constructor(){
            super(32);
        }
    }
    const BI = PN([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
    ].map((n)=>BigInt(n))), FN = BI[0], VN = BI[1], _o = new Uint32Array(80), xo = new Uint32Array(80);
    class HN extends n6 {
        constructor(e){
            super(128, e, 16, !1);
        }
        get() {
            const { Ah: e, Al: t, Bh: r, Bl: s, Ch: i, Cl: l, Dh: u, Dl: h, Eh: f, El: p, Fh: m, Fl: w, Gh: A, Gl: S, Hh: _, Hl: I } = this;
            return [
                e,
                t,
                r,
                s,
                i,
                l,
                u,
                h,
                f,
                p,
                m,
                w,
                A,
                S,
                _,
                I
            ];
        }
        set(e, t, r, s, i, l, u, h, f, p, m, w, A, S, _, I) {
            this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = l | 0, this.Dh = u | 0, this.Dl = h | 0, this.Eh = f | 0, this.El = p | 0, this.Fh = m | 0, this.Fl = w | 0, this.Gh = A | 0, this.Gl = S | 0, this.Hh = _ | 0, this.Hl = I | 0;
        }
        process(e, t) {
            for(let P = 0; P < 16; P++, t += 4)_o[P] = e.getUint32(t), xo[P] = e.getUint32(t += 4);
            for(let P = 16; P < 80; P++){
                const J = _o[P - 15] | 0, H = xo[P - 15] | 0, F = zl(J, H, 1) ^ zl(J, H, 8) ^ k9(J, H, 7), $ = Fl(J, H, 1) ^ Fl(J, H, 8) ^ R9(J, H, 7), Y = _o[P - 2] | 0, O = xo[P - 2] | 0, se = zl(Y, O, 19) ^ n0(Y, O, 61) ^ k9(Y, O, 6), ae = Fl(Y, O, 19) ^ r0(Y, O, 61) ^ R9(Y, O, 6), oe = ON($, ae, xo[P - 7], xo[P - 16]), K = $N(oe, F, se, _o[P - 7], _o[P - 16]);
                _o[P] = K | 0, xo[P] = oe | 0;
            }
            let { Ah: r, Al: s, Bh: i, Bl: l, Ch: u, Cl: h, Dh: f, Dl: p, Eh: m, El: w, Fh: A, Fl: S, Gh: _, Gl: I, Hh: k, Hl: G } = this;
            for(let P = 0; P < 80; P++){
                const J = zl(m, w, 14) ^ zl(m, w, 18) ^ n0(m, w, 41), H = Fl(m, w, 14) ^ Fl(m, w, 18) ^ r0(m, w, 41), F = m & A ^ ~m & _, $ = w & S ^ ~w & I, Y = MN(G, H, $, VN[P], xo[P]), O = NN(Y, k, J, F, FN[P], _o[P]), se = Y | 0, ae = zl(r, s, 28) ^ n0(r, s, 34) ^ n0(r, s, 39), oe = Fl(r, s, 28) ^ r0(r, s, 34) ^ r0(r, s, 39), K = r & i ^ r & u ^ i & u, V = s & l ^ s & h ^ l & h;
                k = _ | 0, G = I | 0, _ = A | 0, I = S | 0, A = m | 0, S = w | 0, { h: m, l: w } = Mi(f | 0, p | 0, O | 0, se | 0), f = u | 0, p = h | 0, u = i | 0, h = l | 0, i = r | 0, l = s | 0;
                const q = kN(se, oe, V);
                r = RN(q, O, ae, K), s = q | 0;
            }
            ({ h: r, l: s } = Mi(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: i, l } = Mi(this.Bh | 0, this.Bl | 0, i | 0, l | 0), { h: u, l: h } = Mi(this.Ch | 0, this.Cl | 0, u | 0, h | 0), { h: f, l: p } = Mi(this.Dh | 0, this.Dl | 0, f | 0, p | 0), { h: m, l: w } = Mi(this.Eh | 0, this.El | 0, m | 0, w | 0), { h: A, l: S } = Mi(this.Fh | 0, this.Fl | 0, A | 0, S | 0), { h: _, l: I } = Mi(this.Gh | 0, this.Gl | 0, _ | 0, I | 0), { h: k, l: G } = Mi(this.Hh | 0, this.Hl | 0, k | 0, G | 0), this.set(r, s, i, l, u, h, f, p, m, w, A, S, _, I, k, G);
        }
        roundClean() {
            ui(_o, xo);
        }
        destroy() {
            ui(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
    }
    class QN extends HN {
        Ah = Bn[0] | 0;
        Al = Bn[1] | 0;
        Bh = Bn[2] | 0;
        Bl = Bn[3] | 0;
        Ch = Bn[4] | 0;
        Cl = Bn[5] | 0;
        Dh = Bn[6] | 0;
        Dl = Bn[7] | 0;
        Eh = Bn[8] | 0;
        El = Bn[9] | 0;
        Fh = Bn[10] | 0;
        Fl = Bn[11] | 0;
        Gh = Bn[12] | 0;
        Gl = Bn[13] | 0;
        Hh = Bn[14] | 0;
        Hl = Bn[15] | 0;
        constructor(){
            super(64);
        }
    }
    const Lo = t6(()=>new zN, _I(1)), dg = t6(()=>new QN, _I(3));
    const r6 = BigInt(0), $y = BigInt(1);
    function Va(n, e = "") {
        if (typeof n != "boolean") {
            const t = e && `"${e}" `;
            throw new Error(t + "expected boolean, got type=" + typeof n);
        }
        return n;
    }
    function PI(n) {
        if (typeof n == "bigint") {
            if (!np(n)) throw new Error("positive bigint expected, got " + n);
        } else Us(n);
        return n;
    }
    function s0(n) {
        const e = PI(n).toString(16);
        return e.length & 1 ? "0" + e : e;
    }
    function kI(n) {
        if (typeof n != "string") throw new Error("hex string expected, got " + typeof n);
        return n === "" ? r6 : BigInt("0x" + n);
    }
    function fg(n) {
        return kI(Tf(n));
    }
    function Ha(n) {
        return kI(Tf(Rd(Ge(n)).reverse()));
    }
    function s6(n, e) {
        Us(e), n = PI(n);
        const t = kd(n.toString(16).padStart(e * 2, "0"));
        if (t.length !== e) throw new Error("number too large");
        return t;
    }
    function i6(n, e) {
        return s6(n, e).reverse();
    }
    function Rd(n) {
        return Uint8Array.from(n);
    }
    const np = (n)=>typeof n == "bigint" && r6 <= n;
    function qN(n, e, t) {
        return np(n) && np(e) && np(t) && e <= n && n < t;
    }
    function Od(n, e, t, r) {
        if (!qN(e, t, r)) throw new Error("expected valid " + n + ": " + t + " <= n < " + r + ", got " + e);
    }
    function KN(n) {
        let e;
        for(e = 0; n > r6; n >>= $y, e += 1);
        return e;
    }
    const o6 = (n)=>($y << BigInt(n)) - $y;
    function GN(n, e, t) {
        if (Us(n, "hashLen"), Us(e, "qByteLen"), typeof t != "function") throw new Error("hmacFn must be a function");
        const r = (I)=>new Uint8Array(I), s = Uint8Array.of(), i = Uint8Array.of(0), l = Uint8Array.of(1), u = 1e3;
        let h = r(n), f = r(n), p = 0;
        const m = ()=>{
            h.fill(1), f.fill(0), p = 0;
        }, w = (...I)=>t(f, ri(h, ...I)), A = (I = s)=>{
            f = w(i, I), h = w(), I.length !== 0 && (f = w(l, I), h = w());
        }, S = ()=>{
            if (p++ >= u) throw new Error("drbg: tried max amount of iterations");
            let I = 0;
            const k = [];
            for(; I < e;){
                h = w();
                const G = h.slice();
                k.push(G), I += h.length;
            }
            return ri(...k);
        };
        return (I, k)=>{
            m(), A(I);
            let G;
            for(; !(G = k(S()));)A();
            return m(), G;
        };
    }
    function tu(n, e = {}, t = {}) {
        if (!n || typeof n != "object") throw new Error("expected valid options object");
        function r(i, l, u) {
            const h = n[i];
            if (u && h === void 0) return;
            const f = typeof h;
            if (f !== l || h === null) throw new Error(`param "${i}" is invalid: expected ${l}, got ${f}`);
        }
        const s = (i, l)=>Object.entries(i).forEach(([u, h])=>r(u, h, l));
        s(e, !1), s(t, !0);
    }
    function mp(n) {
        const e = new WeakMap;
        return (t, ...r)=>{
            const s = e.get(t);
            if (s !== void 0) return s;
            const i = n(t, ...r);
            return e.set(t, i), i;
        };
    }
    const br = BigInt(0), Tn = BigInt(1), Ba = BigInt(2), RI = BigInt(3), OI = BigInt(4), $I = BigInt(5), YN = BigInt(7), MI = BigInt(8), WN = BigInt(9), NI = BigInt(16);
    function Wt(n, e) {
        const t = n % e;
        return t >= br ? t : e + t;
    }
    function qt(n, e, t) {
        let r = n;
        for(; e-- > br;)r *= r, r %= t;
        return r;
    }
    function O9(n, e) {
        if (n === br) throw new Error("invert: expected non-zero number");
        if (e <= br) throw new Error("invert: expected positive modulus, got " + e);
        let t = Wt(n, e), r = e, s = br, i = Tn;
        for(; t !== br;){
            const u = r / t, h = r % t, f = s - i * u;
            r = t, t = h, s = i, i = f;
        }
        if (r !== Tn) throw new Error("invert: does not exist");
        return Wt(s, e);
    }
    function a6(n, e, t) {
        if (!n.eql(n.sqr(e), t)) throw new Error("Cannot find square root");
    }
    function LI(n, e) {
        const t = (n.ORDER + Tn) / OI, r = n.pow(e, t);
        return a6(n, r, e), r;
    }
    function jN(n, e) {
        const t = (n.ORDER - $I) / MI, r = n.mul(e, Ba), s = n.pow(r, t), i = n.mul(e, s), l = n.mul(n.mul(i, Ba), s), u = n.mul(i, n.sub(l, n.ONE));
        return a6(n, u, e), u;
    }
    function XN(n) {
        const e = pg(n), t = UI(n), r = t(e, e.neg(e.ONE)), s = t(e, r), i = t(e, e.neg(r)), l = (n + YN) / NI;
        return (u, h)=>{
            let f = u.pow(h, l), p = u.mul(f, r);
            const m = u.mul(f, s), w = u.mul(f, i), A = u.eql(u.sqr(p), h), S = u.eql(u.sqr(m), h);
            f = u.cmov(f, p, A), p = u.cmov(w, m, S);
            const _ = u.eql(u.sqr(p), h), I = u.cmov(f, p, _);
            return a6(u, I, h), I;
        };
    }
    function UI(n) {
        if (n < RI) throw new Error("sqrt is not defined for small field");
        let e = n - Tn, t = 0;
        for(; e % Ba === br;)e /= Ba, t++;
        let r = Ba;
        const s = pg(n);
        for(; $9(s, r) === 1;)if (r++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
        if (t === 1) return LI;
        let i = s.pow(r, e);
        const l = (e + Tn) / Ba;
        return function(h, f) {
            if (h.is0(f)) return f;
            if ($9(h, f) !== 1) throw new Error("Cannot find square root");
            let p = t, m = h.mul(h.ONE, i), w = h.pow(f, e), A = h.pow(f, l);
            for(; !h.eql(w, h.ONE);){
                if (h.is0(w)) return h.ZERO;
                let S = 1, _ = h.sqr(w);
                for(; !h.eql(_, h.ONE);)if (S++, _ = h.sqr(_), S === p) throw new Error("Cannot find square root");
                const I = Tn << BigInt(p - S - 1), k = h.pow(m, I);
                p = S, m = h.sqr(k), w = h.mul(w, m), A = h.mul(A, k);
            }
            return A;
        };
    }
    function JN(n) {
        return n % OI === RI ? LI : n % MI === $I ? jN : n % NI === WN ? XN(n) : UI(n);
    }
    const ZN = (n, e)=>(Wt(n, e) & Tn) === Tn, eL = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
    ];
    function tL(n) {
        const e = {
            ORDER: "bigint",
            BYTES: "number",
            BITS: "number"
        }, t = eL.reduce((r, s)=>(r[s] = "function", r), e);
        return tu(n, t), n;
    }
    function nL(n, e, t) {
        if (t < br) throw new Error("invalid exponent, negatives unsupported");
        if (t === br) return n.ONE;
        if (t === Tn) return e;
        let r = n.ONE, s = e;
        for(; t > br;)t & Tn && (r = n.mul(r, s)), s = n.sqr(s), t >>= Tn;
        return r;
    }
    function zI(n, e, t = !1) {
        const r = new Array(e.length).fill(t ? n.ZERO : void 0), s = e.reduce((l, u, h)=>n.is0(u) ? l : (r[h] = l, n.mul(l, u)), n.ONE), i = n.inv(s);
        return e.reduceRight((l, u, h)=>n.is0(u) ? l : (r[h] = n.mul(l, r[h]), n.mul(l, u)), i), r;
    }
    function $9(n, e) {
        const t = (n.ORDER - Tn) / Ba, r = n.pow(e, t), s = n.eql(r, n.ONE), i = n.eql(r, n.ZERO), l = n.eql(r, n.neg(n.ONE));
        if (!s && !i && !l) throw new Error("invalid Legendre symbol result");
        return s ? 1 : i ? 0 : -1;
    }
    function rL(n, e) {
        e !== void 0 && Us(e);
        const t = e !== void 0 ? e : n.toString(2).length, r = Math.ceil(t / 8);
        return {
            nBitLength: t,
            nByteLength: r
        };
    }
    class sL {
        ORDER;
        BITS;
        BYTES;
        isLE;
        ZERO = br;
        ONE = Tn;
        _lengths;
        _sqrt;
        _mod;
        constructor(e, t = {}){
            if (e <= br) throw new Error("invalid field: expected ORDER > 0, got " + e);
            let r;
            this.isLE = !1, t != null && typeof t == "object" && (typeof t.BITS == "number" && (r = t.BITS), typeof t.sqrt == "function" && (this.sqrt = t.sqrt), typeof t.isLE == "boolean" && (this.isLE = t.isLE), t.allowedLengths && (this._lengths = t.allowedLengths?.slice()), typeof t.modFromBytes == "boolean" && (this._mod = t.modFromBytes));
            const { nBitLength: s, nByteLength: i } = rL(e, r);
            if (i > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
            this.ORDER = e, this.BITS = s, this.BYTES = i, this._sqrt = void 0, Object.preventExtensions(this);
        }
        create(e) {
            return Wt(e, this.ORDER);
        }
        isValid(e) {
            if (typeof e != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof e);
            return br <= e && e < this.ORDER;
        }
        is0(e) {
            return e === br;
        }
        isValidNot0(e) {
            return !this.is0(e) && this.isValid(e);
        }
        isOdd(e) {
            return (e & Tn) === Tn;
        }
        neg(e) {
            return Wt(-e, this.ORDER);
        }
        eql(e, t) {
            return e === t;
        }
        sqr(e) {
            return Wt(e * e, this.ORDER);
        }
        add(e, t) {
            return Wt(e + t, this.ORDER);
        }
        sub(e, t) {
            return Wt(e - t, this.ORDER);
        }
        mul(e, t) {
            return Wt(e * t, this.ORDER);
        }
        pow(e, t) {
            return nL(this, e, t);
        }
        div(e, t) {
            return Wt(e * O9(t, this.ORDER), this.ORDER);
        }
        sqrN(e) {
            return e * e;
        }
        addN(e, t) {
            return e + t;
        }
        subN(e, t) {
            return e - t;
        }
        mulN(e, t) {
            return e * t;
        }
        inv(e) {
            return O9(e, this.ORDER);
        }
        sqrt(e) {
            return this._sqrt || (this._sqrt = JN(this.ORDER)), this._sqrt(this, e);
        }
        toBytes(e) {
            return this.isLE ? i6(e, this.BYTES) : s6(e, this.BYTES);
        }
        fromBytes(e, t = !1) {
            Ge(e);
            const { _lengths: r, BYTES: s, isLE: i, ORDER: l, _mod: u } = this;
            if (r) {
                if (!r.includes(e.length) || e.length > s) throw new Error("Field.fromBytes: expected " + r + " bytes, got " + e.length);
                const f = new Uint8Array(s);
                f.set(e, i ? 0 : f.length - e.length), e = f;
            }
            if (e.length !== s) throw new Error("Field.fromBytes: expected " + s + " bytes, got " + e.length);
            let h = i ? Ha(e) : fg(e);
            if (u && (h = Wt(h, l)), !t && !this.isValid(h)) throw new Error("invalid field element: outside of range 0..ORDER");
            return h;
        }
        invertBatch(e) {
            return zI(this, e);
        }
        cmov(e, t, r) {
            return r ? t : e;
        }
    }
    function pg(n, e = {}) {
        return new sL(n, e);
    }
    function FI(n) {
        if (typeof n != "bigint") throw new Error("field order must be bigint");
        const e = n.toString(2).length;
        return Math.ceil(e / 8);
    }
    function VI(n) {
        const e = FI(n);
        return e + Math.ceil(e / 2);
    }
    function iL(n, e, t = !1) {
        Ge(n);
        const r = n.length, s = FI(e), i = VI(e);
        if (r < 16 || r < i || r > 1024) throw new Error("expected " + i + "-1024 bytes of input, got " + r);
        const l = t ? Ha(n) : fg(n), u = Wt(l, e - Tn) + Tn;
        return t ? i6(u, s) : s6(u, s);
    }
    const kc = BigInt(0), Pa = BigInt(1);
    function yp(n, e) {
        const t = e.negate();
        return n ? t : e;
    }
    function gd(n, e) {
        const t = zI(n.Fp, e.map((r)=>r.Z));
        return e.map((r, s)=>n.fromAffine(r.toAffine(t[s])));
    }
    function HI(n, e) {
        if (!Number.isSafeInteger(n) || n <= 0 || n > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + n);
    }
    function p3(n, e) {
        HI(n, e);
        const t = Math.ceil(e / n) + 1, r = 2 ** (n - 1), s = 2 ** n, i = o6(n), l = BigInt(n);
        return {
            windows: t,
            windowSize: r,
            mask: i,
            maxNumber: s,
            shiftBy: l
        };
    }
    function M9(n, e, t) {
        const { windowSize: r, mask: s, maxNumber: i, shiftBy: l } = t;
        let u = Number(n & s), h = n >> l;
        u > r && (u -= i, h += Pa);
        const f = e * r, p = f + Math.abs(u) - 1, m = u === 0, w = u < 0, A = e % 2 !== 0;
        return {
            nextN: h,
            offset: p,
            isZero: m,
            isNeg: w,
            isNegF: A,
            offsetF: f
        };
    }
    const g3 = new WeakMap, QI = new WeakMap;
    function m3(n) {
        return QI.get(n) || 1;
    }
    function N9(n) {
        if (n !== kc) throw new Error("invalid wNAF");
    }
    class qI {
        BASE;
        ZERO;
        Fn;
        bits;
        constructor(e, t){
            this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = t;
        }
        _unsafeLadder(e, t, r = this.ZERO) {
            let s = e;
            for(; t > kc;)t & Pa && (r = r.add(s)), s = s.double(), t >>= Pa;
            return r;
        }
        precomputeWindow(e, t) {
            const { windows: r, windowSize: s } = p3(t, this.bits), i = [];
            let l = e, u = l;
            for(let h = 0; h < r; h++){
                u = l, i.push(u);
                for(let f = 1; f < s; f++)u = u.add(l), i.push(u);
                l = u.double();
            }
            return i;
        }
        wNAF(e, t, r) {
            if (!this.Fn.isValid(r)) throw new Error("invalid scalar");
            let s = this.ZERO, i = this.BASE;
            const l = p3(e, this.bits);
            for(let u = 0; u < l.windows; u++){
                const { nextN: h, offset: f, isZero: p, isNeg: m, isNegF: w, offsetF: A } = M9(r, u, l);
                r = h, p ? i = i.add(yp(w, t[A])) : s = s.add(yp(m, t[f]));
            }
            return N9(r), {
                p: s,
                f: i
            };
        }
        wNAFUnsafe(e, t, r, s = this.ZERO) {
            const i = p3(e, this.bits);
            for(let l = 0; l < i.windows && r !== kc; l++){
                const { nextN: u, offset: h, isZero: f, isNeg: p } = M9(r, l, i);
                if (r = u, !f) {
                    const m = t[h];
                    s = s.add(p ? m.negate() : m);
                }
            }
            return N9(r), s;
        }
        getPrecomputes(e, t, r) {
            let s = g3.get(t);
            return s || (s = this.precomputeWindow(t, e), e !== 1 && (typeof r == "function" && (s = r(s)), g3.set(t, s))), s;
        }
        cached(e, t, r) {
            const s = m3(e);
            return this.wNAF(s, this.getPrecomputes(s, e, r), t);
        }
        unsafe(e, t, r, s) {
            const i = m3(e);
            return i === 1 ? this._unsafeLadder(e, t, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, r), t, s);
        }
        createCache(e, t) {
            HI(t, this.bits), QI.set(e, t), g3.delete(e);
        }
        hasCache(e) {
            return m3(e) !== 1;
        }
    }
    function oL(n, e, t, r) {
        let s = e, i = n.ZERO, l = n.ZERO;
        for(; t > kc || r > kc;)t & Pa && (i = i.add(s)), r & Pa && (l = l.add(s)), s = s.double(), t >>= Pa, r >>= Pa;
        return {
            p1: i,
            p2: l
        };
    }
    function L9(n, e, t) {
        if (e) {
            if (e.ORDER !== n) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
            return tL(e), e;
        } else return pg(n, {
            isLE: t
        });
    }
    function KI(n, e, t = {}, r) {
        if (r === void 0 && (r = n === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${n} CURVE object`);
        for (const h of [
            "p",
            "n",
            "h"
        ]){
            const f = e[h];
            if (!(typeof f == "bigint" && f > kc)) throw new Error(`CURVE.${h} must be positive bigint`);
        }
        const s = L9(e.p, t.Fp, r), i = L9(e.n, t.Fn, r), u = [
            "Gx",
            "Gy",
            "a",
            n === "weierstrass" ? "b" : "d"
        ];
        for (const h of u)if (!s.isValid(e[h])) throw new Error(`CURVE.${h} must be valid field element of CURVE.Fp`);
        return e = Object.freeze(Object.assign({}, e)), {
            CURVE: e,
            Fp: s,
            Fn: i
        };
    }
    function l6(n, e) {
        return function(r) {
            const s = n(r);
            return {
                secretKey: s,
                publicKey: e(s)
            };
        };
    }
    const Do = BigInt(0), gn = BigInt(1), y3 = BigInt(2), aL = BigInt(8);
    function lL(n, e, t, r) {
        const s = n.sqr(t), i = n.sqr(r), l = n.add(n.mul(e.a, s), i), u = n.add(n.ONE, n.mul(e.d, n.mul(s, i)));
        return n.eql(l, u);
    }
    function cL(n, e = {}) {
        const t = KI("edwards", n, e, e.FpFnLE), { Fp: r, Fn: s } = t;
        let i = t.CURVE;
        const { h: l } = i;
        tu(e, {}, {
            uvRatio: "function"
        });
        const u = y3 << BigInt(s.BYTES * 8) - gn, h = (I)=>r.create(I), f = e.uvRatio || ((I, k)=>{
            try {
                return {
                    isValid: !0,
                    value: r.sqrt(r.div(I, k))
                };
            } catch  {
                return {
                    isValid: !1,
                    value: Do
                };
            }
        });
        if (!lL(r, i, i.Gx, i.Gy)) throw new Error("bad curve params: generator point");
        function p(I, k, G = !1) {
            const P = G ? gn : Do;
            return Od("coordinate " + I, k, P, u), k;
        }
        function m(I) {
            if (!(I instanceof S)) throw new Error("EdwardsPoint expected");
        }
        const w = mp((I, k)=>{
            const { X: G, Y: P, Z: J } = I, H = I.is0();
            k == null && (k = H ? aL : r.inv(J));
            const F = h(G * k), $ = h(P * k), Y = r.mul(J, k);
            if (H) return {
                x: Do,
                y: gn
            };
            if (Y !== gn) throw new Error("invZ was invalid");
            return {
                x: F,
                y: $
            };
        }), A = mp((I)=>{
            const { a: k, d: G } = i;
            if (I.is0()) throw new Error("bad point: ZERO");
            const { X: P, Y: J, Z: H, T: F } = I, $ = h(P * P), Y = h(J * J), O = h(H * H), se = h(O * O), ae = h($ * k), oe = h(O * h(ae + Y)), K = h(se + h(G * h($ * Y)));
            if (oe !== K) throw new Error("bad point: equation left != right (1)");
            const V = h(P * J), q = h(H * F);
            if (V !== q) throw new Error("bad point: equation left != right (2)");
            return !0;
        });
        class S {
            static BASE = new S(i.Gx, i.Gy, gn, h(i.Gx * i.Gy));
            static ZERO = new S(Do, gn, gn, Do);
            static Fp = r;
            static Fn = s;
            X;
            Y;
            Z;
            T;
            constructor(k, G, P, J){
                this.X = p("x", k), this.Y = p("y", G), this.Z = p("z", P, !0), this.T = p("t", J), Object.freeze(this);
            }
            static CURVE() {
                return i;
            }
            static fromAffine(k) {
                if (k instanceof S) throw new Error("extended point not allowed");
                const { x: G, y: P } = k || {};
                return p("x", G), p("y", P), new S(G, P, gn, h(G * P));
            }
            static fromBytes(k, G = !1) {
                const P = r.BYTES, { a: J, d: H } = i;
                k = Rd(Ge(k, P, "point")), Va(G, "zip215");
                const F = Rd(k), $ = k[P - 1];
                F[P - 1] = $ & -129;
                const Y = Ha(F), O = G ? u : r.ORDER;
                Od("point.y", Y, Do, O);
                const se = h(Y * Y), ae = h(se - gn), oe = h(H * se - J);
                let { isValid: K, value: V } = f(ae, oe);
                if (!K) throw new Error("bad point: invalid y coordinate");
                const q = (V & gn) === gn, B = ($ & 128) !== 0;
                if (!G && V === Do && B) throw new Error("bad point: x=0 and x_0=1");
                return B !== q && (V = h(-V)), S.fromAffine({
                    x: V,
                    y: Y
                });
            }
            static fromHex(k, G = !1) {
                return S.fromBytes(kd(k), G);
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            precompute(k = 8, G = !0) {
                return _.createCache(this, k), G || this.multiply(y3), this;
            }
            assertValidity() {
                A(this);
            }
            equals(k) {
                m(k);
                const { X: G, Y: P, Z: J } = this, { X: H, Y: F, Z: $ } = k, Y = h(G * $), O = h(H * J), se = h(P * $), ae = h(F * J);
                return Y === O && se === ae;
            }
            is0() {
                return this.equals(S.ZERO);
            }
            negate() {
                return new S(h(-this.X), this.Y, this.Z, h(-this.T));
            }
            double() {
                const { a: k } = i, { X: G, Y: P, Z: J } = this, H = h(G * G), F = h(P * P), $ = h(y3 * h(J * J)), Y = h(k * H), O = G + P, se = h(h(O * O) - H - F), ae = Y + F, oe = ae - $, K = Y - F, V = h(se * oe), q = h(ae * K), B = h(se * K), z = h(oe * ae);
                return new S(V, q, z, B);
            }
            add(k) {
                m(k);
                const { a: G, d: P } = i, { X: J, Y: H, Z: F, T: $ } = this, { X: Y, Y: O, Z: se, T: ae } = k, oe = h(J * Y), K = h(H * O), V = h($ * P * ae), q = h(F * se), B = h((J + H) * (Y + O) - oe - K), z = q - V, ee = q + V, j = h(K - G * oe), ce = h(B * z), x = h(ee * j), Q = h(B * j), pe = h(z * ee);
                return new S(ce, x, pe, Q);
            }
            subtract(k) {
                return this.add(k.negate());
            }
            multiply(k) {
                if (!s.isValidNot0(k)) throw new Error("invalid scalar: expected 1 <= sc < curve.n");
                const { p: G, f: P } = _.cached(this, k, (J)=>gd(S, J));
                return gd(S, [
                    G,
                    P
                ])[0];
            }
            multiplyUnsafe(k, G = S.ZERO) {
                if (!s.isValid(k)) throw new Error("invalid scalar: expected 0 <= sc < curve.n");
                return k === Do ? S.ZERO : this.is0() || k === gn ? this : _.unsafe(this, k, (P)=>gd(S, P), G);
            }
            isSmallOrder() {
                return this.multiplyUnsafe(l).is0();
            }
            isTorsionFree() {
                return _.unsafe(this, i.n).is0();
            }
            toAffine(k) {
                return w(this, k);
            }
            clearCofactor() {
                return l === gn ? this : this.multiplyUnsafe(l);
            }
            toBytes() {
                const { x: k, y: G } = this.toAffine(), P = r.toBytes(G);
                return P[P.length - 1] |= k & gn ? 128 : 0, P;
            }
            toHex() {
                return Tf(this.toBytes());
            }
            toString() {
                return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
            }
        }
        const _ = new qI(S, s.BITS);
        return S.BASE.precompute(8), S;
    }
    function uL(n, e, t = {}) {
        if (typeof e != "function") throw new Error('"hash" function param is required');
        tu(t, {}, {
            adjustScalarBytes: "function",
            randomBytes: "function",
            domain: "function",
            prehash: "function",
            mapToCurve: "function"
        });
        const { prehash: r } = t, { BASE: s, Fp: i, Fn: l } = n, u = t.randomBytes || _f, h = t.adjustScalarBytes || ((Y)=>Y), f = t.domain || ((Y, O, se)=>{
            if (Va(se, "phflag"), O.length || se) throw new Error("Contexts/pre-hash are not supported");
            return Y;
        });
        function p(Y) {
            return l.create(Ha(Y));
        }
        function m(Y) {
            const O = P.secretKey;
            Ge(Y, P.secretKey, "secretKey");
            const se = Ge(e(Y), 2 * O, "hashedSecretKey"), ae = h(se.slice(0, O)), oe = se.slice(O, 2 * O), K = p(ae);
            return {
                head: ae,
                prefix: oe,
                scalar: K
            };
        }
        function w(Y) {
            const { head: O, prefix: se, scalar: ae } = m(Y), oe = s.multiply(ae), K = oe.toBytes();
            return {
                head: O,
                prefix: se,
                scalar: ae,
                point: oe,
                pointBytes: K
            };
        }
        function A(Y) {
            return w(Y).pointBytes;
        }
        function S(Y = Uint8Array.of(), ...O) {
            const se = ri(...O);
            return p(e(f(se, Ge(Y, void 0, "context"), !!r)));
        }
        function _(Y, O, se = {}) {
            Y = Ge(Y, void 0, "message"), r && (Y = r(Y));
            const { prefix: ae, scalar: oe, pointBytes: K } = w(O), V = S(se.context, ae, Y), q = s.multiply(V).toBytes(), B = S(se.context, q, K, Y), z = l.create(V + B * oe);
            if (!l.isValid(z)) throw new Error("sign failed: invalid s");
            const ee = ri(q, l.toBytes(z));
            return Ge(ee, P.signature, "result");
        }
        const I = {
            zip215: !0
        };
        function k(Y, O, se, ae = I) {
            const { context: oe, zip215: K } = ae, V = P.signature;
            Y = Ge(Y, V, "signature"), O = Ge(O, void 0, "message"), se = Ge(se, P.publicKey, "publicKey"), K !== void 0 && Va(K, "zip215"), r && (O = r(O));
            const q = V / 2, B = Y.subarray(0, q), z = Ha(Y.subarray(q, V));
            let ee, j, ce;
            try {
                ee = n.fromBytes(se, K), j = n.fromBytes(B, K), ce = s.multiplyUnsafe(z);
            } catch  {
                return !1;
            }
            if (!K && ee.isSmallOrder()) return !1;
            const x = S(oe, j.toBytes(), ee.toBytes(), O);
            return j.add(ee.multiplyUnsafe(x)).subtract(ce).clearCofactor().is0();
        }
        const G = i.BYTES, P = {
            secretKey: G,
            publicKey: G,
            signature: 2 * G,
            seed: G
        };
        function J(Y = u(P.seed)) {
            return Ge(Y, P.seed, "seed");
        }
        function H(Y) {
            return hg(Y) && Y.length === l.BYTES;
        }
        function F(Y, O) {
            try {
                return !!n.fromBytes(Y, O);
            } catch  {
                return !1;
            }
        }
        const $ = {
            getExtendedPublicKey: w,
            randomSecretKey: J,
            isValidSecretKey: H,
            isValidPublicKey: F,
            toMontgomery (Y) {
                const { y: O } = n.fromBytes(Y), se = P.publicKey, ae = se === 32;
                if (!ae && se !== 57) throw new Error("only defined for 25519 and 448");
                const oe = ae ? i.div(gn + O, gn - O) : i.div(O - gn, O + gn);
                return i.toBytes(oe);
            },
            toMontgomerySecret (Y) {
                const O = P.secretKey;
                Ge(Y, O);
                const se = e(Y.subarray(0, O));
                return h(se).subarray(0, O);
            }
        };
        return Object.freeze({
            keygen: l6(J, A),
            getPublicKey: A,
            sign: _,
            verify: k,
            utils: $,
            Point: n,
            lengths: P
        });
    }
    const Sh = BigInt(0), Vl = BigInt(1), i0 = BigInt(2);
    function hL(n) {
        return tu(n, {
            adjustScalarBytes: "function",
            powPminus2: "function"
        }), Object.freeze({
            ...n
        });
    }
    function dL(n) {
        const e = hL(n), { P: t, type: r, adjustScalarBytes: s, powPminus2: i, randomBytes: l } = e, u = r === "x25519";
        if (!u && r !== "x448") throw new Error("invalid type");
        const h = l || _f, f = u ? 255 : 448, p = u ? 32 : 56, m = BigInt(u ? 9 : 5), w = BigInt(u ? 121665 : 39081), A = u ? i0 ** BigInt(254) : i0 ** BigInt(447), S = u ? BigInt(8) * i0 ** BigInt(251) - Vl : BigInt(4) * i0 ** BigInt(445) - Vl, _ = A + S + Vl, I = (V)=>Wt(V, t), k = G(m);
        function G(V) {
            return i6(I(V), p);
        }
        function P(V) {
            const q = Rd(Ge(V, p, "uCoordinate"));
            return u && (q[31] &= 127), I(Ha(q));
        }
        function J(V) {
            return Ha(s(Rd(Ge(V, p, "scalar"))));
        }
        function H(V, q) {
            const B = se(P(q), J(V));
            if (B === Sh) throw new Error("invalid private or public key received");
            return G(B);
        }
        function F(V) {
            return H(V, k);
        }
        const $ = F, Y = H;
        function O(V, q, B) {
            const z = I(V * (q - B));
            return q = I(q - z), B = I(B + z), {
                x_2: q,
                x_3: B
            };
        }
        function se(V, q) {
            Od("u", V, Sh, t), Od("scalar", q, A, _);
            const B = q, z = V;
            let ee = Vl, j = Sh, ce = V, x = Vl, Q = Sh;
            for(let de = BigInt(f - 1); de >= Sh; de--){
                const me = B >> de & Vl;
                Q ^= me, { x_2: ee, x_3: ce } = O(Q, ee, ce), { x_2: j, x_3: x } = O(Q, j, x), Q = me;
                const Ae = ee + j, Te = I(Ae * Ae), Ve = ee - j, De = I(Ve * Ve), mt = Te - De, hn = ce + x, Qr = ce - x, Ts = I(Qr * Ae), qr = I(hn * Ve), mi = Ts + qr, Sr = Ts - qr;
                ce = I(mi * mi), x = I(z * I(Sr * Sr)), ee = I(Te * De), j = I(mt * (Te + I(w * mt)));
            }
            ({ x_2: ee, x_3: ce } = O(Q, ee, ce)), { x_2: j, x_3: x } = O(Q, j, x);
            const pe = i(j);
            return I(ee * pe);
        }
        const ae = {
            secretKey: p,
            publicKey: p,
            seed: p
        }, oe = (V = h(p))=>(Ge(V, ae.seed, "seed"), V), K = {
            randomSecretKey: oe
        };
        return Object.freeze({
            keygen: l6(oe, $),
            getSharedSecret: Y,
            getPublicKey: $,
            scalarMult: H,
            scalarMultBase: F,
            utils: K,
            GuBytes: k.slice(),
            lengths: ae
        });
    }
    const fL = BigInt(1), U9 = BigInt(2), pL = BigInt(3), gL = BigInt(5), mL = BigInt(8), gg = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), yL = {
        p: gg,
        n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
        h: mL,
        a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
        d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
        Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
        Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    };
    function GI(n) {
        const e = BigInt(10), t = BigInt(20), r = BigInt(40), s = BigInt(80), i = gg, u = n * n % i * n % i, h = qt(u, U9, i) * u % i, f = qt(h, fL, i) * n % i, p = qt(f, gL, i) * f % i, m = qt(p, e, i) * p % i, w = qt(m, t, i) * m % i, A = qt(w, r, i) * w % i, S = qt(A, s, i) * A % i, _ = qt(S, s, i) * A % i, I = qt(_, e, i) * p % i;
        return {
            pow_p_5_8: qt(I, U9, i) * n % i,
            b2: u
        };
    }
    function YI(n) {
        return n[0] &= 248, n[31] &= 127, n[31] |= 64, n;
    }
    const z9 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function wL(n, e) {
        const t = gg, r = Wt(e * e * e, t), s = Wt(r * r * e, t), i = GI(n * s).pow_p_5_8;
        let l = Wt(n * r * i, t);
        const u = Wt(e * l * l, t), h = l, f = Wt(l * z9, t), p = u === n, m = u === Wt(-n, t), w = u === Wt(-n * z9, t);
        return p && (l = h), (m || w) && (l = f), ZN(l, t) && (l = Wt(-l, t)), {
            isValid: p || m,
            value: l
        };
    }
    const bL = cL(yL, {
        uvRatio: wL
    });
    function vL(n) {
        return uL(bL, dg, Object.assign({
            adjustScalarBytes: YI
        }, n));
    }
    const $d = vL({}), o0 = (()=>{
        const n = gg;
        return dL({
            P: n,
            type: "x25519",
            powPminus2: (e)=>{
                const { pow_p_5_8: t, b2: r } = GI(e);
                return Wt(qt(t, pL, n) * r, n);
            },
            adjustScalarBytes: YI
        });
    })(), Md = 32, ti = 64, wp = 32;
    let Ac;
    const WI = (async ()=>{
        try {
            return await nr.get().subtle.generateKey({
                name: "Ed25519"
            }, !0, [
                "sign",
                "verify"
            ]), !0;
        } catch  {
            return !1;
        }
    })();
    function EL() {
        const n = $d.utils.randomSecretKey(), e = $d.getPublicKey(n);
        return {
            privateKey: jI(n, e),
            publicKey: e
        };
    }
    function AL(n) {
        if (n.length !== wp) throw new TypeError('"seed" must be 32 bytes in length.');
        if (!(n instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
        const e = n, t = $d.getPublicKey(e);
        return {
            privateKey: jI(e, t),
            publicKey: t
        };
    }
    async function SL(n, e) {
        let t;
        n.length === ti ? t = n.subarray(0, 32) : t = n;
        const r = {
            crv: "Ed25519",
            kty: "OKP",
            x: L(n.subarray(32), "base64url"),
            d: L(t, "base64url"),
            ext: !0,
            key_ops: [
                "sign"
            ]
        }, s = await nr.get().subtle.importKey("jwk", r, {
            name: "Ed25519"
        }, !0, [
            "sign"
        ]), i = await nr.get().subtle.sign({
            name: "Ed25519"
        }, s, e instanceof Uint8Array ? e : e.subarray());
        return new Uint8Array(i, 0, i.byteLength);
    }
    function IL(n, e) {
        const t = n.subarray(0, wp);
        return $d.sign(e instanceof Uint8Array ? e : e.subarray(), t);
    }
    async function CL(n, e) {
        return Ac == null && (Ac = await WI), Ac ? SL(n, e) : IL(n, e);
    }
    async function TL(n, e, t) {
        if (n.buffer instanceof ArrayBuffer) {
            const r = await nr.get().subtle.importKey("raw", n.buffer, {
                name: "Ed25519"
            }, !1, [
                "verify"
            ]);
            return await nr.get().subtle.verify({
                name: "Ed25519"
            }, r, e, t instanceof Uint8Array ? t : t.subarray());
        }
        throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
    }
    function _L(n, e, t) {
        return $d.verify(e, t instanceof Uint8Array ? t : t.subarray(), n);
    }
    async function xL(n, e, t) {
        return Ac == null && (Ac = await WI), Ac ? TL(n, e, t) : _L(n, e, t);
    }
    function jI(n, e) {
        const t = new Uint8Array(ti);
        for(let r = 0; r < wp; r++)t[r] = n[r], t[wp + r] = e[r];
        return t;
    }
    function mg(n) {
        return n == null ? !1 : typeof n.then == "function" && typeof n.catch == "function" && typeof n.finally == "function";
    }
    class XI {
        type = "Ed25519";
        raw;
        constructor(e){
            this.raw = Nd(e, Md);
        }
        toMultihash() {
            return nt.digest(Fr(this));
        }
        toCID() {
            return ge.createV1(114, this.toMultihash());
        }
        toString() {
            return He.encode(this.toMultihash().bytes).substring(1);
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        verify(e, t, r) {
            r?.signal?.throwIfAborted();
            const s = xL(this.raw, t, e);
            return mg(s) ? s.then((i)=>(r?.signal?.throwIfAborted(), i)) : s;
        }
    }
    class bp {
        type = "Ed25519";
        raw;
        publicKey;
        constructor(e, t){
            this.raw = Nd(e, ti), this.publicKey = new XI(t);
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        sign(e, t) {
            t?.signal?.throwIfAborted();
            const r = CL(this.raw, e);
            return mg(r) ? r.then((s)=>(t?.signal?.throwIfAborted(), s)) : (t?.signal?.throwIfAborted(), r);
        }
    }
    function JI(n) {
        if (n.length > ti) {
            n = Nd(n, ti + Md);
            const r = n.subarray(0, ti), s = n.subarray(ti, n.length);
            return new bp(r, s);
        }
        n = Nd(n, ti);
        const e = n.subarray(0, ti), t = n.subarray(Md);
        return new bp(e, t);
    }
    function c6(n) {
        return n = Nd(n, Md), new XI(n);
    }
    async function DL() {
        const { privateKey: n, publicKey: e } = EL();
        return new bp(n, e);
    }
    async function BL(n) {
        const { privateKey: e, publicKey: t } = AL(n);
        return new bp(e, t);
    }
    function Nd(n, e) {
        if (n = Uint8Array.from(n ?? []), n.length !== e) throw new jn(`Key must be a Uint8Array of length ${e}, got ${n.length}`);
        return n;
    }
    const PL = Math.pow(2, 7), kL = Math.pow(2, 14), RL = Math.pow(2, 21), u6 = Math.pow(2, 28), h6 = Math.pow(2, 35), d6 = Math.pow(2, 42), f6 = Math.pow(2, 49), ut = 128, qn = 127;
    function be(n) {
        if (n < PL) return 1;
        if (n < kL) return 2;
        if (n < RL) return 3;
        if (n < u6) return 4;
        if (n < h6) return 5;
        if (n < d6) return 6;
        if (n < f6) return 7;
        if (Number.MAX_SAFE_INTEGER != null && n > Number.MAX_SAFE_INTEGER) throw new RangeError("Could not encode varint");
        return 8;
    }
    function dt(n, e, t = 0) {
        switch(be(n)){
            case 8:
                e[t++] = n & 255 | ut, n /= 128;
            case 7:
                e[t++] = n & 255 | ut, n /= 128;
            case 6:
                e[t++] = n & 255 | ut, n /= 128;
            case 5:
                e[t++] = n & 255 | ut, n /= 128;
            case 4:
                e[t++] = n & 255 | ut, n >>>= 7;
            case 3:
                e[t++] = n & 255 | ut, n >>>= 7;
            case 2:
                e[t++] = n & 255 | ut, n >>>= 7;
            case 1:
                {
                    e[t++] = n & 255, n >>>= 7;
                    break;
                }
            default:
                throw new Error("unreachable");
        }
        return e;
    }
    function OL(n, e, t = 0) {
        switch(be(n)){
            case 8:
                e.set(t++, n & 255 | ut), n /= 128;
            case 7:
                e.set(t++, n & 255 | ut), n /= 128;
            case 6:
                e.set(t++, n & 255 | ut), n /= 128;
            case 5:
                e.set(t++, n & 255 | ut), n /= 128;
            case 4:
                e.set(t++, n & 255 | ut), n >>>= 7;
            case 3:
                e.set(t++, n & 255 | ut), n >>>= 7;
            case 2:
                e.set(t++, n & 255 | ut), n >>>= 7;
            case 1:
                {
                    e.set(t++, n & 255), n >>>= 7;
                    break;
                }
            default:
                throw new Error("unreachable");
        }
        return e;
    }
    function ZI(n, e) {
        let t = n[e], r = 0;
        if (r += t & qn, t < ut || (t = n[e + 1], r += (t & qn) << 7, t < ut) || (t = n[e + 2], r += (t & qn) << 14, t < ut) || (t = n[e + 3], r += (t & qn) << 21, t < ut) || (t = n[e + 4], r += (t & qn) * u6, t < ut) || (t = n[e + 5], r += (t & qn) * h6, t < ut) || (t = n[e + 6], r += (t & qn) * d6, t < ut) || (t = n[e + 7], r += (t & qn) * f6, t < ut)) return r;
        throw new RangeError("Could not decode varint");
    }
    function $L(n, e) {
        let t = n.get(e), r = 0;
        if (r += t & qn, t < ut || (t = n.get(e + 1), r += (t & qn) << 7, t < ut) || (t = n.get(e + 2), r += (t & qn) << 14, t < ut) || (t = n.get(e + 3), r += (t & qn) << 21, t < ut) || (t = n.get(e + 4), r += (t & qn) * u6, t < ut) || (t = n.get(e + 5), r += (t & qn) * h6, t < ut) || (t = n.get(e + 6), r += (t & qn) * d6, t < ut) || (t = n.get(e + 7), r += (t & qn) * f6, t < ut)) return r;
        throw new RangeError("Could not decode varint");
    }
    function zr(n, e, t = 0) {
        return e == null && (e = Wn(be(n))), e instanceof Uint8Array ? dt(n, e, t) : OL(n, e, t);
    }
    function et(n, e = 0) {
        return n instanceof Uint8Array ? ZI(n, e) : $L(n, e);
    }
    const p6 = new Float32Array([
        -0
    ]), Oo = new Uint8Array(p6.buffer);
    function ML(n, e, t) {
        p6[0] = n, e[t] = Oo[0], e[t + 1] = Oo[1], e[t + 2] = Oo[2], e[t + 3] = Oo[3];
    }
    function NL(n, e) {
        return Oo[0] = n[e], Oo[1] = n[e + 1], Oo[2] = n[e + 2], Oo[3] = n[e + 3], p6[0];
    }
    const g6 = new Float64Array([
        -0
    ]), Kn = new Uint8Array(g6.buffer);
    function LL(n, e, t) {
        g6[0] = n, e[t] = Kn[0], e[t + 1] = Kn[1], e[t + 2] = Kn[2], e[t + 3] = Kn[3], e[t + 4] = Kn[4], e[t + 5] = Kn[5], e[t + 6] = Kn[6], e[t + 7] = Kn[7];
    }
    function UL(n, e) {
        return Kn[0] = n[e], Kn[1] = n[e + 1], Kn[2] = n[e + 2], Kn[3] = n[e + 3], Kn[4] = n[e + 4], Kn[5] = n[e + 5], Kn[6] = n[e + 6], Kn[7] = n[e + 7], g6[0];
    }
    const zL = BigInt(Number.MAX_SAFE_INTEGER), FL = BigInt(Number.MIN_SAFE_INTEGER);
    class Gn {
        lo;
        hi;
        constructor(e, t){
            this.lo = e | 0, this.hi = t | 0;
        }
        toNumber(e = !1) {
            if (!e && this.hi >>> 31 > 0) {
                const t = ~this.lo + 1 >>> 0;
                let r = ~this.hi >>> 0;
                return t === 0 && (r = r + 1 >>> 0), -(t + r * 4294967296);
            }
            return this.lo + this.hi * 4294967296;
        }
        toBigInt(e = !1) {
            if (e) return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
            if (this.hi >>> 31) {
                const t = ~this.lo + 1 >>> 0;
                let r = ~this.hi >>> 0;
                return t === 0 && (r = r + 1 >>> 0), -(BigInt(t) + (BigInt(r) << 32n));
            }
            return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
        }
        toString(e = !1) {
            return this.toBigInt(e).toString();
        }
        zzEncode() {
            const e = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;
        }
        zzDecode() {
            const e = -(this.lo & 1);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;
        }
        length() {
            const e = this.lo, t = (this.lo >>> 28 | this.hi << 4) >>> 0, r = this.hi >>> 24;
            return r === 0 ? t === 0 ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;
        }
        static fromBigInt(e) {
            if (e === 0n) return La;
            if (e < zL && e > FL) return this.fromNumber(Number(e));
            const t = e < 0n;
            t && (e = -e);
            let r = e >> 32n, s = e - (r << 32n);
            return t && (r = ~r | 0n, s = ~s | 0n, ++s > F9 && (s = 0n, ++r > F9 && (r = 0n))), new Gn(Number(s), Number(r));
        }
        static fromNumber(e) {
            if (e === 0) return La;
            const t = e < 0;
            t && (e = -e);
            let r = e >>> 0, s = (e - r) / 4294967296 >>> 0;
            return t && (s = ~s >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++s > 4294967295 && (s = 0))), new Gn(r, s);
        }
        static from(e) {
            return typeof e == "number" ? Gn.fromNumber(e) : typeof e == "bigint" ? Gn.fromBigInt(e) : typeof e == "string" ? Gn.fromBigInt(BigInt(e)) : e.low != null || e.high != null ? new Gn(e.low >>> 0, e.high >>> 0) : La;
        }
    }
    const La = new Gn(0, 0);
    La.toBigInt = function() {
        return 0n;
    };
    La.zzEncode = La.zzDecode = function() {
        return this;
    };
    La.length = function() {
        return 1;
    };
    const F9 = 4294967296n;
    function VL(n) {
        let e = 0, t = 0;
        for(let r = 0; r < n.length; ++r)t = n.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : (t & 64512) === 55296 && (n.charCodeAt(r + 1) & 64512) === 56320 ? (++r, e += 4) : e += 3;
        return e;
    }
    function HL(n, e, t) {
        if (t - e < 1) return "";
        let s;
        const i = [];
        let l = 0, u;
        for(; e < t;)u = n[e++], u < 128 ? i[l++] = u : u > 191 && u < 224 ? i[l++] = (u & 31) << 6 | n[e++] & 63 : u > 239 && u < 365 ? (u = ((u & 7) << 18 | (n[e++] & 63) << 12 | (n[e++] & 63) << 6 | n[e++] & 63) - 65536, i[l++] = 55296 + (u >> 10), i[l++] = 56320 + (u & 1023)) : i[l++] = (u & 15) << 12 | (n[e++] & 63) << 6 | n[e++] & 63, l > 8191 && ((s ?? (s = [])).push(String.fromCharCode.apply(String, i)), l = 0);
        return s != null ? (l > 0 && s.push(String.fromCharCode.apply(String, i.slice(0, l))), s.join("")) : String.fromCharCode.apply(String, i.slice(0, l));
    }
    function eC(n, e, t) {
        const r = t;
        let s, i;
        for(let l = 0; l < n.length; ++l)s = n.charCodeAt(l), s < 128 ? e[t++] = s : s < 2048 ? (e[t++] = s >> 6 | 192, e[t++] = s & 63 | 128) : (s & 64512) === 55296 && ((i = n.charCodeAt(l + 1)) & 64512) === 56320 ? (s = 65536 + ((s & 1023) << 10) + (i & 1023), ++l, e[t++] = s >> 18 | 240, e[t++] = s >> 12 & 63 | 128, e[t++] = s >> 6 & 63 | 128, e[t++] = s & 63 | 128) : (e[t++] = s >> 12 | 224, e[t++] = s >> 6 & 63 | 128, e[t++] = s & 63 | 128);
        return t - r;
    }
    function Bs(n, e) {
        return RangeError(`index out of range: ${n.pos} + ${e ?? 1} > ${n.len}`);
    }
    function a0(n, e) {
        return (n[e - 4] | n[e - 3] << 8 | n[e - 2] << 16 | n[e - 1] << 24) >>> 0;
    }
    class QL {
        buf;
        pos;
        len;
        _slice = Uint8Array.prototype.subarray;
        constructor(e){
            this.buf = e, this.pos = 0, this.len = e.length;
        }
        uint32() {
            let e = 4294967295;
            if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return e;
            if ((this.pos += 5) > this.len) throw this.pos = this.len, Bs(this, 10);
            return e;
        }
        int32() {
            return this.uint32() | 0;
        }
        sint32() {
            const e = this.uint32();
            return e >>> 1 ^ -(e & 1) | 0;
        }
        bool() {
            return this.uint32() !== 0;
        }
        fixed32() {
            if (this.pos + 4 > this.len) throw Bs(this, 4);
            return a0(this.buf, this.pos += 4);
        }
        sfixed32() {
            if (this.pos + 4 > this.len) throw Bs(this, 4);
            return a0(this.buf, this.pos += 4) | 0;
        }
        float() {
            if (this.pos + 4 > this.len) throw Bs(this, 4);
            const e = NL(this.buf, this.pos);
            return this.pos += 4, e;
        }
        double() {
            if (this.pos + 8 > this.len) throw Bs(this, 4);
            const e = UL(this.buf, this.pos);
            return this.pos += 8, e;
        }
        bytes() {
            const e = this.uint32(), t = this.pos, r = this.pos + e;
            if (r > this.len) throw Bs(this, e);
            return this.pos += e, t === r ? new Uint8Array(0) : this.buf.subarray(t, r);
        }
        string() {
            const e = this.bytes();
            return HL(e, 0, e.length);
        }
        skip(e) {
            if (typeof e == "number") {
                if (this.pos + e > this.len) throw Bs(this, e);
                this.pos += e;
            } else do if (this.pos >= this.len) throw Bs(this);
            while ((this.buf[this.pos++] & 128) !== 0);
            return this;
        }
        skipType(e) {
            switch(e){
                case 0:
                    this.skip();
                    break;
                case 1:
                    this.skip(8);
                    break;
                case 2:
                    this.skip(this.uint32());
                    break;
                case 3:
                    for(; (e = this.uint32() & 7) !== 4;)this.skipType(e);
                    break;
                case 5:
                    this.skip(4);
                    break;
                default:
                    throw Error(`invalid wire type ${e} at offset ${this.pos}`);
            }
            return this;
        }
        readLongVarint() {
            const e = new Gn(0, 0);
            let t = 0;
            if (this.len - this.pos > 4) {
                for(; t < 4; ++t)if (e.lo = (e.lo | (this.buf[this.pos] & 127) << t * 7) >>> 0, this.buf[this.pos++] < 128) return e;
                if (e.lo = (e.lo | (this.buf[this.pos] & 127) << 28) >>> 0, e.hi = (e.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;
                t = 0;
            } else {
                for(; t < 3; ++t){
                    if (this.pos >= this.len) throw Bs(this);
                    if (e.lo = (e.lo | (this.buf[this.pos] & 127) << t * 7) >>> 0, this.buf[this.pos++] < 128) return e;
                }
                return e.lo = (e.lo | (this.buf[this.pos++] & 127) << t * 7) >>> 0, e;
            }
            if (this.len - this.pos > 4) {
                for(; t < 5; ++t)if (e.hi = (e.hi | (this.buf[this.pos] & 127) << t * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return e;
            } else for(; t < 5; ++t){
                if (this.pos >= this.len) throw Bs(this);
                if (e.hi = (e.hi | (this.buf[this.pos] & 127) << t * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return e;
            }
            throw Error("invalid varint encoding");
        }
        readFixed64() {
            if (this.pos + 8 > this.len) throw Bs(this, 8);
            const e = a0(this.buf, this.pos += 4), t = a0(this.buf, this.pos += 4);
            return new Gn(e, t);
        }
        int64() {
            return this.readLongVarint().toBigInt();
        }
        int64Number() {
            return this.readLongVarint().toNumber();
        }
        int64String() {
            return this.readLongVarint().toString();
        }
        uint64() {
            return this.readLongVarint().toBigInt(!0);
        }
        uint64Number() {
            const e = ZI(this.buf, this.pos);
            return this.pos += be(e), e;
        }
        uint64String() {
            return this.readLongVarint().toString(!0);
        }
        sint64() {
            return this.readLongVarint().zzDecode().toBigInt();
        }
        sint64Number() {
            return this.readLongVarint().zzDecode().toNumber();
        }
        sint64String() {
            return this.readLongVarint().zzDecode().toString();
        }
        fixed64() {
            return this.readFixed64().toBigInt();
        }
        fixed64Number() {
            return this.readFixed64().toNumber();
        }
        fixed64String() {
            return this.readFixed64().toString();
        }
        sfixed64() {
            return this.readFixed64().toBigInt();
        }
        sfixed64Number() {
            return this.readFixed64().toNumber();
        }
        sfixed64String() {
            return this.readFixed64().toString();
        }
    }
    function qL(n) {
        return new QL(n instanceof Uint8Array ? n : n.subarray());
    }
    function Me(n, e, t) {
        const r = qL(n);
        return e.decode(r, void 0, t);
    }
    function KL(n) {
        let r, s = 8192;
        return function(l) {
            if (l < 1 || l > 4096) return Wn(l);
            s + l > 8192 && (r = Wn(8192), s = 0);
            const u = r.subarray(s, s += l);
            return (s & 7) !== 0 && (s = (s | 7) + 1), u;
        };
    }
    class $h {
        fn;
        len;
        next;
        val;
        constructor(e, t, r){
            this.fn = e, this.len = t, this.next = void 0, this.val = r;
        }
    }
    function w3() {}
    class GL {
        head;
        tail;
        len;
        next;
        constructor(e){
            this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;
        }
    }
    const YL = KL();
    function WL(n) {
        return globalThis.Buffer != null ? Wn(n) : YL(n);
    }
    class My {
        len;
        head;
        tail;
        states;
        constructor(){
            this.len = 0, this.head = new $h(w3, 0, 0), this.tail = this.head, this.states = null;
        }
        _push(e, t, r) {
            return this.tail = this.tail.next = new $h(e, t, r), this.len += t, this;
        }
        uint32(e) {
            return this.len += (this.tail = this.tail.next = new XL((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;
        }
        int32(e) {
            return e < 0 ? this._push(l0, 10, Gn.fromNumber(e)) : this.uint32(e);
        }
        sint32(e) {
            return this.uint32((e << 1 ^ e >> 31) >>> 0);
        }
        uint64(e) {
            const t = Gn.fromBigInt(e);
            return this._push(l0, t.length(), t);
        }
        uint64Number(e) {
            return this._push(dt, be(e), e);
        }
        uint64String(e) {
            return this.uint64(BigInt(e));
        }
        int64(e) {
            return this.uint64(e);
        }
        int64Number(e) {
            return this.uint64Number(e);
        }
        int64String(e) {
            return this.uint64String(e);
        }
        sint64(e) {
            const t = Gn.fromBigInt(e).zzEncode();
            return this._push(l0, t.length(), t);
        }
        sint64Number(e) {
            const t = Gn.fromNumber(e).zzEncode();
            return this._push(l0, t.length(), t);
        }
        sint64String(e) {
            return this.sint64(BigInt(e));
        }
        bool(e) {
            return this._push(b3, 1, e ? 1 : 0);
        }
        fixed32(e) {
            return this._push(Ih, 4, e >>> 0);
        }
        sfixed32(e) {
            return this.fixed32(e);
        }
        fixed64(e) {
            const t = Gn.fromBigInt(e);
            return this._push(Ih, 4, t.lo)._push(Ih, 4, t.hi);
        }
        fixed64Number(e) {
            const t = Gn.fromNumber(e);
            return this._push(Ih, 4, t.lo)._push(Ih, 4, t.hi);
        }
        fixed64String(e) {
            return this.fixed64(BigInt(e));
        }
        sfixed64(e) {
            return this.fixed64(e);
        }
        sfixed64Number(e) {
            return this.fixed64Number(e);
        }
        sfixed64String(e) {
            return this.fixed64String(e);
        }
        float(e) {
            return this._push(ML, 4, e);
        }
        double(e) {
            return this._push(LL, 8, e);
        }
        bytes(e) {
            const t = e.length >>> 0;
            return t === 0 ? this._push(b3, 1, 0) : this.uint32(t)._push(JL, t, e);
        }
        string(e) {
            const t = VL(e);
            return t !== 0 ? this.uint32(t)._push(eC, t, e) : this._push(b3, 1, 0);
        }
        fork() {
            return this.states = new GL(this), this.head = this.tail = new $h(w3, 0, 0), this.len = 0, this;
        }
        reset() {
            return this.states != null ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new $h(w3, 0, 0), this.len = 0), this;
        }
        ldelim() {
            const e = this.head, t = this.tail, r = this.len;
            return this.reset().uint32(r), r !== 0 && (this.tail.next = e.next, this.tail = t, this.len += r), this;
        }
        finish() {
            let e = this.head.next;
            const t = WL(this.len);
            let r = 0;
            for(; e != null;)e.fn(e.val, t, r), r += e.len, e = e.next;
            return t;
        }
    }
    function b3(n, e, t) {
        e[t] = n & 255;
    }
    function jL(n, e, t) {
        for(; n > 127;)e[t++] = n & 127 | 128, n >>>= 7;
        e[t] = n;
    }
    class XL extends $h {
        next;
        constructor(e, t){
            super(jL, e, t), this.next = void 0;
        }
    }
    function l0(n, e, t) {
        for(; n.hi !== 0;)e[t++] = n.lo & 127 | 128, n.lo = (n.lo >>> 7 | n.hi << 25) >>> 0, n.hi >>>= 7;
        for(; n.lo > 127;)e[t++] = n.lo & 127 | 128, n.lo = n.lo >>> 7;
        e[t++] = n.lo;
    }
    function Ih(n, e, t) {
        e[t] = n & 255, e[t + 1] = n >>> 8 & 255, e[t + 2] = n >>> 16 & 255, e[t + 3] = n >>> 24;
    }
    function JL(n, e, t) {
        e.set(n, t);
    }
    globalThis.Buffer != null && (My.prototype.bytes = function(n) {
        const e = n.length >>> 0;
        return this.uint32(e), e > 0 && this._push(ZL, e, n), this;
    }, My.prototype.string = function(n) {
        const e = globalThis.Buffer.byteLength(n);
        return this.uint32(e), e > 0 && this._push(eU, e, n), this;
    });
    function ZL(n, e, t) {
        e.set(n, t);
    }
    function eU(n, e, t) {
        n.length < 40 ? eC(n, e, t) : e.utf8Write != null ? e.utf8Write(n, t) : e.set(re(n), t);
    }
    function tU() {
        return new My;
    }
    function Ne(n, e) {
        const t = tU();
        return e.encode(n, t, {
            lengthDelimited: !1
        }), t.finish();
    }
    var vp;
    (function(n) {
        n[n.VARINT = 0] = "VARINT", n[n.BIT64 = 1] = "BIT64", n[n.LENGTH_DELIMITED = 2] = "LENGTH_DELIMITED", n[n.START_GROUP = 3] = "START_GROUP", n[n.END_GROUP = 4] = "END_GROUP", n[n.BIT32 = 5] = "BIT32";
    })(vp || (vp = {}));
    function tC(n, e, t, r) {
        return {
            name: n,
            type: e,
            encode: t,
            decode: r
        };
    }
    function vr(n) {
        function e(s) {
            if (n[s.toString()] == null) throw new Error("Invalid enum value");
            return n[s];
        }
        const t = function(i, l) {
            const u = e(i);
            l.int32(u);
        }, r = function(i) {
            const l = i.int32();
            return e(l);
        };
        return tC("enum", vp.VARINT, t, r);
    }
    function Le(n, e) {
        return tC("message", vp.LENGTH_DELIMITED, n, e);
    }
    class vt extends Error {
        code = "ERR_MAX_LENGTH";
        name = "MaxLengthError";
    }
    class V9 extends Error {
        code = "ERR_MAX_SIZE";
        name = "MaxSizeError";
    }
    var Qt;
    (function(n) {
        n.RSA = "RSA", n.Ed25519 = "Ed25519", n.secp256k1 = "secp256k1", n.ECDSA = "ECDSA";
    })(Qt || (Qt = {}));
    var Ny;
    (function(n) {
        n[n.RSA = 0] = "RSA", n[n.Ed25519 = 1] = "Ed25519", n[n.secp256k1 = 2] = "secp256k1", n[n.ECDSA = 3] = "ECDSA";
    })(Ny || (Ny = {}));
    (function(n) {
        n.codec = ()=>vr(Ny);
    })(Qt || (Qt = {}));
    var Ko;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.Type != null && (r.uint32(8), Qt.codec().encode(t.Type, r)), t.Data != null && (r.uint32(18), r.bytes(t.Data)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {}, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.Type = Qt.codec().decode(t);
                                break;
                            }
                        case 2:
                            {
                                i.Data = t.bytes();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Ko || (Ko = {}));
    var Ep;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.Type != null && (r.uint32(8), Qt.codec().encode(t.Type, r)), t.Data != null && (r.uint32(18), r.bytes(t.Data)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {}, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.Type = Qt.codec().decode(t);
                                break;
                            }
                        case 2:
                            {
                                i.Data = t.bytes();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Ep || (Ep = {}));
    function Go(n) {
        if (isNaN(n) || n <= 0) throw new jn("random bytes length must be a Number bigger than 0");
        return _f(n);
    }
    class m6 {
        type = "RSA";
        jwk;
        _raw;
        _multihash;
        constructor(e, t){
            this.jwk = e, this._multihash = t;
        }
        get raw() {
            return this._raw == null && (this._raw = w6(this.jwk)), this._raw;
        }
        toMultihash() {
            return this._multihash;
        }
        toCID() {
            return ge.createV1(114, this._multihash);
        }
        toString() {
            return He.encode(this.toMultihash().bytes).substring(1);
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        verify(e, t, r) {
            return gU(this.jwk, t, e, r);
        }
    }
    class nC {
        type = "RSA";
        jwk;
        _raw;
        publicKey;
        constructor(e, t){
            this.jwk = e, this.publicKey = t;
        }
        get raw() {
            return this._raw == null && (this._raw = iU(this.jwk)), this._raw;
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        sign(e, t) {
            return pU(this.jwk, e, t);
        }
    }
    const rC = 8192, y6 = 18, nU = 1062, rU = Uint8Array.from([
        48,
        13,
        6,
        9,
        42,
        134,
        72,
        134,
        247,
        13,
        1,
        1,
        1,
        5,
        0
    ]);
    function sU(n) {
        return {
            n: L(n[1], "base64url"),
            e: L(n[2], "base64url"),
            d: L(n[3], "base64url"),
            p: L(n[4], "base64url"),
            q: L(n[5], "base64url"),
            dp: L(n[6], "base64url"),
            dq: L(n[7], "base64url"),
            qi: L(n[8], "base64url"),
            kty: "RSA"
        };
    }
    function iU(n) {
        if (n.n == null || n.e == null || n.d == null || n.p == null || n.q == null || n.dp == null || n.dq == null || n.qi == null) throw new jn("JWK was missing components");
        return Ki([
            $r(Uint8Array.from([
                0
            ])),
            $r(re(n.n, "base64url")),
            $r(re(n.e, "base64url")),
            $r(re(n.d, "base64url")),
            $r(re(n.p, "base64url")),
            $r(re(n.q, "base64url")),
            $r(re(n.dp, "base64url")),
            $r(re(n.dq, "base64url")),
            $r(re(n.qi, "base64url"))
        ]).subarray();
    }
    function oU(n) {
        const e = Xo(n[1], {
            offset: 0
        });
        return {
            kty: "RSA",
            n: L(e[0], "base64url"),
            e: L(e[1], "base64url")
        };
    }
    function w6(n) {
        if (n.n == null || n.e == null) throw new jn("JWK was missing components");
        return Ki([
            rU,
            e6(Ki([
                $r(re(n.n, "base64url")),
                $r(re(n.e, "base64url"))
            ]))
        ]).subarray();
    }
    function aU(n) {
        const e = Xo(n);
        return sC(e);
    }
    function sC(n) {
        const e = sU(n);
        return cU(e);
    }
    function lU(n, e) {
        if (n.byteLength >= nU) throw new fI("Key size is too large");
        const t = Xo(n, {
            offset: 0
        });
        return iC(t, n, e);
    }
    function iC(n, e, t) {
        const r = oU(n);
        if (t == null) {
            const s = Lo(Ko.encode({
                Type: Qt.RSA,
                Data: e
            }));
            t = jo(y6, s);
        }
        return new m6(r, t);
    }
    function cU(n) {
        if (yU(n) > rC) throw new jn("Key size is too large");
        const e = hU(n), t = Lo(Ko.encode({
            Type: Qt.RSA,
            Data: w6(e.publicKey)
        })), r = jo(y6, t);
        return new nC(e.privateKey, new m6(e.publicKey, r));
    }
    async function uU(n) {
        if (n > rC) throw new jn("Key size is too large");
        const e = await fU(n), t = Lo(Ko.encode({
            Type: Qt.RSA,
            Data: w6(e.publicKey)
        })), r = jo(y6, t);
        return new nC(e.privateKey, new m6(e.publicKey, r));
    }
    function hU(n) {
        if (n == null) throw new jn("Missing key parameter");
        return {
            privateKey: n,
            publicKey: {
                kty: n.kty,
                n: n.n,
                e: n.e
            }
        };
    }
    const dU = "1.2.840.113549.1.1.1";
    async function fU(n, e) {
        const t = await nr.get().subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: n,
            publicExponent: new Uint8Array([
                1,
                0,
                1
            ]),
            hash: {
                name: "SHA-256"
            }
        }, !0, [
            "sign",
            "verify"
        ]), r = await mU(t);
        return {
            privateKey: r[0],
            publicKey: r[1]
        };
    }
    async function pU(n, e, t) {
        const r = await nr.get().subtle.importKey("jwk", n, {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "sign"
        ]);
        t?.signal?.throwIfAborted();
        const s = await nr.get().subtle.sign({
            name: "RSASSA-PKCS1-v1_5"
        }, r, e instanceof Uint8Array ? e : e.subarray());
        return t?.signal?.throwIfAborted(), new Uint8Array(s, 0, s.byteLength);
    }
    async function gU(n, e, t, r) {
        const s = await nr.get().subtle.importKey("jwk", n, {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "verify"
        ]);
        r?.signal?.throwIfAborted();
        const i = await nr.get().subtle.verify({
            name: "RSASSA-PKCS1-v1_5"
        }, s, e, t instanceof Uint8Array ? t : t.subarray());
        return r?.signal?.throwIfAborted(), i;
    }
    async function mU(n, e) {
        if (n.privateKey == null || n.publicKey == null) throw new jn("Private and public key are required");
        return await Promise.all([
            nr.get().subtle.exportKey("jwk", n.privateKey),
            nr.get().subtle.exportKey("jwk", n.publicKey)
        ]);
    }
    function yU(n) {
        if (n.kty !== "RSA") throw new jn("invalid key type");
        if (n.n == null) throw new jn("invalid key modulus");
        return re(n.n, "base64url").length * 8;
    }
    class oC {
        oHash;
        iHash;
        blockLen;
        outputLen;
        finished = !1;
        destroyed = !1;
        constructor(e, t){
            if (Cf(e), Ge(t, void 0, "key"), this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
            const r = this.blockLen, s = new Uint8Array(r);
            s.set(t.length > r ? e.create().update(t).digest() : t);
            for(let i = 0; i < s.length; i++)s[i] ^= 54;
            this.iHash.update(s), this.oHash = e.create();
            for(let i = 0; i < s.length; i++)s[i] ^= 106;
            this.oHash.update(s), ui(s);
        }
        update(e) {
            return gp(this), this.iHash.update(e), this;
        }
        digestInto(e) {
            gp(this), Ge(e, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
        }
        digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
        }
        _cloneInto(e) {
            e ||= Object.create(Object.getPrototypeOf(this), {});
            const { oHash: t, iHash: r, finished: s, destroyed: i, blockLen: l, outputLen: u } = this;
            return e = e, e.finished = s, e.destroyed = i, e.blockLen = l, e.outputLen = u, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
        }
        clone() {
            return this._cloneInto();
        }
        destroy() {
            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
        }
    }
    const xf = (n, e, t)=>new oC(n, e).update(t).digest();
    xf.create = (n, e)=>new oC(n, e);
    const H9 = (n, e)=>(n + (n >= 0 ? e : -e) / aC) / e;
    function wU(n, e, t) {
        const [[r, s], [i, l]] = e, u = H9(l * n, t), h = H9(-s * n, t);
        let f = n - u * r - h * i, p = -u * s - h * l;
        const m = f < qi, w = p < qi;
        m && (f = -f), w && (p = -p);
        const A = o6(Math.ceil(KN(t) / 2)) + Sc;
        if (f < qi || f >= A || p < qi || p >= A) throw new Error("splitScalar (endomorphism): failed, k=" + n);
        return {
            k1neg: m,
            k1: f,
            k2neg: w,
            k2: p
        };
    }
    function Ly(n) {
        if (![
            "compact",
            "recovered",
            "der"
        ].includes(n)) throw new Error('Signature format must be "compact", "recovered", or "der"');
        return n;
    }
    function v3(n, e) {
        const t = {};
        for (let r of Object.keys(e))t[r] = n[r] === void 0 ? e[r] : n[r];
        return Va(t.lowS, "lowS"), Va(t.prehash, "prehash"), t.format !== void 0 && Ly(t.format), t;
    }
    class bU extends Error {
        constructor(e = ""){
            super(e);
        }
    }
    const ko = {
        Err: bU,
        _tlv: {
            encode: (n, e)=>{
                const { Err: t } = ko;
                if (n < 0 || n > 256) throw new t("tlv.encode: wrong tag");
                if (e.length & 1) throw new t("tlv.encode: unpadded data");
                const r = e.length / 2, s = s0(r);
                if (s.length / 2 & 128) throw new t("tlv.encode: long form length too big");
                const i = r > 127 ? s0(s.length / 2 | 128) : "";
                return s0(n) + i + s + e;
            },
            decode (n, e) {
                const { Err: t } = ko;
                let r = 0;
                if (n < 0 || n > 256) throw new t("tlv.encode: wrong tag");
                if (e.length < 2 || e[r++] !== n) throw new t("tlv.decode: wrong tlv");
                const s = e[r++], i = !!(s & 128);
                let l = 0;
                if (!i) l = s;
                else {
                    const h = s & 127;
                    if (!h) throw new t("tlv.decode(long): indefinite length not supported");
                    if (h > 4) throw new t("tlv.decode(long): byte length is too big");
                    const f = e.subarray(r, r + h);
                    if (f.length !== h) throw new t("tlv.decode: length bytes not complete");
                    if (f[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
                    for (const p of f)l = l << 8 | p;
                    if (r += h, l < 128) throw new t("tlv.decode(long): not minimal encoding");
                }
                const u = e.subarray(r, r + l);
                if (u.length !== l) throw new t("tlv.decode: wrong value length");
                return {
                    v: u,
                    l: e.subarray(r + l)
                };
            }
        },
        _int: {
            encode (n) {
                const { Err: e } = ko;
                if (n < qi) throw new e("integer: negative integers are not allowed");
                let t = s0(n);
                if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
                return t;
            },
            decode (n) {
                const { Err: e } = ko;
                if (n[0] & 128) throw new e("invalid signature integer: negative");
                if (n[0] === 0 && !(n[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
                return fg(n);
            }
        },
        toSig (n) {
            const { Err: e, _int: t, _tlv: r } = ko, s = Ge(n, void 0, "signature"), { v: i, l } = r.decode(48, s);
            if (l.length) throw new e("invalid signature: left bytes after parsing");
            const { v: u, l: h } = r.decode(2, i), { v: f, l: p } = r.decode(2, h);
            if (p.length) throw new e("invalid signature: left bytes after parsing");
            return {
                r: t.decode(u),
                s: t.decode(f)
            };
        },
        hexFromSig (n) {
            const { _tlv: e, _int: t } = ko, r = e.encode(2, t.encode(n.r)), s = e.encode(2, t.encode(n.s)), i = r + s;
            return e.encode(48, i);
        }
    }, qi = BigInt(0), Sc = BigInt(1), aC = BigInt(2), c0 = BigInt(3), vU = BigInt(4);
    function EU(n, e = {}) {
        const t = KI("weierstrass", n, e), { Fp: r, Fn: s } = t;
        let i = t.CURVE;
        const { h: l, n: u } = i;
        tu(e, {}, {
            allowInfinityPoint: "boolean",
            clearCofactor: "function",
            isTorsionFree: "function",
            fromBytes: "function",
            toBytes: "function",
            endo: "object"
        });
        const { endo: h } = e;
        if (h && (!r.is0(i.a) || typeof h.beta != "bigint" || !Array.isArray(h.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        const f = cC(r, s);
        function p() {
            if (!r.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
        }
        function m(oe, K, V) {
            const { x: q, y: B } = K.toAffine(), z = r.toBytes(q);
            if (Va(V, "isCompressed"), V) {
                p();
                const ee = !r.isOdd(B);
                return ri(lC(ee), z);
            } else return ri(Uint8Array.of(4), z, r.toBytes(B));
        }
        function w(oe) {
            Ge(oe, void 0, "Point");
            const { publicKey: K, publicKeyUncompressed: V } = f, q = oe.length, B = oe[0], z = oe.subarray(1);
            if (q === K && (B === 2 || B === 3)) {
                const ee = r.fromBytes(z);
                if (!r.isValid(ee)) throw new Error("bad point: is not on curve, wrong x");
                const j = _(ee);
                let ce;
                try {
                    ce = r.sqrt(j);
                } catch (pe) {
                    const de = pe instanceof Error ? ": " + pe.message : "";
                    throw new Error("bad point: is not on curve, sqrt error" + de);
                }
                p();
                const x = r.isOdd(ce);
                return (B & 1) === 1 !== x && (ce = r.neg(ce)), {
                    x: ee,
                    y: ce
                };
            } else if (q === V && B === 4) {
                const ee = r.BYTES, j = r.fromBytes(z.subarray(0, ee)), ce = r.fromBytes(z.subarray(ee, ee * 2));
                if (!I(j, ce)) throw new Error("bad point: is not on curve");
                return {
                    x: j,
                    y: ce
                };
            } else throw new Error(`bad point: got length ${q}, expected compressed=${K} or uncompressed=${V}`);
        }
        const A = e.toBytes || m, S = e.fromBytes || w;
        function _(oe) {
            const K = r.sqr(oe), V = r.mul(K, oe);
            return r.add(r.add(V, r.mul(oe, i.a)), i.b);
        }
        function I(oe, K) {
            const V = r.sqr(K), q = _(oe);
            return r.eql(V, q);
        }
        if (!I(i.Gx, i.Gy)) throw new Error("bad curve params: generator point");
        const k = r.mul(r.pow(i.a, c0), vU), G = r.mul(r.sqr(i.b), BigInt(27));
        if (r.is0(r.add(k, G))) throw new Error("bad curve params: a or b");
        function P(oe, K, V = !1) {
            if (!r.isValid(K) || V && r.is0(K)) throw new Error(`bad point coordinate ${oe}`);
            return K;
        }
        function J(oe) {
            if (!(oe instanceof O)) throw new Error("Weierstrass Point expected");
        }
        function H(oe) {
            if (!h || !h.basises) throw new Error("no endo");
            return wU(oe, h.basises, s.ORDER);
        }
        const F = mp((oe, K)=>{
            const { X: V, Y: q, Z: B } = oe;
            if (r.eql(B, r.ONE)) return {
                x: V,
                y: q
            };
            const z = oe.is0();
            K == null && (K = z ? r.ONE : r.inv(B));
            const ee = r.mul(V, K), j = r.mul(q, K), ce = r.mul(B, K);
            if (z) return {
                x: r.ZERO,
                y: r.ZERO
            };
            if (!r.eql(ce, r.ONE)) throw new Error("invZ was invalid");
            return {
                x: ee,
                y: j
            };
        }), $ = mp((oe)=>{
            if (oe.is0()) {
                if (e.allowInfinityPoint && !r.is0(oe.Y)) return;
                throw new Error("bad point: ZERO");
            }
            const { x: K, y: V } = oe.toAffine();
            if (!r.isValid(K) || !r.isValid(V)) throw new Error("bad point: x or y not field elements");
            if (!I(K, V)) throw new Error("bad point: equation left != right");
            if (!oe.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0;
        });
        function Y(oe, K, V, q, B) {
            return V = new O(r.mul(V.X, oe), V.Y, V.Z), K = yp(q, K), V = yp(B, V), K.add(V);
        }
        class O {
            static BASE = new O(i.Gx, i.Gy, r.ONE);
            static ZERO = new O(r.ZERO, r.ONE, r.ZERO);
            static Fp = r;
            static Fn = s;
            X;
            Y;
            Z;
            constructor(K, V, q){
                this.X = P("x", K), this.Y = P("y", V, !0), this.Z = P("z", q), Object.freeze(this);
            }
            static CURVE() {
                return i;
            }
            static fromAffine(K) {
                const { x: V, y: q } = K || {};
                if (!K || !r.isValid(V) || !r.isValid(q)) throw new Error("invalid affine point");
                if (K instanceof O) throw new Error("projective point not allowed");
                return r.is0(V) && r.is0(q) ? O.ZERO : new O(V, q, r.ONE);
            }
            static fromBytes(K) {
                const V = O.fromAffine(S(Ge(K, void 0, "point")));
                return V.assertValidity(), V;
            }
            static fromHex(K) {
                return O.fromBytes(kd(K));
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            precompute(K = 8, V = !0) {
                return ae.createCache(this, K), V || this.multiply(c0), this;
            }
            assertValidity() {
                $(this);
            }
            hasEvenY() {
                const { y: K } = this.toAffine();
                if (!r.isOdd) throw new Error("Field doesn't support isOdd");
                return !r.isOdd(K);
            }
            equals(K) {
                J(K);
                const { X: V, Y: q, Z: B } = this, { X: z, Y: ee, Z: j } = K, ce = r.eql(r.mul(V, j), r.mul(z, B)), x = r.eql(r.mul(q, j), r.mul(ee, B));
                return ce && x;
            }
            negate() {
                return new O(this.X, r.neg(this.Y), this.Z);
            }
            double() {
                const { a: K, b: V } = i, q = r.mul(V, c0), { X: B, Y: z, Z: ee } = this;
                let j = r.ZERO, ce = r.ZERO, x = r.ZERO, Q = r.mul(B, B), pe = r.mul(z, z), de = r.mul(ee, ee), me = r.mul(B, z);
                return me = r.add(me, me), x = r.mul(B, ee), x = r.add(x, x), j = r.mul(K, x), ce = r.mul(q, de), ce = r.add(j, ce), j = r.sub(pe, ce), ce = r.add(pe, ce), ce = r.mul(j, ce), j = r.mul(me, j), x = r.mul(q, x), de = r.mul(K, de), me = r.sub(Q, de), me = r.mul(K, me), me = r.add(me, x), x = r.add(Q, Q), Q = r.add(x, Q), Q = r.add(Q, de), Q = r.mul(Q, me), ce = r.add(ce, Q), de = r.mul(z, ee), de = r.add(de, de), Q = r.mul(de, me), j = r.sub(j, Q), x = r.mul(de, pe), x = r.add(x, x), x = r.add(x, x), new O(j, ce, x);
            }
            add(K) {
                J(K);
                const { X: V, Y: q, Z: B } = this, { X: z, Y: ee, Z: j } = K;
                let ce = r.ZERO, x = r.ZERO, Q = r.ZERO;
                const pe = i.a, de = r.mul(i.b, c0);
                let me = r.mul(V, z), Ae = r.mul(q, ee), Te = r.mul(B, j), Ve = r.add(V, q), De = r.add(z, ee);
                Ve = r.mul(Ve, De), De = r.add(me, Ae), Ve = r.sub(Ve, De), De = r.add(V, B);
                let mt = r.add(z, j);
                return De = r.mul(De, mt), mt = r.add(me, Te), De = r.sub(De, mt), mt = r.add(q, B), ce = r.add(ee, j), mt = r.mul(mt, ce), ce = r.add(Ae, Te), mt = r.sub(mt, ce), Q = r.mul(pe, De), ce = r.mul(de, Te), Q = r.add(ce, Q), ce = r.sub(Ae, Q), Q = r.add(Ae, Q), x = r.mul(ce, Q), Ae = r.add(me, me), Ae = r.add(Ae, me), Te = r.mul(pe, Te), De = r.mul(de, De), Ae = r.add(Ae, Te), Te = r.sub(me, Te), Te = r.mul(pe, Te), De = r.add(De, Te), me = r.mul(Ae, De), x = r.add(x, me), me = r.mul(mt, De), ce = r.mul(Ve, ce), ce = r.sub(ce, me), me = r.mul(Ve, Ae), Q = r.mul(mt, Q), Q = r.add(Q, me), new O(ce, x, Q);
            }
            subtract(K) {
                return this.add(K.negate());
            }
            is0() {
                return this.equals(O.ZERO);
            }
            multiply(K) {
                const { endo: V } = e;
                if (!s.isValidNot0(K)) throw new Error("invalid scalar: out of range");
                let q, B;
                const z = (ee)=>ae.cached(this, ee, (j)=>gd(O, j));
                if (V) {
                    const { k1neg: ee, k1: j, k2neg: ce, k2: x } = H(K), { p: Q, f: pe } = z(j), { p: de, f: me } = z(x);
                    B = pe.add(me), q = Y(V.beta, Q, de, ee, ce);
                } else {
                    const { p: ee, f: j } = z(K);
                    q = ee, B = j;
                }
                return gd(O, [
                    q,
                    B
                ])[0];
            }
            multiplyUnsafe(K) {
                const { endo: V } = e, q = this;
                if (!s.isValid(K)) throw new Error("invalid scalar: out of range");
                if (K === qi || q.is0()) return O.ZERO;
                if (K === Sc) return q;
                if (ae.hasCache(this)) return this.multiply(K);
                if (V) {
                    const { k1neg: B, k1: z, k2neg: ee, k2: j } = H(K), { p1: ce, p2: x } = oL(O, q, z, j);
                    return Y(V.beta, ce, x, B, ee);
                } else return ae.unsafe(q, K);
            }
            toAffine(K) {
                return F(this, K);
            }
            isTorsionFree() {
                const { isTorsionFree: K } = e;
                return l === Sc ? !0 : K ? K(O, this) : ae.unsafe(this, u).is0();
            }
            clearCofactor() {
                const { clearCofactor: K } = e;
                return l === Sc ? this : K ? K(O, this) : this.multiplyUnsafe(l);
            }
            isSmallOrder() {
                return this.multiplyUnsafe(l).is0();
            }
            toBytes(K = !0) {
                return Va(K, "isCompressed"), this.assertValidity(), A(O, this, K);
            }
            toHex(K = !0) {
                return Tf(this.toBytes(K));
            }
            toString() {
                return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
            }
        }
        const se = s.BITS, ae = new qI(O, e.endo ? Math.ceil(se / 2) : se);
        return O.BASE.precompute(8), O;
    }
    function lC(n) {
        return Uint8Array.of(n ? 2 : 3);
    }
    function cC(n, e) {
        return {
            secretKey: e.BYTES,
            publicKey: 1 + n.BYTES,
            publicKeyUncompressed: 1 + 2 * n.BYTES,
            publicKeyHasPrefix: !0,
            signature: 2 * e.BYTES
        };
    }
    function AU(n, e = {}) {
        const { Fn: t } = n, r = e.randomBytes || _f, s = Object.assign(cC(n.Fp, t), {
            seed: VI(t.ORDER)
        });
        function i(A) {
            try {
                const S = t.fromBytes(A);
                return t.isValidNot0(S);
            } catch  {
                return !1;
            }
        }
        function l(A, S) {
            const { publicKey: _, publicKeyUncompressed: I } = s;
            try {
                const k = A.length;
                return S === !0 && k !== _ || S === !1 && k !== I ? !1 : !!n.fromBytes(A);
            } catch  {
                return !1;
            }
        }
        function u(A = r(s.seed)) {
            return iL(Ge(A, s.seed, "seed"), t.ORDER);
        }
        function h(A, S = !0) {
            return n.BASE.multiply(t.fromBytes(A)).toBytes(S);
        }
        function f(A) {
            const { secretKey: S, publicKey: _, publicKeyUncompressed: I } = s;
            if (!hg(A) || "_lengths" in t && t._lengths || S === _) return;
            const k = Ge(A, void 0, "key").length;
            return k === _ || k === I;
        }
        function p(A, S, _ = !0) {
            if (f(A) === !0) throw new Error("first arg must be private key");
            if (f(S) === !1) throw new Error("second arg must be public key");
            const I = t.fromBytes(A);
            return n.fromBytes(S).multiply(I).toBytes(_);
        }
        const m = {
            isValidSecretKey: i,
            isValidPublicKey: l,
            randomSecretKey: u
        }, w = l6(u, h);
        return Object.freeze({
            getPublicKey: h,
            getSharedSecret: p,
            keygen: w,
            Point: n,
            utils: m,
            lengths: s
        });
    }
    function SU(n, e, t = {}) {
        Cf(e), tu(t, {}, {
            hmac: "function",
            lowS: "boolean",
            randomBytes: "function",
            bits2int: "function",
            bits2int_modN: "function"
        }), t = Object.assign({}, t);
        const r = t.randomBytes || _f, s = t.hmac || ((V, q)=>xf(e, V, q)), { Fp: i, Fn: l } = n, { ORDER: u, BITS: h } = l, { keygen: f, getPublicKey: p, getSharedSecret: m, utils: w, lengths: A } = AU(n, t), S = {
            prehash: !0,
            lowS: typeof t.lowS == "boolean" ? t.lowS : !0,
            format: "compact",
            extraEntropy: !1
        }, _ = u * aC < i.ORDER;
        function I(V) {
            const q = u >> Sc;
            return V > q;
        }
        function k(V, q) {
            if (!l.isValidNot0(q)) throw new Error(`invalid signature ${V}: out of range 1..Point.Fn.ORDER`);
            return q;
        }
        function G() {
            if (_) throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
        }
        function P(V, q) {
            Ly(q);
            const B = A.signature, z = q === "compact" ? B : q === "recovered" ? B + 1 : void 0;
            return Ge(V, z);
        }
        class J {
            r;
            s;
            recovery;
            constructor(q, B, z){
                if (this.r = k("r", q), this.s = k("s", B), z != null) {
                    if (G(), ![
                        0,
                        1,
                        2,
                        3
                    ].includes(z)) throw new Error("invalid recovery id");
                    this.recovery = z;
                }
                Object.freeze(this);
            }
            static fromBytes(q, B = S.format) {
                P(q, B);
                let z;
                if (B === "der") {
                    const { r: x, s: Q } = ko.toSig(Ge(q));
                    return new J(x, Q);
                }
                B === "recovered" && (z = q[0], B = "compact", q = q.subarray(1));
                const ee = A.signature / 2, j = q.subarray(0, ee), ce = q.subarray(ee, ee * 2);
                return new J(l.fromBytes(j), l.fromBytes(ce), z);
            }
            static fromHex(q, B) {
                return this.fromBytes(kd(q), B);
            }
            assertRecovery() {
                const { recovery: q } = this;
                if (q == null) throw new Error("invalid recovery id: must be present");
                return q;
            }
            addRecoveryBit(q) {
                return new J(this.r, this.s, q);
            }
            recoverPublicKey(q) {
                const { r: B, s: z } = this, ee = this.assertRecovery(), j = ee === 2 || ee === 3 ? B + u : B;
                if (!i.isValid(j)) throw new Error("invalid recovery id: sig.r+curve.n != R.x");
                const ce = i.toBytes(j), x = n.fromBytes(ri(lC((ee & 1) === 0), ce)), Q = l.inv(j), pe = F(Ge(q, void 0, "msgHash")), de = l.create(-pe * Q), me = l.create(z * Q), Ae = n.BASE.multiplyUnsafe(de).add(x.multiplyUnsafe(me));
                if (Ae.is0()) throw new Error("invalid recovery: point at infinify");
                return Ae.assertValidity(), Ae;
            }
            hasHighS() {
                return I(this.s);
            }
            toBytes(q = S.format) {
                if (Ly(q), q === "der") return kd(ko.hexFromSig(this));
                const { r: B, s: z } = this, ee = l.toBytes(B), j = l.toBytes(z);
                return q === "recovered" ? (G(), ri(Uint8Array.of(this.assertRecovery()), ee, j)) : ri(ee, j);
            }
            toHex(q) {
                return Tf(this.toBytes(q));
            }
        }
        const H = t.bits2int || function(q) {
            if (q.length > 8192) throw new Error("input is too large");
            const B = fg(q), z = q.length * 8 - h;
            return z > 0 ? B >> BigInt(z) : B;
        }, F = t.bits2int_modN || function(q) {
            return l.create(H(q));
        }, $ = o6(h);
        function Y(V) {
            return Od("num < 2^" + h, V, qi, $), l.toBytes(V);
        }
        function O(V, q) {
            return Ge(V, void 0, "message"), q ? Ge(e(V), void 0, "prehashed message") : V;
        }
        function se(V, q, B) {
            const { lowS: z, prehash: ee, extraEntropy: j } = v3(B, S);
            V = O(V, ee);
            const ce = F(V), x = l.fromBytes(q);
            if (!l.isValidNot0(x)) throw new Error("invalid private key");
            const Q = [
                Y(x),
                Y(ce)
            ];
            if (j != null && j !== !1) {
                const Ae = j === !0 ? r(A.secretKey) : j;
                Q.push(Ge(Ae, void 0, "extraEntropy"));
            }
            const pe = ri(...Q), de = ce;
            function me(Ae) {
                const Te = H(Ae);
                if (!l.isValidNot0(Te)) return;
                const Ve = l.inv(Te), De = n.BASE.multiply(Te).toAffine(), mt = l.create(De.x);
                if (mt === qi) return;
                const hn = l.create(Ve * l.create(de + mt * x));
                if (hn === qi) return;
                let Qr = (De.x === mt ? 0 : 2) | Number(De.y & Sc), Ts = hn;
                return z && I(hn) && (Ts = l.neg(hn), Qr ^= 1), new J(mt, Ts, _ ? void 0 : Qr);
            }
            return {
                seed: pe,
                k2sig: me
            };
        }
        function ae(V, q, B = {}) {
            const { seed: z, k2sig: ee } = se(V, q, B);
            return GN(e.outputLen, l.BYTES, s)(z, ee).toBytes(B.format);
        }
        function oe(V, q, B, z = {}) {
            const { lowS: ee, prehash: j, format: ce } = v3(z, S);
            if (B = Ge(B, void 0, "publicKey"), q = O(q, j), !hg(V)) {
                const x = V instanceof J ? ", use sig.toBytes()" : "";
                throw new Error("verify expects Uint8Array signature" + x);
            }
            P(V, ce);
            try {
                const x = J.fromBytes(V, ce), Q = n.fromBytes(B);
                if (ee && x.hasHighS()) return !1;
                const { r: pe, s: de } = x, me = F(q), Ae = l.inv(de), Te = l.create(me * Ae), Ve = l.create(pe * Ae), De = n.BASE.multiplyUnsafe(Te).add(Q.multiplyUnsafe(Ve));
                return De.is0() ? !1 : l.create(De.x) === pe;
            } catch  {
                return !1;
            }
        }
        function K(V, q, B = {}) {
            const { prehash: z } = v3(B, S);
            return q = O(q, z), J.fromBytes(V, "recovered").recoverPublicKey(q).toBytes();
        }
        return Object.freeze({
            keygen: f,
            getPublicKey: p,
            getSharedSecret: m,
            utils: w,
            lengths: A,
            Point: n,
            sign: ae,
            verify: oe,
            recoverPublicKey: K,
            Signature: J,
            hash: e
        });
    }
    const b6 = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    }, IU = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        basises: [
            [
                BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
            ],
            [
                BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                BigInt("0x3086d221a7d46bcde86c90e49284eb15")
            ]
        ]
    }, Q9 = BigInt(2);
    function CU(n) {
        const e = b6.p, t = BigInt(3), r = BigInt(6), s = BigInt(11), i = BigInt(22), l = BigInt(23), u = BigInt(44), h = BigInt(88), f = n * n * n % e, p = f * f * n % e, m = qt(p, t, e) * p % e, w = qt(m, t, e) * p % e, A = qt(w, Q9, e) * f % e, S = qt(A, s, e) * A % e, _ = qt(S, i, e) * S % e, I = qt(_, u, e) * _ % e, k = qt(I, h, e) * I % e, G = qt(k, u, e) * _ % e, P = qt(G, t, e) * p % e, J = qt(P, l, e) * S % e, H = qt(J, r, e) * f % e, F = qt(H, Q9, e);
        if (!Uy.eql(Uy.sqr(F), n)) throw new Error("Cannot find square root");
        return F;
    }
    const Uy = pg(b6.p, {
        sqrt: CU
    }), TU = EU(b6, {
        Fp: Uy,
        endo: IU
    }), Yi = SU(TU, Lo), _U = 33, xU = 32;
    function DU(n, e, t) {
        const r = Ut.digest(e instanceof Uint8Array ? e : e.subarray());
        if (mg(r)) return r.then(({ digest: s })=>(t?.signal?.throwIfAborted(), Yi.sign(s, n, {
                prehash: !1,
                format: "der"
            }))).catch((s)=>{
            throw s.name === "AbortError" ? s : new C9(String(s));
        });
        try {
            return Yi.sign(r.digest, n, {
                prehash: !1,
                format: "der"
            });
        } catch (s) {
            throw new C9(String(s));
        }
    }
    function BU(n, e, t, r) {
        const s = Ut.digest(t instanceof Uint8Array ? t : t.subarray());
        if (mg(s)) return s.then(({ digest: i })=>(r?.signal?.throwIfAborted(), Yi.verify(e, i, n, {
                prehash: !1,
                format: "der"
            }))).catch((i)=>{
            throw i.name === "AbortError" ? i : new T9(String(i));
        });
        try {
            return r?.signal?.throwIfAborted(), Yi.verify(e, s.digest, n, {
                prehash: !1,
                format: "der"
            });
        } catch (i) {
            throw new T9(String(i));
        }
    }
    class uC {
        type = "secp256k1";
        raw;
        _key;
        constructor(e){
            this._key = OU(e), this.raw = kU(this._key);
        }
        toMultihash() {
            return nt.digest(Fr(this));
        }
        toCID() {
            return ge.createV1(114, this.toMultihash());
        }
        toString() {
            return He.encode(this.toMultihash().bytes).substring(1);
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        verify(e, t, r) {
            return BU(this._key, t, e, r);
        }
    }
    class hC {
        type = "secp256k1";
        raw;
        publicKey;
        constructor(e, t){
            this.raw = RU(e), this.publicKey = new uC(t ?? $U(e));
        }
        equals(e) {
            return e == null || !(e.raw instanceof Uint8Array) ? !1 : Ee(this.raw, e.raw);
        }
        sign(e, t) {
            return DU(this.raw, e, t);
        }
    }
    function dC(n) {
        return new hC(n);
    }
    function v6(n) {
        return new uC(n);
    }
    async function PU() {
        const n = MU();
        return new hC(n);
    }
    function kU(n) {
        return Yi.Point.fromBytes(n).toBytes();
    }
    function RU(n) {
        try {
            return Yi.getPublicKey(n, !0), n;
        } catch (e) {
            throw new pI(String(e));
        }
    }
    function OU(n) {
        try {
            return Yi.Point.fromBytes(n), n;
        } catch (e) {
            throw new fI(String(e));
        }
    }
    function $U(n) {
        try {
            return Yi.getPublicKey(n, !0);
        } catch (e) {
            throw new pI(String(e));
        }
    }
    function MU() {
        return Yi.utils.randomSecretKey();
    }
    E6 = async function(n, e) {
        if (n === "Ed25519") return DL();
        if (n === "secp256k1") return PU();
        if (n === "RSA") return uU(UU());
        if (n === "ECDSA") return SN(zU());
        throw new Sf;
    };
    async function NU(n, e) {
        if (n !== "Ed25519") throw new Sf("Seed key derivation only supported for Ed25519 keys");
        return BL(e);
    }
    function Er(n, e) {
        const { Type: t, Data: r } = Ko.decode(n), s = r ?? new Uint8Array;
        switch(t){
            case Qt.RSA:
                return lU(s, e);
            case Qt.Ed25519:
                return c6(s);
            case Qt.secp256k1:
                return v6(s);
            case Qt.ECDSA:
                return SI(s);
            default:
                throw new Sf;
        }
    }
    LU = function(n) {
        if (n.byteLength === Md) return c6(n);
        if (n.byteLength === _U) return v6(n);
        const e = Xo(n), t = e[1]?.[0];
        if (t === mI || t === yI || t === wI) return II(e);
        if (e[0]?.[0] === dU) return iC(e, n);
        throw new jn("Could not extract public key from raw bytes");
    };
    function ir(n) {
        const { Type: e, Data: t } = Ko.decode(n.digest), r = t ?? new Uint8Array;
        switch(e){
            case Qt.Ed25519:
                return c6(r);
            case Qt.secp256k1:
                return v6(r);
            case Qt.ECDSA:
                return SI(r);
            default:
                throw new Sf;
        }
    }
    function Fr(n) {
        return Ko.encode({
            Type: Qt[n.type],
            Data: n.raw
        });
    }
    function fC(n) {
        const e = Ep.decode(n), t = e.Data ?? new Uint8Array;
        switch(e.Type){
            case Qt.RSA:
                return aU(t);
            case Qt.Ed25519:
                return JI(t);
            case Qt.secp256k1:
                return dC(t);
            case Qt.ECDSA:
                return vN(t);
            default:
                throw new Sf;
        }
    }
    pC = function(n) {
        if (n.byteLength === ti) return JI(n);
        if (n.byteLength === xU) return dC(n);
        const e = Xo(n), t = e[2]?.[0];
        if (t === mI || t === yI || t === wI) return AI(e);
        if (e.length > 8) return sC(e);
        throw new jn("Could not extract private key from raw bytes");
    };
    function nu(n) {
        return Ep.encode({
            Type: Qt[n.type],
            Data: n.raw
        });
    }
    function UU(n) {
        return 2048;
    }
    function zU(n) {
        return "P-256";
    }
    const FU = Object.freeze(Object.defineProperty({
        __proto__: null,
        generateKeyPair: E6,
        generateKeyPairFromSeed: NU,
        privateKeyFromProtobuf: fC,
        privateKeyFromRaw: pC,
        privateKeyToProtobuf: nu,
        publicKeyFromMultihash: ir,
        publicKeyFromProtobuf: Er,
        publicKeyFromRaw: LU,
        publicKeyToProtobuf: Fr
    }, Symbol.toStringTag, {
        value: "Module"
    })), Ch = Uint32Array.from([
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ]), Bo = new Uint32Array(80);
    class VU extends n6 {
        A = Ch[0] | 0;
        B = Ch[1] | 0;
        C = Ch[2] | 0;
        D = Ch[3] | 0;
        E = Ch[4] | 0;
        constructor(){
            super(64, 20, 8, !1);
        }
        get() {
            const { A: e, B: t, C: r, D: s, E: i } = this;
            return [
                e,
                t,
                r,
                s,
                i
            ];
        }
        set(e, t, r, s, i) {
            this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = s | 0, this.E = i | 0;
        }
        process(e, t) {
            for(let h = 0; h < 16; h++, t += 4)Bo[h] = e.getUint32(t, !1);
            for(let h = 16; h < 80; h++)Bo[h] = f3(Bo[h - 3] ^ Bo[h - 8] ^ Bo[h - 14] ^ Bo[h - 16], 1);
            let { A: r, B: s, C: i, D: l, E: u } = this;
            for(let h = 0; h < 80; h++){
                let f, p;
                h < 20 ? (f = xI(s, i, l), p = 1518500249) : h < 40 ? (f = s ^ i ^ l, p = 1859775393) : h < 60 ? (f = DI(s, i, l), p = 2400959708) : (f = s ^ i ^ l, p = 3395469782);
                const m = f3(r, 5) + f + u + p + Bo[h] | 0;
                u = l, l = i, i = f3(s, 30), s = r, r = m;
            }
            r = r + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, l = l + this.D | 0, u = u + this.E | 0, this.set(r, s, i, l, u);
        }
        roundClean() {
            ui(Bo);
        }
        destroy() {
            this.set(0, 0, 0, 0, 0), ui(this.buffer);
        }
    }
    const HU = t6(()=>new VU);
    function gC(n, e, t, r) {
        Cf(n);
        const s = DN({
            dkLen: 32,
            asyncTick: 10
        }, r), { c: i, dkLen: l, asyncTick: u } = s;
        if (Us(i, "c"), Us(l, "dkLen"), Us(u, "asyncTick"), i < 1) throw new Error("iterations (c) must be >= 1");
        const h = B9(e, "password"), f = B9(t, "salt"), p = new Uint8Array(l), m = xf.create(n, h), w = m._cloneInto().update(f);
        return {
            c: i,
            dkLen: l,
            asyncTick: u,
            DK: p,
            PRF: m,
            PRFSalt: w
        };
    }
    function mC(n, e, t, r, s) {
        return n.destroy(), e.destroy(), r && r.destroy(), ui(s), t;
    }
    function QU(n, e, t, r) {
        const { c: s, dkLen: i, DK: l, PRF: u, PRFSalt: h } = gC(n, e, t, r);
        let f;
        const p = new Uint8Array(4), m = pd(p), w = new Uint8Array(u.outputLen);
        for(let A = 1, S = 0; S < i; A++, S += u.outputLen){
            const _ = l.subarray(S, S + u.outputLen);
            m.setInt32(0, A, !1), (f = h._cloneInto(f)).update(p).digestInto(w), _.set(w.subarray(0, _.length));
            for(let I = 1; I < s; I++){
                u._cloneInto(f).update(w).digestInto(w);
                for(let k = 0; k < _.length; k++)_[k] ^= w[k];
            }
        }
        return mC(u, h, l, f, w);
    }
    async function yC(n, e, t, r) {
        const { c: s, dkLen: i, asyncTick: l, DK: u, PRF: h, PRFSalt: f } = gC(n, e, t, r);
        let p;
        const m = new Uint8Array(4), w = pd(m), A = new Uint8Array(h.outputLen);
        for(let S = 1, _ = 0; _ < i; S++, _ += h.outputLen){
            const I = u.subarray(_, _ + h.outputLen);
            w.setInt32(0, S, !1), (p = f._cloneInto(p)).update(m).digestInto(A), I.set(A.subarray(0, I.length)), await _N(s - 1, l, ()=>{
                h._cloneInto(p).update(A).digestInto(A);
                for(let k = 0; k < I.length; k++)I[k] ^= A[k];
            });
        }
        return mC(h, f, u, p, A);
    }
    const q9 = {
        sha1: HU,
        "sha2-256": Lo,
        "sha2-512": dg
    };
    function K9(n, e, t, r, s) {
        if (s !== "sha1" && s !== "sha2-256" && s !== "sha2-512") {
            const u = Object.keys(q9).join(" / ");
            throw new jn(`Hash '${s}' is unknown or not supported. Must be ${u}`);
        }
        const i = q9[s], l = QU(i, n, e, {
            c: t,
            dkLen: r
        });
        return As.encode(l).substring(1);
    }
    const A6 = {
        32: 16777619n,
        64: 1099511628211n,
        128: 309485009821345068724781371n,
        256: 374144419156711147060143317175368453031918731002211n,
        512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
        1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
    }, wC = {
        32: 2166136261n,
        64: 14695981039346656037n,
        128: 144066263297769815596495629667062367629n,
        256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
        512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
        1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
    }, bC = new globalThis.TextEncoder;
    function qU(n, e) {
        const t = A6[e];
        let r = wC[e];
        for(let s = 0; s < n.length; s++)r ^= BigInt(n[s]), r = BigInt.asUintN(e, r * t);
        return r;
    }
    function KU(n, e, t) {
        if (t.length === 0) throw new Error("The `utf8Buffer` option must have a length greater than zero");
        const r = A6[e];
        let s = wC[e], i = n;
        for(; i.length > 0;){
            const l = bC.encodeInto(i, t);
            i = i.slice(l.read);
            for(let u = 0; u < l.written; u++)s ^= BigInt(t[u]), s = BigInt.asUintN(e, s * r);
        }
        return s;
    }
    function GU(n, { size: e = 32, utf8Buffer: t } = {}) {
        if (!A6[e]) throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
        if (typeof n == "string") {
            if (t) return KU(n, e, t);
            n = bC.encode(n);
        }
        return qU(n, e);
    }
    const S6 = {
        hash: (n)=>Number(GU(n, {
                size: 32
            })),
        hashV: (n, e)=>YU(S6.hash(n, e))
    };
    function YU(n) {
        let e = n.toString(16);
        return e.length % 2 === 1 && (e = `0${e}`), re(e, "base16");
    }
    const vC = 64;
    class ka {
        fp;
        h;
        seed;
        constructor(e, t, r, s = 2){
            if (s > vC) throw new TypeError("Invalid Fingerprint Size");
            const i = t.hashV(e, r), l = je(s);
            for(let u = 0; u < l.length; u++)l[u] = i[u];
            l.length === 0 && (l[0] = 7), this.fp = l, this.h = t, this.seed = r;
        }
        hash() {
            return this.h.hash(this.fp, this.seed);
        }
        equals(e) {
            return e?.fp instanceof Uint8Array ? Ee(this.fp, e.fp) : !1;
        }
    }
    function Ap(n, e) {
        return Math.floor(Math.random() * (e - n)) + n;
    }
    class u0 {
        contents;
        constructor(e){
            this.contents = new Array(e).fill(null);
        }
        has(e) {
            if (!(e instanceof ka)) throw new TypeError("Invalid Fingerprint");
            return this.contents.some((t)=>e.equals(t));
        }
        add(e) {
            if (!(e instanceof ka)) throw new TypeError("Invalid Fingerprint");
            for(let t = 0; t < this.contents.length; t++)if (this.contents[t] == null) return this.contents[t] = e, !0;
            return !0;
        }
        swap(e) {
            if (!(e instanceof ka)) throw new TypeError("Invalid Fingerprint");
            const t = Ap(0, this.contents.length - 1), r = this.contents[t];
            return this.contents[t] = e, r;
        }
        remove(e) {
            if (!(e instanceof ka)) throw new TypeError("Invalid Fingerprint");
            const t = this.contents.findIndex((r)=>e.equals(r));
            return t > -1 ? (this.contents[t] = null, !0) : !1;
        }
    }
    const WU = 500;
    class G9 {
        bucketSize;
        filterSize;
        fingerprintSize;
        buckets;
        count;
        hash;
        seed;
        constructor(e){
            this.filterSize = e.filterSize, this.bucketSize = e.bucketSize ?? 4, this.fingerprintSize = e.fingerprintSize ?? 2, this.count = 0, this.buckets = [], this.hash = e.hash ?? S6, this.seed = e.seed ?? Ap(0, Math.pow(2, 10));
        }
        add(e) {
            typeof e == "string" && (e = re(e));
            const t = new ka(e, this.hash, this.seed, this.fingerprintSize), r = this.hash.hash(e, this.seed) % this.filterSize, s = (r ^ t.hash()) % this.filterSize;
            if (this.buckets[r] == null && (this.buckets[r] = new u0(this.bucketSize)), this.buckets[s] == null && (this.buckets[s] = new u0(this.bucketSize)), this.buckets[r].add(t) || this.buckets[s].add(t)) return this.count++, !0;
            const i = [
                r,
                s
            ];
            let l = i[Ap(0, i.length - 1)];
            this.buckets[l] == null && (this.buckets[l] = new u0(this.bucketSize));
            for(let u = 0; u < WU; u++){
                const h = this.buckets[l].swap(t);
                if (h != null && (l = (l ^ h.hash()) % this.filterSize, this.buckets[l] == null && (this.buckets[l] = new u0(this.bucketSize)), this.buckets[l].add(h))) return this.count++, !0;
            }
            return !1;
        }
        has(e) {
            typeof e == "string" && (e = re(e));
            const t = new ka(e, this.hash, this.seed, this.fingerprintSize), r = this.hash.hash(e, this.seed) % this.filterSize, s = this.buckets[r]?.has(t) ?? !1;
            if (s) return s;
            const i = (r ^ t.hash()) % this.filterSize;
            return this.buckets[i]?.has(t) ?? !1;
        }
        remove(e) {
            typeof e == "string" && (e = re(e));
            const t = new ka(e, this.hash, this.seed, this.fingerprintSize), r = this.hash.hash(e, this.seed) % this.filterSize, s = this.buckets[r]?.remove(t) ?? !1;
            if (s) return this.count--, s;
            const i = (r ^ t.hash()) % this.filterSize, l = this.buckets[i]?.remove(t) ?? !1;
            return l && this.count--, l;
        }
        get reliable() {
            return Math.floor(100 * (this.count / this.filterSize)) <= 90;
        }
    }
    const jU = {
        1: .5,
        2: .84,
        4: .95,
        8: .98
    };
    function XU(n = .001) {
        return n > .002 ? 2 : n > 1e-5 ? 4 : 8;
    }
    function JU(n, e = .001) {
        const t = XU(e), r = jU[t], s = Math.round(n / r), i = Math.min(Math.ceil(Math.log2(1 / e) + Math.log2(2 * t)), vC);
        return {
            filterSize: s,
            bucketSize: t,
            fingerprintSize: i
        };
    }
    class ZU {
        filterSize;
        bucketSize;
        fingerprintSize;
        scale;
        filterSeries;
        hash;
        seed;
        constructor(e){
            this.bucketSize = e.bucketSize ?? 4, this.filterSize = e.filterSize ?? (1 << 18) / this.bucketSize, this.fingerprintSize = e.fingerprintSize ?? 2, this.scale = e.scale ?? 2, this.hash = e.hash ?? S6, this.seed = e.seed ?? Ap(0, Math.pow(2, 10)), this.filterSeries = [
                new G9({
                    filterSize: this.filterSize,
                    bucketSize: this.bucketSize,
                    fingerprintSize: this.fingerprintSize,
                    hash: this.hash,
                    seed: this.seed
                })
            ];
        }
        add(e) {
            if (typeof e == "string" && (e = re(e)), this.has(e)) return !0;
            let t = this.filterSeries.find((r)=>r.reliable);
            if (t == null) {
                const r = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
                t = new G9({
                    filterSize: r,
                    bucketSize: this.bucketSize,
                    fingerprintSize: this.fingerprintSize,
                    hash: this.hash,
                    seed: this.seed
                }), this.filterSeries.push(t);
            }
            return t.add(e);
        }
        has(e) {
            typeof e == "string" && (e = re(e));
            for(let t = 0; t < this.filterSeries.length; t++)if (this.filterSeries[t].has(e)) return !0;
            return !1;
        }
        remove(e) {
            typeof e == "string" && (e = re(e));
            for(let t = 0; t < this.filterSeries.length; t++)if (this.filterSeries[t].remove(e)) return !0;
            return !1;
        }
        get count() {
            return this.filterSeries.reduce((e, t)=>e + t.count, 0);
        }
    }
    function Wi(n, e = .001, t) {
        return new ZU({
            ...JU(n, e)
        });
    }
    let Sp = class extends Error {
        static name = "AbortError";
        constructor(e = "The operation was aborted"){
            super(e), this.name = "AbortError";
        }
    }, I6 = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, ez = class extends Error {
        static name = "MuxerClosedError";
        constructor(e = "The muxer is closed"){
            super(e), this.name = "MuxerClosedError";
        }
    }, tz = class extends Error {
        static name = "StreamResetError";
        constructor(e = "The stream has been reset"){
            super(e), this.name = "StreamResetError";
        }
    }, Th = class extends Error {
        static name = "StreamStateError";
        constructor(e = "The stream is in an invalid state"){
            super(e), this.name = "StreamStateError";
        }
    };
    class Y9 extends Error {
        static name = "StreamBufferError";
        constructor(e = "The stream buffer was full"){
            super(e), this.name = "StreamBufferError";
        }
    }
    class nz extends Event {
        data;
        constructor(e, t){
            super("message", t), this.data = e;
        }
    }
    let C6 = class extends Event {
        error;
        local;
        constructor(e, t, r){
            super("close", r), this.error = t, this.local = e;
        }
    };
    class rz extends C6 {
        constructor(e, t){
            super(!0, e, t);
        }
    }
    class sz extends C6 {
        constructor(e, t){
            super(!1, e, t);
        }
    }
    function Xe(n) {
        const e = n.getComponents(), t = {};
        let r = 0;
        if (e[r]?.name === "ip6zone" && (t.zone = `${e[r].value}`, r++), e[r].name === "ip4" || e[r].name === "ip6" || e[r].name === "dns" || e[r].name === "dns4" || e[r].name === "dns6" ? (t.type = e[r].name, t.host = e[r].value, r++) : e[r].name === "dnsaddr" && (t.type = e[r].name, t.host = `_dnsaddr.${e[r].value}`, r++), (e[r]?.name === "tcp" || e[r]?.name === "udp") && (t.protocol = e[r].name === "tcp" ? "tcp" : "udp", t.port = parseInt(`${e[r].value}`), r++), e[r]?.name === "ipcidr" && (t.type === "ip4" ? t.cidr = parseInt(`${e[r].value}`) : t.type === "ip6" && (t.cidr = `${e[r].value}`), r++), t.type == null || t.host == null) throw new I6(`Multiaddr ${n} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);
        return e[r]?.name === "tls" && e[r + 1]?.name === "sni" && (t.sni = e[r + 1].value, r += 2), t;
    }
    class iz {
        index = 0;
        input = "";
        new(e) {
            return this.index = 0, this.input = e, this;
        }
        readAtomically(e) {
            const t = this.index, r = e();
            return r === void 0 && (this.index = t), r;
        }
        parseWith(e) {
            const t = e();
            if (this.index === this.input.length) return t;
        }
        peekChar() {
            if (!(this.index >= this.input.length)) return this.input[this.index];
        }
        readChar() {
            if (!(this.index >= this.input.length)) return this.input[this.index++];
        }
        readGivenChar(e) {
            return this.readAtomically(()=>{
                const t = this.readChar();
                if (t === e) return t;
            });
        }
        readSeparator(e, t, r) {
            return this.readAtomically(()=>{
                if (!(t > 0 && this.readGivenChar(e) === void 0)) return r();
            });
        }
        readNumber(e, t, r, s) {
            return this.readAtomically(()=>{
                let i = 0, l = 0;
                const u = this.peekChar();
                if (u === void 0) return;
                const h = u === "0", f = 2 ** (8 * s) - 1;
                for(;;){
                    const p = this.readAtomically(()=>{
                        const m = this.readChar();
                        if (m === void 0) return;
                        const w = Number.parseInt(m, e);
                        if (!Number.isNaN(w)) return w;
                    });
                    if (p === void 0) break;
                    if (i *= e, i += p, i > f || (l += 1, t !== void 0 && l > t)) return;
                }
                if (l !== 0) return !r && h && l > 1 ? void 0 : i;
            });
        }
        readIPv4Addr() {
            return this.readAtomically(()=>{
                const e = new Uint8Array(4);
                for(let t = 0; t < e.length; t++){
                    const r = this.readSeparator(".", t, ()=>this.readNumber(10, 3, !1, 1));
                    if (r === void 0) return;
                    e[t] = r;
                }
                return e;
            });
        }
        readIPv6Addr() {
            const e = (t)=>{
                for(let r = 0; r < t.length / 2; r++){
                    const s = r * 2;
                    if (r < t.length - 3) {
                        const l = this.readSeparator(":", r, ()=>this.readIPv4Addr());
                        if (l !== void 0) return t[s] = l[0], t[s + 1] = l[1], t[s + 2] = l[2], t[s + 3] = l[3], [
                            s + 4,
                            !0
                        ];
                    }
                    const i = this.readSeparator(":", r, ()=>this.readNumber(16, 4, !0, 2));
                    if (i === void 0) return [
                        s,
                        !1
                    ];
                    t[s] = i >> 8, t[s + 1] = i & 255;
                }
                return [
                    t.length,
                    !1
                ];
            };
            return this.readAtomically(()=>{
                const t = new Uint8Array(16), [r, s] = e(t);
                if (r === 16) return t;
                if (s || this.readGivenChar(":") === void 0 || this.readGivenChar(":") === void 0) return;
                const i = new Uint8Array(14), l = 16 - (r + 2), [u] = e(i.subarray(0, l));
                return t.set(i.subarray(0, u), 16 - u), t;
            });
        }
        readIPAddr() {
            return this.readIPv4Addr() ?? this.readIPv6Addr();
        }
    }
    const EC = 45, oz = 15, Rc = new iz;
    function AC(n) {
        if (!(n.length > oz)) return Rc.new(n).parseWith(()=>Rc.readIPv4Addr());
    }
    function SC(n) {
        if (n.includes("%") && (n = n.split("%")[0]), !(n.length > EC)) return Rc.new(n).parseWith(()=>Rc.readIPv6Addr());
    }
    function zy(n, e = !1) {
        if (n.includes("%") && (n = n.split("%")[0]), n.length > EC) return;
        const t = Rc.new(n).parseWith(()=>Rc.readIPAddr());
        if (t) return e && t.length === 4 ? Uint8Array.from([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            255,
            255,
            t[0],
            t[1],
            t[2],
            t[3]
        ]) : t;
    }
    function az(n, e, t) {
        let r = 0;
        for (const s of n)if (!(r < e)) {
            if (r > t) break;
            if (s !== 255) return !1;
            r++;
        }
        return !0;
    }
    function lz(n, e, t, r) {
        let s = 0;
        for (const i of n)if (!(s < t)) {
            if (s > r) break;
            if (i !== e[s]) return !1;
            s++;
        }
        return !0;
    }
    function cz(n) {
        switch(n.length){
            case Ld:
                return n.join(".");
            case Ud:
                {
                    const e = [];
                    for(let t = 0; t < n.length; t++)t % 2 === 0 && e.push(n[t].toString(16).padStart(2, "0") + n[t + 1].toString(16).padStart(2, "0"));
                    return e.join(":");
                }
            default:
                throw new Error("Invalid ip length");
        }
    }
    function uz(n) {
        let e = 0;
        for (let [t, r] of n.entries()){
            if (r === 255) {
                e += 8;
                continue;
            }
            for(; (r & 128) != 0;)e++, r = r << 1;
            if ((r & 128) != 0) return -1;
            for(let s = t + 1; s < n.length; s++)if (n[s] != 0) return -1;
            break;
        }
        return e;
    }
    function hz(n) {
        let e = "0x";
        for (const t of n)e += (t >> 4).toString(16) + (t & 15).toString(16);
        return e;
    }
    const Ld = 4, Ud = 16, dz = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        255,
        255
    ]);
    function IC(n, e) {
        e.length === Ud && n.length === Ld && az(e, 0, 11) && (e = e.slice(12)), e.length === Ld && n.length === Ud && lz(n, dz, 0, 11) && (n = n.slice(12));
        const t = n.length;
        if (t != e.length) throw new Error("Failed to mask ip");
        const r = new Uint8Array(t);
        for(let s = 0; s < t; s++)r[s] = n[s] & e[s];
        return r;
    }
    function fz(n, e) {
        if (typeof e == "string" && (e = zy(e)), e == null) throw new Error("Invalid ip");
        if (e.length !== n.network.length) return !1;
        for(let t = 0; t < e.length; t++)if ((n.network[t] & n.mask[t]) !== (e[t] & n.mask[t])) return !1;
        return !0;
    }
    function pz(n) {
        const [e, t] = n.split("/");
        if (!e || !t) throw new Error("Failed to parse given CIDR: " + n);
        let r = Ld, s = AC(e);
        if (s == null && (r = Ud, s = SC(e), s == null)) throw new Error("Failed to parse given CIDR: " + n);
        const i = parseInt(t, 10);
        if (Number.isNaN(i) || String(i).length !== t.length || i < 0 || i > r * 8) throw new Error("Failed to parse given CIDR: " + n);
        const l = CC(i, 8 * r);
        return {
            network: IC(s, l),
            mask: l
        };
    }
    function CC(n, e) {
        if (e !== 8 * Ld && e !== 8 * Ud) throw new Error("Invalid CIDR mask");
        if (n < 0 || n > e) throw new Error("Invalid CIDR mask");
        const t = e / 8, r = new Uint8Array(t);
        for(let s = 0; s < t; s++){
            if (n >= 8) {
                r[s] = 255, n -= 8;
                continue;
            }
            r[s] = 255 - (255 >> n), n = 0;
        }
        return r;
    }
    class TC {
        constructor(e, t){
            if (t == null) ({ network: this.network, mask: this.mask } = pz(e));
            else {
                const r = zy(e);
                if (r == null) throw new Error("Failed to parse network");
                t = String(t);
                const s = parseInt(t, 10);
                if (Number.isNaN(s) || String(s).length !== t.length || s < 0 || s > r.length * 8) {
                    const i = zy(t);
                    if (i == null) throw new Error("Failed to parse mask");
                    this.mask = i;
                } else this.mask = CC(s, 8 * r.length);
                this.network = IC(r, this.mask);
            }
        }
        contains(e) {
            return fz({
                network: this.network,
                mask: this.mask
            }, e);
        }
        toString() {
            const e = uz(this.mask), t = e !== -1 ? String(e) : hz(this.mask);
            return cz(this.network) + "/" + t;
        }
    }
    function gz(n, e) {
        return new TC(n).contains(e);
    }
    function _C(n) {
        try {
            const e = Xe(n);
            return e.type === "ip6" ? gz("2000::/3", e.host) : !1;
        } catch  {
            return !1;
        }
    }
    function mz(n) {
        try {
            const e = Xe(n);
            switch(e.type){
                case "ip4":
                    return e.host.startsWith("169.254.");
                case "ip6":
                    return e.host.toLowerCase().startsWith("fe80");
                default:
                    return !1;
            }
        } catch  {
            return !1;
        }
    }
    function yz(n) {
        return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n) || /^::1$/.test(n);
    }
    function Fy(n) {
        try {
            const e = Xe(n);
            switch(e.type){
                case "ip4":
                case "ip6":
                    return yz(e.host);
                default:
                    return !1;
            }
        } catch  {
            return !1;
        }
    }
    function zs(n) {
        try {
            return Xe(n), !0;
        } catch  {
            return !1;
        }
    }
    function Je(n) {
        return !!AC(n);
    }
    function xn(n) {
        return !!SC(n);
    }
    var Hl = {}, W9;
    function wz() {
        return W9 || (W9 = 1, (function() {
            var n, e, t, r, s, i, l, u;
            u = function(h) {
                var f, p, m, w;
                return f = (h & 255 << 24) >>> 24, p = (h & 255 << 16) >>> 16, m = (h & 65280) >>> 8, w = h & 255, [
                    f,
                    p,
                    m,
                    w
                ].join(".");
            }, l = function(h) {
                var f, p, m, w, A, S;
                for(f = [], m = w = 0; w <= 3 && h.length !== 0; m = ++w){
                    if (m > 0) {
                        if (h[0] !== ".") throw new Error("Invalid IP");
                        h = h.substring(1);
                    }
                    S = e(h), A = S[0], p = S[1], h = h.substring(p), f.push(A);
                }
                if (h.length !== 0) throw new Error("Invalid IP");
                switch(f.length){
                    case 1:
                        if (f[0] > 4294967295) throw new Error("Invalid IP");
                        return f[0] >>> 0;
                    case 2:
                        if (f[0] > 255 || f[1] > 16777215) throw new Error("Invalid IP");
                        return (f[0] << 24 | f[1]) >>> 0;
                    case 3:
                        if (f[0] > 255 || f[1] > 255 || f[2] > 65535) throw new Error("Invalid IP");
                        return (f[0] << 24 | f[1] << 16 | f[2]) >>> 0;
                    case 4:
                        if (f[0] > 255 || f[1] > 255 || f[2] > 255 || f[3] > 255) throw new Error("Invalid IP");
                        return (f[0] << 24 | f[1] << 16 | f[2] << 8 | f[3]) >>> 0;
                    default:
                        throw new Error("Invalid IP");
                }
            }, t = function(h) {
                return h.charCodeAt(0);
            }, r = t("0"), i = t("a"), s = t("A"), e = function(h) {
                var f, p, m, w, A;
                for(w = 0, f = 10, p = "9", m = 0, h.length > 1 && h[m] === "0" && (h[m + 1] === "x" || h[m + 1] === "X" ? (m += 2, f = 16) : "0" <= h[m + 1] && h[m + 1] <= "9" && (m++, f = 8, p = "7")), A = m; m < h.length;){
                    if ("0" <= h[m] && h[m] <= p) w = w * f + (t(h[m]) - r) >>> 0;
                    else if (f === 16) if ("a" <= h[m] && h[m] <= "f") w = w * f + (10 + t(h[m]) - i) >>> 0;
                    else if ("A" <= h[m] && h[m] <= "F") w = w * f + (10 + t(h[m]) - s) >>> 0;
                    else break;
                    else break;
                    if (w > 4294967295) throw new Error("too large");
                    m++;
                }
                if (m === A) throw new Error("empty octet");
                return [
                    w,
                    m
                ];
            }, n = (function() {
                function h(f, p) {
                    var m, w, A;
                    if (typeof f != "string") throw new Error("Missing `net' parameter");
                    if (p || (A = f.split("/", 2), f = A[0], p = A[1]), p || (p = 32), typeof p == "string" && p.indexOf(".") > -1) {
                        try {
                            this.maskLong = l(p);
                        } catch  {
                            throw new Error("Invalid mask: " + p);
                        }
                        for(m = w = 32; w >= 0; m = --w)if (this.maskLong === 4294967295 << 32 - m >>> 0) {
                            this.bitmask = m;
                            break;
                        }
                    } else if (p || p === 0) this.bitmask = parseInt(p, 10), this.maskLong = 0, this.bitmask > 0 && (this.maskLong = 4294967295 << 32 - this.bitmask >>> 0);
                    else throw new Error("Invalid mask: empty");
                    try {
                        this.netLong = (l(f) & this.maskLong) >>> 0;
                    } catch  {
                        throw new Error("Invalid net address: " + f);
                    }
                    if (!(this.bitmask <= 32)) throw new Error("Invalid mask for ip4: " + p);
                    this.size = Math.pow(2, 32 - this.bitmask), this.base = u(this.netLong), this.mask = u(this.maskLong), this.hostmask = u(~this.maskLong), this.first = this.bitmask <= 30 ? u(this.netLong + 1) : this.base, this.last = this.bitmask <= 30 ? u(this.netLong + this.size - 2) : u(this.netLong + this.size - 1), this.broadcast = this.bitmask <= 30 ? u(this.netLong + this.size - 1) : void 0;
                }
                return h.prototype.contains = function(f) {
                    return typeof f == "string" && (f.indexOf("/") > 0 || f.split(".").length !== 4) && (f = new h(f)), f instanceof h ? this.contains(f.base) && this.contains(f.broadcast || f.last) : (l(f) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
                }, h.prototype.next = function(f) {
                    return f == null && (f = 1), new h(u(this.netLong + this.size * f), this.mask);
                }, h.prototype.forEach = function(f) {
                    var p, m, w;
                    for(w = l(this.first), m = l(this.last), p = 0; w <= m;)f(u(w), w, p), p++, w++;
                }, h.prototype.toString = function() {
                    return this.base + "/" + this.bitmask;
                }, h;
            })(), Hl.ip2long = l, Hl.long2ip = u, Hl.Netmask = n;
        }).call(Hl)), Hl;
    }
    var bz = wz();
    const vz = [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "100.64.0.0/10",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.0.0.0/24",
        "192.0.0.0/29",
        "192.0.0.8/32",
        "192.0.0.9/32",
        "192.0.0.10/32",
        "192.0.0.170/32",
        "192.0.0.171/32",
        "192.0.2.0/24",
        "192.31.196.0/24",
        "192.52.193.0/24",
        "192.88.99.0/24",
        "192.168.0.0/16",
        "192.175.48.0/24",
        "198.18.0.0/15",
        "198.51.100.0/24",
        "203.0.113.0/24",
        "240.0.0.0/4",
        "255.255.255.255/32"
    ], Ez = vz.map((n)=>new bz.Netmask(n));
    function T6(n) {
        for (const e of Ez)if (e.contains(n)) return !0;
        return !1;
    }
    function Az(n) {
        return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n);
    }
    function Sz(n) {
        const e = n.split(":");
        if (e.length < 2) return !1;
        const t = e[e.length - 1].padStart(4, "0"), r = e[e.length - 2].padStart(4, "0"), s = `${parseInt(r.substring(0, 2), 16)}.${parseInt(r.substring(2), 16)}.${parseInt(t.substring(0, 2), 16)}.${parseInt(t.substring(2), 16)}`;
        return T6(s);
    }
    function Iz(n) {
        return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n);
    }
    function Cz(n) {
        const e = n.split(":"), t = e[e.length - 1];
        return T6(t);
    }
    function Tz(n) {
        return /^::$/.test(n) || /^::1$/.test(n) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n) || /^ff([0-9a-fA-F]{2,2}):/i.test(n);
    }
    function _6(n) {
        if (Je(n)) return T6(n);
        if (Az(n)) return Sz(n);
        if (Iz(n)) return Cz(n);
        if (xn(n)) return Tz(n);
    }
    function Is(n) {
        try {
            const e = Xe(n);
            switch(e.type){
                case "ip4":
                case "ip6":
                    return _6(e.host) ?? !1;
                default:
                    return e.host === "localhost";
            }
        } catch  {
            return !1;
        }
    }
    function xt() {
        const n = {};
        return n.promise = new Promise((e, t)=>{
            n.resolve = e, n.reject = t;
        }), n;
    }
    class j9 {
        buffer;
        mask;
        top;
        btm;
        next;
        constructor(e){
            if (!(e > 0) || (e - 1 & e) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
            this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null;
        }
        push(e) {
            return this.buffer[this.top] !== void 0 ? !1 : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, !0);
        }
        shift() {
            const e = this.buffer[this.btm];
            if (e !== void 0) return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e;
        }
        isEmpty() {
            return this.buffer[this.btm] === void 0;
        }
    }
    class E3 {
        size;
        hwm;
        head;
        tail;
        constructor(e = {}){
            this.hwm = e.splitLimit ?? 16, this.head = new j9(this.hwm), this.tail = this.head, this.size = 0;
        }
        calculateSize(e) {
            return e?.byteLength != null ? e.byteLength : 1;
        }
        push(e) {
            if (e?.value != null && (this.size += this.calculateSize(e.value)), !this.head.push(e)) {
                const t = this.head;
                this.head = t.next = new j9(2 * this.head.buffer.length), this.head.push(e);
            }
        }
        shift() {
            let e = this.tail.shift();
            if (e === void 0 && this.tail.next != null) {
                const t = this.tail.next;
                this.tail.next = null, this.tail = t, e = this.tail.shift();
            }
            return e?.value != null && (this.size -= this.calculateSize(e.value)), e;
        }
        isEmpty() {
            return this.head.isEmpty();
        }
    }
    let _z = class extends Error {
        type;
        code;
        constructor(e, t){
            super(e ?? "The operation was aborted"), this.type = "aborted", this.code = t ?? "ABORT_ERR";
        }
    };
    function Hs(n = {}) {
        return xz((t)=>{
            const r = t.shift();
            if (r == null) return {
                done: !0
            };
            if (r.error != null) throw r.error;
            return {
                done: r.done === !0,
                value: r.value
            };
        }, n);
    }
    function xz(n, e) {
        e = e ?? {};
        let t = e.onEnd, r = new E3, s, i, l, u = xt();
        const h = async ()=>{
            try {
                return r.isEmpty() ? l ? {
                    done: !0
                } : await new Promise((I, k)=>{
                    i = (G)=>{
                        i = null, r.push(G);
                        try {
                            I(n(r));
                        } catch (P) {
                            k(P);
                        }
                        return s;
                    };
                }) : n(r);
            } finally{
                r.isEmpty() && queueMicrotask(()=>{
                    u.resolve(), u = xt();
                });
            }
        }, f = (I)=>i != null ? i(I) : (r.push(I), s), p = (I)=>(r = new E3, i != null ? i({
                error: I
            }) : (r.push({
                error: I
            }), s)), m = (I)=>{
            if (l) return s;
            if (e?.objectMode !== !0 && I?.byteLength == null) throw new Error("objectMode was not true but tried to push non-Uint8Array value");
            return f({
                done: !1,
                value: I
            });
        }, w = (I)=>l ? s : (l = !0, I != null ? p(I) : f({
                done: !0
            })), A = ()=>(r = new E3, w(), {
                done: !0
            }), S = (I)=>(w(I), {
                done: !0
            });
        if (s = {
            [Symbol.asyncIterator] () {
                return this;
            },
            next: h,
            return: A,
            throw: S,
            push: m,
            end: w,
            get readableLength () {
                return r.size;
            },
            onEmpty: async (I)=>{
                const k = I?.signal;
                if (k?.throwIfAborted(), r.isEmpty()) return;
                let G, P;
                k != null && (G = new Promise((J, H)=>{
                    P = ()=>{
                        H(new _z);
                    }, k.addEventListener("abort", P);
                }));
                try {
                    await Promise.race([
                        u.promise,
                        G
                    ]);
                } finally{
                    P != null && k != null && k?.removeEventListener("abort", P);
                }
            }
        }, t == null) return s;
        const _ = s;
        return s = {
            [Symbol.asyncIterator] () {
                return this;
            },
            next () {
                return _.next();
            },
            throw (I) {
                return _.throw(I), t != null && (t(I), t = void 0), {
                    done: !0
                };
            },
            return () {
                return _.return(), t != null && (t(), t = void 0), {
                    done: !0
                };
            },
            push: m,
            end (I) {
                return _.end(I), t != null && (t(I), t = void 0), s;
            },
            get readableLength () {
                return _.readableLength;
            },
            onEmpty: (I)=>_.onEmpty(I)
        }, s;
    }
    const Dz = (n)=>{
        const e = n.addEventListener || n.on || n.addListener, t = n.removeEventListener || n.off || n.removeListener;
        if (!e || !t) throw new TypeError("Emitter is not compatible");
        return {
            addListener: e.bind(n),
            removeListener: t.bind(n)
        };
    };
    function Bz(n, e, t) {
        let r;
        const s = new Promise((i, l)=>{
            if (t = {
                rejectionEvents: [
                    "error"
                ],
                multiArgs: !1,
                rejectionMultiArgs: !1,
                resolveImmediately: !1,
                ...t
            }, !(t.count >= 0 && (t.count === Number.POSITIVE_INFINITY || Number.isInteger(t.count)))) throw new TypeError("The `count` option should be at least 0 or more");
            t.signal?.throwIfAborted();
            const u = [
                e
            ].flat(), h = [], { addListener: f, removeListener: p } = Dz(n), m = async (...A)=>{
                const S = t.multiArgs ? A : A[0];
                if (t.filter) try {
                    if (!await t.filter(S)) return;
                } catch (_) {
                    r(), l(_);
                    return;
                }
                h.push(S), t.count === h.length && (r(), i(h));
            }, w = (...A)=>{
                r(), l(t.rejectionMultiArgs ? A : A[0]);
            };
            r = ()=>{
                for (const A of u)p(A, m);
                for (const A of t.rejectionEvents)u.includes(A) || p(A, w);
            };
            for (const A of u)f(A, m);
            for (const A of t.rejectionEvents)u.includes(A) || f(A, w);
            t.signal && t.signal.addEventListener("abort", ()=>{
                w(t.signal.reason);
            }, {
                once: !0
            }), t.resolveImmediately && i(h);
        });
        if (s.cancel = r, typeof t.timeout == "number") {
            const i = j4(s, {
                milliseconds: t.timeout
            });
            return i.cancel = ()=>{
                r(), i.clear();
            }, i;
        }
        return s;
    }
    function an(n, e, t) {
        typeof t == "function" && (t = {
            filter: t
        }), t = {
            ...t,
            count: 1,
            resolveImmediately: !1
        };
        const r = Bz(n, e, t), s = r.then((i)=>i[0]);
        return s.cancel = r.cancel, s;
    }
    function zd(n, e) {
        let t;
        const r = function() {
            const s = function() {
                t = void 0, n();
            };
            clearTimeout(t), t = setTimeout(s, e);
        };
        return r.start = ()=>{}, r.stop = ()=>{
            clearTimeout(t);
        }, r;
    }
    class Pz extends Error {
        remainingPoints;
        msBeforeNext;
        consumedPoints;
        isFirstInDuration;
        constructor(e = "Rate limit exceeded", t){
            super(e), this.name = "RateLimitError", this.remainingPoints = t.remainingPoints, this.msBeforeNext = t.msBeforeNext, this.consumedPoints = t.consumedPoints, this.isFirstInDuration = t.isFirstInDuration;
        }
    }
    let kz = class extends Error {
        static name = "QueueFullError";
        constructor(e = "The queue was full"){
            super(e), this.name = "QueueFullError";
        }
    }, Ip = class extends Error {
        static name = "UnexpectedEOFError";
        name = "UnexpectedEOFError";
    };
    class Rz extends Error {
        static name = "MaxEarlyStreamsError";
        name = "MaxEarlyStreamsError";
    }
    class Oz extends Error {
        static name = "StreamClosedError";
        name = "StreamClosedError";
    }
    function $z(n) {
        return n.reason;
    }
    async function Xn(n, e, t) {
        if (e == null) return n;
        const r = t?.translateError ?? $z;
        if (e.aborted) return n.catch(()=>{}), Promise.reject(r(e));
        let s;
        try {
            return await Promise.race([
                n,
                new Promise((i, l)=>{
                    s = ()=>{
                        l(r(e));
                    }, e.addEventListener("abort", s);
                })
            ]);
        } finally{
            s != null && e.removeEventListener("abort", s);
        }
    }
    let Mz = class {
        deferred;
        signal;
        constructor(e){
            this.signal = e, this.deferred = xt(), this.onAbort = this.onAbort.bind(this), this.signal?.addEventListener("abort", this.onAbort);
        }
        onAbort() {
            this.deferred.reject(this.signal?.reason ?? new Sp);
        }
        cleanup() {
            this.signal?.removeEventListener("abort", this.onAbort);
        }
    };
    function Nz() {
        return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
    }
    let Lz = class {
        id;
        fn;
        options;
        recipients;
        status;
        timeline;
        controller;
        constructor(e, t){
            this.id = Nz(), this.status = "queued", this.fn = e, this.options = t, this.recipients = [], this.timeline = {
                created: Date.now()
            }, this.controller = new AbortController, this.controller.signal, this.onAbort = this.onAbort.bind(this);
        }
        abort(e) {
            this.controller.abort(e);
        }
        onAbort() {
            this.recipients.reduce((t, r)=>t && r.signal?.aborted === !0, !0) && (this.controller.abort(new Sp), this.cleanup());
        }
        async join(e = {}) {
            const t = new Mz(e.signal);
            return this.recipients.push(t), e.signal?.addEventListener("abort", this.onAbort), t.deferred.promise;
        }
        async run() {
            this.status = "running", this.timeline.started = Date.now();
            try {
                this.controller.signal.throwIfAborted();
                const e = await Xn(this.fn({
                    ...this.options ?? {},
                    signal: this.controller.signal
                }), this.controller.signal);
                this.recipients.forEach((t)=>{
                    t.deferred.resolve(e);
                }), this.status = "complete";
            } catch (e) {
                this.recipients.forEach((t)=>{
                    t.deferred.reject(e);
                }), this.status = "errored";
            } finally{
                this.timeline.finished = Date.now(), this.cleanup();
            }
        }
        cleanup() {
            this.recipients.forEach((e)=>{
                e.cleanup(), e.signal?.removeEventListener("abort", this.onAbort);
            });
        }
    }, Yo = class extends Lt {
        concurrency;
        maxSize;
        queue;
        pending;
        sort;
        paused;
        constructor(e = {}){
            super(), this.concurrency = e.concurrency ?? Number.POSITIVE_INFINITY, this.maxSize = e.maxSize ?? Number.POSITIVE_INFINITY, this.pending = 0, this.paused = !1, e.metricName != null && e.metrics?.registerMetricGroup(e.metricName, {
                calculate: ()=>({
                        size: this.queue.length,
                        running: this.pending,
                        queued: this.queue.length - this.pending
                    })
            }), this.sort = e.sort, this.queue = [], this.emitEmpty = zd(this.emitEmpty.bind(this), 1), this.emitIdle = zd(this.emitIdle.bind(this), 1);
        }
        emitEmpty() {
            this.size === 0 && this.safeDispatchEvent("empty");
        }
        emitIdle() {
            this.running === 0 && this.safeDispatchEvent("idle");
        }
        pause() {
            this.paused = !0;
        }
        resume() {
            this.paused && (this.paused = !1, this.tryToStartAnother());
        }
        tryToStartAnother() {
            if (this.paused) return !1;
            if (this.size === 0) return this.emitEmpty(), this.running === 0 && this.emitIdle(), !1;
            if (this.pending < this.concurrency) {
                let e;
                for (const t of this.queue)if (t.status === "queued") {
                    e = t;
                    break;
                }
                return e == null ? !1 : (this.safeDispatchEvent("active"), this.pending++, e.run().finally(()=>{
                    for(let t = 0; t < this.queue.length; t++)if (this.queue[t] === e) {
                        this.queue.splice(t, 1);
                        break;
                    }
                    this.pending--, this.tryToStartAnother(), this.safeDispatchEvent("next");
                }), !0);
            }
            return !1;
        }
        enqueue(e) {
            this.queue.push(e), this.sort != null && this.queue.sort(this.sort);
        }
        async add(e, t) {
            if (t?.signal?.throwIfAborted(), this.size === this.maxSize) throw new kz;
            const r = new Lz(e, t);
            return this.enqueue(r), this.safeDispatchEvent("add"), this.tryToStartAnother(), r.join(t).then((s)=>(this.safeDispatchEvent("completed", {
                    detail: s
                }), this.safeDispatchEvent("success", {
                    detail: {
                        job: r,
                        result: s
                    }
                }), s)).catch((s)=>{
                if (r.status === "queued") {
                    for(let i = 0; i < this.queue.length; i++)if (this.queue[i] === r) {
                        this.queue.splice(i, 1);
                        break;
                    }
                }
                throw this.safeDispatchEvent("failure", {
                    detail: {
                        job: r,
                        error: s
                    }
                }), s;
            });
        }
        clear() {
            this.queue.splice(0, this.queue.length);
        }
        abort() {
            this.queue.forEach((e)=>{
                e.abort(new Sp);
            }), this.clear();
        }
        async onEmpty(e) {
            this.size !== 0 && await an(this, "empty", e);
        }
        async onSizeLessThan(e, t) {
            this.size < e || await an(this, "next", {
                ...t,
                filter: ()=>this.size < e
            });
        }
        async onIdle(e) {
            this.pending === 0 && this.size === 0 || await an(this, "idle", e);
        }
        get size() {
            return this.queue.length;
        }
        get queued() {
            return this.queue.length - this.pending;
        }
        get running() {
            return this.pending;
        }
        async *toGenerator(e) {
            e?.signal?.throwIfAborted();
            const t = Hs({
                objectMode: !0
            }), r = (h)=>{
                h != null ? this.abort() : this.clear(), t.end(h);
            }, s = (h)=>{
                h.detail != null && t.push(h.detail);
            }, i = (h)=>{
                r(h.detail.error);
            }, l = ()=>{
                r();
            }, u = ()=>{
                r(new Sp("Queue aborted"));
            };
            this.addEventListener("completed", s), this.addEventListener("failure", i), this.addEventListener("idle", l), e?.signal?.addEventListener("abort", u);
            try {
                yield* t;
            } finally{
                this.removeEventListener("completed", s), this.removeEventListener("failure", i), this.removeEventListener("idle", l), e?.signal?.removeEventListener("abort", u), r();
            }
        }
    };
    const Uz = Math.pow(2, 20) * 4;
    class x6 extends Lt {
        status;
        timeline;
        inactivityTimeout;
        maxReadBufferLength;
        maxWriteBufferLength;
        log;
        direction;
        maxMessageSize;
        readStatus;
        writeStatus;
        remoteReadStatus;
        remoteWriteStatus;
        writableNeedsDrain;
        readBuffer;
        writeBuffer;
        sendingData;
        onDrainPromise;
        constructor(e){
            super(), this.status = "open", this.log = e.log, this.direction = e.direction ?? "outbound", this.inactivityTimeout = e.inactivityTimeout ?? 12e4, this.maxReadBufferLength = e.maxReadBufferLength ?? Uz, this.maxWriteBufferLength = e.maxWriteBufferLength, this.maxMessageSize = e.maxMessageSize, this.readBuffer = new Re, this.writeBuffer = new Re, this.readStatus = "readable", this.remoteReadStatus = "readable", this.writeStatus = "writable", this.remoteWriteStatus = "writable", this.sendingData = !1, this.writableNeedsDrain = !1, this.timeline = {
                open: Date.now()
            }, this.processSendQueue = this.processSendQueue.bind(this);
            const t = ()=>{
                this.writableNeedsDrain && (this.log.trace("drain event received, continue sending data"), this.writableNeedsDrain = !1, this.processSendQueue()), this.onDrainPromise?.resolve();
            };
            this.addEventListener("drain", t);
            const r = (s)=>{
                this.onDrainPromise?.reject(s.error ?? new Oz);
            };
            this.addEventListener("close", r);
        }
        get readBufferLength() {
            return this.readBuffer.byteLength;
        }
        get writeBufferLength() {
            return this.writeBuffer.byteLength;
        }
        async onDrain(e) {
            return this.writableNeedsDrain !== !0 ? Promise.resolve() : (this.onDrainPromise == null && (this.onDrainPromise = Promise.withResolvers()), Xn(this.onDrainPromise.promise, e?.signal));
        }
        async *[Symbol.asyncIterator]() {
            if (this.readStatus !== "readable" && this.readStatus !== "paused") return;
            const e = Hs(), t = (i)=>{
                e.push(i.data);
            };
            this.addEventListener("message", t);
            const r = (i)=>{
                e.end(i.error);
            };
            this.addEventListener("close", r);
            const s = ()=>{
                e.end();
            };
            this.addEventListener("remoteCloseWrite", s);
            try {
                yield* e;
            } finally{
                this.removeEventListener("message", t), this.removeEventListener("close", r), this.removeEventListener("remoteCloseWrite", s);
            }
        }
        isReadable() {
            return this.status === "open";
        }
        send(e) {
            if (this.writeStatus === "closed" || this.writeStatus === "closing") throw new Th(`Cannot write to a stream that is ${this.writeStatus}`);
            return this.log.trace("append %d bytes to write buffer", e.byteLength), this.writeBuffer.append(e), this.processSendQueue();
        }
        abort(e) {
            if (!(this.status === "aborted" || this.status === "reset" || this.status === "closed")) {
                this.log.error("abort with error - %e", e), this.status = "aborted", this.readBuffer.byteLength > 0 && this.readBuffer.consume(this.readBuffer.byteLength), this.writeBuffer.byteLength > 0 && (this.writeBuffer.consume(this.writeBuffer.byteLength), this.safeDispatchEvent("idle")), this.writeStatus = "closed", this.remoteWriteStatus = "closed", this.readStatus = "closed", this.remoteReadStatus = "closed", this.timeline.close = Date.now();
                try {
                    this.sendReset(e);
                } catch (t) {
                    this.log("failed to send reset to remote - %e", t);
                }
                this.dispatchEvent(new rz(e));
            }
        }
        pause() {
            if (this.readStatus === "closed" || this.readStatus === "closing") throw new Th("Cannot pause a stream that is closing/closed");
            this.readStatus !== "paused" && (this.readStatus = "paused", this.sendPause());
        }
        resume() {
            if (this.readStatus === "closed" || this.readStatus === "closing") throw new Th("Cannot resume a stream that is closing/closed");
            this.readStatus !== "readable" && (this.readStatus = "readable", this.dispatchReadBuffer(), this.sendResume());
        }
        push(e) {
            if (this.readStatus === "closed" || this.readStatus === "closing") throw new Th(`Cannot push data onto a stream that is ${this.readStatus}`);
            if (e.byteLength !== 0) {
                if (this.readBuffer.append(e), this.readStatus === "paused" || this.listenerCount("message") === 0) {
                    this.checkReadBufferLength();
                    return;
                }
                setTimeout(()=>{
                    this.dispatchReadBuffer();
                }, 0);
            }
        }
        unshift(e) {
            if (this.readStatus === "closed" || this.readStatus === "closing") throw new Th(`Cannot push data onto a stream that is ${this.readStatus}`);
            if (e.byteLength !== 0) {
                if (this.readBuffer.prepend(e), this.readStatus === "paused" || this.listenerCount("message") === 0) {
                    this.checkReadBufferLength();
                    return;
                }
                setTimeout(()=>{
                    this.dispatchReadBuffer();
                }, 0);
            }
        }
        onData(e) {
            if (e.byteLength !== 0) {
                if (this.readStatus === "closing" || this.readStatus === "closed") {
                    this.log("ignoring data - read status %s", this.readStatus);
                    return;
                }
                this.readBuffer.append(e), this.dispatchReadBuffer();
            }
        }
        addEventListener(...e) {
            super.addEventListener.apply(this, e), e[0] === "message" && this.readBuffer.byteLength > 0 && queueMicrotask(()=>{
                this.dispatchReadBuffer();
            });
        }
        onRemoteReset() {
            this.log("remote reset"), this.status = "reset", this.writeStatus = "closed", this.remoteWriteStatus = "closed", this.remoteReadStatus = "closed", this.timeline.close = Date.now(), this.readBuffer.byteLength === 0 && (this.readStatus = "closed");
            const e = new tz;
            this.dispatchEvent(new sz(e));
        }
        onTransportClosed(e) {
            this.log("transport closed"), this.readStatus === "readable" && this.readBuffer.byteLength === 0 && (this.log("close readable end after transport closed and read buffer is empty"), this.readStatus = "closed"), this.remoteReadStatus !== "closed" && (this.remoteReadStatus = "closed"), this.remoteWriteStatus !== "closed" && (this.remoteWriteStatus = "closed"), this.writeStatus !== "closed" && (this.writeStatus = "closed"), e != null ? this.abort(e) : (this.status === "open" || this.status === "closing") && (this.timeline.close = Date.now(), this.status = "closed", this.writeStatus = "closed", this.remoteWriteStatus = "closed", this.remoteReadStatus = "closed", this.dispatchEvent(new C6));
        }
        onRemoteCloseWrite() {
            this.remoteWriteStatus !== "closed" && (this.log.trace("on remote close write"), this.remoteWriteStatus = "closed", this.safeDispatchEvent("remoteCloseWrite"), this.writeStatus === "closed" && this.onTransportClosed());
        }
        onRemoteCloseRead() {
            this.log.trace("on remote close read"), this.remoteReadStatus = "closed", this.writeBuffer.byteLength > 0 && (this.writeBuffer.consume(this.writeBuffer.byteLength), this.safeDispatchEvent("idle"));
        }
        processSendQueue() {
            if (this.writableNeedsDrain) return this.log.trace("not processing send queue as drain is required"), this.checkWriteBufferLength(), !1;
            if (this.writeBuffer.byteLength === 0) return this.log.trace("not processing send queue as no bytes to send"), !0;
            if (this.sendingData) return this.log.trace("not processing send queue as already sending data"), !0;
            this.sendingData = !0, this.log.trace("processing send queue with %d queued bytes", this.writeBuffer.byteLength);
            try {
                let e = !0;
                const t = this.writeBuffer.byteLength;
                let r = 0;
                for(; this.writeBuffer.byteLength > 0;){
                    const s = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength);
                    if (s === 0) {
                        e = !1;
                        break;
                    }
                    const i = this.writeBuffer.sublist(0, s), l = new Re(i);
                    this.writeBuffer.consume(i.byteLength);
                    const u = this.sendData(i);
                    if (e = u.canSendMore, r += u.sentBytes, u.sentBytes !== l.byteLength && (l.consume(u.sentBytes), this.writeBuffer.prepend(l)), !e) break;
                }
                return e || (this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer", r, t, this.writeBuffer.byteLength), this.writableNeedsDrain = !0, this.checkWriteBufferLength()), this.writeBuffer.byteLength === 0 && this.safeDispatchEvent("idle"), e;
            } finally{
                this.sendingData = !1;
            }
        }
        dispatchReadBuffer() {
            try {
                if (this.listenerCount("message") === 0) {
                    this.log.trace("not dispatching pause buffer as there are no listeners for the message event");
                    return;
                }
                if (this.readBuffer.byteLength === 0) {
                    this.log.trace("not dispatching pause buffer as there is no data to dispatch");
                    return;
                }
                if (this.readStatus === "paused") {
                    this.log.trace("not dispatching pause buffer we are paused");
                    return;
                }
                if (this.readStatus === "closing" || this.readStatus === "closed") {
                    this.log("dropping %d bytes because the readable end is %s", this.readBuffer.byteLength, this.readStatus), this.readBuffer.consume(this.readBuffer.byteLength);
                    return;
                }
                const e = this.readBuffer.sublist();
                this.readBuffer.consume(e.byteLength), this.dispatchEvent(new nz(e));
            } finally{
                this.readBuffer.byteLength === 0 && this.remoteWriteStatus === "closed" && (this.log("close readable end after dispatching read buffer and remote writable end is closed"), this.readStatus = "closed"), this.checkReadBufferLength();
            }
        }
        checkReadBufferLength() {
            this.readBuffer.byteLength > this.maxReadBufferLength && this.abort(new Y9(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`));
        }
        checkWriteBufferLength() {
            this.maxWriteBufferLength != null && this.writeBuffer.byteLength > this.maxWriteBufferLength && this.abort(new Y9(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`));
        }
        onMuxerNeedsDrain() {
            this.writableNeedsDrain = !0;
        }
        onMuxerDrain() {
            this.safeDispatchEvent("drain");
        }
    }
    class D6 extends x6 {
        remoteAddr;
        metricPrefix;
        metrics;
        constructor(e){
            super(e), this.metricPrefix = e.metricPrefix ?? "", this.metrics = e.metrics, this.remoteAddr = e.remoteAddr, this.addEventListener("close", (t)=>{
                this.metrics?.increment({
                    [`${this.metricPrefix}end`]: !0
                }), t.error != null ? t.local ? this.metrics?.increment({
                    [`${this.metricPrefix}abort`]: !0
                }) : this.metrics?.increment({
                    [`${this.metricPrefix}reset`]: !0
                }) : t.local ? this.metrics?.increment({
                    [`${this.metricPrefix}_local_close`]: !0
                }) : this.metrics?.increment({
                    [`${this.metricPrefix}_remote_close`]: !0
                });
            });
        }
        async close(e) {
            this.status === "open" && (this.status = "closing", this.writeStatus = "closing", this.remoteWriteStatus = "closing", this.remoteReadStatus = "closing", (this.sendingData || this.writeBuffer.byteLength > 0) && (this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength), await an(this, "idle", {
                ...e,
                rejectionEvents: [
                    "close"
                ]
            })), this.writableNeedsDrain && (this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength), await an(this, "drain", {
                ...e,
                rejectionEvents: [
                    "close"
                ]
            })), await this.sendClose(e), this.onTransportClosed());
        }
    }
    function xC(n) {
        return n == null ? !1 : typeof n.then == "function" && typeof n.catch == "function" && typeof n.finally == "function";
    }
    class B6 extends Lt {
        streams;
        protocol;
        status;
        log;
        maConn;
        streamOptions;
        earlyStreams;
        maxEarlyStreams;
        metrics;
        constructor(e, t){
            super(), this.maConn = e, this.protocol = t.protocol, this.streams = [], this.earlyStreams = [], this.status = "open", this.log = e.log.newScope(t.name), this.streamOptions = t.streamOptions, this.maxEarlyStreams = t.maxEarlyStreams ?? 10, this.metrics = t.metrics;
            const r = (l)=>{
                try {
                    this.onData(l.data);
                } catch (u) {
                    this.abort(u), this.maConn.abort(u);
                }
            };
            this.maConn.addEventListener("message", r);
            const s = ()=>{
                this.log("underlying stream drained, signal %d streams to continue writing", this.streams.length), this.streams.forEach((l)=>{
                    l.onMuxerDrain();
                });
            };
            this.maConn.addEventListener("drain", s);
            const i = ()=>{
                this.log("underlying stream closed with status %s and %d streams", this.status, this.streams.length), this.onTransportClosed();
            };
            this.maConn.addEventListener("close", i);
        }
        send(e) {
            const t = this.maConn.send(e);
            return t === !1 && (this.log("underlying stream saturated, signal %d streams to pause writing", this.streams.length), this.streams.forEach((r)=>{
                r.onMuxerNeedsDrain();
            })), t;
        }
        async close(e) {
            this.status === "closed" || this.status === "closing" || (this.status = "closing", await Xn(Promise.all([
                ...this.streams
            ].map(async (t)=>{
                await t.close(e);
            })), e?.signal), this.status = "closed");
        }
        abort(e) {
            this.status !== "closed" && (this.status = "closing", [
                ...this.streams
            ].forEach((t)=>{
                t.abort(e);
            }), this.status = "closed");
        }
        onTransportClosed(e) {
            this.status = "closing";
            try {
                [
                    ...this.streams
                ].forEach((t)=>{
                    t.onTransportClosed(e);
                });
            } catch (t) {
                this.abort(t);
            }
            this.status = "closed";
        }
        async createStream(e) {
            if (this.status !== "open") throw new ez;
            let t = this.onCreateStream({
                ...this.streamOptions,
                ...e
            });
            return xC(t) && (t = await t), this.streams.push(t), this.cleanUpStream(t), t;
        }
        onRemoteStream(e) {
            if (this.streams.push(e), this.cleanUpStream(e), this.listenerCount("stream") === 0) {
                this.earlyStreams.push(e), this.earlyStreams.length > this.maxEarlyStreams && this.abort(new Rz(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));
                return;
            }
            this.safeDispatchEvent("stream", {
                detail: e
            });
        }
        cleanUpStream(e) {
            const t = (r)=>{
                const s = this.streams.findIndex((i)=>i === e);
                s !== -1 && this.streams.splice(s, 1), r.error != null ? r.local ? this.metrics?.increment({
                    [`${e.direction}_stream_reset`]: !0
                }) : this.metrics?.increment({
                    [`${e.direction}_stream_abort`]: !0
                }) : this.metrics?.increment({
                    [`${e.direction}_stream_end`]: !0
                });
            };
            e.addEventListener("close", t), this.metrics?.increment({
                [`${e.direction}_stream`]: !0
            });
        }
        addEventListener(...e) {
            super.addEventListener.apply(this, e), e[0] === "stream" && this.earlyStreams.length > 0 && queueMicrotask(()=>{
                this.earlyStreams.forEach((t)=>{
                    this.safeDispatchEvent("stream", {
                        detail: t
                    });
                }), this.earlyStreams = [];
            });
        }
    }
    class P6 extends x6 {
        id;
        protocol;
        constructor(e){
            super(e), this.id = e.id, this.protocol = e.protocol ?? "";
        }
        async close(e) {
            this.writeStatus === "closing" || this.writeStatus === "closed" || (this.writeStatus = "closing", (this.sendingData || this.writeBuffer.byteLength > 0) && (this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength), await an(this, "idle", {
                ...e,
                rejectionEvents: [
                    "close"
                ]
            })), this.writableNeedsDrain && (this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData), await an(this, "drain", {
                ...e,
                rejectionEvents: [
                    "close"
                ]
            }), this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData)), await this.sendCloseWrite(e), this.writeStatus = "closed", this.log("closed writable end gracefully"), this.remoteWriteStatus === "closed" && this.onTransportClosed());
        }
        async closeRead(e) {
            this.readStatus === "closing" || this.readStatus === "closed" || (this.readBuffer.byteLength > 0 && this.readBuffer.consume(this.readBuffer.byteLength), this.readStatus = "closing", await this.sendCloseRead(e), this.readStatus = "closed", this.log("closed readable end gracefully"));
        }
    }
    function gt(n) {
        const e = new globalThis.AbortController;
        function t() {
            const i = n.filter((l)=>l?.aborted === !0).map((l)=>l?.reason).pop();
            e.abort(i);
            for (const l of n)l?.removeEventListener != null && l.removeEventListener("abort", t);
        }
        for (const i of n){
            if (i?.aborted === !0) {
                t();
                break;
            }
            i?.addEventListener != null && i.addEventListener("abort", t);
        }
        function r() {
            for (const i of n)i?.removeEventListener != null && i.removeEventListener("abort", t);
        }
        const s = e.signal;
        return s.clear = r, s;
    }
    class A3 {
        movingAverage;
        variance;
        deviation;
        forecast;
        timeSpan;
        previousTime;
        constructor(e){
            this.timeSpan = e, this.movingAverage = 0, this.variance = 0, this.deviation = 0, this.forecast = 0;
        }
        alpha(e, t) {
            return 1 - Math.exp(-(e - t) / this.timeSpan);
        }
        push(e, t = Date.now()) {
            if (this.previousTime != null) {
                const r = this.alpha(t, this.previousTime), s = e - this.movingAverage, i = r * s;
                this.movingAverage = r * e + (1 - r) * this.movingAverage, this.variance = (1 - r) * (this.variance + s * i), this.deviation = Math.sqrt(this.variance), this.forecast = this.movingAverage + r * s;
            } else this.movingAverage = e;
            this.previousTime = t;
        }
    }
    const zz = 1.2, Fz = 2, Vz = 5e3, Hz = 6e4, Qz = 5e3;
    class Fd {
        success;
        failure;
        next;
        metric;
        timeoutMultiplier;
        failureMultiplier;
        minTimeout;
        maxTimeout;
        constructor(e = {}){
            const t = e.interval ?? Qz;
            this.success = new A3(t), this.failure = new A3(t), this.next = new A3(t), this.failureMultiplier = e.failureMultiplier ?? Fz, this.timeoutMultiplier = e.timeoutMultiplier ?? zz, this.minTimeout = e.minTimeout ?? Vz, this.maxTimeout = e.maxTimeout ?? Hz, e.metricName != null && (this.metric = e.metrics?.registerMetricGroup(e.metricName));
        }
        getTimeoutSignal(e = {}) {
            let t = Math.round(this.next.movingAverage * (e.timeoutFactor ?? this.timeoutMultiplier));
            t < this.minTimeout && (t = this.minTimeout), t > this.maxTimeout && (t = this.maxTimeout);
            const r = AbortSignal.timeout(t), s = gt([
                e.signal,
                r
            ]);
            return s.start = Date.now(), s.timeout = t, s;
        }
        cleanUp(e) {
            const t = Date.now() - e.start;
            e.aborted ? (this.failure.push(t), this.next.push(t * this.failureMultiplier), this.metric?.update({
                failureMovingAverage: this.failure.movingAverage,
                failureDeviation: this.failure.deviation,
                failureForecast: this.failure.forecast,
                failureVariance: this.failure.variance,
                failure: t
            })) : (this.success.push(t), this.next.push(t), this.metric?.update({
                successMovingAverage: this.success.movingAverage,
                successDeviation: this.success.deviation,
                successForecast: this.success.forecast,
                successVariance: this.success.variance,
                success: t
            }));
        }
    }
    class qz {
        readNext;
        haveNext;
        ended;
        nextResult;
        error;
        constructor(){
            this.ended = !1, this.readNext = xt(), this.haveNext = xt();
        }
        [Symbol.asyncIterator]() {
            return this;
        }
        async next() {
            if (this.nextResult == null && await this.haveNext.promise, this.nextResult == null) throw new Error("HaveNext promise resolved but nextResult was undefined");
            const e = this.nextResult;
            return this.nextResult = void 0, this.readNext.resolve(), this.readNext = xt(), e;
        }
        async throw(e) {
            return this.ended = !0, this.error = e, e != null && (this.haveNext.promise.catch(()=>{}), this.haveNext.reject(e)), {
                done: !0,
                value: void 0
            };
        }
        async return() {
            const e = {
                done: !0,
                value: void 0
            };
            return this.ended = !0, this.nextResult = e, this.haveNext.resolve(), e;
        }
        async push(e, t) {
            await this._push(e, t);
        }
        async end(e, t) {
            e != null ? await this.throw(e) : await this._push(void 0, t);
        }
        async _push(e, t) {
            if (e != null && this.ended) throw this.error ?? new Error("Cannot push value onto an ended pushable");
            for(; this.nextResult != null;)await this.readNext.promise;
            e != null ? this.nextResult = {
                done: !1,
                value: e
            } : (this.ended = !0, this.nextResult = {
                done: !0,
                value: void 0
            }), this.haveNext.resolve(), this.haveNext = xt(), await Xn(this.readNext.promise, t?.signal, t);
        }
    }
    function Kz() {
        return new qz;
    }
    function Gz(n) {
        return n[Symbol.asyncIterator] != null;
    }
    async function Yz(n, e, t) {
        try {
            await Promise.all(n.map(async (r)=>{
                for await (const s of r)await e.push(s, {
                    signal: t
                }), t.throwIfAborted();
            })), await e.end(void 0, {
                signal: t
            });
        } catch (r) {
            await e.end(r, {
                signal: t
            }).catch(()=>{});
        }
    }
    async function* Wz(n) {
        const e = new AbortController, t = Kz();
        Yz(n, t, e.signal).catch(()=>{});
        try {
            yield* t;
        } finally{
            e.abort();
        }
    }
    function* jz(n) {
        for (const e of n)yield* e;
    }
    function Uo(...n) {
        const e = [];
        for (const t of n)Gz(t) || e.push(t);
        return e.length === n.length ? jz(e) : Wz(n);
    }
    Oc = function(n, ...e) {
        if (n == null) throw new Error("Empty pipeline");
        if (S3(n)) {
            const r = n;
            n = ()=>r.source;
        } else if (BC(n) || DC(n)) {
            const r = n;
            n = ()=>r;
        }
        const t = [
            n,
            ...e
        ];
        if (t.length > 1 && S3(t[t.length - 1]) && (t[t.length - 1] = t[t.length - 1].sink), t.length > 2) for(let r = 1; r < t.length - 1; r++)S3(t[r]) && (t[r] = Jz(t[r]));
        return Xz(...t);
    };
    const Xz = (...n)=>{
        let e;
        for(; n.length > 0;)e = n.shift()(e);
        return e;
    }, DC = (n)=>n?.[Symbol.asyncIterator] != null, BC = (n)=>n?.[Symbol.iterator] != null, S3 = (n)=>n == null ? !1 : n.sink != null && n.source != null, Jz = (n)=>(e)=>{
            const t = n.sink(e);
            if (t?.then != null) {
                const r = Hs({
                    objectMode: !0
                });
                t.then(()=>{
                    r.end();
                }, (l)=>{
                    r.end(l);
                });
                let s;
                const i = n.source;
                if (DC(i)) s = async function*() {
                    yield* i, r.end();
                };
                else if (BC(i)) s = function*() {
                    yield* i, r.end();
                };
                else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
                return Uo(r, s());
            }
            return n.source;
        }, Zz = 4194304;
    class X9 extends Error {
        static name = "UnwrappedError";
        name = "UnwrappedError";
    }
    let PC = class extends Error {
        name = "InvalidMessageLengthError";
        code = "ERR_INVALID_MSG_LENGTH";
    }, eF = class extends Error {
        name = "InvalidDataLengthError";
        code = "ERR_MSG_DATA_TOO_LONG";
    }, tF = class extends Error {
        name = "InvalidDataLengthLengthError";
        code = "ERR_MSG_LENGTH_TOO_LONG";
    };
    function nF(n) {
        return typeof n?.closeRead == "function";
    }
    function rF(n) {
        return typeof n?.close == "function";
    }
    function I3(n) {
        return nF(n) ? n.remoteWriteStatus !== "writable" && n.readBufferLength === 0 : rF(n) ? n.status !== "open" : !1;
    }
    function sF(n) {
        return n?.addEventListener != null && n?.removeEventListener != null && n?.send != null && n?.push != null && n?.log != null;
    }
    function kC(n, e) {
        const t = e?.maxBufferSize ?? Zz, r = new Re;
        let s, i = !1;
        if (!sF(n)) throw new I6("Argument should be a Stream or a Multiaddr");
        const l = (p)=>{
            if (r.append(p.data), r.byteLength > t) {
                const m = r.byteLength;
                r.consume(r.byteLength), s?.reject(new Error(`Read buffer overflow - ${m} > ${t}`));
            }
            s?.resolve();
        };
        n.addEventListener("message", l);
        const u = (p)=>{
            p.error != null ? s?.reject(p.error) : s?.resolve();
        };
        n.addEventListener("close", u);
        const h = ()=>{
            s?.resolve();
        };
        n.addEventListener("remoteCloseWrite", h);
        const f = {
            readBuffer: r,
            async read (p) {
                if (i === !0) throw new X9("Stream was unwrapped");
                if (I3(n)) {
                    if (p?.bytes == null) return null;
                    if (r.byteLength < p.bytes) throw n.log.error("closed after reading %d/%d bytes", r.byteLength, p.bytes), new Ip(`Unexpected EOF - stream closed after reading ${r.byteLength}/${p.bytes} bytes`);
                }
                const m = p?.bytes ?? 1;
                for(s = Promise.withResolvers();;){
                    if (r.byteLength >= m) {
                        s.resolve();
                        break;
                    }
                    if (await Xn(s.promise, p?.signal), I3(n)) {
                        if (r.byteLength === 0 && p?.bytes == null) return null;
                        break;
                    }
                    s = Promise.withResolvers();
                }
                const w = p?.bytes ?? r.byteLength;
                if (r.byteLength < w) {
                    if (I3(n)) throw n.log.error("closed while reading %d/%d bytes", r.byteLength, w), new Ip(`Unexpected EOF - stream closed while reading ${r.byteLength}/${w} bytes`);
                    return f.read(p);
                }
                const A = r.sublist(0, w);
                return r.consume(w), A;
            },
            async write (p, m) {
                if (i === !0) throw new X9("Stream was unwrapped");
                n.send(p) || await an(n, "drain", {
                    signal: m?.signal,
                    rejectionEvents: [
                        "close"
                    ]
                });
            },
            unwrap () {
                return i || (i = !0, n.removeEventListener("message", l), n.removeEventListener("close", u), n.removeEventListener("remoteCloseWrite", h), r.byteLength > 0 && (n.log("stream unwrapped with %d unread bytes", r.byteLength), n.push(r))), n;
            }
        };
        return f;
    }
    function Vd(n, e = {}) {
        const t = kC(n, e);
        e.maxDataLength != null && e.maxLengthLength == null && (e.maxLengthLength = be(e.maxDataLength));
        const r = e?.lengthDecoder ?? et, s = e?.lengthEncoder ?? zr;
        return {
            async read (l) {
                let u = -1;
                const h = new Re;
                for(;;){
                    const p = await t.read({
                        ...l,
                        bytes: 1
                    });
                    if (p == null) break;
                    h.append(p);
                    try {
                        u = r(h);
                    } catch (m) {
                        if (m instanceof RangeError) continue;
                        throw m;
                    }
                    if (u < 0) throw new PC("Invalid message length");
                    if (e?.maxLengthLength != null && h.byteLength > e.maxLengthLength) throw new tF(`Message length length too long - ${h.byteLength} > ${e.maxLengthLength}`);
                    if (u > -1) break;
                }
                if (e?.maxDataLength != null && u > e.maxDataLength) throw new eF(`Message length too long - ${u} > ${e.maxDataLength}`);
                const f = await t.read({
                    ...l,
                    bytes: u
                });
                if (f == null) throw n.log.error("tried to read %d bytes but the stream closed", u), new Ip(`Unexpected EOF - tried to read ${u} bytes but the stream closed`);
                if (f.byteLength !== u) throw n.log.error("read %d/%d bytes before the stream closed", f.byteLength, u), new Ip(`Unexpected EOF - read ${f.byteLength}/${u} bytes before the stream closed`);
                return f;
            },
            async write (l, u) {
                await t.write(new Re(s(l.byteLength), l), u);
            },
            async writeV (l, u) {
                const h = new Re(...l.flatMap((f)=>[
                        s(f.byteLength),
                        f
                    ]));
                await t.write(h, u);
            },
            unwrap () {
                return t.unwrap();
            }
        };
    }
    function Jn(n, e) {
        const t = Vd(n, e), r = {
            read: async (s, i)=>{
                const l = await t.read(i);
                return s.decode(l);
            },
            write: async (s, i, l)=>{
                await t.write(i.encode(s), l);
            },
            writeV: async (s, i, l)=>{
                await t.writeV(s.map((u)=>i.encode(u)), l);
            },
            pb: (s)=>({
                    read: async (i)=>r.read(s, i),
                    write: async (i, l)=>r.write(i, s, l),
                    writeV: async (i, l)=>r.writeV(i, s, l),
                    unwrap: ()=>r
                }),
            unwrap: ()=>t.unwrap()
        };
        return r;
    }
    const iF = 1024 * 1024 * 4, oF = 1024 * 1024 * 4;
    class aF {
        buffer;
        maxBufferSize;
        lengthDecoder;
        maxDataLength;
        encodingLength;
        constructor(e = {}){
            this.buffer = new Re, this.maxBufferSize = e.maxBufferSize ?? iF, this.maxDataLength = e.maxDataLength ?? oF, this.lengthDecoder = e.lengthDecoder ?? et, this.encodingLength = e.encodingLength ?? be;
        }
        *decode(e) {
            if (this.buffer.append(e), this.buffer.byteLength > this.maxBufferSize) throw new I6(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);
            for(;;){
                let t;
                try {
                    t = this.lengthDecoder(this.buffer);
                } catch (i) {
                    if (i instanceof RangeError) break;
                    throw i;
                }
                if (t < 0 || t > this.maxDataLength) throw new PC("Invalid message length");
                const r = this.encodingLength(t), s = r + t;
                if (this.buffer.byteLength >= s) {
                    const i = this.buffer.sublist(r, s);
                    this.buffer.consume(s), i.byteLength > 0 && (yield i);
                } else break;
            }
        }
    }
    const lF = [
        "Object",
        "RegExp",
        "Date",
        "Error",
        "Map",
        "Set",
        "WeakMap",
        "WeakSet",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "DataView",
        "Promise",
        "URL",
        "HTMLElement",
        "Int8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array"
    ];
    function RC(n) {
        if (n === null) return "null";
        if (n === void 0) return "undefined";
        if (n === !0 || n === !1) return "boolean";
        const e = typeof n;
        if (e === "string" || e === "number" || e === "bigint" || e === "symbol") return e;
        if (e === "function") return "Function";
        if (Array.isArray(n)) return "Array";
        if (n instanceof Uint8Array) return "Uint8Array";
        if (n.constructor === Object) return "Object";
        const t = cF(n);
        return t || "Object";
    }
    function cF(n) {
        const e = Object.prototype.toString.call(n).slice(8, -1);
        if (lF.includes(e)) return e;
    }
    class U {
        constructor(e, t, r){
            this.major = e, this.majorEncoded = e << 5, this.name = t, this.terminal = r;
        }
        toString() {
            return `Type[${this.major}].${this.name}`;
        }
        compare(e) {
            return this.major < e.major ? -1 : this.major > e.major ? 1 : 0;
        }
        static equals(e, t) {
            return e === t || e.major === t.major && e.name === t.name;
        }
    }
    U.uint = new U(0, "uint", !0);
    U.negint = new U(1, "negint", !0);
    U.bytes = new U(2, "bytes", !0);
    U.string = new U(3, "string", !0);
    U.array = new U(4, "array", !1);
    U.map = new U(5, "map", !1);
    U.tag = new U(6, "tag", !1);
    U.float = new U(7, "float", !0);
    U.false = new U(7, "false", !0);
    U.true = new U(7, "true", !0);
    U.null = new U(7, "null", !0);
    U.undefined = new U(7, "undefined", !0);
    U.break = new U(7, "break", !0);
    class we {
        constructor(e, t, r){
            this.type = e, this.value = t, this.encodedLength = r, this.encodedBytes = void 0, this.byteValue = void 0;
        }
        toString() {
            return `Token[${this.type}].${this.value}`;
        }
    }
    const Df = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", uF = new TextEncoder;
    function Cp(n) {
        return Df && globalThis.Buffer.isBuffer(n);
    }
    function yg(n) {
        return n instanceof Uint8Array ? Cp(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n : Uint8Array.from(n);
    }
    const hF = 24, dF = 200, k6 = Df ? (n)=>n.length >= hF ? globalThis.Buffer.from(n) : J9(n) : (n)=>n.length >= dF ? uF.encode(n) : J9(n), Ni = (n)=>Uint8Array.from(n), fF = Df ? (n, e, t)=>Cp(n) ? new Uint8Array(n.subarray(e, t)) : n.slice(e, t) : (n, e, t)=>n.slice(e, t), pF = Df ? (n, e)=>(n = n.map((t)=>t instanceof Uint8Array ? t : globalThis.Buffer.from(t)), yg(globalThis.Buffer.concat(n, e))) : (n, e)=>{
        const t = new Uint8Array(e);
        let r = 0;
        for (let s of n)r + s.length > t.length && (s = s.subarray(0, t.length - r)), t.set(s, r), r += s.length;
        return t;
    }, gF = Df ? (n)=>globalThis.Buffer.allocUnsafe(n) : (n)=>new Uint8Array(n);
    function mF(n, e) {
        if (Cp(n) && Cp(e)) return n.compare(e);
        for(let t = 0; t < n.length; t++)if (n[t] !== e[t]) return n[t] < e[t] ? -1 : 1;
        return 0;
    }
    function J9(n) {
        const e = [];
        let t = 0;
        for(let r = 0; r < n.length; r++){
            let s = n.charCodeAt(r);
            s < 128 ? e[t++] = s : s < 2048 ? (e[t++] = s >> 6 | 192, e[t++] = s & 63 | 128) : (s & 64512) === 55296 && r + 1 < n.length && (n.charCodeAt(r + 1) & 64512) === 56320 ? (s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++r) & 1023), e[t++] = s >> 18 | 240, e[t++] = s >> 12 & 63 | 128, e[t++] = s >> 6 & 63 | 128, e[t++] = s & 63 | 128) : (s >= 55296 && s <= 57343 && (s = 65533), e[t++] = s >> 12 | 224, e[t++] = s >> 6 & 63 | 128, e[t++] = s & 63 | 128);
        }
        return e;
    }
    const Z9 = 4096;
    function yF(n) {
        const e = n.length;
        if (e <= Z9) return String.fromCharCode.apply(String, n);
        let t = "", r = 0;
        for(; r < e;)t += String.fromCharCode.apply(String, n.slice(r, r += Z9));
        return t;
    }
    const wF = 256;
    class OC {
        constructor(e = wF){
            this.chunkSize = e, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null;
        }
        reset() {
            this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1);
        }
        push(e) {
            let t = this.chunks[this.chunks.length - 1];
            if (this.cursor + e.length <= this.maxCursor + 1) {
                const s = t.length - (this.maxCursor - this.cursor) - 1;
                t.set(e, s);
            } else {
                if (t) {
                    const s = t.length - (this.maxCursor - this.cursor) - 1;
                    s < t.length && (this.chunks[this.chunks.length - 1] = t.subarray(0, s), this.maxCursor = this.cursor - 1);
                }
                e.length < 64 && e.length < this.chunkSize ? (t = gF(this.chunkSize), this.chunks.push(t), this.maxCursor += t.length, this._initReuseChunk === null && (this._initReuseChunk = t), t.set(e, 0)) : (this.chunks.push(e), this.maxCursor += e.length);
            }
            this.cursor += e.length;
        }
        toBytes(e = !1) {
            let t;
            if (this.chunks.length === 1) {
                const r = this.chunks[0];
                e && this.cursor > r.length / 2 ? (t = this.cursor === r.length ? r : r.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : t = fF(r, 0, this.cursor);
            } else t = pF(this.chunks, this.cursor);
            return e && this.reset(), t;
        }
    }
    class bF {
        constructor(e){
            this.dest = e, this.cursor = 0, this.chunks = [
                e
            ];
        }
        reset() {
            this.cursor = 0;
        }
        push(e) {
            if (this.cursor + e.length > this.dest.length) throw new Error("write out of bounds, destination buffer is too small");
            this.dest.set(e, this.cursor), this.cursor += e.length;
        }
        toBytes(e = !1) {
            const t = this.dest.subarray(0, this.cursor);
            return e && this.reset(), t;
        }
    }
    const ke = "CBOR decode error:", zo = "CBOR encode error:";
    function ru(n, e, t) {
        if (n.length - e < t) throw new Error(`${ke} not enough data for type`);
    }
    const Cn = [
        24,
        256,
        65536,
        4294967296,
        BigInt("18446744073709551616")
    ];
    function Ya(n, e, t) {
        ru(n, e, 1);
        const r = n[e];
        if (t.strict === !0 && r < Cn[0]) throw new Error(`${ke} integer encoded in more bytes than necessary (strict decode)`);
        return r;
    }
    function Wa(n, e, t) {
        ru(n, e, 2);
        const r = n[e] << 8 | n[e + 1];
        if (t.strict === !0 && r < Cn[1]) throw new Error(`${ke} integer encoded in more bytes than necessary (strict decode)`);
        return r;
    }
    function ja(n, e, t) {
        ru(n, e, 4);
        const r = n[e] * 16777216 + (n[e + 1] << 16) + (n[e + 2] << 8) + n[e + 3];
        if (t.strict === !0 && r < Cn[2]) throw new Error(`${ke} integer encoded in more bytes than necessary (strict decode)`);
        return r;
    }
    function Xa(n, e, t) {
        ru(n, e, 8);
        const r = n[e] * 16777216 + (n[e + 1] << 16) + (n[e + 2] << 8) + n[e + 3], s = n[e + 4] * 16777216 + (n[e + 5] << 16) + (n[e + 6] << 8) + n[e + 7], i = (BigInt(r) << BigInt(32)) + BigInt(s);
        if (t.strict === !0 && i < Cn[3]) throw new Error(`${ke} integer encoded in more bytes than necessary (strict decode)`);
        if (i <= Number.MAX_SAFE_INTEGER) return Number(i);
        if (t.allowBigInt === !0) return i;
        throw new Error(`${ke} integers outside of the safe integer range are not supported`);
    }
    function vF(n, e, t, r) {
        return new we(U.uint, Ya(n, e + 1, r), 2);
    }
    function EF(n, e, t, r) {
        return new we(U.uint, Wa(n, e + 1, r), 3);
    }
    function AF(n, e, t, r) {
        return new we(U.uint, ja(n, e + 1, r), 5);
    }
    function SF(n, e, t, r) {
        return new we(U.uint, Xa(n, e + 1, r), 9);
    }
    function Ja(n, e) {
        return cn(n, 0, e.value);
    }
    function cn(n, e, t) {
        if (t < Cn[0]) {
            const r = Number(t);
            n.push([
                e | r
            ]);
        } else if (t < Cn[1]) {
            const r = Number(t);
            n.push([
                e | 24,
                r
            ]);
        } else if (t < Cn[2]) {
            const r = Number(t);
            n.push([
                e | 25,
                r >>> 8,
                r & 255
            ]);
        } else if (t < Cn[3]) {
            const r = Number(t);
            n.push([
                e | 26,
                r >>> 24 & 255,
                r >>> 16 & 255,
                r >>> 8 & 255,
                r & 255
            ]);
        } else {
            const r = BigInt(t);
            if (r < Cn[4]) {
                const s = [
                    e | 27,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ];
                let i = Number(r & BigInt(4294967295)), l = Number(r >> BigInt(32) & BigInt(4294967295));
                s[8] = i & 255, i = i >> 8, s[7] = i & 255, i = i >> 8, s[6] = i & 255, i = i >> 8, s[5] = i & 255, s[4] = l & 255, l = l >> 8, s[3] = l & 255, l = l >> 8, s[2] = l & 255, l = l >> 8, s[1] = l & 255, n.push(s);
            } else throw new Error(`${ke} encountered BigInt larger than allowable range`);
        }
    }
    Ja.encodedSize = function(e) {
        return cn.encodedSize(e.value);
    };
    cn.encodedSize = function(e) {
        return e < Cn[0] ? 1 : e < Cn[1] ? 2 : e < Cn[2] ? 3 : e < Cn[3] ? 5 : 9;
    };
    Ja.compareTokens = function(e, t) {
        return e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
    };
    function IF(n, e, t, r) {
        return new we(U.negint, -1 - Ya(n, e + 1, r), 2);
    }
    function CF(n, e, t, r) {
        return new we(U.negint, -1 - Wa(n, e + 1, r), 3);
    }
    function TF(n, e, t, r) {
        return new we(U.negint, -1 - ja(n, e + 1, r), 5);
    }
    const R6 = BigInt(-1), $C = BigInt(1);
    function _F(n, e, t, r) {
        const s = Xa(n, e + 1, r);
        if (typeof s != "bigint") {
            const i = -1 - s;
            if (i >= Number.MIN_SAFE_INTEGER) return new we(U.negint, i, 9);
        }
        if (r.allowBigInt !== !0) throw new Error(`${ke} integers outside of the safe integer range are not supported`);
        return new we(U.negint, R6 - BigInt(s), 9);
    }
    function O6(n, e) {
        const t = e.value, r = typeof t == "bigint" ? t * R6 - $C : t * -1 - 1;
        cn(n, e.type.majorEncoded, r);
    }
    O6.encodedSize = function(e) {
        const t = e.value, r = typeof t == "bigint" ? t * R6 - $C : t * -1 - 1;
        return r < Cn[0] ? 1 : r < Cn[1] ? 2 : r < Cn[2] ? 3 : r < Cn[3] ? 5 : 9;
    };
    O6.compareTokens = function(e, t) {
        return e.value < t.value ? 1 : e.value > t.value ? -1 : 0;
    };
    function Bf(n, e, t, r) {
        ru(n, e, t + r);
        const s = n.slice(e + t, e + t + r);
        return new we(U.bytes, s, t + r);
    }
    function xF(n, e, t, r) {
        return Bf(n, e, 1, t);
    }
    function DF(n, e, t, r) {
        return Bf(n, e, 2, Ya(n, e + 1, r));
    }
    function BF(n, e, t, r) {
        return Bf(n, e, 3, Wa(n, e + 1, r));
    }
    function PF(n, e, t, r) {
        return Bf(n, e, 5, ja(n, e + 1, r));
    }
    function kF(n, e, t, r) {
        const s = Xa(n, e + 1, r);
        if (typeof s == "bigint") throw new Error(`${ke} 64-bit integer bytes lengths not supported`);
        return Bf(n, e, 9, s);
    }
    function Tp(n) {
        return n.encodedBytes === void 0 && (n.encodedBytes = U.equals(n.type, U.string) ? k6(n.value) : n.value), n.encodedBytes;
    }
    function wg(n, e) {
        const t = Tp(e);
        cn(n, e.type.majorEncoded, t.length), n.push(t);
    }
    wg.encodedSize = function(e) {
        const t = Tp(e);
        return cn.encodedSize(t.length) + t.length;
    };
    wg.compareTokens = function(e, t) {
        return RF(Tp(e), Tp(t));
    };
    function RF(n, e) {
        return n.length < e.length ? -1 : n.length > e.length ? 1 : mF(n, e);
    }
    const ev = new TextDecoder, OF = 32;
    function $F(n, e, t) {
        if (t - e < OF) {
            let s = "";
            for(let i = e; i < t; i++){
                const l = n[i];
                if (l & 128) return ev.decode(n.subarray(e, t));
                s += String.fromCharCode(l);
            }
            return s;
        }
        return ev.decode(n.subarray(e, t));
    }
    function Pf(n, e, t, r, s) {
        const i = t + r;
        ru(n, e, i);
        const l = new we(U.string, $F(n, e + t, e + i), i);
        return s.retainStringBytes === !0 && (l.byteValue = n.slice(e + t, e + i)), l;
    }
    function MF(n, e, t, r) {
        return Pf(n, e, 1, t, r);
    }
    function NF(n, e, t, r) {
        return Pf(n, e, 2, Ya(n, e + 1, r), r);
    }
    function LF(n, e, t, r) {
        return Pf(n, e, 3, Wa(n, e + 1, r), r);
    }
    function UF(n, e, t, r) {
        return Pf(n, e, 5, ja(n, e + 1, r), r);
    }
    function zF(n, e, t, r) {
        const s = Xa(n, e + 1, r);
        if (typeof s == "bigint") throw new Error(`${ke} 64-bit integer string lengths not supported`);
        return Pf(n, e, 9, s, r);
    }
    const FF = wg;
    function su(n, e, t, r) {
        return new we(U.array, r, t);
    }
    function VF(n, e, t, r) {
        return su(n, e, 1, t);
    }
    function HF(n, e, t, r) {
        return su(n, e, 2, Ya(n, e + 1, r));
    }
    function QF(n, e, t, r) {
        return su(n, e, 3, Wa(n, e + 1, r));
    }
    function qF(n, e, t, r) {
        return su(n, e, 5, ja(n, e + 1, r));
    }
    function KF(n, e, t, r) {
        const s = Xa(n, e + 1, r);
        if (typeof s == "bigint") throw new Error(`${ke} 64-bit integer array lengths not supported`);
        return su(n, e, 9, s);
    }
    function GF(n, e, t, r) {
        if (r.allowIndefinite === !1) throw new Error(`${ke} indefinite length items not allowed`);
        return su(n, e, 1, 1 / 0);
    }
    function $6(n, e) {
        cn(n, U.array.majorEncoded, e.value);
    }
    $6.compareTokens = Ja.compareTokens;
    $6.encodedSize = function(e) {
        return cn.encodedSize(e.value);
    };
    function iu(n, e, t, r) {
        return new we(U.map, r, t);
    }
    function YF(n, e, t, r) {
        return iu(n, e, 1, t);
    }
    function WF(n, e, t, r) {
        return iu(n, e, 2, Ya(n, e + 1, r));
    }
    function jF(n, e, t, r) {
        return iu(n, e, 3, Wa(n, e + 1, r));
    }
    function XF(n, e, t, r) {
        return iu(n, e, 5, ja(n, e + 1, r));
    }
    function JF(n, e, t, r) {
        const s = Xa(n, e + 1, r);
        if (typeof s == "bigint") throw new Error(`${ke} 64-bit integer map lengths not supported`);
        return iu(n, e, 9, s);
    }
    function ZF(n, e, t, r) {
        if (r.allowIndefinite === !1) throw new Error(`${ke} indefinite length items not allowed`);
        return iu(n, e, 1, 1 / 0);
    }
    function M6(n, e) {
        cn(n, U.map.majorEncoded, e.value);
    }
    M6.compareTokens = Ja.compareTokens;
    M6.encodedSize = function(e) {
        return cn.encodedSize(e.value);
    };
    function eV(n, e, t, r) {
        return new we(U.tag, t, 1);
    }
    function tV(n, e, t, r) {
        return new we(U.tag, Ya(n, e + 1, r), 2);
    }
    function nV(n, e, t, r) {
        return new we(U.tag, Wa(n, e + 1, r), 3);
    }
    function rV(n, e, t, r) {
        return new we(U.tag, ja(n, e + 1, r), 5);
    }
    function sV(n, e, t, r) {
        return new we(U.tag, Xa(n, e + 1, r), 9);
    }
    function N6(n, e) {
        cn(n, U.tag.majorEncoded, e.value);
    }
    N6.compareTokens = Ja.compareTokens;
    N6.encodedSize = function(e) {
        return cn.encodedSize(e.value);
    };
    const MC = 20, NC = 21, LC = 22, UC = 23;
    function iV(n, e, t, r) {
        if (r.allowUndefined === !1) throw new Error(`${ke} undefined values are not supported`);
        return r.coerceUndefinedToNull === !0 ? new we(U.null, null, 1) : new we(U.undefined, void 0, 1);
    }
    function oV(n, e, t, r) {
        if (r.allowIndefinite === !1) throw new Error(`${ke} indefinite length items not allowed`);
        return new we(U.break, void 0, 1);
    }
    function L6(n, e, t) {
        if (t) {
            if (t.allowNaN === !1 && Number.isNaN(n)) throw new Error(`${ke} NaN values are not supported`);
            if (t.allowInfinity === !1 && (n === 1 / 0 || n === -1 / 0)) throw new Error(`${ke} Infinity values are not supported`);
        }
        return new we(U.float, n, e);
    }
    function aV(n, e, t, r) {
        return L6(U6(n, e + 1), 3, r);
    }
    function lV(n, e, t, r) {
        return L6(z6(n, e + 1), 5, r);
    }
    function cV(n, e, t, r) {
        return L6(HC(n, e + 1), 9, r);
    }
    function bg(n, e, t) {
        const r = e.value;
        if (r === !1) n.push([
            U.float.majorEncoded | MC
        ]);
        else if (r === !0) n.push([
            U.float.majorEncoded | NC
        ]);
        else if (r === null) n.push([
            U.float.majorEncoded | LC
        ]);
        else if (r === void 0) n.push([
            U.float.majorEncoded | UC
        ]);
        else {
            let s, i = !1;
            (!t || t.float64 !== !0) && (FC(r), s = U6(Os, 1), r === s || Number.isNaN(r) ? (Os[0] = 249, n.push(Os.slice(0, 3)), i = !0) : (VC(r), s = z6(Os, 1), r === s && (Os[0] = 250, n.push(Os.slice(0, 5)), i = !0))), i || (uV(r), s = HC(Os, 1), Os[0] = 251, n.push(Os.slice(0, 9)));
        }
    }
    bg.encodedSize = function(e, t) {
        const r = e.value;
        if (r === !1 || r === !0 || r === null || r === void 0) return 1;
        if (!t || t.float64 !== !0) {
            FC(r);
            let s = U6(Os, 1);
            if (r === s || Number.isNaN(r)) return 3;
            if (VC(r), s = z6(Os, 1), r === s) return 5;
        }
        return 9;
    };
    const zC = new ArrayBuffer(9), rs = new DataView(zC, 1), Os = new Uint8Array(zC, 0);
    function FC(n) {
        if (n === 1 / 0) rs.setUint16(0, 31744, !1);
        else if (n === -1 / 0) rs.setUint16(0, 64512, !1);
        else if (Number.isNaN(n)) rs.setUint16(0, 32256, !1);
        else {
            rs.setFloat32(0, n);
            const e = rs.getUint32(0), t = (e & 2139095040) >> 23, r = e & 8388607;
            if (t === 255) rs.setUint16(0, 31744, !1);
            else if (t === 0) rs.setUint16(0, (n & 2147483648) >> 16 | r >> 13, !1);
            else {
                const s = t - 127;
                s < -24 ? rs.setUint16(0, 0) : s < -14 ? rs.setUint16(0, (e & 2147483648) >> 16 | 1 << 24 + s, !1) : rs.setUint16(0, (e & 2147483648) >> 16 | s + 15 << 10 | r >> 13, !1);
            }
        }
    }
    function U6(n, e) {
        if (n.length - e < 2) throw new Error(`${ke} not enough data for float16`);
        const t = (n[e] << 8) + n[e + 1];
        if (t === 31744) return 1 / 0;
        if (t === 64512) return -1 / 0;
        if (t === 32256) return NaN;
        const r = t >> 10 & 31, s = t & 1023;
        let i;
        return r === 0 ? i = s * 2 ** -24 : r !== 31 ? i = (s + 1024) * 2 ** (r - 25) : i = s === 0 ? 1 / 0 : NaN, t & 32768 ? -i : i;
    }
    function VC(n) {
        rs.setFloat32(0, n, !1);
    }
    function z6(n, e) {
        if (n.length - e < 4) throw new Error(`${ke} not enough data for float32`);
        const t = (n.byteOffset || 0) + e;
        return new DataView(n.buffer, t, 4).getFloat32(0, !1);
    }
    function uV(n) {
        rs.setFloat64(0, n, !1);
    }
    function HC(n, e) {
        if (n.length - e < 8) throw new Error(`${ke} not enough data for float64`);
        const t = (n.byteOffset || 0) + e;
        return new DataView(n.buffer, t, 8).getFloat64(0, !1);
    }
    bg.compareTokens = Ja.compareTokens;
    function at(n, e, t) {
        throw new Error(`${ke} encountered invalid minor (${t}) for major ${n[e] >>> 5}`);
    }
    function vg(n) {
        return ()=>{
            throw new Error(`${ke} ${n}`);
        };
    }
    const ve = [];
    for(let n = 0; n <= 23; n++)ve[n] = at;
    ve[24] = vF;
    ve[25] = EF;
    ve[26] = AF;
    ve[27] = SF;
    ve[28] = at;
    ve[29] = at;
    ve[30] = at;
    ve[31] = at;
    for(let n = 32; n <= 55; n++)ve[n] = at;
    ve[56] = IF;
    ve[57] = CF;
    ve[58] = TF;
    ve[59] = _F;
    ve[60] = at;
    ve[61] = at;
    ve[62] = at;
    ve[63] = at;
    for(let n = 64; n <= 87; n++)ve[n] = xF;
    ve[88] = DF;
    ve[89] = BF;
    ve[90] = PF;
    ve[91] = kF;
    ve[92] = at;
    ve[93] = at;
    ve[94] = at;
    ve[95] = vg("indefinite length bytes/strings are not supported");
    for(let n = 96; n <= 119; n++)ve[n] = MF;
    ve[120] = NF;
    ve[121] = LF;
    ve[122] = UF;
    ve[123] = zF;
    ve[124] = at;
    ve[125] = at;
    ve[126] = at;
    ve[127] = vg("indefinite length bytes/strings are not supported");
    for(let n = 128; n <= 151; n++)ve[n] = VF;
    ve[152] = HF;
    ve[153] = QF;
    ve[154] = qF;
    ve[155] = KF;
    ve[156] = at;
    ve[157] = at;
    ve[158] = at;
    ve[159] = GF;
    for(let n = 160; n <= 183; n++)ve[n] = YF;
    ve[184] = WF;
    ve[185] = jF;
    ve[186] = XF;
    ve[187] = JF;
    ve[188] = at;
    ve[189] = at;
    ve[190] = at;
    ve[191] = ZF;
    for(let n = 192; n <= 215; n++)ve[n] = eV;
    ve[216] = tV;
    ve[217] = nV;
    ve[218] = rV;
    ve[219] = sV;
    ve[220] = at;
    ve[221] = at;
    ve[222] = at;
    ve[223] = at;
    for(let n = 224; n <= 243; n++)ve[n] = vg("simple values are not supported");
    ve[244] = at;
    ve[245] = at;
    ve[246] = at;
    ve[247] = iV;
    ve[248] = vg("simple values are not supported");
    ve[249] = aV;
    ve[250] = lV;
    ve[251] = cV;
    ve[252] = at;
    ve[253] = at;
    ve[254] = at;
    ve[255] = oV;
    const pi = [];
    for(let n = 0; n < 24; n++)pi[n] = new we(U.uint, n, 1);
    for(let n = -1; n >= -24; n--)pi[31 - n] = new we(U.negint, n, 1);
    pi[64] = new we(U.bytes, new Uint8Array(0), 1);
    pi[96] = new we(U.string, "", 1);
    pi[128] = new we(U.array, 0, 1);
    pi[160] = new we(U.map, 0, 1);
    pi[244] = new we(U.false, !1, 1);
    pi[245] = new we(U.true, !0, 1);
    pi[246] = new we(U.null, null, 1);
    function hV(n) {
        switch(n.type){
            case U.false:
                return Ni([
                    244
                ]);
            case U.true:
                return Ni([
                    245
                ]);
            case U.null:
                return Ni([
                    246
                ]);
            case U.bytes:
                return n.value.length ? void 0 : Ni([
                    64
                ]);
            case U.string:
                return n.value === "" ? Ni([
                    96
                ]) : void 0;
            case U.array:
                return n.value === 0 ? Ni([
                    128
                ]) : void 0;
            case U.map:
                return n.value === 0 ? Ni([
                    160
                ]) : void 0;
            case U.uint:
                return n.value < 24 ? Ni([
                    Number(n.value)
                ]) : void 0;
            case U.negint:
                if (n.value >= -24) return Ni([
                    31 - Number(n.value)
                ]);
        }
    }
    const dV = {
        float64: !1,
        mapSorter: gV,
        quickEncodeToken: hV
    };
    function fV() {
        const n = [];
        return n[U.uint.major] = Ja, n[U.negint.major] = O6, n[U.bytes.major] = wg, n[U.string.major] = FF, n[U.array.major] = $6, n[U.map.major] = M6, n[U.tag.major] = N6, n[U.float.major] = bg, n;
    }
    const md = fV(), rp = new OC;
    class Hd {
        constructor(e, t){
            this.obj = e, this.parent = t;
        }
        includes(e) {
            let t = this;
            do if (t.obj === e) return !0;
            while (t = t.parent);
            return !1;
        }
        static createCheck(e, t) {
            if (e && e.includes(t)) throw new Error(`${zo} object contains circular references`);
            return new Hd(t, e);
        }
    }
    const Po = {
        null: new we(U.null, null),
        undefined: new we(U.undefined, void 0),
        true: new we(U.true, !0),
        false: new we(U.false, !1),
        emptyArray: new we(U.array, 0),
        emptyMap: new we(U.map, 0)
    }, hi = {
        number (n, e, t, r) {
            return !Number.isInteger(n) || !Number.isSafeInteger(n) ? new we(U.float, n) : n >= 0 ? new we(U.uint, n) : new we(U.negint, n);
        },
        bigint (n, e, t, r) {
            return n >= BigInt(0) ? new we(U.uint, n) : new we(U.negint, n);
        },
        Uint8Array (n, e, t, r) {
            return new we(U.bytes, n);
        },
        string (n, e, t, r) {
            return new we(U.string, n);
        },
        boolean (n, e, t, r) {
            return n ? Po.true : Po.false;
        },
        null (n, e, t, r) {
            return Po.null;
        },
        undefined (n, e, t, r) {
            return Po.undefined;
        },
        ArrayBuffer (n, e, t, r) {
            return new we(U.bytes, new Uint8Array(n));
        },
        DataView (n, e, t, r) {
            return new we(U.bytes, new Uint8Array(n.buffer, n.byteOffset, n.byteLength));
        },
        Array (n, e, t, r) {
            if (!n.length) return t.addBreakTokens === !0 ? [
                Po.emptyArray,
                new we(U.break)
            ] : Po.emptyArray;
            r = Hd.createCheck(r, n);
            const s = [];
            let i = 0;
            for (const l of n)s[i++] = sp(l, t, r);
            return t.addBreakTokens ? [
                new we(U.array, n.length),
                s,
                new we(U.break)
            ] : [
                new we(U.array, n.length),
                s
            ];
        },
        Object (n, e, t, r) {
            const s = e !== "Object", i = s ? n.keys() : Object.keys(n), l = s ? n.size : i.length;
            let u;
            if (l) {
                u = new Array(l), r = Hd.createCheck(r, n);
                const h = !s && t.ignoreUndefinedProperties;
                let f = 0;
                for (const p of i){
                    const m = s ? n.get(p) : n[p];
                    h && m === void 0 || (u[f++] = [
                        sp(p, t, r),
                        sp(m, t, r)
                    ]);
                }
                f < l && (u.length = f);
            }
            return u?.length ? (pV(u, t), t.addBreakTokens ? [
                new we(U.map, u.length),
                u,
                new we(U.break)
            ] : [
                new we(U.map, u.length),
                u
            ]) : t.addBreakTokens === !0 ? [
                Po.emptyMap,
                new we(U.break)
            ] : Po.emptyMap;
        }
    };
    hi.Map = hi.Object;
    hi.Buffer = hi.Uint8Array;
    for (const n of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))hi[`${n}Array`] = hi.DataView;
    function sp(n, e = {}, t) {
        const r = RC(n), s = e && e.typeEncoders && e.typeEncoders[r] || hi[r];
        if (typeof s == "function") {
            const l = s(n, r, e, t);
            if (l != null) return l;
        }
        const i = hi[r];
        if (!i) throw new Error(`${zo} unsupported type: ${r}`);
        return i(n, r, e, t);
    }
    function pV(n, e) {
        e.mapSorter && n.sort(e.mapSorter);
    }
    function gV(n, e) {
        const t = Array.isArray(n[0]) ? n[0][0] : n[0], r = Array.isArray(e[0]) ? e[0][0] : e[0];
        if (t.type !== r.type) return t.type.compare(r.type);
        const s = t.type.major, i = md[s].compareTokens(t, r);
        return i === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), i;
    }
    function yd(n, e, t, r) {
        if (Array.isArray(e)) for (const s of e)yd(n, s, t, r);
        else t[e.type.major](n, e, r);
    }
    const tv = U.uint.majorEncoded, nv = U.negint.majorEncoded, mV = U.bytes.majorEncoded, yV = U.string.majorEncoded, rv = U.array.majorEncoded, wV = U.float.majorEncoded | MC, bV = U.float.majorEncoded | NC, vV = U.float.majorEncoded | LC, EV = U.float.majorEncoded | UC, AV = BigInt(-1), SV = BigInt(1);
    function IV(n) {
        return n.addBreakTokens !== !0;
    }
    function QC(n, e, t, r) {
        const s = RC(e), i = t.typeEncoders && t.typeEncoders[s];
        if (i) {
            const l = i(e, s, t, r);
            if (l != null) {
                yd(n, l, md, t);
                return;
            }
        }
        switch(s){
            case "null":
                n.push([
                    vV
                ]);
                return;
            case "undefined":
                n.push([
                    EV
                ]);
                return;
            case "boolean":
                n.push([
                    e ? bV : wV
                ]);
                return;
            case "number":
                !Number.isInteger(e) || !Number.isSafeInteger(e) ? bg(n, new we(U.float, e), t) : e >= 0 ? cn(n, tv, e) : cn(n, nv, e * -1 - 1);
                return;
            case "bigint":
                e >= BigInt(0) ? cn(n, tv, e) : cn(n, nv, e * AV - SV);
                return;
            case "string":
                {
                    const l = k6(e);
                    cn(n, yV, l.length), n.push(l);
                    return;
                }
            case "Uint8Array":
                cn(n, mV, e.length), n.push(e);
                return;
            case "Array":
                if (!e.length) {
                    n.push([
                        rv
                    ]);
                    return;
                }
                r = Hd.createCheck(r, e), cn(n, rv, e.length);
                for (const l of e)QC(n, l, t, r);
                return;
            case "Object":
            case "Map":
                {
                    const l = hi.Object(e, s, t, r);
                    yd(n, l, md, t);
                }
                return;
            default:
                {
                    const l = hi[s];
                    if (!l) throw new Error(`${zo} unsupported type: ${s}`);
                    const u = l(e, s, t, r);
                    yd(n, u, md, t);
                }
        }
    }
    function qC(n, e, t, r) {
        const s = r instanceof Uint8Array;
        let i = s ? new bF(r) : rp;
        const l = sp(n, t);
        if (!Array.isArray(l) && t.quickEncodeToken) {
            const u = t.quickEncodeToken(l);
            if (u) return s ? (i.push(u), i.toBytes()) : u;
            const h = e[l.type.major];
            if (h.encodedSize) {
                const f = h.encodedSize(l, t);
                if (s || (i = new OC(f)), h(i, l, t), i.chunks.length !== 1) throw new Error(`Unexpected error: pre-calculated length for ${l} was wrong`);
                return s ? i.toBytes() : yg(i.chunks[0]);
            }
        }
        return i.reset(), yd(i, l, e, t), i.toBytes(!0);
    }
    function ip(n, e) {
        return e = Object.assign({}, dV, e), IV(e) ? (rp.reset(), QC(rp, n, e, void 0), rp.toBytes(!0)) : qC(n, md, e);
    }
    const CV = {
        strict: !1,
        allowIndefinite: !0,
        allowUndefined: !0,
        allowBigInt: !0
    };
    class TV {
        constructor(e, t = {}){
            this._pos = 0, this.data = e, this.options = t;
        }
        pos() {
            return this._pos;
        }
        done() {
            return this._pos >= this.data.length;
        }
        next() {
            const e = this.data[this._pos];
            let t = pi[e];
            if (t === void 0) {
                const r = ve[e];
                if (!r) throw new Error(`${ke} no decoder for major type ${e >>> 5} (byte 0x${e.toString(16).padStart(2, "0")})`);
                const s = e & 31;
                t = r(this.data, this._pos, s, this.options);
            }
            return this._pos += t.encodedLength, t;
        }
    }
    const Qd = Symbol.for("DONE"), Eg = Symbol.for("BREAK");
    function _V(n, e, t) {
        const r = [];
        for(let s = 0; s < n.value; s++){
            const i = qd(e, t);
            if (i === Eg) {
                if (n.value === 1 / 0) break;
                throw new Error(`${ke} got unexpected break to lengthed array`);
            }
            if (i === Qd) throw new Error(`${ke} found array but not enough entries (got ${s}, expected ${n.value})`);
            r[s] = i;
        }
        return r;
    }
    function xV(n, e, t) {
        const r = t.useMaps === !0, s = t.rejectDuplicateMapKeys === !0, i = r ? void 0 : {}, l = r ? new Map : void 0;
        for(let u = 0; u < n.value; u++){
            const h = qd(e, t);
            if (h === Eg) {
                if (n.value === 1 / 0) break;
                throw new Error(`${ke} got unexpected break to lengthed map`);
            }
            if (h === Qd) throw new Error(`${ke} found map but not enough entries (got ${u} [no key], expected ${n.value})`);
            if (!r && typeof h != "string") throw new Error(`${ke} non-string keys not supported (got ${typeof h})`);
            if (s && (r && l.has(h) || !r && Object.hasOwn(i, h))) throw new Error(`${ke} found repeat map key "${h}"`);
            const f = qd(e, t);
            if (f === Qd) throw new Error(`${ke} found map but not enough entries (got ${u} [no value], expected ${n.value})`);
            r ? l.set(h, f) : i[h] = f;
        }
        return r ? l : i;
    }
    function qd(n, e) {
        if (n.done()) return Qd;
        const t = n.next();
        if (U.equals(t.type, U.break)) return Eg;
        if (t.type.terminal) return t.value;
        if (U.equals(t.type, U.array)) return _V(t, n, e);
        if (U.equals(t.type, U.map)) return xV(t, n, e);
        if (U.equals(t.type, U.tag)) {
            if (e.tags && typeof e.tags[t.value] == "function") {
                const r = qd(n, e);
                return e.tags[t.value](r);
            }
            throw new Error(`${ke} tag not supported (${t.value})`);
        }
        throw new Error("unsupported");
    }
    function DV(n, e) {
        if (!(n instanceof Uint8Array)) throw new Error(`${ke} data to decode must be a Uint8Array`);
        e = Object.assign({}, CV, e);
        const t = yg(n), r = e.tokenizer || new TV(t, e), s = qd(r, e);
        if (s === Qd) throw new Error(`${ke} did not find any content to decode`);
        if (s === Eg) throw new Error(`${ke} got unexpected break`);
        return [
            s,
            n.subarray(r.pos())
        ];
    }
    function Ro(n, e) {
        const [t, r] = DV(n, e);
        if (r.length > 0) throw new Error(`${ke} too many terminals, data makes no sense`);
        return t;
    }
    const $c = 1e3, Mc = $c * 60, Nc = Mc * 60, Qa = Nc * 24, Kd = Qa * 7, Lc = Qa * 365.25, Gd = Lc / 12;
    function BV(n, e) {
        if (typeof n == "string") return PV(n);
        if (typeof n == "number") return OV(n, e);
        throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(n)}`);
    }
    var KC = BV;
    function PV(n) {
        if (typeof n != "string" || n.length === 0 || n.length > 100) throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(n)}`);
        let e = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(n);
        if (!e?.groups) return NaN;
        let { value: t, unit: r = "ms" } = e.groups, s = parseFloat(t), i = r.toLowerCase();
        switch(i){
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
                return s * Lc;
            case "months":
            case "month":
            case "mo":
                return s * Gd;
            case "weeks":
            case "week":
            case "w":
                return s * Kd;
            case "days":
            case "day":
            case "d":
                return s * Qa;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
                return s * Nc;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
                return s * Mc;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
                return s * $c;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
                return s;
            default:
                throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(n)}`);
        }
    }
    function kV(n) {
        let e = Math.abs(n);
        return e >= Lc ? `${Math.round(n / Lc)}y` : e >= Gd ? `${Math.round(n / Gd)}mo` : e >= Kd ? `${Math.round(n / Kd)}w` : e >= Qa ? `${Math.round(n / Qa)}d` : e >= Nc ? `${Math.round(n / Nc)}h` : e >= Mc ? `${Math.round(n / Mc)}m` : e >= $c ? `${Math.round(n / $c)}s` : `${n}ms`;
    }
    function RV(n) {
        let e = Math.abs(n);
        return e >= Lc ? ba(n, e, Lc, "year") : e >= Gd ? ba(n, e, Gd, "month") : e >= Kd ? ba(n, e, Kd, "week") : e >= Qa ? ba(n, e, Qa, "day") : e >= Nc ? ba(n, e, Nc, "hour") : e >= Mc ? ba(n, e, Mc, "minute") : e >= $c ? ba(n, e, $c, "second") : `${n} ms`;
    }
    function OV(n, e) {
        if (typeof n != "number" || !Number.isFinite(n)) throw Error("Value provided to ms.format() must be of type number.");
        return e?.long ? RV(n) : kV(n);
    }
    function ba(n, e, t, r) {
        let s = e >= t * 1.5;
        return `${Math.round(n / t)} ${r}${s ? "s" : ""}`;
    }
    function $V(n) {
        t.debug = t, t.default = t, t.coerce = h, t.disable = i, t.enable = s, t.enabled = l, t.humanize = KC, t.destroy = f, Object.keys(n).forEach((p)=>{
            t[p] = n[p];
        }), t.names = [], t.skips = [], t.formatters = {};
        function e(p) {
            let m = 0;
            for(let w = 0; w < p.length; w++)m = (m << 5) - m + p.charCodeAt(w), m |= 0;
            return t.colors[Math.abs(m) % t.colors.length];
        }
        t.selectColor = e;
        function t(p, m) {
            let w, A = null, S, _;
            function I(...k) {
                if (!I.enabled) return;
                const G = I, P = Number(new Date), J = P - (w || P);
                G.diff = J, G.prev = w, G.curr = P, w = P, k[0] = t.coerce(k[0]), typeof k[0] != "string" && k.unshift("%O");
                let H = 0;
                k[0] = k[0].replace(/%([a-zA-Z%])/g, ($, Y)=>{
                    if ($ === "%%") return "%";
                    H++;
                    const O = t.formatters[Y];
                    if (typeof O == "function") {
                        const se = k[H];
                        $ = O.call(G, se), k.splice(H, 1), H--;
                    }
                    return $;
                }), t.formatArgs.call(G, k), m?.onLog != null && m.onLog(...k), (G.log || t.log).apply(G, k);
            }
            return I.namespace = p, I.useColors = t.useColors(), I.color = t.selectColor(p), I.extend = r, I.destroy = t.destroy, Object.defineProperty(I, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: ()=>A !== null ? A : (S !== t.namespaces && (S = t.namespaces, _ = t.enabled(p)), _),
                set: (k)=>{
                    A = k;
                }
            }), typeof t.init == "function" && t.init(I), I;
        }
        function r(p, m) {
            const w = t(this.namespace + (typeof m > "u" ? ":" : m) + p);
            return w.log = this.log, w;
        }
        function s(p) {
            t.save(p), t.namespaces = p, t.names = [], t.skips = [];
            let m;
            const w = (typeof p == "string" ? p : "").split(/[\s,]+/), A = w.length;
            for(m = 0; m < A; m++)w[m] && (p = w[m].replace(/\*/g, ".*?"), p[0] === "-" ? t.skips.push(new RegExp("^" + p.substr(1) + "$")) : t.names.push(new RegExp("^" + p + "$")));
        }
        function i() {
            const p = [
                ...t.names.map(u),
                ...t.skips.map(u).map((m)=>"-" + m)
            ].join(",");
            return t.enable(""), p;
        }
        function l(p) {
            if (p[p.length - 1] === "*") return !0;
            let m, w;
            for(m = 0, w = t.skips.length; m < w; m++)if (t.skips[m].test(p)) return !1;
            for(m = 0, w = t.names.length; m < w; m++)if (t.names[m].test(p)) return !0;
            return !1;
        }
        function u(p) {
            return p.toString().substring(2, p.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function h(p) {
            return p instanceof Error ? p.stack ?? p.message : p;
        }
        function f() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return t.setupFormatters(t.formatters), t.enable(t.load()), t;
    }
    var MV = {};
    const _p = HV(), NV = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
    ];
    function LV() {
        return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null ? !1 : typeof document < "u" && document.documentElement?.style?.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function UV(n) {
        if (n[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + n[0] + (this.useColors ? "%c " : " ") + "+" + KC(this.diff), !this.useColors) return;
        const e = "color: " + this.color;
        n.splice(1, 0, e, "color: inherit");
        let t = 0, r = 0;
        n[0].replace(/%[a-zA-Z%]/g, (s)=>{
            s !== "%%" && (t++, s === "%c" && (r = t));
        }), n.splice(r, 0, e);
    }
    const zV = console.debug ?? console.log ?? (()=>{});
    function FV(n) {
        try {
            n ? _p?.setItem("debug", n) : _p?.removeItem("debug");
        } catch  {}
    }
    function VV() {
        let n;
        try {
            n = _p?.getItem("debug");
        } catch  {}
        return !n && typeof globalThis.process < "u" && "env" in globalThis.process && (n = MV.DEBUG), n;
    }
    function HV() {
        try {
            return localStorage;
        } catch  {}
    }
    function QV(n) {
        n.j = function(e) {
            try {
                return JSON.stringify(e);
            } catch (t) {
                return "[UnexpectedJSONParseError]: " + t.message;
            }
        };
    }
    const Lr = $V({
        formatArgs: UV,
        save: FV,
        load: VV,
        useColors: LV,
        setupFormatters: QV,
        colors: NV,
        storage: _p,
        log: zV
    });
    Lr.formatters.b = (n)=>n == null ? "undefined" : He.baseEncode(n);
    Lr.formatters.t = (n)=>n == null ? "undefined" : At.baseEncode(n);
    Lr.formatters.m = (n)=>n == null ? "undefined" : As.baseEncode(n);
    Lr.formatters.p = (n)=>n == null ? "undefined" : n.toString();
    Lr.formatters.c = (n)=>n == null ? "undefined" : n.toString();
    Lr.formatters.k = (n)=>n == null ? "undefined" : n.toString();
    Lr.formatters.a = (n)=>n == null ? "undefined" : n.toString();
    function sv(n, e = "") {
        const t = iv(n.message), r = iv(n.stack);
        return t != null && r != null ? r.includes(t) ? `${r.split(`
`).join(`
${e}`)}` : `${t}
${e}${r.split(`
`).join(`
${e}`)}` : r != null ? `${r.split(`
`).join(`
${e}`)}` : t != null ? `${t}` : `${n.toString()}`;
    }
    function qV(n) {
        return n instanceof AggregateError || n?.name === "AggregateError" && Array.isArray(n.errors);
    }
    function GC(n, e = "") {
        if (qV(n)) {
            let t = sv(n, e);
            return n.errors.length > 0 ? (e = `${e}    `, t += `
${e}${n.errors.map((r)=>`${GC(r, `${e}`)}`).join(`
${e}`)}`) : t += `
${e}[Error list was empty]`, t.trim();
        }
        return sv(n, e);
    }
    Lr.formatters.e = (n)=>n == null ? "undefined" : GC(n);
    function KV(n) {
        const e = ()=>{};
        return e.enabled = !1, e.color = "", e.diff = 0, e.log = ()=>{}, e.namespace = n, e.destroy = ()=>!0, e.extend = ()=>e, e;
    }
    function F6(n) {
        return {
            forComponent (e) {
                return ou(e, n);
            }
        };
    }
    function ou(n, e) {
        let t = KV(`${n}:trace`);
        return Lr.enabled(`${n}:trace`) && Lr.names.map((r)=>r.toString()).find((r)=>r.includes(":trace")) != null && (t = Lr(`${n}:trace`, e)), Object.assign(Lr(n, e), {
            error: Lr(`${n}:error`, e),
            trace: t,
            newScope: (r)=>ou(`${n}:${r}`, e)
        });
    }
    function iv(n) {
        if (n != null && (n = n.trim(), n.length !== 0)) return n;
    }
    const ov = 2147483647, YC = Symbol.for("sindresorhus/unlimited-timeout#brand");
    function GV(n, e, ...t) {
        if (typeof n != "function") throw new TypeError("Expected callback to be a function");
        e ??= 0, e = Number(e);
        let r = !1;
        const s = {
            [YC]: !0,
            id: void 0,
            cleared: !1,
            ref () {
                return r = !1, s.id?.ref?.(), s;
            },
            unref () {
                return r = !0, s.id?.unref?.(), s;
            }
        };
        if (e === Number.POSITIVE_INFINITY || e > Number.MAX_SAFE_INTEGER) return s;
        (!Number.isFinite(e) || e < 0) && (e = 0);
        const i = performance.now() + e, l = (u)=>{
            s.cleared || (u <= ov ? (s.id = globalThis.setTimeout(()=>{
                s.cleared || n(...t);
            }, u), r && s.id?.unref?.()) : (s.id = globalThis.setTimeout(()=>{
                const h = performance.now(), f = Math.max(0, i - h);
                l(f);
            }, ov), r && s.id?.unref?.()));
        };
        return l(e), s;
    }
    function YV(n) {
        !n || typeof n != "object" || !n[YC] || (n.cleared = !0, n.id !== void 0 && (globalThis.clearTimeout(n.id), n.id = void 0));
    }
    const WV = new WeakMap;
    function jV({ clearTimeout: n, setTimeout: e } = {}) {
        return (t, { value: r, signal: s } = {})=>{
            if (s?.aborted) return Promise.reject(s.reason);
            let i, l, u;
            const h = n ?? clearTimeout, f = ()=>{
                h(i), u(s.reason);
            }, p = ()=>{
                s && s.removeEventListener("abort", f);
            }, m = new Promise((w, A)=>{
                l = ()=>{
                    p(), w(r);
                }, u = A, i = (e ?? setTimeout)(l, t);
            });
            return s && s.addEventListener("abort", f, {
                once: !0
            }), WV.set(m, ()=>{
                h(i), i = null, l();
            }), m;
        };
    }
    const XV = jV({
        setTimeout: GV,
        clearTimeout: YV
    });
    class Wo extends Yo {
        has(e) {
            return this.find(e) != null;
        }
        find(e) {
            return this.queue.find((t)=>e.equals(t.options.peerId));
        }
    }
    let JV = class extends Yo {
        constructor(e = {}){
            super({
                ...e,
                sort: (t, r)=>t.options.priority > r.options.priority ? -1 : t.options.priority < r.options.priority ? 1 : 0
            });
        }
    };
    class WC {
        memoryStorage;
        points;
        duration;
        blockDuration;
        keyPrefix;
        constructor(e = {}){
            this.points = e.points ?? 4, this.duration = e.duration ?? 1, this.blockDuration = e.blockDuration ?? 0, this.keyPrefix = e.keyPrefix ?? "rlflx", this.memoryStorage = new ZV;
        }
        consume(e, t = 1, r = {}) {
            const s = this.getKey(e), i = this._getKeySecDuration(r);
            let l = this.memoryStorage.incrby(s, t, i);
            if (l.remainingPoints = Math.max(this.points - l.consumedPoints, 0), l.consumedPoints > this.points) throw this.blockDuration > 0 && l.consumedPoints <= this.points + t && (l = this.memoryStorage.set(s, l.consumedPoints, this.blockDuration)), new Pz("Rate limit exceeded", l);
            return l;
        }
        penalty(e, t = 1, r = {}) {
            const s = this.getKey(e), i = this._getKeySecDuration(r), l = this.memoryStorage.incrby(s, t, i);
            return l.remainingPoints = Math.max(this.points - l.consumedPoints, 0), l;
        }
        reward(e, t = 1, r = {}) {
            const s = this.getKey(e), i = this._getKeySecDuration(r), l = this.memoryStorage.incrby(s, -t, i);
            return l.remainingPoints = Math.max(this.points - l.consumedPoints, 0), l;
        }
        block(e, t) {
            const r = t * 1e3, s = this.points + 1;
            return this.memoryStorage.set(this.getKey(e), s, t), {
                remainingPoints: 0,
                msBeforeNext: r === 0 ? -1 : r,
                consumedPoints: s,
                isFirstInDuration: !1
            };
        }
        set(e, t, r = 0) {
            const s = (r >= 0 ? r : this.duration) * 1e3;
            return this.memoryStorage.set(this.getKey(e), t, r), {
                remainingPoints: 0,
                msBeforeNext: s === 0 ? -1 : s,
                consumedPoints: t,
                isFirstInDuration: !1
            };
        }
        get(e) {
            const t = this.memoryStorage.get(this.getKey(e));
            return t != null && (t.remainingPoints = Math.max(this.points - t.consumedPoints, 0)), t;
        }
        delete(e) {
            this.memoryStorage.delete(this.getKey(e));
        }
        _getKeySecDuration(e) {
            return e?.customDuration != null && e.customDuration >= 0 ? e.customDuration : this.duration;
        }
        getKey(e) {
            return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${e}` : e;
        }
        parseKey(e) {
            return e.substring(this.keyPrefix.length);
        }
    }
    class ZV {
        storage;
        constructor(){
            this.storage = new Map;
        }
        incrby(e, t, r) {
            const s = this.storage.get(e);
            if (s != null) {
                const i = s.expiresAt != null ? s.expiresAt.getTime() - new Date().getTime() : -1;
                return s.expiresAt == null || i > 0 ? (s.value += t, {
                    remainingPoints: 0,
                    msBeforeNext: i,
                    consumedPoints: s.value,
                    isFirstInDuration: !1
                }) : this.set(e, t, r);
            }
            return this.set(e, t, r);
        }
        set(e, t, r) {
            const s = r * 1e3, i = this.storage.get(e);
            i != null && clearTimeout(i.timeoutId);
            const l = {
                value: t,
                expiresAt: s > 0 ? new Date(Date.now() + s) : void 0
            };
            return this.storage.set(e, l), s > 0 && (l.timeoutId = setTimeout(()=>{
                this.storage.delete(e);
            }, s), l.timeoutId.unref != null && l.timeoutId.unref()), {
                remainingPoints: 0,
                msBeforeNext: s === 0 ? -1 : s,
                consumedPoints: l.value,
                isFirstInDuration: !0
            };
        }
        get(e) {
            const t = this.storage.get(e);
            if (t != null) return {
                remainingPoints: 0,
                msBeforeNext: t.expiresAt != null ? t.expiresAt.getTime() - new Date().getTime() : -1,
                consumedPoints: t.value,
                isFirstInDuration: !1
            };
        }
        delete(e) {
            const t = this.storage.get(e);
            return t != null ? (t.timeoutId != null && clearTimeout(t.timeoutId), this.storage.delete(e), !0) : !1;
        }
    }
    function V6(n, e, t) {
        let r, s, i = !1;
        function l() {
            const f = {
                signal: s.signal
            };
            if (t?.timeout != null) {
                const p = gt([
                    s.signal,
                    AbortSignal.timeout(t.timeout)
                ]);
                f.signal = p;
            }
            i = !0, Promise.resolve().then(async ()=>{
                await n(f);
            }).catch(()=>{}).finally(()=>{
                i = !1, !s.signal.aborted && (r = setTimeout(l, e));
            });
        }
        const u = zd(l, t?.debounce ?? 100);
        let h = !1;
        return {
            setInterval: (f)=>{
                e !== f && (e = f, r != null && (clearTimeout(r), r = setTimeout(l, e)));
            },
            setTimeout: (f)=>{
                t ??= {}, t.timeout = f;
            },
            run: ()=>{
                i || (clearTimeout(r), u());
            },
            start: ()=>{
                h || (h = !0, s = new AbortController, s.signal, t?.runImmediately === !0 ? queueMicrotask(()=>{
                    l();
                }) : r = setTimeout(l, e));
            },
            stop: ()=>{
                clearTimeout(r), s?.abort(), h = !1;
            }
        };
    }
    class eH extends Map {
        metric;
        constructor(e){
            super();
            const { name: t, metrics: r } = e;
            this.metric = r.registerMetric(t), this.updateComponentMetric();
        }
        set(e, t) {
            return super.set(e, t), this.updateComponentMetric(), this;
        }
        delete(e) {
            const t = super.delete(e);
            return this.updateComponentMetric(), t;
        }
        clear() {
            super.clear(), this.updateComponentMetric();
        }
        updateComponentMetric() {
            this.metric.update(this.size);
        }
    }
    function Qs(n) {
        const { name: e, metrics: t } = n;
        let r;
        return t != null ? r = new eH({
            name: e,
            metrics: t
        }) : r = new Map, r;
    }
    const zi = "/", jC = new TextEncoder().encode(zi), h0 = jC[0];
    class Nt {
        _buf;
        constructor(e, t){
            if (typeof e == "string") this._buf = re(e);
            else if (e instanceof Uint8Array) this._buf = e;
            else throw new Error("Invalid key, should be String of Uint8Array");
            if (t == null && (t = !0), t && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== h0) throw new Error("Invalid key");
        }
        toString(e = "utf8") {
            return L(this._buf, e);
        }
        uint8Array() {
            return this._buf;
        }
        get [Symbol.toStringTag]() {
            return `Key(${this.toString()})`;
        }
        static withNamespaces(e) {
            return new Nt(e.join(zi));
        }
        static random() {
            return new Nt(Math.random().toString().substring(2));
        }
        static asKey(e) {
            return e instanceof Uint8Array || typeof e == "string" ? new Nt(e) : typeof e.uint8Array == "function" ? new Nt(e.uint8Array()) : null;
        }
        clean() {
            if ((this._buf == null || this._buf.byteLength === 0) && (this._buf = jC), this._buf[0] !== h0) {
                const e = new Uint8Array(this._buf.byteLength + 1);
                e.fill(h0, 0, 1), e.set(this._buf, 1), this._buf = e;
            }
            for(; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === h0;)this._buf = this._buf.subarray(0, -1);
        }
        less(e) {
            const t = this.list(), r = e.list();
            for(let s = 0; s < t.length; s++){
                if (r.length < s + 1) return !1;
                const i = t[s], l = r[s];
                if (i < l) return !0;
                if (i > l) return !1;
            }
            return t.length < r.length;
        }
        reverse() {
            return Nt.withNamespaces(this.list().slice().reverse());
        }
        namespaces() {
            return this.list();
        }
        baseNamespace() {
            const e = this.namespaces();
            return e[e.length - 1];
        }
        list() {
            return this.toString().split(zi).slice(1);
        }
        type() {
            return tH(this.baseNamespace());
        }
        name() {
            return nH(this.baseNamespace());
        }
        instance(e) {
            return new Nt(this.toString() + ":" + e);
        }
        path() {
            let e = this.parent().toString();
            return e.endsWith(zi) || (e += zi), e += this.type(), new Nt(e);
        }
        parent() {
            const e = this.list();
            return e.length === 1 ? new Nt(zi) : new Nt(e.slice(0, -1).join(zi));
        }
        child(e) {
            return this.toString() === zi ? e : e.toString() === zi ? this : new Nt(this.toString() + e.toString(), !1);
        }
        isAncestorOf(e) {
            return e.toString() === this.toString() ? !1 : e.toString().startsWith(this.toString());
        }
        isDecendantOf(e) {
            return e.toString() === this.toString() ? !1 : this.toString().startsWith(e.toString());
        }
        isTopLevel() {
            return this.list().length === 1;
        }
        concat(...e) {
            return Nt.withNamespaces([
                ...this.namespaces(),
                ...rH(e.map((t)=>t.namespaces()))
            ]);
        }
    }
    function tH(n) {
        const e = n.split(":");
        return e.length < 2 ? "" : e.slice(0, -1).join(":");
    }
    function nH(n) {
        const e = n.split(":");
        return e[e.length - 1];
    }
    function rH(n) {
        return [].concat(...n);
    }
    function sH(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function XC(n) {
        if (sH(n)) return (async ()=>{
            let r = new Uint8Array(0);
            for await (const s of n)r = xe([
                r,
                s
            ], r.length + s.length);
            return r;
        })();
        const e = [];
        let t = 0;
        for (const r of n)e.push(r), t += r.byteLength;
        return xe(e, t);
    }
    function d0({ enumerable: n = !0, configurable: e = !1 } = {}) {
        return {
            enumerable: n,
            configurable: e,
            writable: !1
        };
    }
    function* iH(n, e) {
        if (e != null && typeof e == "object") if (Array.isArray(e)) for (const [t, r] of e.entries()){
            const s = [
                ...n,
                t
            ], i = ge.asCID(r);
            i != null ? yield [
                s.join("/"),
                i
            ] : typeof r == "object" && (yield* Vy(r, s));
        }
        else {
            const t = ge.asCID(e);
            t != null ? yield [
                n.join("/"),
                t
            ] : yield* Vy(e, n);
        }
    }
    function* Vy(n, e) {
        if (n == null || n instanceof Uint8Array) return;
        const t = ge.asCID(n);
        t != null && (yield [
            e.join("/"),
            t
        ]);
        for (const [r, s] of Object.entries(n)){
            const i = [
                ...e,
                r
            ];
            yield* iH(i, s);
        }
    }
    function* oH(n, e) {
        if (Array.isArray(e)) for (const [t, r] of e.entries()){
            const s = [
                ...n,
                t
            ];
            yield s.join("/"), typeof r == "object" && ge.asCID(r) == null && (yield* Hy(r, s));
        }
        else yield* Hy(e, n);
    }
    function* Hy(n, e) {
        if (!(n == null || typeof n != "object")) for (const [t, r] of Object.entries(n)){
            const s = [
                ...e,
                t
            ];
            yield s.join("/"), r != null && !(r instanceof Uint8Array) && typeof r == "object" && ge.asCID(r) == null && (yield* oH(s, r));
        }
    }
    function aH(n, e) {
        let t = n;
        for (const [r, s] of e.entries()){
            if (t = t[s], t == null) throw new Error(`Object has no property at ${e.slice(0, r + 1).map((l)=>`[${JSON.stringify(l)}]`).join("")}`);
            const i = ge.asCID(t);
            if (i != null) return {
                value: i,
                remaining: e.slice(r + 1).join("/")
            };
        }
        return {
            value: t
        };
    }
    let lH = class {
        cid;
        bytes;
        value;
        asBlock;
        constructor({ cid: e, bytes: t, value: r }){
            if (e == null || t == null || typeof r > "u") throw new Error("Missing required argument");
            this.cid = e, this.bytes = t, this.value = r, this.asBlock = this, Object.defineProperties(this, {
                cid: d0(),
                bytes: d0(),
                value: d0(),
                asBlock: d0()
            });
        }
        links() {
            return Vy(this.value, []);
        }
        tree() {
            return Hy(this.value, []);
        }
        get(e = "/") {
            return aH(this.value, e.split("/").filter(Boolean));
        }
    };
    function cH({ bytes: n, cid: e, value: t, codec: r }) {
        const s = t !== void 0 ? t : r?.decode(n);
        if (s === void 0) throw new Error('Missing required argument, must either provide "value" or "codec"');
        return new lH({
            cid: e,
            bytes: n,
            value: s
        });
    }
    class uH extends Error {
        static name = "AlreadyPinnedError";
        name = "AlreadyPinnedError";
    }
    class av extends Error {
        static name = "BlockPinnedError";
        name = "BlockPinnedError";
    }
    class hH extends Error {
        static name = "InvalidDatastoreVersionError";
        name = "InvalidDatastoreVersionError";
    }
    class Qy extends Error {
        static name = "InvalidConfigurationError";
        name = "InvalidConfigurationError";
    }
    class dH extends AggregateError {
        static name = "GetFailedError";
        name = "GetFailedError";
    }
    class fH extends AggregateError {
        static name = "LoadBlockFailedError";
        name = "LoadBlockFailedError";
    }
    class lv extends Error {
        static name = "BlockNotFoundWhileOfflineError";
        name = "BlockNotFoundWhileOfflineError";
    }
    const JC = "/pin/", cv = "/pinned-block/", qy = No, uv = 1;
    function f0(n) {
        return n.version === 0 && (n = n.toV1()), new Nt(`${JC}${n.toString(qy)}`);
    }
    class pH {
        datastore;
        blockstore;
        getCodec;
        constructor(e, t, r){
            this.datastore = e, this.blockstore = t, this.getCodec = r;
        }
        async *add(e, t = {}) {
            const r = f0(e);
            if (await this.datastore.has(r)) throw new uH("Already pinned");
            const s = Math.round(t.depth ?? 1 / 0);
            if (s < 0) throw new jS("Depth must be greater than or equal to 0");
            const i = new Yo({
                concurrency: uv
            });
            for await (const u of this.#e(e, i, {
                ...t,
                depth: s
            }))await this.#t(u, (h)=>h.pinnedBy.find((f)=>Ee(f, e.bytes)) != null ? !1 : (h.pinCount++, h.pinnedBy.push(e.bytes), !0), t), yield u;
            const l = {
                depth: s,
                metadata: t.metadata ?? {}
            };
            await this.datastore.put(r, ip(l), t);
        }
        async *#e(e, t, r) {
            if (r.depth === -1) return;
            const s = await this.getCodec(e.code), i = await XC(this.blockstore.get(e, r)), l = cH({
                bytes: i,
                cid: e,
                codec: s
            });
            yield e;
            for (const [, u] of l.links())yield* await t.add(async ()=>this.#e(u, t, {
                    ...r,
                    depth: r.depth - 1
                }));
        }
        async #t(e, t, r) {
            const s = new Nt(`${cv}${qy.encode(e.multihash.bytes)}`);
            let i = {
                pinCount: 0,
                pinnedBy: []
            };
            try {
                i = Ro(await this.datastore.get(s, r));
            } catch (u) {
                if (u.name !== "NotFoundError") throw u;
            }
            if (t(i)) {
                if (i.pinCount === 0 && await this.datastore.has(s)) {
                    await this.datastore.delete(s);
                    return;
                }
                await this.datastore.put(s, ip(i), r), r.onProgress?.(new Be("helia:pin:add", e));
            }
        }
        async *rm(e, t = {}) {
            const r = f0(e), s = await this.datastore.get(r, t), i = Ro(s);
            await this.datastore.delete(r, t);
            const l = new Yo({
                concurrency: uv
            });
            for await (const u of this.#e(e, l, {
                ...t,
                depth: i.depth
            }))await this.#t(u, (h)=>(h.pinCount--, h.pinnedBy = h.pinnedBy.filter((f)=>Ee(f, e.bytes)), !0), {
                ...t,
                depth: i.depth
            }), yield u;
        }
        async *ls(e = {}) {
            for await (const { key: t, value: r } of this.datastore.query({
                prefix: JC + (e.cid != null ? `${e.cid.toString(No)}` : "")
            }, e)){
                const s = ge.parse(t.toString().substring(5), No), i = Ro(r);
                yield {
                    cid: s,
                    ...i
                };
            }
        }
        async isPinned(e, t = {}) {
            const r = new Nt(`${cv}${qy.encode(e.multihash.bytes)}`);
            return this.datastore.has(r, t);
        }
        async get(e, t) {
            const r = f0(e), s = await this.datastore.get(r, t);
            return Ro(s);
        }
        async setMetadata(e, t, r) {
            const s = f0(e), i = await this.datastore.get(s, r), l = Ro(i);
            l.metadata = t ?? {}, await this.datastore.put(s, ip(l), r);
        }
    }
    const gH = 1, mH = 5, yH = 100;
    class wH extends Error {
        static name = "InsufficientProvidersError";
        constructor(e = "Insufficient providers found"){
            super(e), this.name = "InsufficientProvidersError";
        }
    }
    class p0 extends Error {
        static name = "NoRoutersAvailableError";
        constructor(e = "No routers available"){
            super(e), this.name = "NoRoutersAvailableError";
        }
    }
    class bH extends Error {
        static name = "UnknownHashAlgorithmError";
        constructor(e = "Unknown hash algorithm"){
            super(e), this.name = "UnknownHashAlgorithmError";
        }
    }
    class vH extends Error {
        static name = "UnknownCodecError";
        constructor(e = "Unknown codec"){
            super(e), this.name = "UnknownCodecError";
        }
    }
    const EH = 5;
    class AH {
        log;
        routers;
        providerLookupConcurrency;
        constructor(e, t){
            this.log = e.logger.forComponent("helia:routing"), this.routers = t.routers ?? [], this.providerLookupConcurrency = t.providerLookupConcurrency ?? EH, this.findProviders = e.metrics?.traceFunction("helia.routing.findProviders", this.findProviders.bind(this), {
                optionsIndex: 1
            }) ?? this.findProviders, this.provide = e.metrics?.traceFunction("helia.routing.provide", this.provide.bind(this), {
                optionsIndex: 1
            }) ?? this.provide, this.cancelReprovide = e.metrics?.traceFunction("helia.routing.cancelReprovide", this.cancelReprovide.bind(this), {
                optionsIndex: 1
            }) ?? this.cancelReprovide, this.put = e.metrics?.traceFunction("helia.routing.put", this.put.bind(this), {
                optionsIndex: 2
            }) ?? this.put, this.get = e.metrics?.traceFunction("helia.routing.get", this.get.bind(this), {
                optionsIndex: 1
            }) ?? this.get, this.findPeer = e.metrics?.traceFunction("helia.routing.findPeer", this.findPeer.bind(this), {
                optionsIndex: 1
            }) ?? this.findPeer, this.getClosestPeers = e.metrics?.traceFunction("helia.routing.getClosestPeers", this.getClosestPeers.bind(this), {
                optionsIndex: 1
            }) ?? this.getClosestPeers;
        }
        async start() {
            await ag(...this.routers);
        }
        async stop() {
            await lg(...this.routers);
        }
        async *findProviders(e, t = {}) {
            if (this.routers.length === 0) throw new p0("No content routers available");
            const r = new Wo({
                concurrency: this.providerLookupConcurrency
            });
            let s = 0;
            const i = this;
            let l = 0;
            this.log("findProviders for %c start using routers %s", e, this.routers.map((h)=>h.toString()).join(", "));
            const u = va(this.routers, "findProviders").map(async function*(h) {
                let f = 0;
                try {
                    for await (const p of h.findProviders(e, t))f++, yield p;
                } catch  {} finally{
                    i.log("router %s found %d providers for %c", h, f, e), l++, l === u.length && r.size === 0 && r.emitIdle();
                }
            });
            for await (const h of Uo(r.toGenerator(), ...u))if (h != null) {
                if (h.multiaddrs.length === 0) {
                    if (r.find(h.id) != null) continue;
                    r.add(async ()=>{
                        try {
                            const f = await this.findPeer(h.id, t);
                            return f.multiaddrs.length === 0 ? null : {
                                ...f,
                                protocols: h.protocols,
                                routing: h.routing
                            };
                        } catch (f) {
                            return this.log.error("could not load multiaddrs for peer %p - %e", h.id, f), null;
                        }
                    }, {
                        peerId: h.id,
                        signal: t.signal
                    }).catch((f)=>{
                        this.log.error("could not load multiaddrs for peer %p - %e", h.id, f);
                    });
                    continue;
                }
                s++, yield h;
            }
            this.log("findProviders finished, found %d providers for %c", s, e);
        }
        async provide(e, t = {}) {
            if (this.routers.length === 0) throw new p0("No content routers available");
            await Promise.all(va(this.routers, "provide").map(async (r)=>{
                await r.provide(e, t);
            }));
        }
        async cancelReprovide(e, t = {}) {
            await Promise.all(va(this.routers, "cancelReprovide").map(async (r)=>{
                await r.cancelReprovide(e, t);
            }));
        }
        async put(e, t, r) {
            await Promise.all(va(this.routers, "put").map(async (s)=>{
                await s.put(e, t, r);
            }));
        }
        async get(e, t) {
            const r = [];
            let s;
            try {
                s = await Promise.any(va(this.routers, "get").map(async (i)=>{
                    try {
                        return await i.get(e, t);
                    } catch (l) {
                        this.log("router %s failed with %e", i, l), r.push(l);
                    }
                }));
            } catch  {}
            if (s == null) throw new dH(r, `Failed to get value key ${L(e, "base58btc")}`);
            return s;
        }
        async findPeer(e, t) {
            if (this.routers.length === 0) throw new p0("No peer routers available");
            const r = this, s = Uo(...va(this.routers, "findPeer").map((i)=>(async function*() {
                    try {
                        yield await i.findPeer(e, t);
                    } catch (l) {
                        r.log.error(l);
                    }
                })()));
            for await (const i of s)if (i != null) return i;
            throw new h$("Could not find peer in routing");
        }
        async *getClosestPeers(e, t = {}) {
            if (this.routers.length === 0) throw new p0("No peer routers available");
            for await (const r of Uo(...va(this.routers, "getClosestPeers").map((s)=>s.getClosestPeers(e, t))))r != null && (yield r);
        }
    }
    function va(n, e) {
        return n.filter((t)=>t[e] != null);
    }
    let Uc = class extends Error {
        static name = "AbortError";
        name = "AbortError";
        constructor(e = "The operation was aborted", ...t){
            super(e, ...t);
        }
    };
    async function si(n, e, t, r) {
        const s = new Uc(r?.errorMessage);
        r?.errorCode != null && (s.code = r.errorCode);
        const i = r?.errorEvent ?? "error";
        return t?.aborted === !0 ? Promise.reject(s) : new Promise((l, u)=>{
            function h() {
                T3(t, "abort", m), T3(n, e, f), T3(n, i, p);
            }
            const f = (w)=>{
                try {
                    if (r?.filter?.(w) === !1) return;
                } catch (A) {
                    h(), u(A);
                    return;
                }
                h(), l(w);
            }, p = (w)=>{
                if (h(), w instanceof Error) {
                    u(w);
                    return;
                }
                u(w.detail ?? r?.error ?? new Error(`The "${r?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
            }, m = ()=>{
                h(), u(s);
            };
            C3(t, "abort", m), C3(n, e, f), C3(n, i, p);
        });
    }
    function C3(n, e, t) {
        n != null && (ZC(n) ? n.addEventListener(e, t) : n.addListener(e, t));
    }
    function T3(n, e, t) {
        n != null && (ZC(n) ? n.removeEventListener(e, t) : n.removeListener(e, t));
    }
    function ZC(n) {
        return typeof n.addEventListener == "function" && typeof n.removeEventListener == "function";
    }
    class SH extends Error {
        static name = "QueueFullError";
        constructor(e = "The queue was full"){
            super(e), this.name = "QueueFullError";
        }
    }
    class IH {
        deferred;
        signal;
        constructor(e){
            this.signal = e, this.deferred = Promise.withResolvers(), this.onAbort = this.onAbort.bind(this), this.signal?.addEventListener("abort", this.onAbort);
        }
        onAbort() {
            this.deferred.reject(this.signal?.reason ?? new Uc);
        }
        cleanup() {
            this.signal?.removeEventListener("abort", this.onAbort);
        }
    }
    function CH() {
        return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
    }
    class TH {
        id;
        fn;
        options;
        recipients;
        status;
        timeline;
        controller;
        constructor(e, t){
            this.id = CH(), this.status = "queued", this.fn = e, this.options = t, this.recipients = [], this.timeline = {
                created: Date.now()
            }, this.controller = new AbortController, this.controller.signal, this.onAbort = this.onAbort.bind(this);
        }
        abort(e) {
            this.controller.abort(e);
        }
        onAbort() {
            this.recipients.reduce((t, r)=>t && r.signal?.aborted === !0, !0) && (this.controller.abort(new Uc), this.cleanup());
        }
        async join(e = {}) {
            const t = new IH(e.signal);
            return this.recipients.push(t), e.signal?.addEventListener("abort", this.onAbort), t.deferred.promise;
        }
        async run() {
            this.status = "running", this.timeline.started = Date.now();
            try {
                this.controller.signal.throwIfAborted();
                const e = await Xn(this.fn({
                    ...this.options ?? {},
                    signal: this.controller.signal
                }), this.controller.signal);
                this.recipients.forEach((t)=>{
                    t.deferred.resolve(e);
                }), this.status = "complete";
            } catch (e) {
                this.recipients.forEach((t)=>{
                    t.deferred.reject(e);
                }), this.status = "errored";
            } finally{
                this.timeline.finished = Date.now(), this.cleanup();
            }
        }
        cleanup() {
            this.recipients.forEach((e)=>{
                e.cleanup(), e.signal?.removeEventListener("abort", this.onAbort);
            });
        }
    }
    function hv(n, e) {
        let t;
        const r = function() {
            const s = function() {
                t = void 0, n();
            };
            clearTimeout(t), t = setTimeout(s, e);
        };
        return r.start = ()=>{}, r.stop = ()=>{
            clearTimeout(t);
        }, r;
    }
    class dv extends Lt {
        concurrency;
        maxSize;
        queue;
        pending;
        sort;
        autoStart;
        constructor(e = {}){
            super(), this.concurrency = e.concurrency ?? Number.POSITIVE_INFINITY, this.maxSize = e.maxSize ?? Number.POSITIVE_INFINITY, this.pending = 0, this.autoStart = e.autoStart ?? !0, this.sort = e.sort, this.queue = [], this.emitEmpty = hv(this.emitEmpty.bind(this), 1), this.emitIdle = hv(this.emitIdle.bind(this), 1);
        }
        [Symbol.asyncIterator]() {
            return this.toGenerator();
        }
        emitEmpty() {
            this.size === 0 && this.safeDispatchEvent("empty");
        }
        emitIdle() {
            this.running === 0 && this.safeDispatchEvent("idle");
        }
        tryToStartAnother() {
            if (this.size === 0) return this.emitEmpty(), this.running === 0 && this.emitIdle(), !1;
            if (this.pending < this.concurrency) {
                let e;
                for (const t of this.queue)if (t.status === "queued") {
                    e = t;
                    break;
                }
                return e == null ? !1 : (this.safeDispatchEvent("active"), this.pending++, e.run().finally(()=>{
                    for(let t = 0; t < this.queue.length; t++)if (this.queue[t] === e) {
                        this.queue.splice(t, 1);
                        break;
                    }
                    this.pending--, this.safeDispatchEvent("next"), this.autoStart && this.tryToStartAnother();
                }), !0);
            }
            return !1;
        }
        enqueue(e) {
            this.queue.push(e), this.sort != null && this.queue.sort(this.sort);
        }
        start() {
            this.autoStart === !1 && (this.autoStart = !0, this.tryToStartAnother());
        }
        pause() {
            this.autoStart = !1;
        }
        async add(e, t) {
            if (t?.signal?.throwIfAborted(), this.size === this.maxSize) throw new SH;
            const r = new TH(e, t);
            return this.enqueue(r), this.safeDispatchEvent("add"), this.autoStart && this.tryToStartAnother(), r.join(t).then((s)=>(this.safeDispatchEvent("success", {
                    detail: {
                        job: r,
                        result: s
                    }
                }), s)).catch((s)=>{
                if (r.status === "queued") {
                    for(let i = 0; i < this.queue.length; i++)if (this.queue[i] === r) {
                        this.queue.splice(i, 1);
                        break;
                    }
                }
                throw this.safeDispatchEvent("failure", {
                    detail: {
                        job: r,
                        error: s
                    }
                }), s;
            });
        }
        clear() {
            this.queue.splice(0, this.queue.length);
        }
        abort() {
            this.queue.forEach((e)=>{
                e.abort(new Uc);
            }), this.clear();
        }
        async onEmpty(e) {
            this.size !== 0 && await si(this, "empty", e?.signal);
        }
        async onSizeLessThan(e, t) {
            this.size < e || await si(this, "next", t?.signal, {
                filter: ()=>this.size < e
            });
        }
        async onIdle(e) {
            this.pending === 0 && this.size === 0 || await si(this, "idle", e?.signal);
        }
        get size() {
            return this.queue.length;
        }
        get queued() {
            return this.queue.length - this.pending;
        }
        get running() {
            return this.pending;
        }
        async *toGenerator(e) {
            e?.signal?.throwIfAborted();
            const t = Hs({
                objectMode: !0
            }), r = (h)=>{
                h != null ? this.abort() : this.clear(), t.end(h);
            }, s = (h)=>{
                h.detail != null && t.push(h.detail.result);
            }, i = (h)=>{
                r(h.detail.error);
            }, l = ()=>{
                r();
            }, u = ()=>{
                r(new Uc("Queue aborted"));
            };
            this.addEventListener("success", s), this.addEventListener("failure", i), this.addEventListener("idle", l), e?.signal?.addEventListener("abort", u);
            try {
                yield* t;
            } finally{
                this.removeEventListener("success", s), this.removeEventListener("failure", i), this.removeEventListener("idle", l), e?.signal?.removeEventListener("abort", u), r();
            }
        }
    }
    const eT = "lock:worker:request-read", tT = "lock:worker:abort-read-request", nT = "lock:worker:release-read", rT = "lock:master:grant-read", sT = "lock:master:error-read", iT = "lock:worker:request-write", oT = "lock:worker:abort-write-request", aT = "lock:worker:release-write", lT = "lock:master:grant-write", cT = "lock:master:error-write", uT = "lock:worker:finalize", hT = "mortice", _H = {
        singleProcess: !1
    }, fv = (n, e, t, r, s, i, l, u, h)=>(f)=>{
            if (f.data == null) return;
            const p = {
                type: f.data.type,
                name: f.data.name,
                identifier: f.data.identifier
            };
            p.type === s && n.safeDispatchEvent(t, {
                detail: {
                    name: p.name,
                    identifier: p.identifier,
                    handler: async ()=>{
                        e.postMessage({
                            type: h,
                            name: p.name,
                            identifier: p.identifier
                        }), await new Promise((m)=>{
                            const w = (A)=>{
                                if (A?.data == null) return;
                                const S = {
                                    type: A.data.type,
                                    name: A.data.name,
                                    identifier: A.data.identifier
                                };
                                S.type === u && S.identifier === p.identifier && (e.removeEventListener("message", w), m());
                            };
                            e.addEventListener("message", w);
                        });
                    },
                    onError: (m)=>{
                        e.postMessage({
                            type: l,
                            name: p.name,
                            identifier: p.identifier,
                            error: {
                                message: m.message,
                                name: m.name,
                                stack: m.stack
                            }
                        });
                    }
                }
            }), p.type === i && n.safeDispatchEvent(r, {
                detail: {
                    name: p.name,
                    identifier: p.identifier
                }
            }), p.type === uT && n.safeDispatchEvent("finalizeRequest", {
                detail: {
                    name: p.name
                }
            });
        }, xH = (n = 10)=>Math.random().toString().substring(2, n + 2);
    class DH {
        name;
        channel;
        constructor(e){
            this.name = e, this.channel = new BroadcastChannel(hT);
        }
        readLock(e) {
            return this.sendRequest(eT, tT, rT, sT, nT, e);
        }
        writeLock(e) {
            return this.sendRequest(iT, oT, lT, cT, aT, e);
        }
        finalize() {
            this.channel.postMessage({
                type: uT,
                name: this.name
            }), this.channel.close();
        }
        async sendRequest(e, t, r, s, i, l) {
            l?.signal?.throwIfAborted();
            const u = xH();
            return this.channel.postMessage({
                type: e,
                identifier: u,
                name: this.name
            }), new Promise((h, f)=>{
                const p = ()=>{
                    this.channel.postMessage({
                        type: t,
                        identifier: u,
                        name: this.name
                    });
                };
                l?.signal?.addEventListener("abort", p, {
                    once: !0
                });
                const m = (w)=>{
                    if (w.data?.identifier === u && (w.data?.type === r && (this.channel.removeEventListener("message", m), l?.signal?.removeEventListener("abort", p), h(()=>{
                        this.channel.postMessage({
                            type: i,
                            identifier: u,
                            name: this.name
                        });
                    })), w.data.type === s)) {
                        this.channel.removeEventListener("message", m), l?.signal?.removeEventListener("abort", p);
                        const A = new Error;
                        w.data.error != null && (A.message = w.data.error.message, A.name = w.data.error.name, A.stack = w.data.error.stack), f(A);
                    }
                };
                this.channel.addEventListener("message", m);
            });
        }
    }
    const BH = (n)=>{
        if (n = Object.assign({}, _H, n), !!globalThis.document || n.singleProcess) {
            const t = new BroadcastChannel(hT), r = new Lt;
            return t.addEventListener("message", fv(r, t, "requestReadLock", "abortReadLockRequest", eT, tT, sT, nT, rT)), t.addEventListener("message", fv(r, t, "requestWriteLock", "abortWriteLockRequest", iT, oT, cT, aT, lT)), r;
        }
        return new DH(n.name);
    }, Ra = new Map;
    let _h;
    function dT(n) {
        return typeof n?.readLock == "function" && typeof n?.writeLock == "function";
    }
    function PH(n) {
        if (_h == null && (_h = BH(n), !dT(_h))) {
            const e = _h;
            e.addEventListener("requestReadLock", (t)=>{
                const r = t.detail.name, s = t.detail.identifier, i = Ra.get(r);
                if (i == null) return;
                const l = new AbortController, u = (h)=>{
                    h.detail.name !== r || h.detail.identifier !== s || l.abort();
                };
                e.addEventListener("abortReadLockRequest", u), i.readLock({
                    signal: l.signal
                }).then(async (h)=>{
                    await t.detail.handler().finally(()=>{
                        h();
                    });
                }).catch((h)=>{
                    t.detail.onError(h);
                }).finally(()=>{
                    e.removeEventListener("abortReadLockRequest", u);
                });
            }), e.addEventListener("requestWriteLock", (t)=>{
                const r = t.detail.name, s = t.detail.identifier, i = Ra.get(r);
                if (i == null) return;
                const l = new AbortController, u = (h)=>{
                    h.detail.name !== r || h.detail.identifier !== s || l.abort();
                };
                e.addEventListener("abortWriteLockRequest", u), i.writeLock({
                    signal: l.signal
                }).then(async (h)=>{
                    await t.detail.handler().finally(()=>{
                        h();
                    });
                }).catch((h)=>{
                    t.detail.onError(h);
                }).finally(()=>{
                    e.removeEventListener("abortWriteLockRequest", u);
                });
            }), e.addEventListener("finalizeRequest", (t)=>{
                const r = t.detail.name, s = Ra.get(r);
                s?.finalize();
            });
        }
        return _h;
    }
    async function _3(n, e) {
        let t, r;
        const s = new Promise((l, u)=>{
            t = l, r = u;
        }), i = ()=>{
            r(new Uc);
        };
        return e?.signal?.addEventListener("abort", i, {
            once: !0
        }), n.add(async ()=>{
            await new Promise((l)=>{
                t(()=>{
                    e?.signal?.removeEventListener("abort", i), l();
                });
            });
        }, {
            signal: e?.signal
        }).catch((l)=>{
            r(l);
        }), s;
    }
    const kH = (n, e)=>{
        let t = Ra.get(n);
        if (t != null) return t;
        const r = PH(e);
        if (dT(r)) return t = r, Ra.set(n, t), t;
        const s = new dv({
            concurrency: 1
        });
        let i;
        return t = {
            async readLock (l) {
                if (i != null) return _3(i, l);
                i = new dv({
                    concurrency: e.concurrency,
                    autoStart: !1
                });
                const u = i, h = _3(i, l);
                return s.add(async ()=>{
                    u.start(), await u.onIdle().then(()=>{
                        i === u && (i = null);
                    });
                }), h;
            },
            async writeLock (l) {
                return i = null, _3(s, l);
            },
            finalize: ()=>{
                Ra.delete(n);
            },
            queue: s
        }, Ra.set(n, t), e.autoFinalize === !0 && s.addEventListener("idle", ()=>{
            t.finalize();
        }, {
            once: !0
        }), t;
    }, RH = {
        name: "lock",
        concurrency: 1 / 0,
        singleProcess: !1,
        autoFinalize: !1
    };
    function fT(n) {
        const e = Object.assign({}, RH, n);
        return kH(e.name, e);
    }
    class OH {
        lock;
        child;
        pins;
        started;
        constructor(e, t, r = {}){
            this.child = e, this.pins = t, this.lock = fT({
                singleProcess: r.holdGcLock
            }), this.started = !1;
        }
        isStarted() {
            return this.started;
        }
        async start() {
            await ag(this.child), this.started = !0;
        }
        async stop() {
            await lg(this.child), this.started = !1;
        }
        unwrap() {
            return this.child;
        }
        async put(e, t, r = {}) {
            r?.signal?.throwIfAborted();
            const s = await this.lock.readLock();
            try {
                return await this.child.put(e, t, r);
            } finally{
                s();
            }
        }
        async *putMany(e, t = {}) {
            t?.signal?.throwIfAborted();
            const r = await this.lock.readLock();
            try {
                yield* this.child.putMany(e, t);
            } finally{
                r();
            }
        }
        async *get(e, t = {}) {
            t?.signal?.throwIfAborted();
            const r = await this.lock.readLock();
            try {
                yield* this.child.get(e, t);
            } finally{
                r();
            }
        }
        async *getMany(e, t = {}) {
            t?.signal?.throwIfAborted();
            const r = await this.lock.readLock();
            try {
                yield* this.child.getMany(e, t);
            } finally{
                r();
            }
        }
        async delete(e, t = {}) {
            t?.signal?.throwIfAborted();
            const r = await this.lock.writeLock();
            try {
                if (await this.pins.isPinned(e)) throw new av("Block was pinned - please unpin and try again");
                await this.child.delete(e, t);
            } finally{
                r();
            }
        }
        async *deleteMany(e, t = {}) {
            t?.signal?.throwIfAborted();
            const r = await this.lock.writeLock();
            try {
                const s = this;
                yield* this.child.deleteMany((async function*() {
                    for await (const i of e){
                        if (await s.pins.isPinned(i)) throw new av("Block was pinned - please unpin and try again");
                        yield i;
                    }
                })(), t);
            } finally{
                r();
            }
        }
        async has(e, t = {}) {
            t?.signal?.throwIfAborted();
            const r = await this.lock.readLock();
            try {
                return await this.child.has(e, t);
            } finally{
                r();
            }
        }
        async *getAll(e = {}) {
            e?.signal?.throwIfAborted();
            const t = await this.lock.readLock();
            try {
                yield* this.child.getAll(e);
            } finally{
                t();
            }
        }
        createSession(e, t) {
            return t?.signal?.throwIfAborted(), this.child.createSession(e, t);
        }
    }
    const x3 = new Nt("/version"), pv = 1;
    async function $H(n) {
        if (!await n.has(x3)) {
            await n.put(x3, re(`${pv}`));
            return;
        }
        const e = await n.get(x3), t = L(e);
        if (parseInt(t, 10) !== pv) throw new hH("Invalid datastore version, a datastore migration may be required");
    }
    const pT = 42;
    function gT(n) {
        return n instanceof ArrayBuffer ? new Uint8Array(n, 0, n.byteLength) : n;
    }
    function MH(n) {
        if (n.asCID !== n && n["/"] !== n.bytes) return null;
        const e = ge.asCID(n);
        if (!e) return null;
        const t = new Uint8Array(e.bytes.byteLength + 1);
        return t.set(e.bytes, 1), [
            new we(U.tag, pT),
            new we(U.bytes, t)
        ];
    }
    function NH() {
        throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
    }
    function LH(n) {
        if (Number.isNaN(n)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
        if (n === 1 / 0 || n === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
        return null;
    }
    function UH(n) {
        for (const e of n.keys())if (typeof e != "string" || e.length === 0) throw new Error("Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded");
        return null;
    }
    const Ky = {
        float64: !0,
        typeEncoders: {
            Map: UH,
            Object: MH,
            undefined: NH,
            number: LH
        }
    }, zH = {
        ...Ky,
        typeEncoders: {
            ...Ky.typeEncoders
        }
    };
    function FH(n) {
        if (n[0] !== 0) throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
        return ge.decode(n.subarray(1));
    }
    const xp = {
        allowIndefinite: !1,
        coerceUndefinedToNull: !0,
        allowNaN: !1,
        allowInfinity: !1,
        allowBigInt: !0,
        strict: !0,
        useMaps: !1,
        rejectDuplicateMapKeys: !0,
        tags: []
    };
    xp.tags[pT] = FH;
    let VH, HH, mT, QH, qH;
    VH = {
        ...xp,
        tags: xp.tags.slice()
    };
    HH = "dag-cbor";
    mT = 113;
    QH = (n)=>ip(n, Ky);
    qH = (n)=>Ro(gT(n), xp);
    KH = Object.freeze(Object.defineProperty({
        __proto__: null,
        code: mT,
        decode: qH,
        decodeOptions: VH,
        encode: QH,
        encodeOptions: zH,
        name: HH,
        toByteView: gT
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    class GH extends Array {
        constructor(){
            super(), this.inRecursive = [];
        }
        prefix(e) {
            const t = this.inRecursive[this.inRecursive.length - 1];
            t && (U.equals(t.type, U.array) && (t.elements++, t.elements !== 1 && e.push([
                44
            ])), U.equals(t.type, U.map) && (t.elements++, t.elements !== 1 && (t.elements % 2 === 1 ? e.push([
                44
            ]) : e.push([
                58
            ]))));
        }
        [U.uint.major](e, t) {
            this.prefix(e);
            const r = String(t.value), s = [];
            for(let i = 0; i < r.length; i++)s[i] = r.charCodeAt(i);
            e.push(s);
        }
        [U.negint.major](e, t) {
            this[U.uint.major](e, t);
        }
        [U.bytes.major](e, t) {
            throw new Error(`${zo} unsupported type: Uint8Array`);
        }
        [U.string.major](e, t) {
            this.prefix(e);
            const r = k6(JSON.stringify(t.value));
            e.push(r.length > 32 ? yg(r) : r);
        }
        [U.array.major](e, t) {
            this.prefix(e), this.inRecursive.push({
                type: U.array,
                elements: 0
            }), e.push([
                91
            ]);
        }
        [U.map.major](e, t) {
            this.prefix(e), this.inRecursive.push({
                type: U.map,
                elements: 0
            }), e.push([
                123
            ]);
        }
        [U.tag.major](e, t) {}
        [U.float.major](e, t) {
            if (t.type.name === "break") {
                const l = this.inRecursive.pop();
                if (l) {
                    if (U.equals(l.type, U.array)) e.push([
                        93
                    ]);
                    else if (U.equals(l.type, U.map)) e.push([
                        125
                    ]);
                    else throw new Error("Unexpected recursive type; this should not happen!");
                    return;
                }
                throw new Error("Unexpected break; this should not happen!");
            }
            if (t.value === void 0) throw new Error(`${zo} unsupported type: undefined`);
            if (this.prefix(e), t.type.name === "true") {
                e.push([
                    116,
                    114,
                    117,
                    101
                ]);
                return;
            } else if (t.type.name === "false") {
                e.push([
                    102,
                    97,
                    108,
                    115,
                    101
                ]);
                return;
            } else if (t.type.name === "null") {
                e.push([
                    110,
                    117,
                    108,
                    108
                ]);
                return;
            }
            const r = String(t.value), s = [];
            let i = !1;
            for(let l = 0; l < r.length; l++)s[l] = r.charCodeAt(l), !i && (s[l] === 46 || s[l] === 101 || s[l] === 69) && (i = !0);
            i || (s.push(46), s.push(48)), e.push(s);
        }
    }
    function YH(n, e) {
        if (Array.isArray(n[0]) || Array.isArray(e[0])) throw new Error(`${zo} complex map keys are not supported`);
        const t = n[0], r = e[0];
        if (t.type !== U.string || r.type !== U.string) throw new Error(`${zo} non-string map keys are not supported`);
        if (t < r) return -1;
        if (t > r) return 1;
        throw new Error(`${zo} unexpected duplicate map keys, this is not supported`);
    }
    const WH = {
        addBreakTokens: !0,
        mapSorter: YH
    };
    function jH(n, e) {
        return e = Object.assign({}, WH, e), qC(n, new GH, e);
    }
    class yT {
        constructor(e, t = {}){
            this._pos = 0, this.data = e, this.options = t, this.modeStack = [
                "value"
            ], this.lastToken = "";
        }
        pos() {
            return this._pos;
        }
        done() {
            return this._pos >= this.data.length;
        }
        ch() {
            return this.data[this._pos];
        }
        currentMode() {
            return this.modeStack[this.modeStack.length - 1];
        }
        skipWhitespace() {
            let e = this.ch();
            for(; e === 32 || e === 9 || e === 13 || e === 10;)e = this.data[++this._pos];
        }
        expect(e) {
            if (this.data.length - this._pos < e.length) throw new Error(`${ke} unexpected end of input at position ${this._pos}`);
            for(let t = 0; t < e.length; t++)if (this.data[this._pos++] !== e[t]) throw new Error(`${ke} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...e)}'`);
        }
        parseNumber() {
            const e = this._pos;
            let t = !1, r = !1;
            const s = (u)=>{
                for(; !this.done();){
                    const h = this.ch();
                    if (u.includes(h)) this._pos++;
                    else break;
                }
            };
            if (this.ch() === 45 && (t = !0, this._pos++), this.ch() === 48) if (this._pos++, this.ch() === 46) this._pos++, r = !0;
            else return new we(U.uint, 0, this._pos - e);
            if (s([
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57
            ]), t && this._pos === e + 1) throw new Error(`${ke} unexpected token at position ${this._pos}`);
            if (!this.done() && this.ch() === 46) {
                if (r) throw new Error(`${ke} unexpected token at position ${this._pos}`);
                r = !0, this._pos++, s([
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57
                ]);
            }
            !this.done() && (this.ch() === 101 || this.ch() === 69) && (r = !0, this._pos++, !this.done() && (this.ch() === 43 || this.ch() === 45) && this._pos++, s([
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57
            ]));
            const i = String.fromCharCode.apply(null, this.data.subarray(e, this._pos)), l = parseFloat(i);
            return r ? new we(U.float, l, this._pos - e) : this.options.allowBigInt !== !0 || Number.isSafeInteger(l) ? new we(l >= 0 ? U.uint : U.negint, l, this._pos - e) : new we(l >= 0 ? U.uint : U.negint, BigInt(i), this._pos - e);
        }
        parseString() {
            if (this.ch() !== 34) throw new Error(`${ke} unexpected character at position ${this._pos}; this shouldn't happen`);
            this._pos++;
            for(let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++){
                const u = this.data[i];
                if (u === 92 || u < 32 || u >= 128) break;
                if (u === 34) {
                    const h = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
                    return this._pos = i + 1, new we(U.string, h, l);
                }
            }
            const e = this._pos, t = [], r = ()=>{
                if (this._pos + 4 >= this.data.length) throw new Error(`${ke} unexpected end of unicode escape sequence at position ${this._pos}`);
                let i = 0;
                for(let l = 0; l < 4; l++){
                    let u = this.ch();
                    if (u >= 48 && u <= 57) u -= 48;
                    else if (u >= 97 && u <= 102) u = u - 97 + 10;
                    else if (u >= 65 && u <= 70) u = u - 65 + 10;
                    else throw new Error(`${ke} unexpected unicode escape character at position ${this._pos}`);
                    i = i * 16 + u, this._pos++;
                }
                return i;
            }, s = ()=>{
                const i = this.ch();
                let l = null, u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                if (this._pos + u > this.data.length) throw new Error(`${ke} unexpected unicode sequence at position ${this._pos}`);
                let h, f, p, m;
                switch(u){
                    case 1:
                        i < 128 && (l = i);
                        break;
                    case 2:
                        h = this.data[this._pos + 1], (h & 192) === 128 && (m = (i & 31) << 6 | h & 63, m > 127 && (l = m));
                        break;
                    case 3:
                        h = this.data[this._pos + 1], f = this.data[this._pos + 2], (h & 192) === 128 && (f & 192) === 128 && (m = (i & 15) << 12 | (h & 63) << 6 | f & 63, m > 2047 && (m < 55296 || m > 57343) && (l = m));
                        break;
                    case 4:
                        h = this.data[this._pos + 1], f = this.data[this._pos + 2], p = this.data[this._pos + 3], (h & 192) === 128 && (f & 192) === 128 && (p & 192) === 128 && (m = (i & 15) << 18 | (h & 63) << 12 | (f & 63) << 6 | p & 63, m > 65535 && m < 1114112 && (l = m));
                }
                l === null ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, t.push(l >>> 10 & 1023 | 55296), l = 56320 | l & 1023), t.push(l), this._pos += u;
            };
            for(; !this.done();){
                const i = this.ch();
                let l;
                switch(i){
                    case 92:
                        if (this._pos++, this.done()) throw new Error(`${ke} unexpected string termination at position ${this._pos}`);
                        switch(l = this.ch(), this._pos++, l){
                            case 34:
                            case 39:
                            case 92:
                            case 47:
                                t.push(l);
                                break;
                            case 98:
                                t.push(8);
                                break;
                            case 116:
                                t.push(9);
                                break;
                            case 110:
                                t.push(10);
                                break;
                            case 102:
                                t.push(12);
                                break;
                            case 114:
                                t.push(13);
                                break;
                            case 117:
                                t.push(r());
                                break;
                            default:
                                throw new Error(`${ke} unexpected string escape character at position ${this._pos}`);
                        }
                        break;
                    case 34:
                        return this._pos++, new we(U.string, yF(t), this._pos - e);
                    default:
                        if (i < 32) throw new Error(`${ke} invalid control character at position ${this._pos}`);
                        i < 128 ? (t.push(i), this._pos++) : s();
                }
            }
            throw new Error(`${ke} unexpected end of string at position ${this._pos}`);
        }
        parseValue() {
            switch(this.ch()){
                case 123:
                    return this.modeStack.push("obj-start"), this._pos++, new we(U.map, 1 / 0, 1);
                case 91:
                    return this.modeStack.push("array-start"), this._pos++, new we(U.array, 1 / 0, 1);
                case 34:
                    return this.parseString();
                case 110:
                    return this.expect([
                        110,
                        117,
                        108,
                        108
                    ]), new we(U.null, null, 4);
                case 102:
                    return this.expect([
                        102,
                        97,
                        108,
                        115,
                        101
                    ]), new we(U.false, !1, 5);
                case 116:
                    return this.expect([
                        116,
                        114,
                        117,
                        101
                    ]), new we(U.true, !0, 4);
                case 45:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    return this.parseNumber();
                default:
                    throw new Error(`${ke} unexpected character at position ${this._pos}`);
            }
        }
        next() {
            switch(this.skipWhitespace(), this.currentMode()){
                case "value":
                    return this.modeStack.pop(), this.parseValue();
                case "array-value":
                    {
                        if (this.modeStack.pop(), this.ch() === 93) return this._pos++, this.skipWhitespace(), new we(U.break, void 0, 1);
                        if (this.ch() !== 44) throw new Error(`${ke} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
                        return this._pos++, this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue();
                    }
                case "array-start":
                    return this.modeStack.pop(), this.ch() === 93 ? (this._pos++, this.skipWhitespace(), new we(U.break, void 0, 1)) : (this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue());
                case "obj-key":
                    if (this.ch() === 125) return this.modeStack.pop(), this._pos++, this.skipWhitespace(), new we(U.break, void 0, 1);
                    if (this.ch() !== 44) throw new Error(`${ke} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
                    this._pos++, this.skipWhitespace();
                case "obj-start":
                    {
                        if (this.modeStack.pop(), this.ch() === 125) return this._pos++, this.skipWhitespace(), new we(U.break, void 0, 1);
                        const e = this.parseString();
                        if (this.skipWhitespace(), this.ch() !== 58) throw new Error(`${ke} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
                        return this._pos++, this.modeStack.push("obj-value"), e;
                    }
                case "obj-value":
                    return this.modeStack.pop(), this.modeStack.push("obj-key"), this.skipWhitespace(), this.parseValue();
                default:
                    throw new Error(`${ke} unexpected parse state at position ${this._pos}; this shouldn't happen`);
            }
        }
    }
    function XH(n, e) {
        return e = Object.assign({
            tokenizer: new yT(n, e)
        }, e), Ro(n, e);
    }
    function JH(n) {
        return n instanceof ArrayBuffer ? new Uint8Array(n, 0, n.byteLength) : n;
    }
    function ZH(n) {
        if (n.asCID !== n && n["/"] !== n.bytes) return null;
        const e = ge.asCID(n);
        if (!e) return null;
        const t = e.toString();
        return [
            new we(U.map, 1 / 0, 1),
            new we(U.string, "/", 1),
            new we(U.string, t, t.length),
            new we(U.break, void 0, 1)
        ];
    }
    function Dp(n) {
        const e = As.encode(n).slice(1);
        return [
            new we(U.map, 1 / 0, 1),
            new we(U.string, "/", 1),
            new we(U.map, 1 / 0, 1),
            new we(U.string, "bytes", 5),
            new we(U.string, e, e.length),
            new we(U.break, void 0, 1),
            new we(U.break, void 0, 1)
        ];
    }
    function Ps(n) {
        return Dp(new Uint8Array(n.buffer, n.byteOffset, n.byteLength));
    }
    function eQ(n) {
        return Dp(new Uint8Array(n));
    }
    function tQ() {
        throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
    }
    function nQ(n) {
        if (Number.isNaN(n)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
        if (n === 1 / 0 || n === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
        return null;
    }
    const rQ = {
        typeEncoders: {
            Object: ZH,
            Buffer: Dp,
            Uint8Array: Dp,
            Int8Array: Ps,
            Uint16Array: Ps,
            Int16Array: Ps,
            Uint32Array: Ps,
            Int32Array: Ps,
            Float32Array: Ps,
            Float64Array: Ps,
            Uint8ClampedArray: Ps,
            BigInt64Array: Ps,
            BigUint64Array: Ps,
            DataView: Ps,
            ArrayBuffer: eQ,
            undefined: tQ,
            number: nQ
        }
    };
    class sQ extends yT {
        constructor(e, t){
            super(e, t), this.tokenBuffer = [];
        }
        done() {
            return this.tokenBuffer.length === 0 && super.done();
        }
        _next() {
            return this.tokenBuffer.length > 0 ? this.tokenBuffer.pop() : super.next();
        }
        next() {
            const e = this._next();
            if (U.equals(e.type, U.map)) {
                const t = this._next();
                if (U.equals(t.type, U.string) && t.value === "/") {
                    const r = this._next();
                    if (U.equals(r.type, U.string)) {
                        const s = this._next();
                        if (!U.equals(s.type, U.break)) throw new Error("Invalid encoded CID form");
                        return this.tokenBuffer.push(r), new we(U.tag, 42, 0);
                    }
                    if (U.equals(r.type, U.map)) {
                        const s = this._next();
                        if (U.equals(s.type, U.string) && s.value === "bytes") {
                            const i = this._next();
                            if (U.equals(i.type, U.string)) {
                                for(let u = 0; u < 2; u++){
                                    const h = this._next();
                                    if (!U.equals(h.type, U.break)) throw new Error("Invalid encoded Bytes form");
                                }
                                const l = As.decode(`m${i.value}`);
                                return new we(U.bytes, l, i.value.length);
                            }
                            this.tokenBuffer.push(i);
                        }
                        this.tokenBuffer.push(s);
                    }
                    this.tokenBuffer.push(r);
                }
                this.tokenBuffer.push(t);
            }
            return e;
        }
    }
    const Gy = {
        allowIndefinite: !1,
        allowUndefined: !1,
        allowNaN: !1,
        allowInfinity: !1,
        allowBigInt: !0,
        strict: !0,
        useMaps: !1,
        rejectDuplicateMapKeys: !0,
        tags: []
    };
    Gy.tags[42] = ge.parse;
    const iQ = "dag-json", wT = 297, bT = (n)=>jH(n, rQ), vT = (n)=>{
        const e = JH(n), t = Object.assign(Gy, {
            tokenizer: new sQ(e, Gy)
        });
        return XH(e, t);
    }, gv = (n)=>oQ.decode(bT(n)), oQ = new TextDecoder, aQ = (n)=>vT(lQ.encode(n)), lQ = new TextEncoder, cQ = Object.freeze(Object.defineProperty({
        __proto__: null,
        code: wT,
        decode: vT,
        encode: bT,
        format: gv,
        name: iQ,
        parse: aQ,
        stringify: gv
    }, Symbol.toStringTag, {
        value: "Module"
    })), uQ = new TextDecoder;
    function H6(n, e) {
        let t = 0;
        for(let r = 0;; r += 7){
            if (r >= 64) throw new Error("protobuf: varint overflow");
            if (e >= n.length) throw new Error("protobuf: unexpected end of data");
            const s = n[e++];
            if (t += r < 28 ? (s & 127) << r : (s & 127) * 2 ** r, s < 128) break;
        }
        return [
            t,
            e
        ];
    }
    function Bp(n, e) {
        let t;
        [t, e] = H6(n, e);
        const r = e + t;
        if (t < 0 || r < 0) throw new Error("protobuf: invalid length");
        if (r > n.length) throw new Error("protobuf: unexpected end of data");
        return [
            n.subarray(e, r),
            r
        ];
    }
    function ET(n, e) {
        let t;
        return [t, e] = H6(n, e), [
            t & 7,
            t >> 3,
            e
        ];
    }
    function hQ(n) {
        const e = {}, t = n.length;
        let r = 0;
        for(; r < t;){
            let s, i;
            if ([s, i, r] = ET(n, r), i === 1) {
                if (e.Hash) throw new Error("protobuf: (PBLink) duplicate Hash section");
                if (s !== 2) throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Hash`);
                if (e.Name !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
                if (e.Tsize !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
                [e.Hash, r] = Bp(n, r);
            } else if (i === 2) {
                if (e.Name !== void 0) throw new Error("protobuf: (PBLink) duplicate Name section");
                if (s !== 2) throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Name`);
                if (e.Tsize !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
                let l;
                [l, r] = Bp(n, r), e.Name = uQ.decode(l);
            } else if (i === 3) {
                if (e.Tsize !== void 0) throw new Error("protobuf: (PBLink) duplicate Tsize section");
                if (s !== 0) throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Tsize`);
                [e.Tsize, r] = H6(n, r);
            } else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${i}`);
        }
        if (r > t) throw new Error("protobuf: (PBLink) unexpected end of data");
        return e;
    }
    function dQ(n) {
        const e = n.length;
        let t = 0, r, s = !1, i;
        for(; t < e;){
            let u, h;
            if ([u, h, t] = ET(n, t), u !== 2) throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${u}`);
            if (h === 1) {
                if (i) throw new Error("protobuf: (PBNode) duplicate Data section");
                [i, t] = Bp(n, t), r && (s = !0);
            } else if (h === 2) {
                if (s) throw new Error("protobuf: (PBNode) duplicate Links section");
                r || (r = []);
                let f;
                [f, t] = Bp(n, t), r.push(hQ(f));
            } else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${h}`);
        }
        if (t > e) throw new Error("protobuf: (PBNode) unexpected end of data");
        const l = {};
        return i && (l.Data = i), l.Links = r || [], l;
    }
    const AT = new TextEncoder, mv = 2 ** 32, fQ = 2 ** 31;
    function pQ(n, e) {
        let t = e.length;
        if (typeof n.Tsize == "number") {
            if (n.Tsize < 0) throw new Error("Tsize cannot be negative");
            if (!Number.isSafeInteger(n.Tsize)) throw new Error("Tsize too large for encoding");
            t = wd(e, t, n.Tsize) - 1, e[t] = 24;
        }
        if (typeof n.Name == "string") {
            const r = AT.encode(n.Name);
            t -= r.length, e.set(r, t), t = wd(e, t, r.length) - 1, e[t] = 18;
        }
        return n.Hash && (t -= n.Hash.length, e.set(n.Hash, t), t = wd(e, t, n.Hash.length) - 1, e[t] = 10), e.length - t;
    }
    function gQ(n) {
        const e = yQ(n), t = new Uint8Array(e);
        let r = e;
        if (n.Data && (r -= n.Data.length, t.set(n.Data, r), r = wd(t, r, n.Data.length) - 1, t[r] = 10), n.Links) for(let s = n.Links.length - 1; s >= 0; s--){
            const i = pQ(n.Links[s], t.subarray(0, r));
            r -= i, r = wd(t, r, i) - 1, t[r] = 18;
        }
        return t;
    }
    function mQ(n) {
        let e = 0;
        if (n.Hash) {
            const t = n.Hash.length;
            e += 1 + t + Ic(t);
        }
        if (typeof n.Name == "string") {
            const t = AT.encode(n.Name).length;
            e += 1 + t + Ic(t);
        }
        return typeof n.Tsize == "number" && (e += 1 + Ic(n.Tsize)), e;
    }
    function yQ(n) {
        let e = 0;
        if (n.Data) {
            const t = n.Data.length;
            e += 1 + t + Ic(t);
        }
        if (n.Links) for (const t of n.Links){
            const r = mQ(t);
            e += 1 + r + Ic(r);
        }
        return e;
    }
    function wd(n, e, t) {
        e -= Ic(t);
        const r = e;
        for(; t >= fQ;)n[e++] = t & 127 | 128, t /= 128;
        for(; t >= 128;)n[e++] = t & 127 | 128, t >>>= 7;
        return n[e] = t, r;
    }
    function Ic(n) {
        return n % 2 === 0 && n++, Math.floor((wQ(n) + 6) / 7);
    }
    function wQ(n) {
        let e = 0;
        return n >= mv && (n = Math.floor(n / mv), e = 32), n >= 65536 && (n >>>= 16, e += 16), n >= 256 && (n >>>= 8, e += 8), e + bQ[n];
    }
    const bQ = [
        0,
        1,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8
    ], vQ = [
        "Data",
        "Links"
    ], EQ = [
        "Hash",
        "Name",
        "Tsize"
    ], Yy = new TextEncoder;
    function ST(n, e) {
        if (n === e) return 0;
        const t = n.Name ? Yy.encode(n.Name) : [], r = e.Name ? Yy.encode(e.Name) : [];
        let s = t.length, i = r.length;
        for(let l = 0, u = Math.min(s, i); l < u; ++l)if (t[l] !== r[l]) {
            s = t[l], i = r[l];
            break;
        }
        return s < i ? -1 : i < s ? 1 : 0;
    }
    function yv(n, e) {
        return !Object.keys(n).some((t)=>!e.includes(t));
    }
    function IT(n) {
        if (typeof n.asCID == "object") {
            const t = ge.asCID(n);
            if (!t) throw new TypeError("Invalid DAG-PB form");
            return {
                Hash: t
            };
        }
        if (typeof n != "object" || Array.isArray(n)) throw new TypeError("Invalid DAG-PB form");
        const e = {};
        if (n.Hash) {
            let t = ge.asCID(n.Hash);
            try {
                t || (typeof n.Hash == "string" ? t = ge.parse(n.Hash) : n.Hash instanceof Uint8Array && (t = ge.decode(n.Hash)));
            } catch (r) {
                throw new TypeError(`Invalid DAG-PB form: ${r.message}`);
            }
            t && (e.Hash = t);
        }
        if (!e.Hash) throw new TypeError("Invalid DAG-PB form");
        return typeof n.Name == "string" && (e.Name = n.Name), typeof n.Tsize == "number" && (e.Tsize = n.Tsize), e;
    }
    function CT(n) {
        if ((n instanceof Uint8Array || typeof n == "string") && (n = {
            Data: n
        }), typeof n != "object" || Array.isArray(n)) throw new TypeError("Invalid DAG-PB form");
        const e = {};
        if (n.Data !== void 0) if (typeof n.Data == "string") e.Data = Yy.encode(n.Data);
        else if (n.Data instanceof Uint8Array) e.Data = n.Data;
        else throw new TypeError("Invalid DAG-PB form");
        if (n.Links !== void 0) if (Array.isArray(n.Links)) e.Links = n.Links.map(IT), e.Links.sort(ST);
        else throw new TypeError("Invalid DAG-PB form");
        else e.Links = [];
        return e;
    }
    function TT(n) {
        if (!n || typeof n != "object" || Array.isArray(n) || n instanceof Uint8Array || n["/"] && n["/"] === n.bytes) throw new TypeError("Invalid DAG-PB form");
        if (!yv(n, vQ)) throw new TypeError("Invalid DAG-PB form (extraneous properties)");
        if (n.Data !== void 0 && !(n.Data instanceof Uint8Array)) throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
        if (!Array.isArray(n.Links)) throw new TypeError("Invalid DAG-PB form (Links must be a list)");
        for(let e = 0; e < n.Links.length; e++){
            const t = n.Links[e];
            if (!t || typeof t != "object" || Array.isArray(t) || t instanceof Uint8Array || t["/"] && t["/"] === t.bytes) throw new TypeError("Invalid DAG-PB form (bad link)");
            if (!yv(t, EQ)) throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
            if (t.Hash === void 0) throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
            if (t.Hash == null || !t.Hash["/"] || t.Hash["/"] !== t.Hash.bytes) throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
            if (t.Name !== void 0 && typeof t.Name != "string") throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
            if (t.Tsize !== void 0) {
                if (typeof t.Tsize != "number" || t.Tsize % 1 !== 0) throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
                if (t.Tsize < 0) throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
            }
            if (e > 0 && ST(t, n.Links[e - 1]) === -1) throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
        }
    }
    function AQ(n, e = []) {
        return CT({
            Data: n,
            Links: e
        });
    }
    function SQ(n, e, t) {
        return IT({
            Hash: t,
            Name: n,
            Tsize: e
        });
    }
    function IQ(n) {
        return n instanceof ArrayBuffer ? new Uint8Array(n, 0, n.byteLength) : n;
    }
    const CQ = "dag-pb", _T = 112;
    function TQ(n) {
        TT(n);
        const e = {};
        return n.Links && (e.Links = n.Links.map((t)=>{
            const r = {};
            return t.Hash && (r.Hash = t.Hash.bytes), t.Name !== void 0 && (r.Name = t.Name), t.Tsize !== void 0 && (r.Tsize = t.Tsize), r;
        })), n.Data && (e.Data = n.Data), gQ(e);
    }
    function _Q(n) {
        const e = IQ(n), t = dQ(e), r = {};
        return t.Data && (r.Data = t.Data), t.Links && (r.Links = t.Links.map((s)=>{
            const i = {};
            try {
                i.Hash = ge.decode(s.Hash);
            } catch  {}
            if (!i.Hash) throw new Error("Invalid Hash field found in link, expected CID");
            return s.Name !== void 0 && (i.Name = s.Name), s.Tsize !== void 0 && (i.Tsize = s.Tsize), i;
        })), r;
    }
    const xQ = Object.freeze(Object.defineProperty({
        __proto__: null,
        code: _T,
        createLink: SQ,
        createNode: AQ,
        decode: _Q,
        encode: TQ,
        name: CQ,
        prepare: CT,
        validate: TT
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function Q6(n) {
        return n?.then != null;
    }
    function DQ(n = [], e) {
        const t = {
            [_T]: xQ,
            [Af]: EM,
            [mT]: KH,
            [wT]: cQ,
            [rI]: yM
        };
        return n.forEach((r)=>{
            t[r.code] = r;
        }), async (r)=>{
            let s = t[r];
            if (s == null && e != null) {
                const i = e(r);
                Q6(i) ? s = await i : s = i, t[s.code] = s;
            }
            if (s != null) return s;
            throw new vH(`Could not load codec for ${r}`);
        };
    }
    function BQ(n = [], e) {
        const t = {
            [Ut.code]: Ut,
            [w9.code]: w9,
            [nt.code]: nt
        };
        return n.forEach((r)=>{
            t[r.code] = r;
        }), async (r)=>{
            let s = t[r];
            if (s == null && e != null) {
                const i = e(r);
                Q6(i) ? s = await i : s = i, t[s.code] = s;
            }
            if (s != null) return s;
            throw new bH(`No hasher configured for multihash code 0x${r.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
        };
    }
    let q6 = class Wy extends Error {
        static name = "NotFoundError";
        static code = "ERR_NOT_FOUND";
        name = Wy.name;
        code = Wy.code;
        constructor(e = "Not Found"){
            super(e);
        }
    };
    class xT {
        has(e, t) {
            return Promise.reject(new Error(".has is not implemented"));
        }
        put(e, t, r) {
            return Promise.reject(new Error(".put is not implemented"));
        }
        async *putMany(e, t) {
            for await (const { cid: r, bytes: s } of e)await this.put(r, s, t), yield r;
        }
        get(e, t) {
            throw new Error(".get is not implemented");
        }
        async *getMany(e, t) {
            for await (const r of e)yield {
                cid: r,
                bytes: this.get(r, t)
            };
        }
        delete(e, t) {
            return Promise.reject(new Error(".delete is not implemented"));
        }
        async *deleteMany(e, t) {
            for await (const r of e)await this.delete(r, t), yield r;
        }
        async *getAll(e) {
            throw new Error(".getAll is not implemented");
        }
    }
    const g0 = 0;
    class m0 extends Error {
        static name = "IdentityHashDigestTooLongError";
        name = "IdentityHashDigestTooLongError";
    }
    class PQ extends xT {
        child;
        maxDigestLength;
        constructor(e, t){
            super(), this.child = e, this.maxDigestLength = t?.maxDigestLength;
        }
        put(e, t, r) {
            if (e.multihash.code === g0) {
                if (this.maxDigestLength != null && e.multihash.digest.byteLength > this.maxDigestLength) throw new m0(`Identity digest too long - ${e.multihash.digest.byteLength} > this.maxDigestLength`);
                return r?.signal?.throwIfAborted(), e;
            }
            return this.child == null ? (r?.signal?.throwIfAborted(), e) : this.child.put(e, t, r);
        }
        async *get(e, t) {
            if (e.multihash.code === g0) {
                if (this.maxDigestLength != null && e.multihash.digest.byteLength > this.maxDigestLength) throw new m0(`Identity digest too long - ${e.multihash.digest.byteLength} > this.maxDigestLength`);
                t?.signal?.throwIfAborted(), yield e.multihash.digest;
                return;
            }
            if (this.child == null) throw t?.signal?.throwIfAborted(), new q6;
            yield* this.child.get(e, t);
        }
        has(e, t) {
            if (e.multihash.code === g0) {
                if (this.maxDigestLength != null && e.multihash.digest.byteLength > this.maxDigestLength) throw new m0(`Identity digest too long - ${e.multihash.digest.byteLength} > this.maxDigestLength`);
                return t?.signal?.throwIfAborted(), !0;
            }
            return this.child == null ? (t?.signal?.throwIfAborted(), !1) : this.child.has(e, t);
        }
        delete(e, t) {
            if (e.code === g0) {
                if (this.maxDigestLength != null && e.multihash.digest.byteLength > this.maxDigestLength) throw new m0(`Identity digest too long - ${e.multihash.digest.byteLength} > this.maxDigestLength`);
                t?.signal?.throwIfAborted();
                return;
            }
            if (this.child != null) return this.child.delete(e, t);
        }
        async *getAll(e) {
            this.child != null && (yield* this.child.getAll(e)), e?.signal?.throwIfAborted();
        }
    }
    function K6(n) {
        const [e, t] = n[Symbol.asyncIterator] != null ? [
            n[Symbol.asyncIterator](),
            Symbol.asyncIterator
        ] : [
            n[Symbol.iterator](),
            Symbol.iterator
        ], r = [];
        return {
            peek: ()=>e.next(),
            push: (s)=>{
                r.push(s);
            },
            next: ()=>r.length > 0 ? {
                    done: !1,
                    value: r.shift()
                } : e.next(),
            [t] () {
                return this;
            }
        };
    }
    function kQ(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function Sa(n, e) {
        let t = 0;
        if (kQ(n)) return (async function*() {
            for await (const h of n)await e(h, t++) && (yield h);
        })();
        const r = K6(n), { value: s, done: i } = r.next();
        if (i === !0) return (function*() {})();
        const l = e(s, t++);
        if (typeof l.then == "function") return (async function*() {
            await l && (yield s);
            for (const h of r)await e(h, t++) && (yield h);
        })();
        const u = e;
        return (function*() {
            l === !0 && (yield s);
            for (const h of r)u(h, t++) && (yield h);
        })();
    }
    function RQ(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function wv(n) {
        return n?.then != null;
    }
    function bv(n, e) {
        let t = 0;
        if (RQ(n)) return (async function*() {
            for await (const h of n){
                const f = e(h, t++);
                wv(f) && await f, yield h;
            }
        })();
        const r = K6(n), { value: s, done: i } = r.next();
        if (i === !0) return (function*() {})();
        const l = e(s, t++);
        if (typeof l?.then == "function") return (async function*() {
            await l, yield s;
            for (const h of r){
                const f = e(h, t++);
                wv(f) && await f, yield h;
            }
        })();
        const u = e;
        return (function*() {
            yield s;
            for (const h of r)u(h, t++), yield h;
        })();
    }
    const OQ = 128;
    class DT {
        child;
        getHasher;
        log;
        logger;
        blockBrokers;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("helia:networked-storage"), this.logger = e.logger, this.blockBrokers = e.blockBrokers, this.child = new PQ(e.blockstore, {
                maxDigestLength: t.maxIdentityHashDigestLength ?? OQ
            }), this.getHasher = e.getHasher;
        }
        async put(e, t, r = {}) {
            return await this.child.has(e, r) ? (r.onProgress?.(new Be("blocks:put:duplicate", e)), e) : (r.onProgress?.(new Be("blocks:put:providers:notify", e)), await Promise.all(this.blockBrokers.map(async (s)=>s.announce?.(e, r))), r.onProgress?.(new Be("blocks:put:blockstore:put", e)), this.child.put(e, t, r));
        }
        async *putMany(e, t = {}) {
            const r = Sa(e, async ({ cid: i })=>{
                const l = await this.child.has(i, t);
                return l && t.onProgress?.(new Be("blocks:put-many:duplicate", i)), !l;
            }), s = bv(r, async ({ cid: i })=>{
                t.onProgress?.(new Be("blocks:put-many:providers:notify", i)), await Promise.all(this.blockBrokers.map(async (l)=>l.announce?.(i, t)));
            });
            t.onProgress?.(new Be("blocks:put-many:blockstore:put-many")), yield* this.child.putMany(s, t);
        }
        async *get(e, t = {}) {
            const r = await this.child.has(e, t), s = t.offline === !0;
            if (!r) {
                if (s) throw new lv("The block was present in the blockstore and the node is running offline so cannot fetch it");
                const i = await this.getHasher(e.multihash.code);
                t?.signal?.throwIfAborted(), t.onProgress?.(new Be("blocks:get:providers:get", e));
                const l = await vv(e, this.blockBrokers, i, {
                    ...t,
                    log: this.log
                });
                t.onProgress?.(new Be("blocks:get:blockstore:put", e)), await this.child.put(e, l, t), t.onProgress?.(new Be("blocks:get:providers:notify", e)), await Promise.all(this.blockBrokers.map(async (u)=>u.announce?.(e, t))), yield l;
                return;
            }
            t.onProgress?.(new Be("blocks:get:blockstore:get", e)), yield* this.child.get(e, t);
        }
        async *getMany(e, t = {}) {
            t.onProgress?.(new Be("blocks:get-many:blockstore:get-many")), yield* this.child.getMany(bv(e, async (r)=>{
                const s = await this.child.has(r, t), i = t.offline === !0;
                if (!s) {
                    if (i) throw new lv("The block was present in the blockstore and the node is running offline so cannot fetch it");
                    const l = await this.getHasher(r.multihash.code);
                    t?.signal?.throwIfAborted(), t.onProgress?.(new Be("blocks:get-many:providers:get", r));
                    const u = await vv(r, this.blockBrokers, l, {
                        ...t,
                        log: this.log
                    });
                    t.onProgress?.(new Be("blocks:get-many:blockstore:put", r)), await this.child.put(r, u, t), t.onProgress?.(new Be("blocks:get-many:providers:notify", r)), await Promise.all(this.blockBrokers.map(async (h)=>h.announce?.(r, t)));
                }
            }));
        }
        async delete(e, t = {}) {
            t.onProgress?.(new Be("blocks:delete:blockstore:delete", e)), await this.child.delete(e, t);
        }
        async *deleteMany(e, t = {}) {
            t.onProgress?.(new Be("blocks:delete-many:blockstore:delete-many")), yield* this.child.deleteMany((async function*() {
                for await (const r of e)yield r;
            })(), t);
        }
        async has(e, t = {}) {
            return this.child.has(e, t);
        }
        async *getAll(e = {}) {
            e.onProgress?.(new Be("blocks:get-all:blockstore:get-many")), yield* this.child.getAll(e);
        }
    }
    async function vv(n, e, t, r) {
        const s = MQ(n, t), i = new AbortController, l = gt([
            i.signal,
            r.signal
        ]);
        i.signal;
        const u = [];
        for (const h of e)$Q(h) && u.push(h);
        if (u.length === 0) throw new Qy(`No block brokers capable of retrieving blocks are configured, the CID ${n} cannot be fetched from the network`);
        try {
            return await Promise.any(u.map(async (h)=>{
                try {
                    let f = !1;
                    const p = await h.retrieve(n, {
                        ...r,
                        signal: l,
                        validateFn: async (m)=>{
                            await s(m), r.signal?.throwIfAborted(), f = !0;
                        }
                    });
                    return f || (await s(p), r.signal?.throwIfAborted()), p;
                } catch (f) {
                    throw r.log.error("could not retrieve verified block for %c from %s - %e", n, h.name, f), f;
                }
            }));
        } catch (h) {
            throw new fH(h.errors, `Failed to load block for ${n}`);
        } finally{
            i.abort(), l.clear();
        }
    }
    function $Q(n) {
        return typeof n.retrieve == "function";
    }
    const MQ = (n, e)=>{
        if (e == null) throw new jS(`No hasher configured for multihash code 0x${n.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
        return async (t)=>{
            let r;
            const s = e.digest(t, {
                truncate: n.multihash.digest.byteLength
            });
            if (Q6(s) ? r = await s : r = s, !Ee(r.digest, n.multihash.digest)) throw new d$("Hash of downloaded block did not match multihash from passed CID");
        };
    };
    class NQ extends DT {
        closeController;
        constructor(e, t){
            super(e), this.closeController = new AbortController, this.closeController.signal, this.log = e.logger.forComponent(`helia:session-storage:${t.root}`);
        }
        close() {
            this.closeController.abort();
        }
        async addPeer(e, t) {
            await Promise.all(this.blockBrokers.map((r)=>r.addPeer(e, t)));
        }
        async put(e, t, r = {}) {
            const s = gt([
                this.closeController.signal,
                r.signal
            ]);
            try {
                return await super.put(e, t, {
                    ...r,
                    signal: s
                });
            } finally{
                s.clear();
            }
        }
        async *putMany(e, t = {}) {
            const r = gt([
                this.closeController.signal,
                t.signal
            ]);
            try {
                yield* super.putMany(e, {
                    ...t,
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
        async *get(e, t = {}) {
            const r = gt([
                this.closeController.signal,
                t.signal
            ]);
            try {
                yield* super.get(e, {
                    ...t,
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
        async *getMany(e, t = {}) {
            const r = gt([
                this.closeController.signal,
                t.signal
            ]);
            try {
                yield* super.getMany(e, {
                    ...t,
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
        async delete(e, t = {}) {
            const r = gt([
                this.closeController.signal,
                t.signal
            ]);
            try {
                await super.delete(e, {
                    ...t,
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
        async *deleteMany(e, t = {}) {
            const r = gt([
                this.closeController.signal,
                t.signal
            ]);
            try {
                yield* super.deleteMany(e, {
                    ...t,
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
        async has(e, t = {}) {
            const r = gt([
                this.closeController.signal,
                t.signal
            ]);
            try {
                return await super.has(e, {
                    ...t,
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
        async *getAll(e = {}) {
            const t = gt([
                this.closeController.signal,
                e.signal
            ]);
            try {
                yield* super.getAll({
                    ...e,
                    signal: t
                });
            } finally{
                t.clear();
            }
        }
    }
    class LQ extends DT {
        started;
        constructor(e, t = {}){
            super(e, t), this.started = !1;
        }
        isStarted() {
            return this.started;
        }
        async start() {
            await ag(this.child, ...this.blockBrokers), this.started = !0;
        }
        async stop() {
            await lg(this.child, ...this.blockBrokers), this.started = !1;
        }
        unwrap() {
            return this.child;
        }
        createSession(e, t) {
            if (this.blockBrokers.length === 0) throw new Qy("No block brokers configured");
            const r = this.blockBrokers.map((s)=>s.createSession?.(t)).filter((s)=>s != null);
            if (r.length === 0) throw new Qy(`No configured block brokers support sessions - tried ${this.blockBrokers.map((s)=>s.name).join(", ")}`);
            return new NQ({
                blockstore: this.child,
                blockBrokers: r,
                getHasher: this.getHasher,
                logger: this.logger
            }, {
                root: e
            });
        }
    }
    class BT extends Lt {
        initialPeerSearchComplete;
        requests;
        logName;
        log;
        logger;
        minProviders;
        maxProviders;
        providers;
        evictionFilter;
        initialProviders;
        cidPeerFilterSize;
        constructor(e, t){
            super(), this.logName = t.name, this.logger = e.logger, this.log = e.logger.forComponent(this.logName), this.requests = new Map, this.minProviders = t.minProviders ?? gH, this.maxProviders = t.maxProviders ?? mH, this.cidPeerFilterSize = t.cidPeerFilterSize ?? yH, this.providers = [], this.evictionFilter = Wi(this.maxProviders), this.initialProviders = [
                ...t.providers ?? []
            ];
        }
        async retrieve(e, t = {}) {
            const r = As.encode(e.multihash.bytes), s = this.requests.get(r);
            if (s != null) return this.log("join existing request for %c", e), s.observers++, s.promise;
            const i = xt(), l = {
                promise: i.promise,
                observers: 1,
                queryFilter: Wi(this.cidPeerFilterSize)
            };
            this.requests.set(r, l);
            let u = !1;
            this.initialPeerSearchComplete == null && (u = !0, this.log = this.logger.forComponent(`${this.logName}:${e}`), this.initialPeerSearchComplete = this.findProviders(e, this.minProviders, t));
            let h = !1;
            const f = new Yo({
                concurrency: this.maxProviders
            });
            f.addEventListener("failure", (w)=>{
                this.log.error("error querying provider %s, evicting from session - %e", w.detail.job.options.provider, w.detail.error), this.evict(w.detail.job.options.provider);
            }), f.addEventListener("success", (w)=>{
                h = !0, i.resolve(w.detail.result);
            }), f.addEventListener("idle", ()=>{
                if (h) {
                    this.log.trace("session idle, found block");
                    return;
                }
                if (t.signal?.aborted === !0) {
                    this.log.trace("session idle, signal aborted");
                    return;
                }
                Promise.resolve().then(async ()=>{
                    this.log("no session peers had block for for %c, finding new providers", e);
                    for(let w = 0; w < this.minProviders && this.providers.length !== 0; w++){
                        const A = this.providers[Math.floor(Math.random() * this.providers.length)];
                        this.evict(A);
                    }
                    await this.findProviders(e, this.minProviders, t), this.log("found new providers re-retrieving %c", e), this.requests.delete(r), i.resolve(await this.retrieve(e, t));
                }).catch((w)=>{
                    this.log.error("could not find new providers for %c - %e", e, w), i.reject(w);
                });
            });
            const p = (w)=>{
                const A = this.toFilterKey(w.detail);
                l.queryFilter.has(A) || (l.queryFilter.add(A), this.emitFoundProviderProgressEvent(e, w.detail, t), f.add(async ()=>this.queryProvider(e, w.detail, t), {
                    provider: w.detail
                }).catch((S)=>{
                    t.signal?.aborted !== !0 && this.log.error("error retrieving session block for %c - %e", e, S);
                }));
            };
            if (this.addEventListener("provider", p), u) try {
                await Xn(this.initialPeerSearchComplete, t.signal), u && this.log("found initial session peers for %c", e);
            } catch (w) {
                throw u && this.log("failed to find initial session peers for %c - %e", e, w), this.requests.delete(r), l.observers > 1 && i.reject(w), w;
            }
            Promise.all([
                ...this.providers
            ].filter((w)=>{
                const A = this.toFilterKey(w), S = l.queryFilter.has(A);
                return S || l.queryFilter.add(this.toFilterKey(w)), !S;
            }).map(async (w)=>f.add(async ()=>this.queryProvider(e, w, t), {
                    provider: w
                }))).catch((w)=>{
                t.signal?.aborted !== !0 && this.log.error("error retrieving session block for %c - %e", e, w);
            });
            const m = ()=>{
                i.reject(new u$(t.signal?.reason ?? "Session aborted")), f.abort();
            };
            t.signal?.addEventListener("abort", m);
            try {
                return await Xn(i.promise, t.signal);
            } finally{
                this.removeEventListener("provider", p), t.signal?.removeEventListener("abort", m), f.clear(), this.requests.delete(r);
            }
        }
        evict(e) {
            this.evictionFilter.add(this.toFilterKey(e));
            const t = this.providers.findIndex((r)=>this.equals(r, e));
            t !== -1 && this.providers.splice(t, 1);
        }
        isEvicted(e) {
            return this.evictionFilter.has(this.toFilterKey(e));
        }
        hasProvider(e) {
            return !!(this.providers.find((t)=>this.equals(t, e)) != null || this.isEvicted(e));
        }
        async addPeer(e, t) {
            const r = await this.convertToProvider(e, "manually-added", t);
            r == null || this.hasProvider(r) || (this.providers.push(r), this.safeDispatchEvent("provider", {
                detail: r
            }));
        }
        async findProviders(e, t, r) {
            const s = xt();
            let i = 0;
            return Promise.resolve().then(async ()=>{
                if (this.log("finding %d-%d new provider(s) for %c - %d initial providers", t, this.maxProviders, e, this.initialProviders.length), this.initialProviders.length > 0) for(; i < t && this.initialProviders.length > 0;){
                    const l = this.initialProviders.pop();
                    if (l == null) break;
                    const u = await this.convertToProvider(l, "manual", r);
                    if (r.signal?.aborted === !0) break;
                    if (u != null && !this.hasProvider(u) && (this.log("found %d/%d new providers", i, this.maxProviders), this.providers.push(u), this.safeDispatchEvent("provider", {
                        detail: u
                    }), i++, i === t && (this.log("session is ready with %d peer(s), only initial peers present", t), s.resolve()), this.providers.length === this.maxProviders)) {
                        this.log("found max session peers", i);
                        break;
                    }
                }
                if (i < this.maxProviders) for await (const l of this.findNewProviders(e, r)){
                    if (i === this.maxProviders || r.signal?.aborted === !0) break;
                    if (!this.hasProvider(l) && (this.log("found %d/%d new providers", i, this.maxProviders), this.providers.push(l), this.safeDispatchEvent("provider", {
                        detail: l
                    }), i++, i === t && (this.log("session is ready with %d peer(s), new peers present", t), s.resolve()), this.providers.length === this.maxProviders)) {
                        this.log("found max session peers", i);
                        break;
                    }
                }
                if (this.log("found %d/%d new session peers", i, this.maxProviders), i < t) throw new wH(`Found ${i} of ${t} ${this.name} providers for ${e}`);
            }).catch((l)=>{
                this.log.error("error searching routing for potential session peers for %c - %e", e, l), s.reject(l);
            }), s.promise;
        }
    }
    class UQ {
        libp2p;
        blockstore;
        datastore;
        events;
        pins;
        logger;
        routing;
        getCodec;
        getHasher;
        dns;
        metrics;
        log;
        constructor(e){
            this.logger = e.logger ?? e.libp2p.logger, this.log = this.logger.forComponent("helia"), this.getHasher = BQ(e.hashers, e.loadHasher), this.getCodec = DQ(e.codecs, e.loadCodec), this.dns = e.dns ?? dI(), this.metrics = e.metrics, this.libp2p = e.libp2p, this.events = new Lt;
            const t = {
                blockstore: e.blockstore,
                datastore: e.datastore,
                logger: this.logger,
                libp2p: this.libp2p,
                blockBrokers: [],
                getHasher: this.getHasher,
                getCodec: this.getCodec,
                dns: this.dns,
                metrics: this.metrics,
                ...e.components ?? {}
            };
            this.routing = t.routing = new AH(t, {
                routers: (e.routers ?? []).flatMap((s)=>{
                    typeof s == "function" && (s = s(t));
                    const i = [
                        s
                    ], l = zQ(s);
                    l != null && i.push(l);
                    const u = FQ(s);
                    return u != null && i.push(u), i;
                }),
                providerLookupConcurrency: e.providerLookupConcurrency
            }), t.blockBrokers = e.blockBrokers.map((s)=>s(t));
            const r = new LQ(t, e);
            this.pins = new pH(e.datastore, r, this.getCodec), this.blockstore = new OH(r, this.pins, {
                holdGcLock: e.holdGcLock ?? !0
            }), this.datastore = e.datastore;
        }
        async start() {
            await $H(this.datastore), await ag(this.blockstore, this.datastore, this.routing, this.libp2p), this.events.dispatchEvent(new CustomEvent("start", {
                detail: this
            }));
        }
        async stop() {
            await lg(this.blockstore, this.datastore, this.routing, this.libp2p), this.events.dispatchEvent(new CustomEvent("stop", {
                detail: this
            }));
        }
        async gc(e = {}) {
            const t = await this.blockstore.lock.writeLock();
            try {
                const r = this, s = this.blockstore.unwrap();
                this.log("gc start"), await qo(s.deleteMany((async function*() {
                    for await (const { cid: i } of s.getAll())try {
                        if (await r.pins.isPinned(i, e)) continue;
                        yield i, e.onProgress?.(new Be("helia:gc:deleted", i));
                    } catch (l) {
                        r.log.error("error during gc - %e", l), e.onProgress?.(new Be("helia:gc:error", l));
                    }
                })()));
            } finally{
                t();
            }
            this.log("gc finished");
        }
    }
    function zQ(n) {
        return n?.[c$];
    }
    function FQ(n) {
        return n?.[f$];
    }
    let VQ = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, HQ = class extends Error {
        static name = "UnsupportedProtocolError";
        constructor(e = "Unsupported protocol error"){
            super(e), this.name = "UnsupportedProtocolError";
        }
    }, QQ = class extends Error {
        static name = "TimeoutError";
        constructor(e = "Timed out"){
            super(e), this.name = "TimeoutError";
        }
    }, qQ = class extends Error {
        static name = "NotStartedError";
        constructor(e = "Not started"){
            super(e), this.name = "NotStartedError";
        }
    };
    const KQ = Symbol.for("@libp2p/peer-id");
    function GQ(n) {
        return !!n?.[KQ];
    }
    const YQ = 8, G6 = 1024 * 1024 * 4;
    let WQ = class extends Error {
        name = "InvalidMessageLengthError";
        code = "ERR_INVALID_MSG_LENGTH";
    }, PT = class extends Error {
        name = "InvalidDataLengthError";
        code = "ERR_MSG_DATA_TOO_LONG";
    }, jQ = class extends Error {
        name = "InvalidDataLengthLengthError";
        code = "ERR_MSG_LENGTH_TOO_LONG";
    }, Ev = class extends Error {
        name = "UnexpectedEOFError";
        code = "ERR_UNEXPECTED_EOF";
    };
    function kT(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function RT(n, e) {
        if (n.byteLength > e) throw new PT("Message length too long");
    }
    const Ag = (n)=>{
        const e = be(n), t = Wn(e);
        return zr(n, t), Ag.bytes = e, t;
    };
    Ag.bytes = 0;
    function OT(n, e) {
        e = e ?? {};
        const t = e.lengthEncoder ?? Ag, r = e?.maxDataLength ?? G6;
        function* s(i) {
            RT(i, r);
            const l = t(i.byteLength);
            l instanceof Uint8Array ? yield l : yield* l, i instanceof Uint8Array ? yield i : yield* i;
        }
        return kT(n) ? (async function*() {
            for await (const i of n)yield* s(i);
        })() : (function*() {
            for (const i of n)yield* s(i);
        })();
    }
    OT.single = (n, e)=>{
        e = e ?? {};
        const t = e.lengthEncoder ?? Ag, r = e?.maxDataLength ?? G6;
        return RT(n, r), new Re(t(n.byteLength), n);
    };
    var Ia;
    (function(n) {
        n[n.LENGTH = 0] = "LENGTH", n[n.DATA = 1] = "DATA";
    })(Ia || (Ia = {}));
    const Y6 = (n)=>{
        const e = et(n);
        return Y6.bytes = be(e), e;
    };
    Y6.bytes = 0;
    function jy(n, e) {
        const t = new Re;
        let r = Ia.LENGTH, s = -1;
        const i = e?.lengthDecoder ?? Y6, l = e?.maxLengthLength ?? YQ, u = e?.maxDataLength ?? G6;
        function* h() {
            for(; t.byteLength > 0;){
                if (r === Ia.LENGTH) try {
                    if (s = i(t), s < 0) throw new WQ("Invalid message length");
                    if (s > u) throw new PT("Message length too long");
                    const f = i.bytes;
                    t.consume(f), e?.onLength != null && e.onLength(s), r = Ia.DATA;
                } catch (f) {
                    if (f instanceof RangeError) {
                        if (t.byteLength > l) throw new jQ("Message length length too long");
                        break;
                    }
                    throw f;
                }
                if (r === Ia.DATA) {
                    if (t.byteLength < s) break;
                    const f = t.sublist(0, s);
                    t.consume(s), e?.onData != null && e.onData(f), yield f, r = Ia.LENGTH;
                }
            }
        }
        return kT(n) ? (async function*() {
            for await (const f of n)t.append(f), yield* h();
            if (t.byteLength > 0) throw new Ev("Unexpected end of input");
        })() : (function*() {
            for (const f of n)t.append(f), yield* h();
            if (t.byteLength > 0) throw new Ev("Unexpected end of input");
        })();
    }
    jy.fromReader = (n, e)=>{
        let t = 1;
        const r = (async function*() {
            for(;;)try {
                const { done: i, value: l } = await n.next(t);
                if (i === !0) return;
                l != null && (yield l);
            } catch (i) {
                if (i.code === "ERR_UNDER_READ") return {
                    done: !0,
                    value: null
                };
                throw i;
            } finally{
                t = 1;
            }
        })();
        return jy(r, {
            ...e ?? {},
            onLength: (i)=>{
                t = i;
            }
        });
    };
    function XQ(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function kf(n, e) {
        let t = 0;
        if (XQ(n)) return (async function*() {
            for await (const h of n)yield e(h, t++);
        })();
        const r = K6(n), { value: s, done: i } = r.next();
        if (i === !0) return (function*() {})();
        const l = e(s, t++);
        if (typeof l.then == "function") return (async function*() {
            yield await l;
            for (const h of r)yield e(h, t++);
        })();
        const u = e;
        return (function*() {
            yield l;
            for (const h of r)yield u(h, t++);
        })();
    }
    function JQ(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function Pp(n, e) {
        return JQ(n) ? (async function*() {
            let t = 0;
            if (!(e < 1)) {
                for await (const r of n)if (yield r, t++, t === e) return;
            }
        })() : (function*() {
            let t = 0;
            if (!(e < 1)) {
                for (const r of n)if (yield r, t++, t === e) return;
            }
        })();
    }
    const y0 = "/ipfs/bitswap/1.2.0", ZQ = 1024, eq = 1024, tq = 1024, nq = 5e3, rq = 10, sq = 50, iq = !1, oq = 3, $T = 1024 * 1024 * 4, aq = $T;
    var mn;
    (function(n) {
        n.WantBlock = "WantBlock", n.WantHave = "WantHave";
    })(mn || (mn = {}));
    var Xy;
    (function(n) {
        n[n.WantBlock = 0] = "WantBlock", n[n.WantHave = 1] = "WantHave";
    })(Xy || (Xy = {}));
    (function(n) {
        n.codec = ()=>vr(Xy);
    })(mn || (mn = {}));
    var Yd;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.cid != null && t.cid.byteLength > 0 && (r.uint32(10), r.bytes(t.cid)), t.priority != null && t.priority !== 0 && (r.uint32(16), r.int32(t.priority)), t.cancel != null && (r.uint32(24), r.bool(t.cancel)), t.wantType != null && (r.uint32(32), mn.codec().encode(t.wantType, r)), t.sendDontHave != null && (r.uint32(40), r.bool(t.sendDontHave)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    cid: je(0),
                    priority: 0
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.cid = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.priority = t.int32();
                                break;
                            }
                        case 3:
                            {
                                i.cancel = t.bool();
                                break;
                            }
                        case 4:
                            {
                                i.wantType = mn.codec().decode(t);
                                break;
                            }
                        case 5:
                            {
                                i.sendDontHave = t.bool();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Yd || (Yd = {}));
    var kp;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.entries != null) for (const i of t.entries)r.uint32(10), Yd.codec().encode(i, r);
                t.full != null && (r.uint32(16), r.bool(t.full)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    entries: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                if (s.limits?.entries != null && i.entries.length === s.limits.entries) throw new vt('Decode error - map field "entries" had too many elements');
                                i.entries.push(Yd.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.entries$
                                }));
                                break;
                            }
                        case 2:
                            {
                                i.full = t.bool();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(kp || (kp = {}));
    var Wd;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.prefix != null && t.prefix.byteLength > 0 && (r.uint32(10), r.bytes(t.prefix)), t.data != null && t.data.byteLength > 0 && (r.uint32(18), r.bytes(t.data)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    prefix: je(0),
                    data: je(0)
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.prefix = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.data = t.bytes();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Wd || (Wd = {}));
    var li;
    (function(n) {
        n.HaveBlock = "HaveBlock", n.DoNotHaveBlock = "DoNotHaveBlock";
    })(li || (li = {}));
    var Rp;
    (function(n) {
        n[n.HaveBlock = 0] = "HaveBlock", n[n.DoNotHaveBlock = 1] = "DoNotHaveBlock";
    })(Rp || (Rp = {}));
    (function(n) {
        n.codec = ()=>vr(Rp);
    })(li || (li = {}));
    var jd;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.cid != null && t.cid.byteLength > 0 && (r.uint32(10), r.bytes(t.cid)), t.type != null && Rp[t.type] !== 0 && (r.uint32(16), li.codec().encode(t.type, r)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    cid: je(0),
                    type: li.HaveBlock
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.cid = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.type = li.codec().decode(t);
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(jd || (jd = {}));
    var Xd;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.wantlist != null && (r.uint32(10), kp.codec().encode(t.wantlist, r)), t.blocks != null) for (const i of t.blocks)r.uint32(26), Wd.codec().encode(i, r);
                if (t.blockPresences != null) for (const i of t.blockPresences)r.uint32(34), jd.codec().encode(i, r);
                t.pendingBytes != null && t.pendingBytes !== 0 && (r.uint32(40), r.int32(t.pendingBytes)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    blocks: [],
                    blockPresences: [],
                    pendingBytes: 0
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.wantlist = kp.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.wantlist
                                });
                                break;
                            }
                        case 3:
                            {
                                if (s.limits?.blocks != null && i.blocks.length === s.limits.blocks) throw new vt('Decode error - map field "blocks" had too many elements');
                                i.blocks.push(Wd.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.blocks$
                                }));
                                break;
                            }
                        case 4:
                            {
                                if (s.limits?.blockPresences != null && i.blockPresences.length === s.limits.blockPresences) throw new vt('Decode error - map field "blockPresences" had too many elements');
                                i.blockPresences.push(jd.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.blockPresences$
                                }));
                                break;
                            }
                        case 5:
                            {
                                i.pendingBytes = t.int32();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Xd || (Xd = {}));
    function lq(n, e) {
        for (const [t, r] of e.wantlist.entries()){
            const s = n.wantlist.get(t);
            s != null && (s.priority > r.priority && (r.priority = s.priority), r.cancel = r.cancel ?? s.cancel, r.wantType = r.wantType ?? s.wantType, r.sendDontHave = r.sendDontHave ?? s.sendDontHave), n.wantlist.set(t, r);
        }
        for (const [t, r] of e.blockPresences.entries())n.blockPresences.set(t, r);
        for (const [t, r] of e.blocks.entries())n.blocks.set(t, r);
        return e.full && !n.full && (n.full = !0), n;
    }
    class cq extends Error {
        static name = "BlockTooLargeError";
        constructor(e = "Block too large"){
            super(e), this.name = "BlockTooLargeError";
        }
    }
    const uq = 4193648, hq = uq + 16;
    function* dq(n, e) {
        const t = [
            ...n.wantlist.values()
        ], r = [
            ...n.blockPresences.values()
        ], s = [
            ...n.blocks.values()
        ];
        let i = 0, l = 0, u = 0, h = !1;
        for(;;){
            const f = {
                wantlist: {
                    full: n.full ?? !1,
                    entries: []
                },
                blockPresences: [],
                blocks: [],
                pendingBytes: 0
            };
            let p = Xd.encode(f).byteLength, { added: m, hasMore: w, newSize: A } = D3(s, f.blocks, u, e, p, fq);
            u += m, p = A;
            const S = w;
            ({ added: m, hasMore: w, newSize: A } = D3(r, f.blockPresences, l, e, p, pq)), l += m, p = A;
            const _ = w;
            if ({ added: m, hasMore: w, newSize: A } = D3(t, f.wantlist.entries, i, e, p, gq), i += m, p = A, h = !S && !_ && !w, h || (f.wantlist.full = !1), yield Xd.encode(f), h) break;
        }
    }
    function D3(n, e, t, r, s, i) {
        let l = 0, u = !1;
        for(let h = t; h < n.length; h++){
            const f = n[h], p = i(f);
            if (p > hq) throw new cq("Cannot send block as after encoding it is over the max message size");
            const m = s + p;
            if (m > r) {
                u = !0;
                break;
            }
            e.push(f), l++, s = m;
        }
        return {
            hasMore: u,
            added: l,
            newSize: s
        };
    }
    function fq(n) {
        return W6(3, Wd.encode(n));
    }
    function pq(n) {
        return W6(4, jd.encode(n));
    }
    function gq(n) {
        return W6(1, Yd.encode(n));
    }
    function W6(n, e) {
        const t = be(n), r = be(e.byteLength);
        return t + r + e.byteLength;
    }
    let mq = class extends Lt {
        log;
        libp2p;
        routing;
        protocols;
        running;
        maxInboundStreams;
        maxOutboundStreams;
        messageReceiveTimeout;
        registrarIds;
        metrics;
        sendQueue;
        runOnLimitedConnections;
        maxOutgoingMessageSize;
        maxIncomingMessageSize;
        constructor(e, t = {}){
            super(), this.log = e.logger.forComponent("helia:bitswap:network"), this.libp2p = e.libp2p, this.routing = e.routing, this.protocols = t.protocols ?? [
                y0
            ], this.registrarIds = [], this.running = !1, this._onStream = this._onStream.bind(this), this.maxInboundStreams = t.maxInboundStreams ?? eq, this.maxOutboundStreams = t.maxOutboundStreams ?? tq, this.messageReceiveTimeout = t.messageReceiveTimeout ?? nq, this.runOnLimitedConnections = t.runOnLimitedConnections ?? iq, this.maxIncomingMessageSize = t.maxIncomingMessageSize ?? $T, this.maxOutgoingMessageSize = t.maxOutgoingMessageSize ?? t.maxIncomingMessageSize ?? aq, this.metrics = {
                blocksSent: e.metrics?.registerCounter("helia_bitswap_sent_blocks_total"),
                dataSent: e.metrics?.registerCounter("helia_bitswap_sent_data_bytes_total")
            }, this.sendQueue = new Wo({
                concurrency: t.messageSendConcurrency ?? sq,
                metrics: e.metrics,
                metricName: "helia_bitswap_message_send_queue"
            });
        }
        async start() {
            if (this.running) return;
            this.running = !0, await this.libp2p.handle(this.protocols, this._onStream, {
                maxInboundStreams: this.maxInboundStreams,
                maxOutboundStreams: this.maxOutboundStreams,
                runOnLimitedConnection: this.runOnLimitedConnections
            });
            const e = {
                onConnect: (t)=>{
                    this.safeDispatchEvent("peer:connected", {
                        detail: t
                    });
                },
                onDisconnect: (t)=>{
                    this.safeDispatchEvent("peer:disconnected", {
                        detail: t
                    });
                }
            };
            this.registrarIds = [];
            for (const t of this.protocols)this.registrarIds.push(await this.libp2p.register(t, e));
            this.libp2p.getConnections().forEach((t)=>{
                this.safeDispatchEvent("peer:connected", {
                    detail: t.remotePeer
                });
            });
        }
        async stop() {
            if (this.running = !1, await this.libp2p.unhandle(this.protocols), this.registrarIds != null) {
                for (const e of this.registrarIds)this.libp2p.unregister(e);
                this.registrarIds = [];
            }
        }
        _onStream(e, t) {
            this.running && Promise.resolve().then(async ()=>{
                this.log("incoming new bitswap %s stream from %p", e.protocol, t.remotePeer);
                const r = ()=>{
                    e.status === "open" ? e.abort(new QQ(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`)) : this.log("stream aborted with status %s", e.status);
                };
                let s = AbortSignal.timeout(this.messageReceiveTimeout);
                s.addEventListener("abort", r), await e.close({
                    signal: s
                });
                const i = Hs();
                e.addEventListener("message", (l)=>{
                    i.push(l.data);
                }), e.addEventListener("remoteCloseWrite", ()=>{
                    i.end();
                }), e.addEventListener("close", (l)=>{
                    l.error != null && i.end(l.error);
                });
                for await (const l of jy(i, {
                    maxDataLength: this.maxIncomingMessageSize
                }))try {
                    const u = Xd.decode(l);
                    this.log("incoming new bitswap %s message from %p on stream", e.protocol, t.remotePeer, e.id), this.safeDispatchEvent("bitswap:message", {
                        detail: {
                            peer: t.remotePeer,
                            message: u
                        }
                    }), s.removeEventListener("abort", r), s = AbortSignal.timeout(this.messageReceiveTimeout), s.addEventListener("abort", r);
                } catch (u) {
                    this.log.error("error reading incoming bitswap message from %p on stream - %e", t.remotePeer, e.id, u), e.abort(u);
                    break;
                }
            }).catch((r)=>{
                this.log.error("error handling incoming stream from %p - %e", t.remotePeer, r), e.abort(r);
            });
        }
        async *findProviders(e, t) {
            t?.onProgress?.(new Be("bitswap:find-providers", e));
            for await (const r of this.routing.findProviders(e, t)){
                if (!await this.libp2p.isDialable(r.multiaddrs, {
                    runOnLimitedConnection: this.runOnLimitedConnections
                })) {
                    this.log("skipping peer %p as they are not dialable - %a", r.id, r.multiaddrs);
                    continue;
                }
                t?.onProgress?.(new Be("bitswap:found-provider", {
                    type: "bitswap",
                    cid: e,
                    provider: r,
                    routing: r.routing
                })), yield r;
            }
        }
        async findAndConnect(e, t) {
            t?.providers != null && await Promise.all(t.providers.map(async (r)=>this.connectTo(r).catch((s)=>{
                    this.log.error("could not connect to supplied provider - %e", s);
                }))), await qo(kf(Pp(this.findProviders(e, t), t?.maxProviders ?? oq), async (r)=>this.connectTo(r.id, t))).catch((r)=>{
                this.log.error(r);
            });
        }
        async sendMessage(e, t, r) {
            if (!this.running) throw new Error("network isn't running");
            const s = this.sendQueue.queue.find((i)=>e.equals(i.options.peerId) && i.status === "queued");
            if (s != null) {
                s.options.message = lq(s.options.message, t), await s.join({
                    signal: r?.signal
                });
                return;
            }
            await this.sendQueue.add(async (i)=>{
                const l = i?.message;
                if (l == null) throw new VQ("No message to send");
                this.log("sendMessage to %p", e), i?.onProgress?.(new Be("bitswap:network:send-wantlist", e));
                const u = await this.libp2p.dialProtocol(e, y0, i);
                await u.closeRead();
                try {
                    for (const h of dq(l, this.maxOutgoingMessageSize))u.send(OT.single(h)) || await u.onDrain(i);
                    await u.close(i);
                } catch (h) {
                    i?.onProgress?.(new Be("bitswap:network:send-wantlist:error", {
                        peer: e,
                        error: h
                    })), this.log.error("error sending message to %p - %e", e, h), u.abort(h);
                }
                this._updateSentStats(l.blocks);
            }, {
                peerId: e,
                signal: r?.signal,
                message: t
            });
        }
        async connectTo(e, t) {
            if (!this.running) throw new qQ("Network isn't running");
            t?.onProgress?.(new Be("bitswap:network:dial", e));
            const [r] = await Promise.all([
                this.libp2p.dial(e, t),
                si(this.libp2p, "peer:identify", t?.signal, {
                    filter: (s)=>{
                        if (!s.detail.peerId.equals(e)) return !1;
                        if (s.detail.protocols.includes(y0)) return !0;
                        throw new HQ(`${e} did not support ${y0}`);
                    }
                })
            ]);
            return r;
        }
        _updateSentStats(e) {
            let t = 0;
            for (const r of e.values())t += r.data.byteLength;
            this.metrics.dataSent?.increment(t), this.metrics.blocksSent?.increment(e.size);
        }
    };
    function B3(n, e) {
        const t = {
            [Symbol.iterator]: ()=>t,
            next: ()=>{
                const r = n.next(), s = r.value;
                return r.done === !0 || s == null ? {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: e(s)
                };
            }
        };
        return t;
    }
    let MT = class {
        map;
        constructor(e){
            if (this.map = new Map, e != null) for (const [t, r] of e.entries())this.map.set(t.toString(), {
                key: t,
                value: r
            });
        }
        [Symbol.iterator]() {
            return this.entries();
        }
        clear() {
            this.map.clear();
        }
        delete(e) {
            return this.map.delete(e.toString());
        }
        entries() {
            return B3(this.map.entries(), (e)=>[
                    e[1].key,
                    e[1].value
                ]);
        }
        forEach(e) {
            this.map.forEach((t, r)=>{
                e(t.value, t.key, this);
            });
        }
        get(e) {
            return this.map.get(e.toString())?.value;
        }
        has(e) {
            return this.map.has(e.toString());
        }
        set(e, t) {
            this.map.set(e.toString(), {
                key: e,
                value: t
            });
        }
        keys() {
            return B3(this.map.values(), (e)=>e.key);
        }
        values() {
            return B3(this.map.values(), (e)=>e.value);
        }
        get size() {
            return this.map.size;
        }
    }, yq = class extends MT {
        metric;
        constructor(e){
            super();
            const { name: t, metrics: r } = e;
            this.metric = r.registerMetric(t), this.updateComponentMetric();
        }
        set(e, t) {
            return super.set(e, t), this.updateComponentMetric(), this;
        }
        delete(e) {
            const t = super.delete(e);
            return this.updateComponentMetric(), t;
        }
        clear() {
            super.clear(), this.updateComponentMetric();
        }
        updateComponentMetric() {
            this.metric.update(this.size);
        }
    };
    function NT(n) {
        const { name: e, metrics: t } = n;
        let r;
        return t != null ? r = new yq({
            name: e,
            metrics: t
        }) : r = new MT, r;
    }
    class Mh {
        full;
        pendingBytes;
        wantlist;
        blocks;
        blockPresences;
        constructor(e = !1, t = 0){
            this.full = e, this.wantlist = new Map, this.blocks = new Map, this.blockPresences = new Map, this.pendingBytes = 0;
        }
        addWantlistEntry(e, t) {
            const r = As.encode(e.multihash.bytes);
            this.wantlist.set(r, t);
        }
        addBlockPresence(e, t) {
            const r = As.encode(e.multihash.bytes);
            this.blockPresences.set(r, t);
        }
        addBlock(e, t) {
            const r = As.encode(e.multihash.bytes);
            this.blocks.set(r, t);
        }
    }
    function wq(n) {
        let e = new Uint8Array(n.reduce((r, s)=>r + be(s), 0)), t = 0;
        for (const r of n)e = zr(r, e, t), t += be(r);
        return e;
    }
    function Av(n) {
        return wq([
            n.version,
            n.code,
            n.multihash.code,
            n.multihash.digest.byteLength
        ]);
    }
    class bq {
        peerId;
        blockstore;
        network;
        wants;
        exchangeCount;
        bytesSent;
        bytesReceived;
        lastExchange;
        maxSizeReplaceHasWithBlock;
        log;
        constructor(e, t){
            this.peerId = e.peerId, this.blockstore = e.blockstore, this.network = e.network, this.wants = new Map, this.log = e.logger.forComponent(`helia:bitswap:ledger:${e.peerId}`), this.exchangeCount = 0, this.bytesSent = 0, this.bytesReceived = 0, this.maxSizeReplaceHasWithBlock = t.maxSizeReplaceHasWithBlock ?? ZQ;
        }
        sentBytes(e) {
            this.exchangeCount++, this.lastExchange = new Date().getTime(), this.bytesSent += e;
        }
        receivedBytes(e) {
            this.exchangeCount++, this.lastExchange = new Date().getTime(), this.bytesReceived += e;
        }
        debtRatio() {
            return this.bytesSent / (this.bytesReceived + 1);
        }
        async sendBlocksToPeer(e) {
            const t = new Mh, r = new Set;
            for (const [s, i] of this.wants.entries())try {
                const l = await XC(this.blockstore.get(i.cid, e));
                i.wantType === mn.WantHave ? l.byteLength < this.maxSizeReplaceHasWithBlock ? (this.log("sending have and block for %c", i.cid), r.add(s), t.addBlock(i.cid, {
                    data: l,
                    prefix: Av(i.cid)
                })) : (this.log("sending have for %c", i.cid), t.addBlockPresence(i.cid, {
                    cid: i.cid.bytes,
                    type: li.HaveBlock
                })) : (this.log("sending block for %c", i.cid), r.add(s), t.addBlock(i.cid, {
                    data: l,
                    prefix: Av(i.cid)
                }));
            } catch (l) {
                if (l.name !== "NotFoundError") throw l;
                if (this.log("do not have block for %c", i.cid), !i.sendDontHave || i.sentDoNotHave === !0) continue;
                i.sentDoNotHave = !0, t.addBlockPresence(i.cid, {
                    cid: i.cid.bytes,
                    type: li.DoNotHaveBlock
                });
            }
            if (t.blocks.size > 0 || t.blockPresences.size > 0) {
                this.log("sending message"), await this.network.sendMessage(this.peerId, t, e), this.log("sent message"), this.sentBytes([
                    ...t.blocks.values()
                ].reduce((s, i)=>s + i.data.byteLength, 0));
                for (const s of r)this.wants.delete(s);
            }
        }
    }
    class vq {
        blockstore;
        network;
        ledgerMap;
        maxSizeReplaceHasWithBlock;
        log;
        logger;
        constructor(e, t = {}){
            this.blockstore = e.blockstore, this.network = e.network, this.maxSizeReplaceHasWithBlock = t.maxSizeReplaceHasWithBlock, this.log = e.logger.forComponent("helia:bitswap:peer-want-lists"), this.logger = e.logger, this.ledgerMap = NT({
                name: "helia_bitswap_ledger_map",
                metrics: e.metrics
            }), this.network.addEventListener("bitswap:message", (r)=>{
                this.receiveMessage(r.detail.peer, r.detail.message).catch((s)=>{
                    this.log.error("error receiving bitswap message from %p - %e", r.detail.peer, s);
                });
            }), this.network.addEventListener("peer:disconnected", (r)=>{
                this.peerDisconnected(r.detail);
            });
        }
        ledgerForPeer(e) {
            const t = this.ledgerMap.get(e);
            if (t != null) return {
                peer: t.peerId,
                value: t.debtRatio(),
                sent: t.bytesSent,
                received: t.bytesReceived,
                exchanged: t.exchangeCount
            };
        }
        wantListForPeer(e) {
            const t = this.ledgerMap.get(e);
            if (t != null) return [
                ...t.wants.values()
            ];
        }
        peers() {
            return Array.from(this.ledgerMap.values()).map((e)=>e.peerId);
        }
        async receiveMessage(e, t) {
            let r = this.ledgerMap.get(e);
            if (r == null && (r = new bq({
                peerId: e,
                blockstore: this.blockstore,
                network: this.network,
                logger: this.logger
            }, {
                maxSizeReplaceHasWithBlock: this.maxSizeReplaceHasWithBlock
            }), this.ledgerMap.set(e, r)), r.receivedBytes(t.blocks?.reduce((s, i)=>s + i.data.byteLength, 0) ?? 0), t.wantlist != null) {
                t.wantlist.full === !0 && r.wants.clear();
                for (const s of t.wantlist.entries){
                    const i = ge.decode(s.cid), l = L(i.multihash.bytes, "base64");
                    s.cancel === !0 ? (this.log("peer %p cancelled want of block for %c", e, i), r.wants.delete(l)) : (s.wantType === mn.WantHave ? this.log("peer %p wanted block presence for %c", e, i) : this.log("peer %p wanted block for %c", e, i), r.wants.set(l, {
                        cid: i,
                        priority: s.priority,
                        wantType: s.wantType ?? mn.WantBlock,
                        sendDontHave: s.sendDontHave ?? !1
                    }));
                }
            }
            this.log("send blocks to peer"), await r.sendBlocksToPeer();
        }
        async receivedBlock(e, t) {
            const r = L(e.multihash.bytes, "base64"), s = [];
            for (const i of this.ledgerMap.values())i.wants.has(r) && s.push(i);
            await Promise.all(s.map(async (i)=>i.sendBlocksToPeer(t)));
        }
        peerDisconnected(e) {
            this.ledgerMap.delete(e);
        }
    }
    class Eq extends BT {
        name = "bitswap-session";
        wantList;
        network;
        libp2p;
        constructor(e, t){
            super(e, {
                ...t,
                name: "helia:bitswap:session"
            }), this.wantList = e.wantList, this.network = e.network, this.libp2p = e.libp2p;
        }
        async queryProvider(e, t, r) {
            this.log("sending WANT-BLOCK for %c to %p", e, t);
            const s = await this.wantList.wantSessionBlock(e, t.peerId, r);
            if (this.log("%p %s %c", t, s.has ? "has" : "does not have", e), s.has && s.block != null) return s.block;
            throw new Error("Provider did not have block");
        }
        async *findNewProviders(e, t = {}) {
            for await (const r of this.network.findProviders(e, t))yield {
                peerId: r.id,
                routing: r.routing
            };
        }
        toFilterKey(e) {
            return e.peerId.toMultihash().bytes;
        }
        equals(e, t) {
            return e.peerId.equals(t.peerId);
        }
        async convertToProvider(e, t, r) {
            if (GQ(e)) return {
                peerId: e,
                routing: t
            };
            if (await this.libp2p.isDialable(e) !== !1) try {
                return {
                    peerId: (await this.libp2p.dial(e, r)).remotePeer,
                    routing: t
                };
            } catch  {}
        }
        emitFoundProviderProgressEvent(e, t, r) {
            r?.onProgress?.(new Be("bitswap:found-provider", {
                type: "bitswap",
                cid: e,
                provider: {
                    id: t.peerId,
                    multiaddrs: [],
                    routing: t.routing
                },
                routing: t.routing
            }));
        }
    }
    function Aq(n, e) {
        return new Eq(n, e);
    }
    class Sq {
        blocksReceived;
        duplicateBlocksReceived;
        dataReceived;
        duplicateDataReceived;
        constructor(e){
            this.blocksReceived = e.metrics?.registerMetricGroup("helia_bitswap_received_blocks"), this.duplicateBlocksReceived = e.metrics?.registerMetricGroup("helia_bitswap_duplicate_received_blocks"), this.dataReceived = e.metrics?.registerMetricGroup("helia_bitswap_data_received_bytes"), this.duplicateDataReceived = e.metrics?.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes");
        }
        updateBlocksReceived(e = 1, t) {
            const r = {
                global: e
            };
            t != null && (r[t.toString()] = e), this.blocksReceived?.increment(r);
        }
        updateDuplicateBlocksReceived(e = 1, t) {
            const r = {
                global: e
            };
            t != null && (r[t.toString()] = e), this.duplicateBlocksReceived?.increment(r);
        }
        updateDataReceived(e, t) {
            const r = {
                global: e
            };
            t != null && (r[t.toString()] = e), this.dataReceived?.increment(r);
        }
        updateDuplicateDataReceived(e, t) {
            const r = {
                global: e
            };
            t != null && (r[t.toString()] = e), this.duplicateDataReceived?.increment(r);
        }
    }
    function Iq(n) {
        if (!(n instanceof Uint8Array)) throw new Error("arg needs to be a Uint8Array");
        const e = [];
        for(; n.length > 0;){
            const t = et(n);
            e.push(t), n = n.slice(be(t));
        }
        return e;
    }
    class Cq extends Lt {
        peers;
        wants;
        network;
        log;
        sendMessagesDelay;
        sendMessagesTimeout;
        hashLoader;
        sendingMessages;
        constructor(e, t = {}){
            super(), this.peers = NT({
                name: "helia_bitswap_peers",
                metrics: e.metrics
            }), this.wants = Qs({
                name: "helia_bitswap_wantlist",
                metrics: e.metrics
            }), this.network = e.network, this.sendMessagesDelay = t.sendMessagesDelay ?? rq, this.log = e.logger.forComponent("helia:bitswap:wantlist"), this.hashLoader = t.hashLoader, this.network.addEventListener("bitswap:message", (r)=>{
                this.receiveMessage(r.detail.peer, r.detail.message).catch((s)=>{
                    this.log.error("error receiving bitswap message from %p - %e", r.detail.peer, s);
                });
            }), this.network.addEventListener("peer:connected", (r)=>{
                this.peerConnected(r.detail).catch((s)=>{
                    this.log.error("error processing newly connected bitswap peer %p - %e", r.detail, s);
                });
            }), this.network.addEventListener("peer:disconnected", (r)=>{
                this.peerDisconnected(r.detail);
            });
        }
        async addEntry(e, t) {
            const r = L(e.multihash.bytes, "base64");
            let s = this.wants.get(r);
            s == null && (s = {
                cid: e,
                priority: t.priority ?? 1,
                wantType: t.wantType ?? mn.WantBlock,
                cancel: !1,
                sendDontHave: !0
            }, this.wants.set(r, s)), s.wantType === mn.WantHave && t.wantType === mn.WantBlock && (s.wantType = mn.WantBlock), await this.sendMessagesDebounced();
            try {
                return t.wantType === mn.WantBlock ? (await si(this, "block", t?.signal, {
                    filter: (u)=>Ee(e.multihash.digest, u.detail.cid.multihash.digest),
                    errorMessage: "Want was aborted"
                })).detail : (await si(this, "presence", t?.signal, {
                    filter: (l)=>Ee(e.multihash.digest, l.detail.cid.multihash.digest),
                    errorMessage: "Want was aborted"
                })).detail;
            } finally{
                t.signal?.aborted === !0 && (this.log("want for %c was aborted, cancelling want", e), s.cancel = !0, await this.sendMessagesDebounced());
            }
        }
        async sendMessagesDebounced() {
            await this.sendingMessages?.promise, clearTimeout(this.sendMessagesTimeout), this.sendMessagesTimeout = setTimeout(()=>{
                this.sendMessages().catch((e)=>{
                    this.log("error sending messages to peers - %e", e);
                });
            }, this.sendMessagesDelay);
        }
        async sendMessages() {
            this.sendingMessages = xt(), await Promise.all([
                ...this.peers.entries()
            ].map(async ([e, t])=>{
                const r = new Set, s = new Mh;
                for (const [i, l] of this.wants.entries())t.has(i) || l.cancel || (r.add(i), s.addWantlistEntry(l.cid, {
                    cid: l.cid.bytes,
                    priority: l.priority,
                    wantType: l.wantType,
                    cancel: l.cancel,
                    sendDontHave: l.sendDontHave
                }));
                if (s.wantlist.size !== 0) try {
                    await this.network.sendMessage(e, s);
                    for (const i of r)t.add(i);
                } catch (i) {
                    this.log.error("error sending full wantlist to new peer - %e", i);
                }
            })).catch((e)=>{
                this.log.error("error sending messages - %e", e);
            });
            for (const [e, t] of this.wants)if (t.cancel) {
                this.wants.delete(e);
                for (const r of this.peers.values())r.delete(e);
            }
            this.sendingMessages.resolve();
        }
        has(e) {
            const t = L(e.multihash.bytes, "base64");
            return this.wants.has(t);
        }
        async wantSessionPresence(e, t, r = {}) {
            const s = new Mh;
            return s.addWantlistEntry(e, {
                cid: e.bytes,
                sendDontHave: !0,
                wantType: mn.WantHave,
                priority: 1
            }), await this.network.sendMessage(t, s), (await si(this, "presence", r.signal, {
                filter: (l)=>t.equals(l.detail.sender) && Ee(e.multihash.digest, l.detail.cid.multihash.digest)
            })).detail;
        }
        async wantBlock(e, t = {}) {
            return this.addEntry(e, {
                ...t,
                wantType: mn.WantBlock
            });
        }
        async wantSessionBlock(e, t, r = {}) {
            const s = new Mh;
            return s.addWantlistEntry(e, {
                cid: e.bytes,
                sendDontHave: !0,
                wantType: mn.WantBlock,
                priority: 1
            }), await this.network.sendMessage(t, s), (await si(this, "presence", r.signal, {
                filter: (l)=>t.equals(l.detail.sender) && Ee(e.multihash.digest, l.detail.cid.multihash.digest)
            })).detail;
        }
        async receivedBlock(e, t) {
            const r = L(e.multihash.bytes, "base64"), s = this.wants.get(r);
            s != null && (s.cancel = !0, await this.sendMessagesDebounced());
        }
        async receiveMessage(e, t) {
            this.log("received message from %p with %d blocks", e, t.blocks.length);
            let r = !1;
            for (const s of t.blocks){
                if (s.prefix == null || s.data == null) continue;
                const i = Iq(s.prefix), l = i[0], u = i[1], h = i[2], f = i[3], p = h === Ut.code ? Ut : await this.hashLoader?.getHasher(h);
                if (p == null) {
                    this.log.error("unknown hash algorithm", h);
                    continue;
                }
                let m = p.digest(s.data, {
                    truncate: f
                });
                m.then != null && (m = await m);
                const w = ge.create(l === 0 ? 0 : 1, u, m);
                this.log("received block from %p for %c", e, w), this.safeDispatchEvent("block", {
                    detail: {
                        sender: e,
                        cid: w,
                        block: s.data
                    }
                }), this.safeDispatchEvent("presence", {
                    detail: {
                        sender: e,
                        cid: w,
                        has: !0,
                        block: s.data
                    }
                });
                const A = L(w.multihash.bytes, "base64"), S = this.wants.get(A);
                S != null && (S.cancel = !0, r = !0);
            }
            for (const { cid: s, type: i } of t.blockPresences){
                const l = ge.decode(s);
                this.log("received %s from %p for %c", i, e, l), this.safeDispatchEvent("presence", {
                    detail: {
                        sender: e,
                        cid: l,
                        has: i === li.HaveBlock
                    }
                });
            }
            r && await this.sendMessagesDebounced();
        }
        async peerConnected(e) {
            const t = new Set, r = new Mh(!0);
            for (const [s, i] of this.wants.entries())i.cancel || (t.add(s), r.addWantlistEntry(i.cid, {
                cid: i.cid.bytes,
                priority: 1,
                wantType: mn.WantBlock,
                cancel: !1,
                sendDontHave: !1
            }));
            if (r.wantlist.size === 0) {
                this.peers.set(e, t);
                return;
            }
            try {
                await this.network.sendMessage(e, r), this.peers.set(e, t);
            } catch (s) {
                this.log.error("error sending full wantlist to new peer %p - %e", e, s);
            }
        }
        peerDisconnected(e) {
            this.peers.delete(e);
        }
        start() {}
        stop() {
            this.peers.clear(), clearTimeout(this.sendMessagesTimeout);
        }
    }
    class Tq {
        log;
        logger;
        stats;
        network;
        blockstore;
        peerWantLists;
        wantList;
        libp2p;
        constructor(e, t = {}){
            this.logger = e.logger, this.log = e.logger.forComponent("helia:bitswap"), this.blockstore = e.blockstore, this.libp2p = e.libp2p, this.stats = new Sq(e), this.network = new mq(e, t), this.peerWantLists = new vq({
                ...e,
                network: this.network
            }, t), this.wantList = new Cq({
                ...e,
                network: this.network
            }, t);
        }
        createSession(e = {}) {
            return Aq({
                wantList: this.wantList,
                network: this.network,
                logger: this.logger,
                libp2p: this.libp2p
            }, e);
        }
        async want(e, t = {}) {
            const r = new AbortController, s = gt([
                r.signal,
                t.signal
            ]);
            r.signal, this.network.findAndConnect(e, {
                ...t,
                signal: s
            }).catch((i)=>{
                r.signal.aborted || this.log.error("error during finding and connect for cid %c - %e", e, i);
            });
            try {
                const i = await this.wantList.wantBlock(e, {
                    ...t,
                    signal: s
                });
                return t.onProgress?.(new Be("bitswap:block", {
                    cid: e,
                    sender: i.sender
                })), i.block;
            } finally{
                r.abort(), s.clear();
            }
        }
        async notify(e, t = {}) {
            await Promise.all([
                this.peerWantLists.receivedBlock(e, t),
                this.wantList.receivedBlock(e, t)
            ]);
        }
        getWantlist() {
            return [
                ...this.wantList.wants.values()
            ].filter((e)=>!e.cancel).map((e)=>({
                    cid: e.cid,
                    priority: e.priority,
                    wantType: e.wantType
                }));
        }
        getPeerWantlist(e) {
            return this.peerWantLists.wantListForPeer(e);
        }
        async start() {
            this.wantList.start(), await this.network.start();
        }
        async stop() {
            this.wantList.stop(), await this.network.stop();
        }
    }
    const _q = (n, e = {})=>new Tq(n, e);
    class xq {
        name = "bitswap";
        bitswap;
        started;
        constructor(e, t = {}){
            const { getHasher: r } = e;
            this.bitswap = _q(e, {
                hashLoader: {
                    getHasher: async (s)=>r(s)
                },
                ...t
            }), this.started = !1;
        }
        isStarted() {
            return this.started;
        }
        async start() {
            await this.bitswap.start(), this.started = !0;
        }
        async stop() {
            await this.bitswap.stop(), this.started = !1;
        }
        async announce(e, t) {
            await this.bitswap.notify(e, t);
        }
        async retrieve(e, t = {}) {
            return this.bitswap.want(e, t);
        }
        createSession(e) {
            const t = this.bitswap.createSession(e);
            return {
                name: "bitswap-session",
                addPeer: async (r, s)=>{
                    await t.addPeer(r, s);
                },
                announce: async (r, s)=>{
                    await this.bitswap.notify(r, s);
                },
                retrieve: async (r, s)=>t.retrieve(r, s)
            };
        }
    }
    function Dq(n = {}) {
        return (e)=>new xq(e, n);
    }
    const Bq = Symbol.for("@libp2p/peer-id");
    function Pq(n) {
        return !!n?.[Bq];
    }
    let ls = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, Jd = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, kq = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, Rq = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const Oq = 4, LT = 6, $q = 273, Mq = 33, UT = 41, Nq = 42, Lq = 43, zT = 53, FT = 54, VT = 55, HT = 56, Uq = 132, zq = 301, Fq = 302, Vq = 400, Hq = 421, Qq = 444, qq = 445, Kq = 446, Gq = 447, QT = 448, Yq = 449, Wq = 454, jq = 460, Xq = 461, Jq = 465, Zq = 466, eK = 480, tK = 481, nK = 443, rK = 477, sK = 478, iK = 479, oK = 277, aK = 275, lK = 276, cK = 280, uK = 281, hK = 290, dK = 777;
    function Sv(n) {
        return (e)=>L(e, n);
    }
    function Iv(n) {
        return (e)=>re(e, n);
    }
    function Nh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function Xl(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function fK(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = Xl(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function pK(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = Xl(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Cv(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Nh(t);
        return `${r}:${s}`;
    }
    const qT = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new ls("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, gK = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = qT(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new ls("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, mK = function(n) {
        if (n.byteLength !== 4) throw new ls("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, yK = function(n) {
        if (n.byteLength !== 16) throw new ls("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new ls(`Invalid IPv6 address "${t}"`);
        }
    };
    function wK(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new ls(`Invalid IPv6 address "${n}"`);
        }
    }
    const P3 = Object.values(un).map((n)=>n.decoder), bK = (function() {
        let n = P3[0].or(P3[1]);
        return P3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function vK(n) {
        return bK.decode(n);
    }
    function EK(n) {
        return (e)=>n.encoder.encode(e);
    }
    function AK(n) {
        if (parseInt(n).toString() !== n) throw new Jd("Value must be an integer");
    }
    function SK(n) {
        if (n < 0) throw new Jd("Value must be a positive integer, or zero");
    }
    function IK(n) {
        return (e)=>{
            if (e > n) throw new Jd(`Value must be smaller than or equal to ${n}`);
        };
    }
    function CK(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const w0 = CK(AK, SK, IK(65535)), Pn = -1;
    let TK = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new Rq(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const au = new TK, _K = [
        {
            code: Oq,
            name: "ip4",
            size: 32,
            valueToBytes: qT,
            bytesToValue: mK,
            validate: (n)=>{
                if (!Je(n)) throw new Jd(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: LT,
            name: "tcp",
            size: 16,
            valueToBytes: Xl,
            bytesToValue: Nh,
            validate: w0
        },
        {
            code: $q,
            name: "udp",
            size: 16,
            valueToBytes: Xl,
            bytesToValue: Nh,
            validate: w0
        },
        {
            code: Mq,
            name: "dccp",
            size: 16,
            valueToBytes: Xl,
            bytesToValue: Nh,
            validate: w0
        },
        {
            code: UT,
            name: "ip6",
            size: 128,
            valueToBytes: gK,
            bytesToValue: yK,
            stringToValue: wK,
            validate: (n)=>{
                if (!xn(n)) throw new Jd(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: Nq,
            name: "ip6zone",
            size: Pn
        },
        {
            code: Lq,
            name: "ipcidr",
            size: 8,
            bytesToValue: Sv("base10"),
            valueToBytes: Iv("base10")
        },
        {
            code: zT,
            name: "dns",
            size: Pn
        },
        {
            code: FT,
            name: "dns4",
            size: Pn
        },
        {
            code: VT,
            name: "dns6",
            size: Pn
        },
        {
            code: HT,
            name: "dnsaddr",
            size: Pn
        },
        {
            code: Uq,
            name: "sctp",
            size: 16,
            valueToBytes: Xl,
            bytesToValue: Nh,
            validate: w0
        },
        {
            code: zq,
            name: "udt"
        },
        {
            code: Fq,
            name: "utp"
        },
        {
            code: Vq,
            name: "unix",
            size: Pn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: Hq,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Pn,
            bytesToValue: Sv("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? Iv("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: Qq,
            name: "onion",
            size: 96,
            bytesToValue: Cv,
            valueToBytes: fK
        },
        {
            code: qq,
            name: "onion3",
            size: 296,
            bytesToValue: Cv,
            valueToBytes: pK
        },
        {
            code: Kq,
            name: "garlic64",
            size: Pn
        },
        {
            code: Gq,
            name: "garlic32",
            size: Pn
        },
        {
            code: QT,
            name: "tls"
        },
        {
            code: Yq,
            name: "sni",
            size: Pn
        },
        {
            code: Wq,
            name: "noise"
        },
        {
            code: jq,
            name: "quic"
        },
        {
            code: Xq,
            name: "quic-v1"
        },
        {
            code: Jq,
            name: "webtransport"
        },
        {
            code: Zq,
            name: "certhash",
            size: Pn,
            bytesToValue: EK(yn),
            valueToBytes: vK
        },
        {
            code: eK,
            name: "http"
        },
        {
            code: tK,
            name: "http-path",
            size: Pn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: nK,
            name: "https"
        },
        {
            code: rK,
            name: "ws"
        },
        {
            code: sK,
            name: "wss"
        },
        {
            code: iK,
            name: "p2p-websocket-star"
        },
        {
            code: oK,
            name: "p2p-stardust"
        },
        {
            code: aK,
            name: "p2p-webrtc-star"
        },
        {
            code: lK,
            name: "p2p-webrtc-direct"
        },
        {
            code: cK,
            name: "webrtc-direct"
        },
        {
            code: uK,
            name: "webrtc"
        },
        {
            code: hK,
            name: "p2p-circuit"
        },
        {
            code: dK,
            name: "memory",
            size: Pn
        }
    ];
    _K.forEach((n)=>{
        au.addProtocol(n);
    });
    function xK(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = au.getProtocol(r), i = be(r), l = kK(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Pn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function DK(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = au.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Pn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Pn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function BK(n) {
        if (n.charAt(0) !== "/") throw new ls('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = au.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new ls(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new ls(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new ls("Incomplete multiaddr");
        return e;
    }
    function PK(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = au.getProtocol(e.code);
            if (t == null) throw new ls(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function kK(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const RK = Symbol.for("nodejs.util.inspect.custom"), KT = Symbol.for("@multiformats/multiaddr");
    function OK(n) {
        if (n == null && (n = "/"), NK(n)) return n.getComponents();
        if (n instanceof Uint8Array) return xK(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), BK(n);
        if (Array.isArray(n)) return n;
        throw new ls("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let $K = class Lh {
        [KT] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = OK(e), t.validate !== !1 && MK(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = DK(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = PK(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new Lh(e);
            return new Lh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new kq(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new Lh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new Lh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [RK]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function MK(n) {
        n.getComponents().forEach((e)=>{
            const t = au.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function NK(n) {
        return !!n?.[KT];
    }
    function LK(n) {
        return new $K(n);
    }
    const UK = [
        LT,
        zT,
        HT,
        FT,
        VT
    ];
    function Tv(n) {
        return GT("sni", n)?.value;
    }
    function _v(n) {
        const e = GT("tcp", n)?.value;
        return e == null ? "" : `:${e}`;
    }
    function GT(n, e) {
        return e.find((t)=>t.name === n);
    }
    function xv(n) {
        return n.some(({ code: e })=>e === QT);
    }
    function ks(n, e) {
        const t = YT[n.name];
        if (t == null) throw new Error(`Can't interpret protocol ${n.name}`);
        const r = t(n, e);
        return n.code === UT ? `[${r}]` : r;
    }
    const YT = {
        ip4: (n, e)=>n.value,
        ip6: (n, e)=>e.length === 0 ? n.value : `[${n.value}]`,
        tcp: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            return `tcp://${ks(t, e)}:${n.value}`;
        },
        udp: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            return `udp://${ks(t, e)}:${n.value}`;
        },
        dnsaddr: (n, e)=>n.value,
        dns4: (n, e)=>n.value,
        dns6: (n, e)=>n.value,
        dns: (n, e)=>n.value,
        ipfs: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            return `${ks(t, e)}`;
        },
        p2p: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            return `${ks(t, e)}`;
        },
        http: (n, e)=>{
            const t = xv(e), r = Tv(e), s = _v(e);
            if (t && r != null) return `https://${r}${s}`;
            const i = t ? "https://" : "http://", l = e.pop();
            if (l == null) throw new Error("Unexpected end of multiaddr");
            let u = ks(l, e);
            return u = u?.replace("tcp://", ""), `${i}${u}`;
        },
        "http-path": (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            const r = ks(t, e), s = decodeURIComponent(n.value ?? "");
            return `${r}${s}`;
        },
        tls: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            return ks(t, e);
        },
        sni: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            return ks(t, e);
        },
        https: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            let r = ks(t, e);
            return r = r?.replace("tcp://", ""), `https://${r}`;
        },
        ws: (n, e)=>{
            const t = xv(e), r = Tv(e), s = _v(e);
            if (t && r != null) return `wss://${r}${s}`;
            const i = t ? "wss://" : "ws://", l = e.pop();
            if (l == null) throw new Error("Unexpected end of multiaddr");
            let u = ks(l, e);
            return u = u?.replace("tcp://", ""), `${i}${u}`;
        },
        wss: (n, e)=>{
            const t = e.pop();
            if (t == null) throw new Error("Unexpected end of multiaddr");
            let r = ks(t, e);
            return r = r?.replace("tcp://", ""), `wss://${r}`;
        }
    };
    function Sg(n, e) {
        const r = LK(n).getComponents(), s = r.pop();
        if (s == null) throw new Error("Unexpected end of multiaddr");
        const i = YT[s.name];
        if (i == null) throw new Error(`No interpreter found for ${s.name}`);
        let l = i(s, r) ?? "";
        return UK.includes(s.code) && (l = l.replace(/^.*:\/\//, ""), s.value === "443" ? l = `https://${l}` : l = `http://${l}`), (l.startsWith("http://") || l.startsWith("https://") || l.startsWith("ws://") || l.startsWith("wss://")) && (l = new URL(l).toString(), l.endsWith("/") && (l = l.substring(0, l.length - 1))), l;
    }
    let zc = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, Zd = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, zK = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const WT = 4, Cc = 6, jT = 273, FK = 33, XT = 41, JT = 42, j6 = 43, ZT = 53, e_ = 54, t_ = 55, n_ = 56, VK = 132, HK = 301, QK = 302, r_ = 400, St = 421, qK = 444, KK = 445, GK = 446, YK = 447, bd = 448, s_ = 449, WK = 454, i_ = 460, o_ = 461, a_ = 465, ef = 466, Tc = 480, jK = 481, Jy = 443, X6 = 477, l_ = 478, XK = 479, JK = 277, ZK = 275, eG = 276, c_ = 280, vd = 281, J6 = 290, u_ = 777;
    function Dv(n) {
        return (e)=>L(e, n);
    }
    function Bv(n) {
        return (e)=>re(e, n);
    }
    function Uh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function Jl(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function tG(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = Jl(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function nG(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = Jl(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Pv(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Uh(t);
        return `${r}:${s}`;
    }
    const h_ = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new zc("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, rG = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = h_(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new zc("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, sG = function(n) {
        if (n.byteLength !== 4) throw new zc("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, iG = function(n) {
        if (n.byteLength !== 16) throw new zc("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new zc(`Invalid IPv6 address "${t}"`);
        }
    };
    function oG(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new zc(`Invalid IPv6 address "${n}"`);
        }
    }
    const k3 = Object.values(un).map((n)=>n.decoder), aG = (function() {
        let n = k3[0].or(k3[1]);
        return k3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function lG(n) {
        return aG.decode(n);
    }
    function cG(n) {
        return (e)=>n.encoder.encode(e);
    }
    function uG(n) {
        if (parseInt(n).toString() !== n) throw new Zd("Value must be an integer");
    }
    function hG(n) {
        if (n < 0) throw new Zd("Value must be a positive integer, or zero");
    }
    function dG(n) {
        return (e)=>{
            if (e > n) throw new Zd(`Value must be smaller than or equal to ${n}`);
        };
    }
    function fG(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const b0 = fG(uG, hG, dG(65535)), kr = -1;
    let pG = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new zK(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const gG = new pG, mG = [
        {
            code: WT,
            name: "ip4",
            size: 32,
            valueToBytes: h_,
            bytesToValue: sG,
            validate: (n)=>{
                if (!Je(n)) throw new Zd(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: Cc,
            name: "tcp",
            size: 16,
            valueToBytes: Jl,
            bytesToValue: Uh,
            validate: b0
        },
        {
            code: jT,
            name: "udp",
            size: 16,
            valueToBytes: Jl,
            bytesToValue: Uh,
            validate: b0
        },
        {
            code: FK,
            name: "dccp",
            size: 16,
            valueToBytes: Jl,
            bytesToValue: Uh,
            validate: b0
        },
        {
            code: XT,
            name: "ip6",
            size: 128,
            valueToBytes: rG,
            bytesToValue: iG,
            stringToValue: oG,
            validate: (n)=>{
                if (!xn(n)) throw new Zd(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: JT,
            name: "ip6zone",
            size: kr
        },
        {
            code: j6,
            name: "ipcidr",
            size: 8,
            bytesToValue: Dv("base10"),
            valueToBytes: Bv("base10")
        },
        {
            code: ZT,
            name: "dns",
            size: kr
        },
        {
            code: e_,
            name: "dns4",
            size: kr
        },
        {
            code: t_,
            name: "dns6",
            size: kr
        },
        {
            code: n_,
            name: "dnsaddr",
            size: kr
        },
        {
            code: VK,
            name: "sctp",
            size: 16,
            valueToBytes: Jl,
            bytesToValue: Uh,
            validate: b0
        },
        {
            code: HK,
            name: "udt"
        },
        {
            code: QK,
            name: "utp"
        },
        {
            code: r_,
            name: "unix",
            size: kr,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: St,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: kr,
            bytesToValue: Dv("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? Bv("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: qK,
            name: "onion",
            size: 96,
            bytesToValue: Pv,
            valueToBytes: tG
        },
        {
            code: KK,
            name: "onion3",
            size: 296,
            bytesToValue: Pv,
            valueToBytes: nG
        },
        {
            code: GK,
            name: "garlic64",
            size: kr
        },
        {
            code: YK,
            name: "garlic32",
            size: kr
        },
        {
            code: bd,
            name: "tls"
        },
        {
            code: s_,
            name: "sni",
            size: kr
        },
        {
            code: WK,
            name: "noise"
        },
        {
            code: i_,
            name: "quic"
        },
        {
            code: o_,
            name: "quic-v1"
        },
        {
            code: a_,
            name: "webtransport"
        },
        {
            code: ef,
            name: "certhash",
            size: kr,
            bytesToValue: cG(yn),
            valueToBytes: lG
        },
        {
            code: Tc,
            name: "http"
        },
        {
            code: jK,
            name: "http-path",
            size: kr,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Jy,
            name: "https"
        },
        {
            code: X6,
            name: "ws"
        },
        {
            code: l_,
            name: "wss"
        },
        {
            code: XK,
            name: "p2p-websocket-star"
        },
        {
            code: JK,
            name: "p2p-stardust"
        },
        {
            code: ZK,
            name: "p2p-webrtc-star"
        },
        {
            code: eG,
            name: "p2p-webrtc-direct"
        },
        {
            code: c_,
            name: "webrtc-direct"
        },
        {
            code: vd,
            name: "webrtc"
        },
        {
            code: J6,
            name: "p2p-circuit"
        },
        {
            code: u_,
            name: "memory",
            size: kr
        }
    ];
    mG.forEach((n)=>{
        gG.addProtocol(n);
    });
    const Bt = (n)=>({
            match: (e)=>{
                const t = e[0];
                return t == null || t.code !== n || t.value != null ? !1 : e.slice(1);
            }
        }), $e = (n, e)=>({
            match: (t)=>{
                const r = t[0];
                return r?.code !== n || r.value == null || e != null && r.value !== e ? !1 : t.slice(1);
            }
        }), yG = (n)=>({
            match: (e)=>n.match(e) === !1 ? e : !1
        }), tt = (n)=>({
            match: (e)=>{
                const t = n.match(e);
                return t === !1 ? e : t;
            }
        }), rr = (...n)=>({
            match: (e)=>{
                let t;
                for (const r of n){
                    const s = r.match(e);
                    s !== !1 && (t == null || s.length < t.length) && (t = s);
                }
                return t ?? !1;
            }
        }), ht = (...n)=>({
            match: (e)=>{
                for (const t of n){
                    const r = t.match(e);
                    if (r === !1) return !1;
                    e = r;
                }
                return e;
            }
        });
    function Rt(...n) {
        function e(s) {
            if (s == null) return !1;
            let i = s.getComponents();
            for (const l of n){
                const u = l.match(i);
                if (u === !1) return !1;
                i = u;
            }
            return i;
        }
        function t(s) {
            return e(s) !== !1;
        }
        function r(s) {
            const i = e(s);
            return i === !1 ? !1 : i.length === 0;
        }
        return {
            matchers: n,
            matches: t,
            exactMatch: r
        };
    }
    const wG = $e(St), bG = Rt(wG), Ig = $e(e_), Cg = $e(t_), Tg = $e(n_), Z6 = $e(ZT);
    Rt(Ig, tt($e(St)));
    Rt(Cg, tt($e(St)));
    Rt(Tg, tt($e(St)));
    const d_ = Rt(rr(Z6, Tg, Ig, Cg), tt($e(St))), f_ = ht($e(WT), tt($e(j6))), p_ = ht(tt($e(JT)), $e(XT), tt($e(j6))), e8 = rr(f_, p_), qa = rr(e8, Z6, Ig, Cg, Tg), vG = Rt(rr(e8, ht(rr(Z6, Tg, Ig, Cg), tt($e(St))))), kv = Rt(f_), Rv = Rt(p_), EG = Rt(e8), t8 = ht(qa, $e(Cc)), Rf = ht(qa, $e(jT)), Op = Rt(ht(t8, tt($e(St))));
    Rt(Rf);
    const n8 = ht(Rf, Bt(i_), tt($e(St))), _g = ht(Rf, Bt(o_), tt($e(St))), AG = rr(n8, _g);
    Rt(n8);
    const SG = Rt(_g), Zy = rr(qa, t8, Rf, n8, _g), g_ = rr(ht(Zy, Bt(X6), tt($e(St)))), tf = Rt(g_), m_ = rr(ht(Zy, Bt(l_), tt($e(St))), ht(Zy, Bt(bd), tt($e(s_)), Bt(X6), tt($e(St)))), $p = Rt(m_), y_ = ht(Rf, Bt(c_), tt($e(ef)), tt($e(ef)), tt($e(St))), e4 = Rt(y_), w_ = ht(_g, Bt(a_), tt($e(ef)), tt($e(ef)), tt($e(St))), Ov = Rt(w_), Mp = rr(g_, m_, ht(t8, tt($e(St))), ht(AG, tt($e(St))), ht(qa, tt($e(St))), y_, w_, $e(St)), r8 = Rt(Mp), IG = ht(tt(Mp), Bt(J6), yG(Bt(vd)), tt($e(St))), di = Rt(IG), CG = rr(ht(Mp, Bt(J6), Bt(vd), tt($e(St))), ht(Mp, Bt(vd), tt($e(St))), ht(Bt(vd), tt($e(St)))), t4 = Rt(CG), TG = rr(ht(qa, $e(Cc), Bt(Tc), tt($e(St))), ht(qa, Bt(Tc), tt($e(St)))), _G = Rt(TG), xG = ht(qa, rr(ht($e(Cc, "443"), Bt(Tc)), ht($e(Cc), Bt(Jy)), ht($e(Cc), Bt(bd), Bt(Tc)), ht(Bt(bd), Bt(Tc)), Bt(bd), Bt(Jy)), tt($e(St))), DG = Rt(xG), BG = rr(ht($e(u_), tt($e(St))));
    Rt(BG);
    const PG = rr(ht($e(r_), tt($e(St))));
    Rt(PG);
    function b_(n, e, t) {
        return n.filter((r)=>{
            if (DG.matches(r) || e && _G.matches(r)) return t || d_.matches(r) ? !0 : Is(r) === !1;
            if (!e && t) {
                const { host: s } = Xe(r);
                if (s === "127.0.0.1" || s === "localhost" || s.endsWith(".localhost")) return !0;
            }
            return !1;
        });
    }
    async function* v_(n, e, t, r, s, i = {}) {
        for await (const l of e.findProviders(n, i)){
            const u = b_(l.multiaddrs, r, s);
            if (u.length === 0) continue;
            const h = new URL(Sg(u[0]));
            yield new E_(h, {
                logger: t,
                transformRequestInit: i.transformRequestInit,
                routing: l.routing
            });
        }
    }
    async function kG(n, e, t) {
        const { signal: r, log: s } = t ?? {}, i = n.headers.get("content-length");
        if (i != null) {
            const h = parseInt(i, 10);
            if (h > e) throw s?.error("content-length header (%d) is greater than the limit (%d)", h, e), n.body != null && await n.body.cancel().catch((f)=>{
                s?.error("error cancelling response body after content-length check - %e", f);
            }), new Error(`Content-Length header (${h}) is greater than the limit (${e}).`);
        }
        const l = n.body?.getReader();
        if (l == null) throw new Error("Response body is not readable");
        const u = new Re;
        try {
            for(;;){
                if (r?.aborted === !0) throw new Error("Response body read was aborted.");
                const { done: h, value: f } = await l.read();
                if (h) break;
                if (u.append(f), u.byteLength > e) throw new Error(`Response body is greater than the limit (${e}), received ${u.byteLength} bytes.`);
            }
        } finally{
            l.cancel().catch((h)=>{
                s?.error("error cancelling reader - %e", h);
            }).finally(()=>{
                l.releaseLock();
            });
        }
        return u.subarray();
    }
    class E_ {
        url;
        #e = 0;
        #t = 0;
        #n = 0;
        #l = 0;
        #h = new Map;
        log;
        transformRequestInit;
        routing;
        constructor(e, { logger: t, transformRequestInit: r, routing: s }){
            this.url = e instanceof URL ? e : new URL(e), this.transformRequestInit = r, this.log = t.forComponent(`helia:trustless-gateway-block-broker:${this.url.host}`), this.routing = s;
        }
        #m(e) {
            const t = e.multihash.bytes;
            return As.encode(t);
        }
        async getRawBlock(e, { signal: t, maxSize: r = MG } = {}) {
            const s = new URL(this.url.toString());
            if (s.pathname = `/ipfs/${e.toString()}`, s.search = "?format=raw", t?.aborted === !0) throw new Error(`Signal to fetch raw block for CID ${e} from gateway ${this.url} was aborted prior to fetch`);
            const i = this.#m(e), l = new AbortController, u = ()=>{
                l.abort();
            };
            t?.addEventListener("abort", u);
            try {
                let h = this.#h.get(i);
                if (h == null) {
                    this.#e++;
                    const f = {
                        signal: l.signal,
                        headers: {
                            Accept: "application/vnd.ipld.raw"
                        },
                        cache: "force-cache"
                    }, p = this.transformRequestInit != null ? await this.transformRequestInit(f) : f, m = new Headers(p.headers);
                    this.log(`sending request
%s %s HTTP/1.1
%s
`, p.method ?? "GET", s, [
                        ...m.entries()
                    ].map(([w, A])=>`${w}: ${A}`).join(`
`)), h = fetch(s.toString(), p).then(async (w)=>{
                        if (this.log(`received response
HTTP/1.1 %d %s
%s
`, w.status, w.statusText, [
                            ...w.headers.entries()
                        ].map(([S, _])=>`${S}: ${_}`).join(`
`)), !w.ok) throw this.#t++, new Error(`Unable to fetch raw block for CID ${e} from gateway ${this.url}, received ${w.status} ${w.statusText}`);
                        const A = await kG(w, r, {
                            signal: l.signal,
                            log: this.log
                        });
                        return this.#l++, A;
                    }), this.#h.set(i, h);
                }
                return await h;
            } catch (h) {
                throw t?.aborted === !0 ? new Error(`Fetching raw block for CID ${e} from gateway ${this.url} was aborted`) : (this.#t++, new Error(`Unable to fetch raw block for CID ${e} - ${h.message}`));
            } finally{
                t?.removeEventListener("abort", u), this.#h.delete(i);
            }
        }
        reliability() {
            return this.#e === 0 ? 1 : this.#n > 0 ? -1 / 0 : this.#l / (this.#e + this.#t * 3);
        }
        incrementInvalidBlocks() {
            this.#n++;
        }
        getStats() {
            return {
                attempts: this.#e,
                errors: this.#t,
                invalidBlocks: this.#n,
                successes: this.#l,
                pendingResponses: this.#h.size
            };
        }
        toString() {
            return `TrustlessGateway(${this.url})`;
        }
    }
    class RG extends BT {
        name = "trustless-gateway-session";
        routing;
        allowInsecure;
        allowLocal;
        transformRequestInit;
        constructor(e, t){
            super(e, {
                ...t,
                name: "helia:trustless-gateway:session"
            }), this.routing = e.routing, this.allowInsecure = t.allowInsecure ?? A_, this.allowLocal = t.allowLocal ?? S_, this.transformRequestInit = t.transformRequestInit;
        }
        async queryProvider(e, t, r) {
            this.log("fetching BLOCK for %c from %s", e, t.url);
            const s = await t.getRawBlock(e, r);
            return this.log.trace("got block for %c from %s", e, t.url), await r.validateFn?.(s), s;
        }
        async *findNewProviders(e, t = {}) {
            yield* v_(e, this.routing, this.logger, this.allowInsecure, this.allowLocal, {
                ...t,
                transformRequestInit: this.transformRequestInit
            });
        }
        toFilterKey(e) {
            return e.url.toString();
        }
        equals(e, t) {
            return e.url.toString() === t.url.toString();
        }
        async convertToProvider(e, t, r) {
            if (Pq(e)) return;
            const s = b_(Array.isArray(e) ? e : [
                e
            ], this.allowInsecure, this.allowLocal);
            if (s.length === 0) return;
            const i = Sg(s[0]);
            return new E_(i, {
                logger: this.logger,
                transformRequestInit: this.transformRequestInit,
                routing: t
            });
        }
        emitFoundProviderProgressEvent(e, t, r) {
            r?.onProgress?.(new Be("trustless-gateway:found-provider", {
                type: "trustless-gateway",
                cid: e,
                url: t.url.toJSON(),
                routing: t.routing
            }));
        }
    }
    function OG(n, e) {
        return new RG(n, e);
    }
    class $G {
        name = "trustless-gateway";
        allowInsecure;
        allowLocal;
        transformRequestInit;
        routing;
        log;
        logger;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("helia:trustless-gateway-block-broker"), this.logger = e.logger, this.routing = e.routing, this.allowInsecure = t.allowInsecure ?? A_, this.allowLocal = t.allowLocal ?? S_, this.transformRequestInit = t.transformRequestInit;
        }
        async retrieve(e, t = {}) {
            const r = [];
            for await (const s of v_(e, this.routing, this.logger, this.allowInsecure, this.allowLocal, {
                ...t,
                transformRequestInit: this.transformRequestInit
            })){
                this.log("getting block for %c from %s", e, s.url);
                try {
                    const i = await s.getRawBlock(e, t);
                    this.log.trace("got block for %c from %s", e, s.url);
                    try {
                        await t.validateFn?.(i);
                    } catch (l) {
                        this.log.error("failed to validate block for %c from %s - %e", e, s.url, l);
                        continue;
                    }
                    return i;
                } catch (i) {
                    if (this.log.error("failed to get block for %c from %s - %e", e, s.url, i), i instanceof Error ? r.push(i) : r.push(new Error(`Unable to fetch raw block for CID ${e} from gateway ${s.url}`)), t.signal?.aborted === !0) {
                        this.log.trace("request aborted while fetching raw block for CID %c from gateway %s", e, s.url);
                        break;
                    }
                }
            }
            throw r.length > 0 ? new AggregateError(r, `Unable to fetch raw block for CID ${e} from any gateway`) : new Error(`Unable to fetch raw block for CID ${e} from any gateway`);
        }
        createSession(e = {}) {
            return OG({
                logger: this.logger,
                routing: this.routing
            }, {
                ...e,
                allowLocal: this.allowLocal,
                allowInsecure: this.allowInsecure,
                transformRequestInit: this.transformRequestInit
            });
        }
    }
    const A_ = !1, S_ = !1, MG = 2097152;
    function NG(n = {}) {
        return (e)=>new $G(e, n);
    }
    const LG = Symbol.for("@libp2p/content-routing");
    let I_ = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, _c = class extends Error {
        static name = "NotFoundError";
        constructor(e = "Not found"){
            super(e), this.name = "NotFoundError";
        }
    }, UG = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, zG = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const s8 = Symbol.for("@libp2p/peer-id");
    function FG(n) {
        return !!n?.[s8];
    }
    const VG = Symbol.for("@libp2p/peer-routing"), C_ = Symbol.for("nodejs.util.inspect.custom"), HG = 114;
    let i8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [s8] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(HG, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [C_]() {
            return `PeerId(${this.toString()})`;
        }
    }, QG = class extends i8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, qG = class extends i8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, KG = class extends i8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const GG = 2336;
    let T_ = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [C_]() {
            return `PeerId(${this.url})`;
        }
        [s8] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(GG, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const YG = 114, $v = 2336;
    function WG(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return jG(ge.parse(n));
            throw new I_('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return o8(t);
    }
    function o8(n) {
        if (JG(n)) return new QG({
            multihash: n
        });
        if (XG(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new qG({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new KG({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new T_(new URL(t));
        }
        throw new zG("Supplied PeerID Multihash is invalid");
    }
    function jG(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== YG && n.code !== $v) throw new UG("Supplied PeerID CID is invalid");
        if (n.code === $v) {
            const e = L(n.multihash.digest);
            return new T_(new URL(e));
        }
        return o8(n.multihash);
    }
    function XG(n) {
        return n.code === nt.code;
    }
    function JG(n) {
        return n.code === Ut.code;
    }
    let cs = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, nf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, ZG = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, eY = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const tY = 4, nY = 6, rY = 273, sY = 33, iY = 41, oY = 42, aY = 43, lY = 53, cY = 54, uY = 55, hY = 56, dY = 132, fY = 301, pY = 302, gY = 400, mY = 421, yY = 444, wY = 445, bY = 446, vY = 447, EY = 448, AY = 449, SY = 454, IY = 460, CY = 461, TY = 465, _Y = 466, xY = 480, DY = 481, BY = 443, PY = 477, kY = 478, RY = 479, OY = 277, $Y = 275, MY = 276, NY = 280, LY = 281, UY = 290, zY = 777;
    function Mv(n) {
        return (e)=>L(e, n);
    }
    function Nv(n) {
        return (e)=>re(e, n);
    }
    function zh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function Zl(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function FY(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = Zl(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function VY(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = Zl(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Lv(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = zh(t);
        return `${r}:${s}`;
    }
    const __ = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new cs("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, HY = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = __(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new cs("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, QY = function(n) {
        if (n.byteLength !== 4) throw new cs("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, qY = function(n) {
        if (n.byteLength !== 16) throw new cs("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new cs(`Invalid IPv6 address "${t}"`);
        }
    };
    function KY(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new cs(`Invalid IPv6 address "${n}"`);
        }
    }
    const R3 = Object.values(un).map((n)=>n.decoder), GY = (function() {
        let n = R3[0].or(R3[1]);
        return R3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function YY(n) {
        return GY.decode(n);
    }
    function WY(n) {
        return (e)=>n.encoder.encode(e);
    }
    function jY(n) {
        if (parseInt(n).toString() !== n) throw new nf("Value must be an integer");
    }
    function XY(n) {
        if (n < 0) throw new nf("Value must be a positive integer, or zero");
    }
    function JY(n) {
        return (e)=>{
            if (e > n) throw new nf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function ZY(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const v0 = ZY(jY, XY, JY(65535)), kn = -1;
    let eW = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new eY(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const lu = new eW, tW = [
        {
            code: tY,
            name: "ip4",
            size: 32,
            valueToBytes: __,
            bytesToValue: QY,
            validate: (n)=>{
                if (!Je(n)) throw new nf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: nY,
            name: "tcp",
            size: 16,
            valueToBytes: Zl,
            bytesToValue: zh,
            validate: v0
        },
        {
            code: rY,
            name: "udp",
            size: 16,
            valueToBytes: Zl,
            bytesToValue: zh,
            validate: v0
        },
        {
            code: sY,
            name: "dccp",
            size: 16,
            valueToBytes: Zl,
            bytesToValue: zh,
            validate: v0
        },
        {
            code: iY,
            name: "ip6",
            size: 128,
            valueToBytes: HY,
            bytesToValue: qY,
            stringToValue: KY,
            validate: (n)=>{
                if (!xn(n)) throw new nf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: oY,
            name: "ip6zone",
            size: kn
        },
        {
            code: aY,
            name: "ipcidr",
            size: 8,
            bytesToValue: Mv("base10"),
            valueToBytes: Nv("base10")
        },
        {
            code: lY,
            name: "dns",
            size: kn
        },
        {
            code: cY,
            name: "dns4",
            size: kn
        },
        {
            code: uY,
            name: "dns6",
            size: kn
        },
        {
            code: hY,
            name: "dnsaddr",
            size: kn
        },
        {
            code: dY,
            name: "sctp",
            size: 16,
            valueToBytes: Zl,
            bytesToValue: zh,
            validate: v0
        },
        {
            code: fY,
            name: "udt"
        },
        {
            code: pY,
            name: "utp"
        },
        {
            code: gY,
            name: "unix",
            size: kn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: mY,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: kn,
            bytesToValue: Mv("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? Nv("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: yY,
            name: "onion",
            size: 96,
            bytesToValue: Lv,
            valueToBytes: FY
        },
        {
            code: wY,
            name: "onion3",
            size: 296,
            bytesToValue: Lv,
            valueToBytes: VY
        },
        {
            code: bY,
            name: "garlic64",
            size: kn
        },
        {
            code: vY,
            name: "garlic32",
            size: kn
        },
        {
            code: EY,
            name: "tls"
        },
        {
            code: AY,
            name: "sni",
            size: kn
        },
        {
            code: SY,
            name: "noise"
        },
        {
            code: IY,
            name: "quic"
        },
        {
            code: CY,
            name: "quic-v1"
        },
        {
            code: TY,
            name: "webtransport"
        },
        {
            code: _Y,
            name: "certhash",
            size: kn,
            bytesToValue: WY(yn),
            valueToBytes: YY
        },
        {
            code: xY,
            name: "http"
        },
        {
            code: DY,
            name: "http-path",
            size: kn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: BY,
            name: "https"
        },
        {
            code: PY,
            name: "ws"
        },
        {
            code: kY,
            name: "wss"
        },
        {
            code: RY,
            name: "p2p-websocket-star"
        },
        {
            code: OY,
            name: "p2p-stardust"
        },
        {
            code: $Y,
            name: "p2p-webrtc-star"
        },
        {
            code: MY,
            name: "p2p-webrtc-direct"
        },
        {
            code: NY,
            name: "webrtc-direct"
        },
        {
            code: LY,
            name: "webrtc"
        },
        {
            code: UY,
            name: "p2p-circuit"
        },
        {
            code: zY,
            name: "memory",
            size: kn
        }
    ];
    tW.forEach((n)=>{
        lu.addProtocol(n);
    });
    function nW(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = lu.getProtocol(r), i = be(r), l = oW(s, n, t + i);
            let u = 0;
            l > 0 && s.size === kn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function rW(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = lu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === kn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === kn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function sW(n) {
        if (n.charAt(0) !== "/") throw new cs('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = lu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new cs(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new cs(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new cs("Incomplete multiaddr");
        return e;
    }
    function iW(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = lu.getProtocol(e.code);
            if (t == null) throw new cs(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function oW(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const aW = Symbol.for("nodejs.util.inspect.custom"), x_ = Symbol.for("@multiformats/multiaddr");
    function lW(n) {
        if (n == null && (n = "/"), hW(n)) return n.getComponents();
        if (n instanceof Uint8Array) return nW(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), sW(n);
        if (Array.isArray(n)) return n;
        throw new cs("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let cW = class Fh {
        [x_] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = lW(e), t.validate !== !1 && uW(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = rW(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = iW(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new Fh(e);
            return new Fh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new ZG(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new Fh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new Fh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [aW]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function uW(n) {
        n.getComponents().forEach((e)=>{
            const t = lu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function hW(n) {
        return !!n?.[x_];
    }
    function dW(n) {
        return new cW(n);
    }
    async function* O3(n, e = {}) {
        const t = n.getReader();
        try {
            for(;;){
                const r = await t.read();
                if (r.done) return;
                yield r.value;
            }
        } finally{
            e.preventCancel !== !0 && await t.cancel(), t.releaseLock();
        }
    }
    var $3 = {
        exports: {}
    }, Uv;
    function fW() {
        return Uv || (Uv = 1, (function(n) {
            (function() {
                n.exports = I;
                var e = 86400, t = 3200, r = 146097 * t / 400, s = e * r, i = 1e3 * s, l = 864e13, u = 4294967296, h = 1e6, f = "000000000", p = Math.trunc || function(O) {
                    var se = O - O % 1;
                    return se == 0 && (O < 0 || O === 0 && 1 / O != 1 / 0) ? -0 : se;
                }, m = I.prototype, w = (I.fromDate = function(O) {
                    return new I(+O);
                }, I.fromInt64BE = H(0, 1, 2, 3, 0, 4), I.fromInt64LE = H(3, 2, 1, 0, 4, 0), I.fromString = function(oe) {
                    var se, ae = new I, oe = (oe += "").replace(/^\s*[+\-]?\d+/, function(V) {
                        var V = +V, q = 1970 + (V - 1970) % 400;
                        return ae.year = V - q, q;
                    }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(K, V, q) {
                        return V < 0 && (q *= -1), se = 6e4 * (60 * +V + +q), "";
                    }).replace(/\.\d+$/, function(K) {
                        return ae.nano = +(K + f).substr(1, 9), "";
                    }).split(/\D+/);
                    if (1 < oe.length ? oe[1]-- : oe[1] = 0, ae.time = se = Date.UTC.apply(Date, oe) - (se || 0), isNaN(se)) throw new TypeError("Invalid Date");
                    return k(ae);
                }, I.fromTimeT = function(O) {
                    return P(O, 0);
                }, m.year = 0, m.time = 0, m.nano = 0, m.addNano = function(O) {
                    return this.nano += +O || 0, this;
                }, m.getNano = function() {
                    var O = k(this);
                    return (O.time % 1e3 * h + +O.nano + 1e9) % 1e9;
                }, m.getTimeT = function() {
                    var se = k(this), O = Math.floor(se.time / 1e3), se = se.year;
                    return se && (O += se * r * e / t), O;
                }, m.getYear = function() {
                    return this.toDate().getUTCFullYear() + this.year;
                }, m.toDate = function() {
                    return G(k(this).time);
                }, m.toJSON = function() {
                    return this.toString().replace(/0{1,6}Z$/, "Z");
                }, m.toString = function(O) {
                    var se = this, ae = se.toDate(), oe = {
                        H: function() {
                            return $(ae.getUTCHours());
                        },
                        L: function() {
                            return Y(ae.getUTCMilliseconds(), 3);
                        },
                        M: function() {
                            return $(ae.getUTCMinutes());
                        },
                        N: function() {
                            return Y(se.getNano(), 9);
                        },
                        S: function() {
                            return $(ae.getUTCSeconds());
                        },
                        Y: function() {
                            var K = se.getYear();
                            return 999999 < K ? "+" + K : 9999 < K ? "+" + Y(K, 6) : 0 <= K ? Y(K, 4) : -999999 <= K ? "-" + Y(-K, 6) : K;
                        },
                        a: function() {
                            return S[ae.getUTCDay()];
                        },
                        b: function() {
                            return A[ae.getUTCMonth()];
                        },
                        d: function() {
                            return $(ae.getUTCDate());
                        },
                        e: function() {
                            return (function(K) {
                                return (9 < K ? "" : " ") + (0 | K);
                            })(ae.getUTCDate());
                        },
                        m: function() {
                            return $(ae.getUTCMonth() + 1);
                        }
                    };
                    return (function K(V) {
                        return V.replace(/%./g, function(q) {
                            var z = q[1], B = _[z], z = oe[z];
                            return B ? K(B) : z ? z() : q;
                        });
                    })(O || w);
                }, m.writeInt64BE = J(0, 1, 2, 3, 0, 4), m.writeInt64LE = J(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), A = [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec"
                ], S = [
                    "Sun",
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat"
                ], _ = {
                    "%": "%",
                    F: "%Y-%m-%d",
                    n: `
`,
                    R: "%H:%M",
                    T: "%H:%M:%S",
                    t: "	",
                    X: "%T",
                    Z: "GMT",
                    z: "+0000"
                };
                return I;
                function I(O, se, ae) {
                    var oe = this;
                    if (!(oe instanceof I)) return new I(O, se, ae);
                    oe.time = +O || 0, oe.nano = +se || 0, oe.year = +ae || 0, k(oe);
                }
                function k(O) {
                    var se, ae, oe, K = O.year, V = O.time, q = O.nano, B = ((q < 0 || h <= q) && (q -= (ae = Math.floor(q / h)) * h, V += ae, ae = 1), K % t);
                    return (V < -l || l < V || B) && ((se = p(V / i)) && (K += se * t, V -= se * i), (oe = G(V)).setUTCFullYear(B + oe.getUTCFullYear()), oe = (V = +oe) + (se = p((K -= B) / t)) * i, se && -l <= oe && oe <= l && (K -= se * t, V = oe), ae = 1), ae && (O.year = K, O.time = V, O.nano = q), O;
                }
                function G(O) {
                    var se = new Date(0);
                    return se.setTime(O), se;
                }
                function P(K, oe) {
                    K = +K || 0;
                    var ae = p((oe = (oe | 0) * u) / s) + p(K / s), oe = oe % s + K % s, K = p(oe / s);
                    return K && (ae += K, oe -= K * s), new I(1e3 * oe, 0, ae * t);
                }
                function J(O, se, ae, oe, K, V) {
                    return function(B, z) {
                        var j = k(this);
                        B = B || new Array(8), F(B, z |= 0);
                        var ce = Math.floor(j.time / 1e3), j = j.year * (r * e / t), ee = p(j / u) + p(ce / u), j = j % u + ce % u, ce = Math.floor(j / u);
                        return ce && (ee += ce, j -= ce * u), q(B, z + K, ee), q(B, z + V, j), B;
                    };
                    function q(B, z, ee) {
                        B[z + O] = ee >> 24 & 255, B[z + se] = ee >> 16 & 255, B[z + ae] = ee >> 8 & 255, B[z + oe] = 255 & ee;
                    }
                }
                function H(O, se, ae, oe, K, V) {
                    return function(B, z) {
                        F(B, z |= 0);
                        var ee = q(B, z + K);
                        return P(q(B, z + V), ee);
                    };
                    function q(B, z) {
                        return 16777216 * B[z + O] + (B[z + se] << 16 | B[z + ae] << 8 | B[z + oe]);
                    }
                }
                function F(O, se) {
                    if (O = O && O.length, O == null) throw new TypeError("Invalid Buffer");
                    if (O < se + 8) throw new RangeError("Out of range");
                }
                function $(O) {
                    return (9 < O ? "" : "0") + (0 | O);
                }
                function Y(O, se) {
                    return (f + (0 | O)).substr(-se);
                }
            })();
        })($3)), $3.exports;
    }
    var pW = fW();
    const n4 = Zc(pW);
    class Ca extends Error {
        static name = "SignatureVerificationError";
        constructor(e = "Record signature verification failed"){
            super(e), this.name = "SignatureVerificationError";
        }
    }
    class gW extends Error {
        static name = "RecordExpiredError";
        constructor(e = "Record has expired"){
            super(e), this.name = "RecordExpiredError";
        }
    }
    class D_ extends Error {
        static name = "UnsupportedValidityError";
        constructor(e = "The validity type is unsupported"){
            super(e), this.name = "UnsupportedValidityError";
        }
    }
    class mW extends Error {
        static name = "RecordTooLargeError";
        constructor(e = "The record is too large"){
            super(e), this.name = "RecordTooLargeError";
        }
    }
    class yW extends Error {
        static name = "InvalidValueError";
        constructor(e = "Value must be a valid content path starting with /"){
            super(e), this.name = "InvalidValueError";
        }
    }
    class wW extends Error {
        static name = "InvalidRecordDataError";
        constructor(e = "Invalid record data"){
            super(e), this.name = "InvalidRecordDataError";
        }
    }
    class zv extends Error {
        static name = "InvalidEmbeddedPublicKeyError";
        constructor(e = "Invalid embedded public key"){
            super(e), this.name = "InvalidEmbeddedPublicKeyError";
        }
    }
    var Fs;
    (function(n) {
        (function(r) {
            r.EOL = "EOL";
        })(n.ValidityType || (n.ValidityType = {}));
        let e;
        (function(r) {
            r[r.EOL = 0] = "EOL";
        })(e || (e = {})), (function(r) {
            r.codec = ()=>vr(e);
        })(n.ValidityType || (n.ValidityType = {}));
        let t;
        n.codec = ()=>(t == null && (t = Le((r, s, i = {})=>{
                i.lengthDelimited !== !1 && s.fork(), r.value != null && (s.uint32(10), s.bytes(r.value)), r.signatureV1 != null && (s.uint32(18), s.bytes(r.signatureV1)), r.validityType != null && (s.uint32(24), n.ValidityType.codec().encode(r.validityType, s)), r.validity != null && (s.uint32(34), s.bytes(r.validity)), r.sequence != null && (s.uint32(40), s.uint64(r.sequence)), r.ttl != null && (s.uint32(48), s.uint64(r.ttl)), r.pubKey != null && (s.uint32(58), s.bytes(r.pubKey)), r.signatureV2 != null && (s.uint32(66), s.bytes(r.signatureV2)), r.data != null && (s.uint32(74), s.bytes(r.data)), i.lengthDelimited !== !1 && s.ldelim();
            }, (r, s, i = {})=>{
                const l = {}, u = s == null ? r.len : r.pos + s;
                for(; r.pos < u;){
                    const h = r.uint32();
                    switch(h >>> 3){
                        case 1:
                            {
                                l.value = r.bytes();
                                break;
                            }
                        case 2:
                            {
                                l.signatureV1 = r.bytes();
                                break;
                            }
                        case 3:
                            {
                                l.validityType = n.ValidityType.codec().decode(r);
                                break;
                            }
                        case 4:
                            {
                                l.validity = r.bytes();
                                break;
                            }
                        case 5:
                            {
                                l.sequence = r.uint64();
                                break;
                            }
                        case 6:
                            {
                                l.ttl = r.uint64();
                                break;
                            }
                        case 7:
                            {
                                l.pubKey = r.bytes();
                                break;
                            }
                        case 8:
                            {
                                l.signatureV2 = r.bytes();
                                break;
                            }
                        case 9:
                            {
                                l.data = r.bytes();
                                break;
                            }
                        default:
                            {
                                r.skipType(h & 7);
                                break;
                            }
                    }
                }
                return l;
            })), t), n.encode = (r)=>Ne(r, n.codec()), n.decode = (r, s)=>Me(r, n.codec(), s);
    })(Fs || (Fs = {}));
    let bW = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const vW = ou("ipns:utils"), B_ = re("/ipns/"), EW = 0, AW = 18;
    function SW(n) {
        let e;
        if (n.pubKey != null) try {
            e = Er(n.pubKey);
        } catch (t) {
            throw vW.error(t), t;
        }
        if (e != null) return e;
    }
    function IW(n) {
        const e = re("ipns-signature:");
        return xe([
            e,
            n
        ]);
    }
    function P_(n) {
        return "signatureV1" in n ? Fs.encode({
            value: re(n.value),
            signatureV1: n.signatureV1,
            validityType: n.validityType,
            validity: re(n.validity),
            sequence: n.sequence,
            ttl: n.ttl,
            pubKey: n.pubKey,
            signatureV2: n.signatureV2,
            data: n.data
        }) : Fs.encode({
            pubKey: n.pubKey,
            signatureV2: n.signatureV2,
            data: n.data
        });
    }
    function Of(n) {
        const e = Fs.decode(n);
        if (e.sequence != null && (e.sequence = BigInt(e.sequence)), e.ttl != null && (e.ttl = BigInt(e.ttl)), e.signatureV2 == null || e.data == null) throw new Ca("Missing data or signatureV2");
        const t = R_(e.data), r = CW(t.Value), s = L(t.Validity);
        if (e.value != null && e.signatureV1 != null) return TW(e), {
            value: r,
            validityType: Fs.ValidityType.EOL,
            validity: s,
            sequence: t.Sequence,
            ttl: t.TTL,
            pubKey: e.pubKey,
            signatureV1: e.signatureV1,
            signatureV2: e.signatureV2,
            data: e.data
        };
        if (e.signatureV2 != null) return {
            value: r,
            validityType: Fs.ValidityType.EOL,
            validity: s,
            sequence: t.Sequence,
            ttl: t.TTL,
            pubKey: e.pubKey,
            signatureV2: e.signatureV2,
            data: e.data
        };
        throw new Error("invalid record: does not include signatureV1 or signatureV2");
    }
    function k_(n) {
        return xe([
            B_,
            n.bytes
        ]);
    }
    function r4(n) {
        const e = kt(n.slice(B_.length));
        if (!s4(e, EW) && !s4(e, AW)) throw new bW("Multihash in IPNS key was not identity or sha2-256");
        return e;
    }
    function R_(n) {
        const e = Ro(n);
        if (e.ValidityType === 0) e.ValidityType = Fs.ValidityType.EOL;
        else throw new D_("The validity type is unsupported");
        return Number.isInteger(e.Sequence) && (e.Sequence = BigInt(e.Sequence)), Number.isInteger(e.TTL) && (e.TTL = BigInt(e.TTL)), e;
    }
    function CW(n) {
        const e = L(n).trim();
        if (e.startsWith("/")) return e;
        try {
            return `/ipfs/${ge.decode(n).toV1().toString()}`;
        } catch  {}
        try {
            return `/ipfs/${ge.parse(e).toV1().toString()}`;
        } catch  {}
        throw new yW("Value must be a valid content path starting with /");
    }
    function TW(n) {
        if (n.data == null) throw new wW("Record data is missing");
        const e = R_(n.data);
        if (!Ee(e.Value, n.value ?? new Uint8Array(0))) throw new Ca('Field "value" did not match between protobuf and CBOR');
        if (!Ee(e.Validity, n.validity ?? new Uint8Array(0))) throw new Ca('Field "validity" did not match between protobuf and CBOR');
        if (e.ValidityType !== n.validityType) throw new Ca('Field "validityType" did not match between protobuf and CBOR');
        if (e.Sequence !== n.sequence) throw new Ca('Field "sequence" did not match between protobuf and CBOR');
        if (e.TTL !== n.ttl) throw new Ca('Field "ttl" did not match between protobuf and CBOR');
    }
    function s4(n, e) {
        return n.code === e;
    }
    const E0 = ou("ipns:validator"), _W = 1024 * 10;
    async function xW(n, e) {
        const t = Of(e);
        let r;
        try {
            const s = IW(t.data);
            r = await n.verify(s, t.signatureV2);
        } catch  {
            r = !1;
        }
        if (!r) throw E0.error("record signature verification failed"), new Ca("Record signature verification failed");
        if (t.validityType === Fs.ValidityType.EOL) {
            if (n4.fromString(t.validity).toDate().getTime() < Date.now()) throw E0.error("record has expired"), new gW("record has expired");
        } else if (t.validityType != null) throw E0.error("the validity type is unsupported"), new D_("The validity type is unsupported");
        E0("ipns record for %s is valid", t.value);
    }
    async function O_(n, e) {
        if (e.byteLength > _W) throw new mW("The record is too large");
        const t = r4(n);
        let r;
        s4(t, 0) && (r = ir(t));
        const s = Of(e), i = SW(s) ?? r;
        if (i == null) throw new zv("Could not extract public key from IPNS record or routing key");
        const l = k_(i.toMultihash());
        if (!Ee(l, n)) throw new zv("Embedded public key did not match routing key");
        await xW(i, e);
    }
    let DW = class extends Error {
        name = "InvalidMessageLengthError";
        code = "ERR_INVALID_MESSAGE_LENGTH";
    };
    async function* M3(n, e = {}) {
        const t = /\r?\n/, r = new TextDecoder("utf8");
        let s = "";
        for await (let i of n){
            if (typeof i == "string" && (i = new TextEncoder().encode(i)), Oh(i) && (i = i.subarray()), s += r.decode(i, {
                stream: !0
            }), s.length > (e?.maxMessageLength ?? s.length)) throw new DW("Incoming message too long");
            const l = s.split(t);
            s = l.pop() ?? "";
            for(let u = 0; u < l.length; u++)yield JSON.parse(l[u]);
        }
        s += r.decode(), s !== "" && (yield JSON.parse(s));
    }
    function BW(n, e, t) {
        let r = 0, s = n.length;
        for(; s > 0;){
            const i = Math.trunc(s / 2);
            let l = r + i;
            t(n[l], e) <= 0 ? (r = ++l, s -= i + 1) : s = i;
        }
        return r;
    }
    class PW {
        #e = [];
        enqueue(e, t) {
            const { priority: r = 0, id: s } = t ?? {}, i = {
                priority: r,
                id: s,
                run: e
            };
            if (this.size === 0 || this.#e[this.size - 1].priority >= r) {
                this.#e.push(i);
                return;
            }
            const l = BW(this.#e, i, (u, h)=>h.priority - u.priority);
            this.#e.splice(l, 0, i);
        }
        setPriority(e, t) {
            const r = this.#e.findIndex((i)=>i.id === e);
            if (r === -1) throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);
            const [s] = this.#e.splice(r, 1);
            this.enqueue(s.run, {
                priority: t,
                id: e
            });
        }
        dequeue() {
            return this.#e.shift()?.run;
        }
        filter(e) {
            return this.#e.filter((t)=>t.priority === e.priority).map((t)=>t.run);
        }
        get size() {
            return this.#e.length;
        }
    }
    class kW extends JS {
        #e;
        #t;
        #n = 0;
        #l;
        #h = !1;
        #m = !1;
        #c;
        #T = 0;
        #b = 0;
        #u;
        #d;
        #a;
        #o = [];
        #i = 0;
        #r;
        #_;
        #s = 0;
        #y;
        #f;
        #k = 1n;
        #w = new Map;
        timeout;
        constructor(e){
            if (super(), e = {
                carryoverIntervalCount: !1,
                intervalCap: Number.POSITIVE_INFINITY,
                interval: 0,
                concurrency: Number.POSITIVE_INFINITY,
                autoStart: !0,
                queueClass: PW,
                strict: !1,
                ...e
            }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString() ?? ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString() ?? ""}\` (${typeof e.interval})`);
            if (e.strict && e.interval === 0) throw new TypeError("The `strict` option requires a non-zero `interval`");
            if (e.strict && e.intervalCap === Number.POSITIVE_INFINITY) throw new TypeError("The `strict` option requires a finite `intervalCap`");
            if (this.#e = e.carryoverIntervalCount ?? e.carryoverConcurrencyCount ?? !1, this.#t = e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, this.#l = e.intervalCap, this.#c = e.interval, this.#a = e.strict, this.#r = new e.queueClass, this.#_ = e.queueClass, this.concurrency = e.concurrency, e.timeout !== void 0 && !(Number.isFinite(e.timeout) && e.timeout > 0)) throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${e.timeout}\` (${typeof e.timeout})`);
            this.timeout = e.timeout, this.#f = e.autoStart === !1, this.#z();
        }
        #v(e) {
            for(; this.#i < this.#o.length;){
                const r = this.#o[this.#i];
                if (r !== void 0 && e - r >= this.#c) this.#i++;
                else break;
            }
            (this.#i > 100 && this.#i > this.#o.length / 2 || this.#i === this.#o.length) && (this.#o = this.#o.slice(this.#i), this.#i = 0);
        }
        #R(e) {
            this.#a ? this.#o.push(e) : this.#n++;
        }
        #O() {
            this.#a ? this.#o.length > this.#i && this.#o.pop() : this.#n > 0 && this.#n--;
        }
        #E() {
            return this.#o.length - this.#i;
        }
        get #$() {
            return this.#t ? !0 : this.#a ? this.#E() < this.#l : this.#n < this.#l;
        }
        get #M() {
            return this.#s < this.#y;
        }
        #N() {
            this.#s--, this.#s === 0 && this.emit("pendingZero"), this.#I(), this.emit("next");
        }
        #L() {
            this.#d = void 0, this.#B(), this.#D();
        }
        #U(e) {
            if (this.#a) {
                if (this.#v(e), this.#E() >= this.#l) {
                    const r = this.#o[this.#i], s = this.#c - (e - r);
                    return this.#A(s), !0;
                }
                return !1;
            }
            if (this.#u === void 0) {
                const t = this.#T - e;
                if (t < 0) {
                    if (this.#b > 0) {
                        const r = e - this.#b;
                        if (r < this.#c) return this.#A(this.#c - r), !0;
                    }
                    this.#n = this.#e ? this.#s : 0;
                } else return this.#A(t), !0;
            }
            return !1;
        }
        #A(e) {
            this.#d === void 0 && (this.#d = setTimeout(()=>{
                this.#L();
            }, e));
        }
        #S() {
            this.#u && (clearInterval(this.#u), this.#u = void 0);
        }
        #x() {
            this.#d && (clearTimeout(this.#d), this.#d = void 0);
        }
        #I() {
            if (this.#r.size === 0) {
                if (this.#S(), this.emit("empty"), this.#s === 0) {
                    if (this.#x(), this.#a && this.#i > 0) {
                        const t = Date.now();
                        this.#v(t);
                    }
                    this.emit("idle");
                }
                return !1;
            }
            let e = !1;
            if (!this.#f) {
                const t = Date.now(), r = !this.#U(t);
                if (this.#$ && this.#M) {
                    const s = this.#r.dequeue();
                    this.#t || (this.#R(t), this.#g()), this.emit("active"), s(), r && this.#D(), e = !0;
                }
            }
            return e;
        }
        #D() {
            this.#t || this.#u !== void 0 || this.#a || (this.#u = setInterval(()=>{
                this.#B();
            }, this.#c), this.#T = Date.now() + this.#c);
        }
        #B() {
            this.#a || (this.#n === 0 && this.#s === 0 && this.#u && this.#S(), this.#n = this.#e ? this.#s : 0), this.#C(), this.#g();
        }
        #C() {
            for(; this.#I(););
        }
        get concurrency() {
            return this.#y;
        }
        set concurrency(e) {
            if (!(typeof e == "number" && e >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            this.#y = e, this.#C();
        }
        setPriority(e, t) {
            if (typeof t != "number" || !Number.isFinite(t)) throw new TypeError(`Expected \`priority\` to be a finite number, got \`${t}\` (${typeof t})`);
            this.#r.setPriority(e, t);
        }
        async add(e, t = {}) {
            return t = {
                timeout: this.timeout,
                ...t,
                id: t.id ?? (this.#k++).toString()
            }, new Promise((r, s)=>{
                const i = Symbol(`task-${t.id}`);
                this.#r.enqueue(async ()=>{
                    this.#s++, this.#w.set(i, {
                        id: t.id,
                        priority: t.priority ?? 0,
                        startTime: Date.now(),
                        timeout: t.timeout
                    });
                    let l;
                    try {
                        try {
                            t.signal?.throwIfAborted();
                        } catch (f) {
                            throw this.#F(), this.#w.delete(i), f;
                        }
                        this.#b = Date.now();
                        let u = e({
                            signal: t.signal
                        });
                        if (t.timeout && (u = j4(Promise.resolve(u), {
                            milliseconds: t.timeout,
                            message: `Task timed out after ${t.timeout}ms (queue has ${this.#s} running, ${this.#r.size} waiting)`
                        })), t.signal) {
                            const { signal: f } = t;
                            u = Promise.race([
                                u,
                                new Promise((p, m)=>{
                                    l = ()=>{
                                        m(f.reason);
                                    }, f.addEventListener("abort", l, {
                                        once: !0
                                    });
                                })
                            ]);
                        }
                        const h = await u;
                        r(h), this.emit("completed", h);
                    } catch (u) {
                        s(u), this.emit("error", u);
                    } finally{
                        l && t.signal?.removeEventListener("abort", l), this.#w.delete(i), queueMicrotask(()=>{
                            this.#N();
                        });
                    }
                }, t), this.emit("add"), this.#I();
            });
        }
        async addAll(e, t) {
            return Promise.all(e.map(async (r)=>this.add(r, t)));
        }
        start() {
            return this.#f ? (this.#f = !1, this.#C(), this) : this;
        }
        pause() {
            this.#f = !0;
        }
        clear() {
            this.#r = new this.#_, this.#S(), this.#P(), this.emit("empty"), this.#s === 0 && (this.#x(), this.emit("idle")), this.emit("next");
        }
        async onEmpty() {
            this.#r.size !== 0 && await this.#p("empty");
        }
        async onSizeLessThan(e) {
            this.#r.size < e || await this.#p("next", ()=>this.#r.size < e);
        }
        async onIdle() {
            this.#s === 0 && this.#r.size === 0 || await this.#p("idle");
        }
        async onPendingZero() {
            this.#s !== 0 && await this.#p("pendingZero");
        }
        async onRateLimit() {
            this.isRateLimited || await this.#p("rateLimit");
        }
        async onRateLimitCleared() {
            this.isRateLimited && await this.#p("rateLimitCleared");
        }
        onError() {
            return new Promise((e, t)=>{
                const r = (s)=>{
                    this.off("error", r), t(s);
                };
                this.on("error", r);
            });
        }
        async #p(e, t) {
            return new Promise((r)=>{
                const s = ()=>{
                    t && !t() || (this.off(e, s), r());
                };
                this.on(e, s);
            });
        }
        get size() {
            return this.#r.size;
        }
        sizeBy(e) {
            return this.#r.filter(e).length;
        }
        get pending() {
            return this.#s;
        }
        get isPaused() {
            return this.#f;
        }
        #z() {
            this.#t || (this.on("add", ()=>{
                this.#r.size > 0 && this.#g();
            }), this.on("next", ()=>{
                this.#g();
            }));
        }
        #g() {
            this.#t || this.#m || (this.#m = !0, queueMicrotask(()=>{
                this.#m = !1, this.#P();
            }));
        }
        #F() {
            this.#t || (this.#O(), this.#g());
        }
        #P() {
            const e = this.#h;
            if (this.#t || this.#r.size === 0) {
                e && (this.#h = !1, this.emit("rateLimitCleared"));
                return;
            }
            let t;
            if (this.#a) {
                const s = Date.now();
                this.#v(s), t = this.#E();
            } else t = this.#n;
            const r = t >= this.#l;
            r !== e && (this.#h = r, this.emit(r ? "rateLimit" : "rateLimitCleared"));
        }
        get isRateLimited() {
            return this.#h;
        }
        get isSaturated() {
            return this.#s === this.#y && this.#r.size > 0 || this.isRateLimited && this.#r.size > 0;
        }
        get runningTasks() {
            return [
                ...this.#w.values()
            ].map((e)=>({
                    ...e
                }));
        }
    }
    class A0 extends Error {
        static name = "InvalidRequestError";
        constructor(e = "Invalid request"){
            super(e), this.name = "InvalidRequestError";
        }
    }
    class Li extends Error {
        static name = "BadResponseError";
        constructor(e = "Bad response"){
            super(e), this.name = "BadResponseError";
        }
    }
    function RW(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function OW(n) {
        if (RW(n)) return (async ()=>{
            for await (const e of n)return e;
        })();
        for (const e of n)return e;
    }
    const Fv = re("/ipns/");
    function Vv(n) {
        return Ee(n.subarray(0, Fv.byteLength), Fv);
    }
    class $W {
        client;
        constructor(e){
            this.client = e;
        }
        async *findProviders(e, t = {}) {
            try {
                yield* kf(this.client.getProviders(e, t), (r)=>({
                        id: r.ID,
                        multiaddrs: r.Addrs ?? [],
                        routing: "delegated-http-routing-v1"
                    }));
            } catch (r) {
                if (r instanceof _c) return;
                throw r;
            }
        }
        async provide() {}
        async cancelReprovide() {}
        async put(e, t, r) {
            if (!Vv(e)) return;
            const s = r4(e), i = ge.createV1(114, s), l = Of(t);
            await this.client.putIPNS(i, l, r);
        }
        async get(e, t) {
            if (!Vv(e)) throw new _c("Not found");
            const r = r4(e), s = ge.createV1(114, r);
            try {
                const i = await this.client.getIPNS(s, t);
                return P_(i);
            } catch (i) {
                throw i.name === "BadResponseError" ? new _c("Not found") : i;
            }
        }
        toString() {
            return `DelegatedRoutingV1HttpApiClientContentRouting(${this.client.url})`;
        }
    }
    class MW {
        client;
        constructor(e){
            this.client = e;
        }
        async findPeer(e, t = {}) {
            const r = await OW(this.client.getPeers(e, t));
            if (r != null) return {
                id: r.ID,
                multiaddrs: r.Addrs ?? []
            };
            throw new _c("Not found");
        }
        async *getClosestPeers(e, t = {}) {
            let r;
            try {
                r = ge.decode(e);
            } catch  {
                try {
                    r = o8(kt(e));
                } catch  {
                    r = ge.createV1(Af, nt.digest(e));
                }
            }
            for await (const s of this.client.getClosestPeers(r, t))yield {
                id: s.ID,
                multiaddrs: s.Addrs ?? []
            };
        }
        toString() {
            return `DelegatedRoutingV1HttpApiClientPeerRouting(${this.client.url})`;
        }
    }
    const S0 = {
        concurrentRequests: 4,
        timeout: 3e4,
        cacheTTL: 300 * 1e3,
        cacheName: "delegated-routing-v1-cache"
    };
    class NW {
        url;
        started;
        httpQueue;
        shutDownController;
        timeout;
        contentRouting;
        peerRouting;
        filterAddrs;
        filterProtocols;
        inFlightRequests;
        cacheName;
        cache;
        cacheTTL;
        log;
        constructor(e, t){
            this.log = e.logger.forComponent("delegated-routing-v1-http-api-client"), this.started = !1, this.shutDownController = new AbortController, this.shutDownController.signal, this.httpQueue = new kW({
                concurrency: t.concurrentRequests ?? S0.concurrentRequests
            }), this.inFlightRequests = new Map, this.url = t.url instanceof URL ? t.url : new URL(t.url), this.timeout = t.timeout ?? S0.timeout, this.filterAddrs = t.filterAddrs, this.filterProtocols = t.filterProtocols, this.contentRouting = new $W(this), this.peerRouting = new MW(this), this.cacheName = t.cacheName ?? S0.cacheName, this.cacheTTL = t.cacheTTL ?? S0.cacheTTL;
        }
        get [LG]() {
            return this.contentRouting;
        }
        get [VG]() {
            return this.peerRouting;
        }
        isStarted() {
            return this.started;
        }
        async start() {
            this.started || (this.started = !0, this.cacheTTL > 0 && (this.cache = await globalThis.caches?.open(this.cacheName), this.cache != null && this.log("cache enabled with ttl %d", this.cacheTTL)));
        }
        async stop() {
            this.httpQueue.clear(), this.shutDownController.abort(), await globalThis.caches?.delete(this.cacheName), this.started = !1;
        }
        async *getProviders(e, t = {}) {
            this.log("getProviders starts: %c", e);
            const r = AbortSignal.timeout(this.timeout), s = gt([
                this.shutDownController.signal,
                r,
                t.signal
            ]), i = xt(), l = xt();
            let u = 0;
            this.httpQueue.add(async ()=>(i.resolve(), l.promise));
            try {
                await i.promise;
                const h = new URL(`${this.url}routing/v1/providers/${e}`);
                this.#t(h, t.filterAddrs, t.filterProtocols);
                const f = {
                    headers: {
                        accept: "application/x-ndjson, application/json;q=0.8"
                    },
                    signal: s
                }, p = await this.#n(h.toString(), f);
                if (!p.ok) {
                    if (p.status === 404) return;
                    throw p.status === 422 ? new A0("Request does not conform to schema or semantic constraints") : new Li(`Unexpected status code: ${p.status}`);
                }
                const m = p.headers.get("Content-Type");
                if (m == null) throw new Li("No Content-Type header received");
                if (p.body == null) {
                    if (m !== "application/x-ndjson") throw new Li("Routing response had no body");
                    return;
                }
                if (m.startsWith("application/json")) {
                    const A = (await p.json()).Providers ?? [];
                    for (const S of A){
                        const _ = this.#e(S);
                        _ != null && (u++, yield _);
                    }
                } else if (m.includes("application/x-ndjson")) for await (const w of M3(O3(p.body))){
                    const A = this.#e(w);
                    A != null && (u++, yield A);
                }
                else throw new Li(`Unsupported Content-Type: ${m}`);
            } finally{
                s.clear(), l.resolve(), this.log("getProviders finished found %d providers for %c", u, e);
            }
        }
        async *getPeers(e, t = {}) {
            this.log("getPeers starts: %c", e);
            const r = AbortSignal.timeout(this.timeout), s = gt([
                this.shutDownController.signal,
                r,
                t.signal
            ]), i = xt(), l = xt();
            this.httpQueue.add(async ()=>(i.resolve(), l.promise));
            try {
                await i.promise;
                const u = new URL(`${this.url}routing/v1/peers/${e.toCID().toString()}`);
                this.#t(u, t.filterAddrs, t.filterProtocols);
                const h = {
                    headers: {
                        Accept: "application/x-ndjson"
                    },
                    signal: s
                }, f = await this.#n(u.toString(), h);
                if (f.status === 404) return;
                if (f.status === 422) throw new A0("Request does not conform to schema or semantic constraints");
                if (f.body == null) throw new Li("Routing response had no body");
                if (f.headers.get("Content-Type")?.startsWith("application/json")) {
                    const w = (await f.json()).Peers ?? [];
                    for (const A of w){
                        const S = this.#e(A);
                        S != null && (yield S);
                    }
                } else for await (const m of M3(O3(f.body))){
                    const w = this.#e(m);
                    w != null && (yield w);
                }
            } catch (u) {
                this.log.error("getPeers errored - %e", u);
            } finally{
                s.clear(), l.resolve(), this.log("getPeers finished: %c", e);
            }
        }
        async *getClosestPeers(e, t = {}) {
            let r;
            if (FG(e)) r = e.toCID().toString();
            else if (ge.asCID(e) === e || e instanceof ge) r = e.toV1().toString();
            else throw new I_("Key must be CID or PeerId");
            this.log("getClosestPeers starts: %s", r);
            const s = AbortSignal.timeout(this.timeout), i = gt([
                this.shutDownController.signal,
                s,
                t.signal
            ]), l = xt(), u = xt();
            this.httpQueue.add(async ()=>(l.resolve(), u.promise));
            try {
                await l.promise;
                const h = new URL(`${this.url}routing/v1/dht/closest/peers/${r}`);
                this.#t(h, t.filterAddrs, t.filterProtocols);
                const f = {
                    headers: {
                        Accept: "application/x-ndjson"
                    },
                    signal: i
                }, p = await this.#n(h.toString(), f);
                if (p.status === 404) return;
                if (p.status === 422) throw new A0("Request does not conform to schema or semantic constraints");
                if (p.body == null) throw new Li("Routing response had no body");
                if (p.headers.get("Content-Type")?.startsWith("application/json")) {
                    const A = (await p.json()).Peers ?? [];
                    for (const S of A){
                        const _ = this.#e(S);
                        _ != null && (yield _);
                    }
                } else for await (const w of M3(O3(p.body))){
                    const A = this.#e(w);
                    A != null && (yield A);
                }
            } catch (h) {
                this.log.error("getClosestPeers errored - %e", h);
            } finally{
                i.clear(), u.resolve(), this.log("getClosestPeers finished: %s", r);
            }
        }
        async getIPNS(e, t = {}) {
            this.log("getIPNS starts: %s", e);
            const r = AbortSignal.timeout(this.timeout), s = gt([
                this.shutDownController.signal,
                r,
                t.signal
            ]), i = xt(), l = xt();
            this.httpQueue.add(async ()=>(i.resolve(), l.promise));
            const u = `${this.url}routing/v1/ipns/${e}`;
            try {
                await i.promise;
                const h = {
                    headers: {
                        Accept: "application/vnd.ipfs.ipns-record"
                    },
                    signal: s
                }, f = await this.#n(u, h);
                if (this.log("getIPNS GET %s %d", u, f.status), f.status === 404) throw new _c("No matching records found");
                if (f.status === 422) throw new A0("Request does not conform to schema or semantic constraints");
                if (!f.ok) throw new Li(`Unexpected status code: ${f.status}`);
                const p = f.headers.get("Content-Type");
                if (p == null || !p.includes("application/vnd.ipfs.ipns-record")) throw new _c("No matching records found");
                if (f.body == null) throw new Li("GET ipns response had no body");
                const m = await f.arrayBuffer(), w = new Uint8Array(m, 0, m.byteLength);
                return t.validate !== !1 && await O_(k_(e.multihash), w), Of(w);
            } catch (h) {
                throw this.log.error("getIPNS GET %s error - %e", u, h), h;
            } finally{
                s.clear(), l.resolve(), this.log("getIPNS finished: %s", e);
            }
        }
        async putIPNS(e, t, r = {}) {
            this.log("putIPNS starts: %c", e);
            const s = AbortSignal.timeout(this.timeout), i = gt([
                this.shutDownController.signal,
                s,
                r.signal
            ]), l = xt(), u = xt();
            this.httpQueue.add(async ()=>(l.resolve(), u.promise));
            const h = `${this.url}routing/v1/ipns/${e}`;
            try {
                await l.promise;
                const f = P_(t), p = {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/vnd.ipfs.ipns-record"
                    },
                    body: f,
                    signal: i
                }, m = await this.#n(h, p);
                if (this.log("putIPNS PUT %s %d", h, m.status), m.status !== 200) throw new Li("PUT ipns response had status other than 200");
            } catch (f) {
                throw this.log.error("putIPNS PUT %s error - %e", h, f.stack), f;
            } finally{
                i.clear(), u.resolve(), this.log("putIPNS finished: %c", e);
            }
        }
        #e(e) {
            try {
                const t = [], r = e.Addrs?.map(dW) ?? [];
                return e.Protocols != null && t.push(...e.Protocols), e.Protocol != null && (t.push(e.Protocol), delete e.Protocol), {
                    ...e,
                    Schema: "peer",
                    ID: WG(e.ID),
                    Addrs: r,
                    Protocols: t
                };
            } catch (t) {
                this.log.error("could not conform record to peer schema - %e", t);
            }
        }
        #t(e, t, r) {
            if (t != null || this.filterAddrs != null) {
                const s = t?.join(",") ?? this.filterAddrs?.join(",") ?? "";
                s !== "" && e.searchParams.set("filter-addrs", s);
            }
            if (r != null || this.filterProtocols != null) {
                const s = r?.join(",") ?? this.filterProtocols?.join(",") ?? "";
                s !== "" && e.searchParams.set("filter-protocols", s);
            }
        }
        async #n(e, t) {
            const r = t.method ?? "GET", s = `${r}-${e}`;
            if (r === "GET") {
                const h = await this.cache?.match(e);
                if (h != null) {
                    if (parseInt(h.headers.get("x-cache-expires") ?? "0", 10) > Date.now()) return this.log("returning cached response for %s", s), this.logResponse(h), h;
                    this.log("evicting cached response for %s", s), await this.cache?.delete(e);
                } else this.cache != null && this.log("cache miss for %s", s);
            }
            const i = this.inFlightRequests.get(s);
            if (i != null) {
                const h = await i;
                return this.log("deduplicating outgoing request for %s", s), h.clone();
            }
            this.log("outgoing request:"), this.logRequest(e, t);
            const l = fetch(e, t).then(async (h)=>{
                if (this.log("incoming response:"), this.logResponse(h), this.cache != null && h.ok && r === "GET") {
                    const f = Date.now() + this.cacheTTL, p = new Headers(h.headers);
                    p.set("x-cache-expires", f.toString());
                    const m = new Response(h.clone().body, {
                        status: h.status,
                        statusText: h.statusText,
                        headers: p
                    });
                    await this.cache.put(e, m);
                }
                return h;
            }).finally(()=>{
                this.inFlightRequests.delete(s);
            });
            return this.inFlightRequests.set(s, l), await l;
        }
        toString() {
            return `DefaultDelegatedRoutingV1HttpApiClient(${this.url})`;
        }
        logRequest(e, t) {
            const r = new Headers(t.headers);
            this.log("%s %s HTTP/1.1", t.method ?? "GET", e);
            for (const [s, i] of r.entries())this.log("%s: %s", s, i);
        }
        logResponse(e) {
            this.log("HTTP/1.1 %d %s", e.status, e.statusText);
            for (const [t, r] of e.headers.entries())this.log("%s: %s", t, r);
        }
    }
    function LW(n) {
        return (e)=>new NW(e, n);
    }
    let UW = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, zW = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const $_ = Symbol.for("@libp2p/peer-id");
    function FW(n) {
        return {
            url: "https://delegated-ipfs.dev",
            filterProtocols: [
                "unknown",
                "transport-bitswap",
                "transport-ipfs-gateway-http"
            ],
            filterAddrs: [
                "https",
                "webtransport",
                "webrtc",
                "webrtc-direct",
                "wss",
                "tls"
            ]
        };
    }
    const M_ = Symbol.for("nodejs.util.inspect.custom"), VW = 114;
    let a8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [$_] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(VW, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [M_]() {
            return `PeerId(${this.toString()})`;
        }
    }, HW = class extends a8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, QW = class extends a8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, qW = class extends a8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const KW = 2336;
    let N_ = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [M_]() {
            return `PeerId(${this.url})`;
        }
        [$_] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(KW, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const GW = 114, Hv = 2336;
    function YW(n) {
        if (XW(n)) return new HW({
            multihash: n
        });
        if (jW(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new QW({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new qW({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new N_(new URL(t));
        }
        throw new zW("Supplied PeerID Multihash is invalid");
    }
    function WW(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== GW && n.code !== Hv) throw new UW("Supplied PeerID CID is invalid");
        if (n.code === Hv) {
            const e = L(n.multihash.digest);
            return new N_(new URL(e));
        }
        return YW(n.multihash);
    }
    function jW(n) {
        return n.code === nt.code;
    }
    function XW(n) {
        return n.code === Ut.code;
    }
    let us = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, rf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, JW = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, ZW = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const ej = 4, tj = 6, nj = 273, rj = 33, sj = 41, ij = 42, oj = 43, aj = 53, lj = 54, cj = 55, uj = 56, hj = 132, dj = 301, fj = 302, pj = 400, gj = 421, mj = 444, yj = 445, wj = 446, bj = 447, vj = 448, Ej = 449, Aj = 454, Sj = 460, Ij = 461, Cj = 465, Tj = 466, _j = 480, xj = 481, Dj = 443, Bj = 477, Pj = 478, kj = 479, Rj = 277, Oj = 275, $j = 276, Mj = 280, Nj = 281, Lj = 290, Uj = 777;
    function Qv(n) {
        return (e)=>L(e, n);
    }
    function qv(n) {
        return (e)=>re(e, n);
    }
    function Vh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function ec(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function zj(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = ec(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Fj(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = ec(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Kv(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Vh(t);
        return `${r}:${s}`;
    }
    const L_ = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new us("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, Vj = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = L_(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new us("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, Hj = function(n) {
        if (n.byteLength !== 4) throw new us("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, Qj = function(n) {
        if (n.byteLength !== 16) throw new us("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new us(`Invalid IPv6 address "${t}"`);
        }
    };
    function qj(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new us(`Invalid IPv6 address "${n}"`);
        }
    }
    const N3 = Object.values(un).map((n)=>n.decoder), Kj = (function() {
        let n = N3[0].or(N3[1]);
        return N3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function Gj(n) {
        return Kj.decode(n);
    }
    function Yj(n) {
        return (e)=>n.encoder.encode(e);
    }
    function Wj(n) {
        if (parseInt(n).toString() !== n) throw new rf("Value must be an integer");
    }
    function jj(n) {
        if (n < 0) throw new rf("Value must be a positive integer, or zero");
    }
    function Xj(n) {
        return (e)=>{
            if (e > n) throw new rf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function Jj(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const I0 = Jj(Wj, jj, Xj(65535)), Rn = -1;
    let Zj = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new ZW(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const cu = new Zj, eX = [
        {
            code: ej,
            name: "ip4",
            size: 32,
            valueToBytes: L_,
            bytesToValue: Hj,
            validate: (n)=>{
                if (!Je(n)) throw new rf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: tj,
            name: "tcp",
            size: 16,
            valueToBytes: ec,
            bytesToValue: Vh,
            validate: I0
        },
        {
            code: nj,
            name: "udp",
            size: 16,
            valueToBytes: ec,
            bytesToValue: Vh,
            validate: I0
        },
        {
            code: rj,
            name: "dccp",
            size: 16,
            valueToBytes: ec,
            bytesToValue: Vh,
            validate: I0
        },
        {
            code: sj,
            name: "ip6",
            size: 128,
            valueToBytes: Vj,
            bytesToValue: Qj,
            stringToValue: qj,
            validate: (n)=>{
                if (!xn(n)) throw new rf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: ij,
            name: "ip6zone",
            size: Rn
        },
        {
            code: oj,
            name: "ipcidr",
            size: 8,
            bytesToValue: Qv("base10"),
            valueToBytes: qv("base10")
        },
        {
            code: aj,
            name: "dns",
            size: Rn
        },
        {
            code: lj,
            name: "dns4",
            size: Rn
        },
        {
            code: cj,
            name: "dns6",
            size: Rn
        },
        {
            code: uj,
            name: "dnsaddr",
            size: Rn
        },
        {
            code: hj,
            name: "sctp",
            size: 16,
            valueToBytes: ec,
            bytesToValue: Vh,
            validate: I0
        },
        {
            code: dj,
            name: "udt"
        },
        {
            code: fj,
            name: "utp"
        },
        {
            code: pj,
            name: "unix",
            size: Rn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: gj,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Rn,
            bytesToValue: Qv("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? qv("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: mj,
            name: "onion",
            size: 96,
            bytesToValue: Kv,
            valueToBytes: zj
        },
        {
            code: yj,
            name: "onion3",
            size: 296,
            bytesToValue: Kv,
            valueToBytes: Fj
        },
        {
            code: wj,
            name: "garlic64",
            size: Rn
        },
        {
            code: bj,
            name: "garlic32",
            size: Rn
        },
        {
            code: vj,
            name: "tls"
        },
        {
            code: Ej,
            name: "sni",
            size: Rn
        },
        {
            code: Aj,
            name: "noise"
        },
        {
            code: Sj,
            name: "quic"
        },
        {
            code: Ij,
            name: "quic-v1"
        },
        {
            code: Cj,
            name: "webtransport"
        },
        {
            code: Tj,
            name: "certhash",
            size: Rn,
            bytesToValue: Yj(yn),
            valueToBytes: Gj
        },
        {
            code: _j,
            name: "http"
        },
        {
            code: xj,
            name: "http-path",
            size: Rn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Dj,
            name: "https"
        },
        {
            code: Bj,
            name: "ws"
        },
        {
            code: Pj,
            name: "wss"
        },
        {
            code: kj,
            name: "p2p-websocket-star"
        },
        {
            code: Rj,
            name: "p2p-stardust"
        },
        {
            code: Oj,
            name: "p2p-webrtc-star"
        },
        {
            code: $j,
            name: "p2p-webrtc-direct"
        },
        {
            code: Mj,
            name: "webrtc-direct"
        },
        {
            code: Nj,
            name: "webrtc"
        },
        {
            code: Lj,
            name: "p2p-circuit"
        },
        {
            code: Uj,
            name: "memory",
            size: Rn
        }
    ];
    eX.forEach((n)=>{
        cu.addProtocol(n);
    });
    function tX(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = cu.getProtocol(r), i = be(r), l = iX(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Rn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function nX(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = cu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Rn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Rn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function rX(n) {
        if (n.charAt(0) !== "/") throw new us('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = cu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new us(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new us(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new us("Incomplete multiaddr");
        return e;
    }
    function sX(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = cu.getProtocol(e.code);
            if (t == null) throw new us(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function iX(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const oX = Symbol.for("nodejs.util.inspect.custom"), U_ = Symbol.for("@multiformats/multiaddr");
    function aX(n) {
        if (n == null && (n = "/"), uX(n)) return n.getComponents();
        if (n instanceof Uint8Array) return tX(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), rX(n);
        if (Array.isArray(n)) return n;
        throw new us("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let lX = class Hh {
        [U_] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = aX(e), t.validate !== !1 && cX(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = nX(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = sX(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new Hh(e);
            return new Hh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new JW(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new Hh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new Hh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [oX]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function cX(n) {
        n.getComponents().forEach((e)=>{
            const t = cu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function uX(n) {
        return !!n?.[U_];
    }
    function hX(n) {
        return new lX(n);
    }
    const Gv = "[a-fA-F\\d:]", $o = (n)=>n && n.includeBoundaries ? `(?:(?<=\\s|^)(?=${Gv})|(?<=${Gv})(?=\\s|$))` : "", Ns = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", sn = "[a-fA-F\\d]{1,4}", xg = `
(?:
(?:${sn}:){7}(?:${sn}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${sn}:){6}(?:${Ns}|:${sn}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${sn}:){5}(?::${Ns}|(?::${sn}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${sn}:){4}(?:(?::${sn}){0,1}:${Ns}|(?::${sn}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${sn}:){3}(?:(?::${sn}){0,2}:${Ns}|(?::${sn}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${sn}:){2}(?:(?::${sn}){0,3}:${Ns}|(?::${sn}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${sn}:){1}(?:(?::${sn}){0,4}:${Ns}|(?::${sn}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${sn}){0,5}:${Ns}|(?::${sn}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), dX = new RegExp(`(?:^${Ns}$)|(?:^${xg}$)`), fX = new RegExp(`^${Ns}$`), pX = new RegExp(`^${xg}$`), Dg = (n)=>n && n.exact ? dX : new RegExp(`(?:${$o(n)}${Ns}${$o(n)})|(?:${$o(n)}${xg}${$o(n)})`, "g");
    Dg.v4 = (n)=>n && n.exact ? fX : new RegExp(`${$o(n)}${Ns}${$o(n)}`, "g");
    Dg.v6 = (n)=>n && n.exact ? pX : new RegExp(`${$o(n)}${xg}${$o(n)}`, "g");
    function gX(n) {
        const e = (...t)=>n(...t);
        return Object.defineProperty(e, "name", {
            value: `functionTimeout(${n.name || "<anonymous>"})`,
            configurable: !0
        }), e;
    }
    const { toString: mX } = Object.prototype;
    function yX(n) {
        return mX.call(n) === "[object RegExp]";
    }
    const Yv = {
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        dotAll: "s",
        sticky: "y",
        unicode: "u"
    };
    function wX(n, e = {}) {
        if (!yX(n)) throw new TypeError("Expected a RegExp instance");
        const t = Object.keys(Yv).map((s)=>(typeof e[s] == "boolean" ? e[s] : n[s]) ? Yv[s] : "").join(""), r = new RegExp(e.source || n.source, t);
        return r.lastIndex = typeof e.lastIndex == "number" ? e.lastIndex : n.lastIndex, r;
    }
    function z_(n, e, { timeout: t } = {}) {
        try {
            return gX(()=>wX(n).test(e), {
                timeout: t
            })();
        } catch (r) {
            throw r;
        }
    }
    const bX = 15, vX = 45, F_ = {
        timeout: 400
    };
    function Wv(n) {
        return n.length > vX ? !1 : z_(Dg.v6({
            exact: !0
        }), n, F_);
    }
    function EX(n) {
        return n.length > bX ? !1 : z_(Dg.v4({
            exact: !0
        }), n, F_);
    }
    const jv = {
        http: "80",
        https: "443",
        ws: "80",
        wss: "443"
    }, AX = [
        "http",
        "https",
        "ws",
        "wss"
    ];
    function V_(n, e) {
        e = e ?? {};
        const t = e.defaultDnsType ?? "dns", { scheme: r, hostname: s, port: i, path: l } = SX(n), u = [
            IX(s, t),
            CX(i, r),
            TX(r)
        ];
        l != null && u.push(_X(l));
        const h = "/" + u.filter((f)=>!!f).reduce((f, p)=>f.concat(p), []).join("/");
        return hX(h);
    }
    function SX(n) {
        const [e] = n.split(":");
        AX.includes(e) || (n = "http" + n.substring(e.length));
        let { protocol: t, hostname: r, port: s, pathname: i, search: l } = new URL(n);
        if (s == null || s === "") {
            const h = xX(e);
            h != null && (s = h), h == null && t === "http:" && (s = "80");
        }
        let u;
        return i != null && i !== "" && i !== "/" && (i.startsWith("/") && (i = i.substring(1)), u = i), l != null && l !== "" && (u = u ?? "", u += l), {
            scheme: e,
            hostname: r,
            port: s,
            path: u
        };
    }
    function IX(n, e) {
        if (!(n == null || n === "")) {
            if (EX(n)) return [
                "ip4",
                n
            ];
            if (Wv(n)) return [
                "ip6",
                n
            ];
            if (n[0] === "[") {
                const t = n.substring(1, n.length - 1);
                if (Wv(t)) return [
                    "ip6",
                    t
                ];
            }
            return [
                e,
                n
            ];
        }
    }
    function CX(n, e) {
        if (!(n == null || n === "")) return e === "udp" ? [
            "udp",
            n
        ] : [
            "tcp",
            n
        ];
    }
    function TX(n) {
        if (n.match(/^tcp$|^udp$/) == null) return n === "https" ? [
            "/tls/http"
        ] : n === "wss" ? [
            "/tls/ws"
        ] : [
            n
        ];
    }
    function _X(n) {
        if (!(n == null || n === "")) return [
            "http-path",
            encodeURIComponent(n)
        ];
    }
    function xX(n) {
        if (!(n == null || n === "" || jv[n] == null)) return jv[n];
    }
    const DX = [
        "https://trustless-gateway.link",
        "https://4everland.io"
    ], BX = 2336;
    function PX(n) {
        return n = n.toString(), {
            id: WW(ge.createV1(BX, nt.digest(re(n)))),
            multiaddrs: [
                V_(n)
            ]
        };
    }
    function kX(n) {
        return new URL(L(n.id.toMultihash().digest));
    }
    class RX {
        gateways;
        shuffle;
        constructor(e = {}){
            this.gateways = (e.gateways ?? DX).map((t)=>PX(t)), this.shuffle = e.shuffle ?? !0;
        }
        async *findProviders(e, t) {
            yield* (this.shuffle ? this.gateways.toSorted(()=>Math.random() > .5 ? 1 : -1) : this.gateways).map((r)=>({
                    ...r,
                    protocols: [
                        "transport-ipfs-gateway-http"
                    ],
                    routing: "http-gateway-routing"
                }));
        }
        toString() {
            return `HTTPGatewayRouter([${this.gateways.map((e)=>kX(e)).join(", ")}])`;
        }
    }
    function OX(n = {}) {
        return new RX(n);
    }
    class $X {
        libp2p;
        constructor(e){
            this.libp2p = e;
        }
        async provide(e, t) {
            await this.libp2p.contentRouting.provide(e, t);
        }
        async cancelReprovide(e, t) {
            await this.libp2p.contentRouting.cancelReprovide(e, t);
        }
        async *findProviders(e, t) {
            yield* this.libp2p.contentRouting.findProviders(e, t);
        }
        async put(e, t, r) {
            await this.libp2p.contentRouting.put(e, t, r);
        }
        async get(e, t) {
            return this.libp2p.contentRouting.get(e, t);
        }
        async findPeer(e, t) {
            return this.libp2p.peerRouting.findPeer(e, t);
        }
        async *getClosestPeers(e, t) {
            yield* this.libp2p.peerRouting.getClosestPeers(e, t);
        }
        toString() {
            return "Libp2pRouter()";
        }
    }
    function MX(n) {
        return new $X(n);
    }
    function NX(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function sf(n) {
        if (NX(n)) return (async ()=>{
            const t = [];
            for await (const r of n)t.push(r);
            return t;
        })();
        const e = [];
        for (const t of n)e.push(t);
        return e;
    }
    function LX(n) {
        return typeof n?.then == "function";
    }
    class H_ extends xT {
        data;
        constructor(){
            super(), this.data = new Map;
        }
        put(e, t, r) {
            r?.signal?.throwIfAborted();
            let s;
            if (t instanceof Uint8Array) s = [
                t
            ];
            else {
                const i = sf(t);
                if (LX(i)) return i.then((l)=>this._put(e, l, r));
                s = i;
            }
            return this._put(e, s, r);
        }
        _put(e, t, r) {
            return r?.signal?.throwIfAborted(), this.data.set(At.encode(e.multihash.bytes), t), e;
        }
        *get(e, t) {
            t?.signal?.throwIfAborted();
            const r = this.data.get(At.encode(e.multihash.bytes));
            if (r == null) throw new q6;
            yield* r;
        }
        has(e, t) {
            return t?.signal?.throwIfAborted(), this.data.has(At.encode(e.multihash.bytes));
        }
        async delete(e, t) {
            t?.signal?.throwIfAborted(), this.data.delete(At.encode(e.multihash.bytes));
        }
        *getAll(e) {
            e?.signal?.throwIfAborted();
            for (const [t, r] of this.data.entries())yield {
                cid: ge.createV1(Af, kt(At.decode(t))),
                bytes: (async function*() {
                    yield* r;
                })()
            }, e?.signal?.throwIfAborted();
        }
    }
    ou("blockstore:core:tiered");
    const UX = "SHARDING";
    function zX(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function Xv(n, e) {
        return zX(n) ? (async function*() {
            yield* (await sf(n)).sort(e);
        })() : (function*() {
            yield* sf(n).sort(e);
        })();
    }
    class FX {
        put(e, t, r) {
            return Promise.reject(new Error(".put is not implemented"));
        }
        get(e, t) {
            return Promise.reject(new Error(".get is not implemented"));
        }
        has(e, t) {
            return Promise.reject(new Error(".has is not implemented"));
        }
        delete(e, t) {
            return Promise.reject(new Error(".delete is not implemented"));
        }
        async *putMany(e, t = {}) {
            for await (const { key: r, value: s } of e)await this.put(r, s, t), yield r;
        }
        async *getMany(e, t = {}) {
            for await (const r of e)yield {
                key: r,
                value: await this.get(r, t)
            };
        }
        async *deleteMany(e, t = {}) {
            for await (const r of e)await this.delete(r, t), yield r;
        }
        batch() {
            let e = [], t = [];
            return {
                put (r, s) {
                    e.push({
                        key: r,
                        value: s
                    });
                },
                delete (r) {
                    t.push(r);
                },
                commit: async (r)=>{
                    await qo(this.putMany(e, r)), e = [], await qo(this.deleteMany(t, r)), t = [];
                }
            };
        }
        async *_all(e, t) {
            throw new Error("._all is not implemented");
        }
        async *_allKeys(e, t) {
            throw new Error("._allKeys is not implemented");
        }
        query(e, t) {
            let r = this._all(e, t);
            if (e.prefix != null) {
                const s = e.prefix;
                r = Sa(r, (i)=>i.key.toString().startsWith(s));
            }
            if (Array.isArray(e.filters) && (r = e.filters.reduce((s, i)=>Sa(s, i), r)), Array.isArray(e.orders) && (r = e.orders.reduce((s, i)=>Xv(s, i), r)), e.offset != null) {
                let s = 0;
                const i = e.offset;
                r = Sa(r, ()=>s++ >= i);
            }
            return e.limit != null && (r = Pp(r, e.limit)), r;
        }
        queryKeys(e, t) {
            let r = this._allKeys(e, t);
            if (e.prefix != null) {
                const s = e.prefix;
                r = Sa(r, (i)=>i.toString().startsWith(s));
            }
            if (Array.isArray(e.filters) && (r = e.filters.reduce((s, i)=>Sa(s, i), r)), Array.isArray(e.orders) && (r = e.orders.reduce((s, i)=>Xv(s, i), r)), e.offset != null) {
                const s = e.offset;
                let i = 0;
                r = Sa(r, ()=>i++ >= s);
            }
            return e.limit != null && (r = Pp(r, e.limit)), r;
        }
    }
    class l8 extends FX {
        data;
        constructor(){
            super(), this.data = new Map;
        }
        put(e, t, r) {
            return r?.signal?.throwIfAborted(), this.data.set(e.toString(), t), e;
        }
        get(e, t) {
            t?.signal?.throwIfAborted();
            const r = this.data.get(e.toString());
            if (r == null) throw new q6;
            return r;
        }
        has(e, t) {
            return t?.signal?.throwIfAborted(), this.data.has(e.toString());
        }
        delete(e, t) {
            t?.signal?.throwIfAborted(), this.data.delete(e.toString());
        }
        *_all(e, t) {
            t?.signal?.throwIfAborted();
            for (const [r, s] of this.data.entries())yield {
                key: new Nt(r),
                value: s
            }, t?.signal?.throwIfAborted();
        }
        *_allKeys(e, t) {
            t?.signal?.throwIfAborted();
            for (const r of this.data.keys())yield new Nt(r), t?.signal?.throwIfAborted();
        }
    }
    new Nt(UX);
    ou("datastore:core:tiered");
    const VX = Symbol.for("@libp2p/connection"), Jv = Symbol.for("@libp2p/content-routing");
    let HX = class extends Error {
        static name = "AbortError";
        constructor(e = "The operation was aborted"){
            super(e), this.name = "AbortError";
        }
    }, Vr = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    };
    class i4 extends Error {
        static name = "ConnectionClosedError";
        constructor(e = "The connection is closed"){
            super(e), this.name = "ConnectionClosedError";
        }
    }
    let QX = class extends Error {
        static name = "NotFoundError";
        constructor(e = "Not found"){
            super(e), this.name = "NotFoundError";
        }
    };
    class Q_ extends Error {
        static name = "InvalidPeerIdError";
        constructor(e = "Invalid PeerID"){
            super(e), this.name = "InvalidPeerIdError";
        }
    }
    let c8 = class extends Error {
        static name = "InvalidMultiaddrError";
        constructor(e = "Invalid multiaddr"){
            super(e), this.name = "InvalidMultiaddrError";
        }
    }, qX = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, KX = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }, GX = class extends Error {
        static name = "TimeoutError";
        constructor(e = "Timed out"){
            super(e), this.name = "TimeoutError";
        }
    };
    class Np extends Error {
        static name = "NotStartedError";
        constructor(e = "Not started"){
            super(e), this.name = "NotStartedError";
        }
    }
    let L3 = class extends Error {
        static name = "DialError";
        constructor(e = "Dial error"){
            super(e), this.name = "DialError";
        }
    };
    class Zv extends Error {
        static name = "LimitedConnectionError";
        constructor(e = "Limited connection"){
            super(e), this.name = "LimitedConnectionError";
        }
    }
    class YX extends Error {
        static name = "TooManyInboundProtocolStreamsError";
        constructor(e = "Too many inbound protocol streams"){
            super(e), this.name = "TooManyInboundProtocolStreamsError";
        }
    }
    let WX = class extends Error {
        static name = "TooManyOutboundProtocolStreamsError";
        constructor(e = "Too many outbound protocol streams"){
            super(e), this.name = "TooManyOutboundProtocolStreamsError";
        }
    }, jX = class extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    };
    class XX extends Event {
        error;
        local;
        constructor(e, t, r){
            super("close", r), this.error = t, this.local = e;
        }
    }
    const eE = Symbol.for("@libp2p/peer-discovery"), u8 = Symbol.for("@libp2p/peer-id");
    function JX(n) {
        return !!n?.[u8];
    }
    const tE = Symbol.for("@libp2p/peer-routing"), q_ = "keep-alive";
    function h8(n) {
        return n != null && typeof n.start == "function" && typeof n.stop == "function";
    }
    async function ZX(...n) {
        const e = [];
        for (const t of n)h8(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStart != null && await t.beforeStart();
        })), await Promise.all(e.map(async (t)=>{
            await t.start();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStart != null && await t.afterStart();
        }));
    }
    async function eJ(...n) {
        const e = [];
        for (const t of n)h8(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStop != null && await t.beforeStop();
        })), await Promise.all(e.map(async (t)=>{
            await t.stop();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStop != null && await t.afterStop();
        }));
    }
    var Lp;
    (function(n) {
        n[n.FATAL_ALL = 0] = "FATAL_ALL", n[n.NO_FATAL = 1] = "NO_FATAL";
    })(Lp || (Lp = {}));
    const o4 = Symbol.for("@libp2p/service-capabilities"), nE = Symbol.for("@libp2p/service-dependencies"), K_ = Symbol.for("nodejs.util.inspect.custom"), tJ = 114;
    let d8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [u8] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(tJ, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [K_]() {
            return `PeerId(${this.toString()})`;
        }
    }, G_ = class extends d8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, Y_ = class extends d8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, W_ = class extends d8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const nJ = 2336;
    let j_ = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [K_]() {
            return `PeerId(${this.url})`;
        }
        [u8] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(nJ, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const rJ = 114, rE = 2336;
    function Fc(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return oJ(ge.parse(n));
            throw new Vr('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return f8(t);
    }
    function sJ(n) {
        if (n.type === "Ed25519") return new Y_({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "secp256k1") return new W_({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "RSA") return new G_({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        throw new jX;
    }
    function iJ(n) {
        return sJ(n.publicKey);
    }
    function f8(n) {
        if (lJ(n)) return new G_({
            multihash: n
        });
        if (aJ(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new Y_({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new W_({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new j_(new URL(t));
        }
        throw new KX("Supplied PeerID Multihash is invalid");
    }
    function oJ(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== rJ && n.code !== rE) throw new qX("Supplied PeerID CID is invalid");
        if (n.code === rE) {
            const e = L(n.multihash.digest);
            return new j_(new URL(e));
        }
        return f8(n.multihash);
    }
    function aJ(n) {
        return n.code === nt.code;
    }
    function lJ(n) {
        return n.code === Ut.code;
    }
    var cJ = {};
    async function uJ(n) {
        if (n.connectionProtector === null && cJ?.LIBP2P_FORCE_PNET != null) throw new Vr("Private network is enforced, but no protector was provided");
        return n;
    }
    function Ed(n, e) {
        const t = {
            [Symbol.iterator]: ()=>t,
            next: ()=>{
                const r = n.next(), s = r.value;
                return r.done === !0 || s == null ? {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: e(s)
                };
            }
        };
        return t;
    }
    function U3(n) {
        const e = kt(He.decode(`z${n}`));
        return f8(e);
    }
    let p8 = class {
        map;
        constructor(e){
            if (this.map = new Map, e != null) for (const [t, r] of e.entries())this.map.set(t.toString(), {
                key: t,
                value: r
            });
        }
        [Symbol.iterator]() {
            return this.entries();
        }
        clear() {
            this.map.clear();
        }
        delete(e) {
            return this.map.delete(e.toString());
        }
        entries() {
            return Ed(this.map.entries(), (e)=>[
                    e[1].key,
                    e[1].value
                ]);
        }
        forEach(e) {
            this.map.forEach((t, r)=>{
                e(t.value, t.key, this);
            });
        }
        get(e) {
            return this.map.get(e.toString())?.value;
        }
        has(e) {
            return this.map.has(e.toString());
        }
        set(e, t) {
            this.map.set(e.toString(), {
                key: e,
                value: t
            });
        }
        keys() {
            return Ed(this.map.values(), (e)=>e.key);
        }
        values() {
            return Ed(this.map.values(), (e)=>e.value);
        }
        get size() {
            return this.map.size;
        }
    }, X_ = class op {
        set;
        constructor(e){
            if (this.set = new Set, e != null) for (const t of e)this.set.add(t.toString());
        }
        get size() {
            return this.set.size;
        }
        [Symbol.iterator]() {
            return this.values();
        }
        add(e) {
            this.set.add(e.toString());
        }
        clear() {
            this.set.clear();
        }
        delete(e) {
            this.set.delete(e.toString());
        }
        entries() {
            return Ed(this.set.entries(), (e)=>{
                const t = U3(e[0]);
                return [
                    t,
                    t
                ];
            });
        }
        forEach(e) {
            this.set.forEach((t)=>{
                const r = U3(t);
                e(r, r, this);
            });
        }
        has(e) {
            return this.set.has(e.toString());
        }
        values() {
            return Ed(this.set.values(), (e)=>U3(e));
        }
        intersection(e) {
            const t = new op;
            for (const r of e)this.has(r) && t.add(r);
            return t;
        }
        difference(e) {
            const t = new op;
            for (const r of this)e.has(r) || t.add(r);
            return t;
        }
        union(e) {
            const t = new op;
            for (const r of e)t.add(r);
            for (const r of this)t.add(r);
            return t;
        }
    }, os = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, sE = class extends Error {
        static name = "NotFoundError";
        constructor(e = "Not found"){
            super(e), this.name = "NotFoundError";
        }
    }, hJ = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, dJ = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }, fJ = class extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    };
    const g8 = Symbol.for("@libp2p/peer-id");
    function ap(n) {
        return !!n?.[g8];
    }
    const J_ = Symbol.for("nodejs.util.inspect.custom"), pJ = 114;
    let m8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [g8] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(pJ, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [J_]() {
            return `PeerId(${this.toString()})`;
        }
    }, Z_ = class extends m8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, ex = class extends m8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, tx = class extends m8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const gJ = 2336;
    let nx = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [J_]() {
            return `PeerId(${this.url})`;
        }
        [g8] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(gJ, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const mJ = 114, iE = 2336;
    function yJ(n) {
        if (n.type === "Ed25519") return new ex({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "secp256k1") return new tx({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "RSA") return new Z_({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        throw new fJ;
    }
    function wJ(n) {
        if (vJ(n)) return new Z_({
            multihash: n
        });
        if (bJ(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new ex({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new tx({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new nx(new URL(t));
        }
        throw new dJ("Supplied PeerID Multihash is invalid");
    }
    function rx(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== mJ && n.code !== iE) throw new hJ("Supplied PeerID CID is invalid");
        if (n.code === iE) {
            const e = L(n.multihash.digest);
            return new nx(new URL(e));
        }
        return wJ(n.multihash);
    }
    function bJ(n) {
        return n.code === nt.code;
    }
    function vJ(n) {
        return n.code === Ut.code;
    }
    var Up;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.publicKey != null && t.publicKey.byteLength > 0 && (r.uint32(10), r.bytes(t.publicKey)), t.payloadType != null && t.payloadType.byteLength > 0 && (r.uint32(18), r.bytes(t.payloadType)), t.payload != null && t.payload.byteLength > 0 && (r.uint32(26), r.bytes(t.payload)), t.signature != null && t.signature.byteLength > 0 && (r.uint32(42), r.bytes(t.signature)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    publicKey: je(0),
                    payloadType: je(0),
                    payload: je(0),
                    signature: je(0)
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.publicKey = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.payloadType = t.bytes();
                                break;
                            }
                        case 3:
                            {
                                i.payload = t.bytes();
                                break;
                            }
                        case 5:
                            {
                                i.signature = t.bytes();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Up || (Up = {}));
    class EJ extends Error {
        constructor(e = "Invalid signature"){
            super(e), this.name = "InvalidSignatureError";
        }
    }
    class ci {
        static createFromProtobuf = (e)=>{
            const t = Up.decode(e), r = Er(t.publicKey);
            return new ci({
                publicKey: r,
                payloadType: t.payloadType,
                payload: t.payload,
                signature: t.signature
            });
        };
        static seal = async (e, t, r)=>{
            if (t == null) throw new Error("Missing private key");
            const s = e.domain, i = e.codec, l = e.marshal(), u = oE(s, i, l), h = await t.sign(u.subarray(), r);
            return new ci({
                publicKey: t.publicKey,
                payloadType: i,
                payload: l,
                signature: h
            });
        };
        static openAndCertify = async (e, t, r)=>{
            const s = ci.createFromProtobuf(e);
            if (!await s.validate(t, r)) throw new EJ("Envelope signature is not valid for the given domain");
            return s;
        };
        publicKey;
        payloadType;
        payload;
        signature;
        marshaled;
        constructor(e){
            const { publicKey: t, payloadType: r, payload: s, signature: i } = e;
            this.publicKey = t, this.payloadType = r, this.payload = s, this.signature = i;
        }
        marshal() {
            return this.marshaled == null && (this.marshaled = Up.encode({
                publicKey: Fr(this.publicKey),
                payloadType: this.payloadType,
                payload: this.payload.subarray(),
                signature: this.signature
            })), this.marshaled;
        }
        equals(e) {
            return e == null ? !1 : Ee(this.marshal(), e.marshal());
        }
        async validate(e, t) {
            const r = oE(e, this.payloadType, this.payload);
            return this.publicKey.verify(r.subarray(), this.signature, t);
        }
    }
    const oE = (n, e, t)=>{
        const r = re(n), s = zr(r.byteLength), i = zr(e.length), l = zr(t.length);
        return new Re(s, r, i, e, l, t);
    };
    let AJ = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const sx = Symbol.for("@libp2p/peer-id"), ix = Symbol.for("nodejs.util.inspect.custom"), SJ = 114;
    let y8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [sx] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(SJ, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [ix]() {
            return `PeerId(${this.toString()})`;
        }
    }, IJ = class extends y8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, CJ = class extends y8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, TJ = class extends y8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const _J = 2336;
    let xJ = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [ix]() {
            return `PeerId(${this.url})`;
        }
        [sx] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(_J, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    function DJ(n) {
        if (PJ(n)) return new IJ({
            multihash: n
        });
        if (BJ(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new CJ({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new TJ({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new xJ(new URL(t));
        }
        throw new AJ("Supplied PeerID Multihash is invalid");
    }
    function BJ(n) {
        return n.code === nt.code;
    }
    function PJ(n) {
        return n.code === Ut.code;
    }
    let hs = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, of = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, kJ = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, RJ = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const OJ = 4, $J = 6, MJ = 273, NJ = 33, LJ = 41, UJ = 42, zJ = 43, FJ = 53, VJ = 54, HJ = 55, QJ = 56, qJ = 132, KJ = 301, GJ = 302, YJ = 400, WJ = 421, jJ = 444, XJ = 445, JJ = 446, ZJ = 447, eZ = 448, tZ = 449, nZ = 454, rZ = 460, sZ = 461, iZ = 465, oZ = 466, aZ = 480, lZ = 481, cZ = 443, uZ = 477, hZ = 478, dZ = 479, fZ = 277, pZ = 275, gZ = 276, mZ = 280, yZ = 281, wZ = 290, bZ = 777;
    function aE(n) {
        return (e)=>L(e, n);
    }
    function lE(n) {
        return (e)=>re(e, n);
    }
    function Qh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function tc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function vZ(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = tc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function EZ(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = tc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function cE(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Qh(t);
        return `${r}:${s}`;
    }
    const ox = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new hs("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, AZ = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = ox(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new hs("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, SZ = function(n) {
        if (n.byteLength !== 4) throw new hs("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, IZ = function(n) {
        if (n.byteLength !== 16) throw new hs("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new hs(`Invalid IPv6 address "${t}"`);
        }
    };
    function CZ(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new hs(`Invalid IPv6 address "${n}"`);
        }
    }
    const z3 = Object.values(un).map((n)=>n.decoder), TZ = (function() {
        let n = z3[0].or(z3[1]);
        return z3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function _Z(n) {
        return TZ.decode(n);
    }
    function xZ(n) {
        return (e)=>n.encoder.encode(e);
    }
    function DZ(n) {
        if (parseInt(n).toString() !== n) throw new of("Value must be an integer");
    }
    function BZ(n) {
        if (n < 0) throw new of("Value must be a positive integer, or zero");
    }
    function PZ(n) {
        return (e)=>{
            if (e > n) throw new of(`Value must be smaller than or equal to ${n}`);
        };
    }
    function kZ(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const C0 = kZ(DZ, BZ, PZ(65535)), On = -1;
    let RZ = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new RJ(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const uu = new RZ, OZ = [
        {
            code: OJ,
            name: "ip4",
            size: 32,
            valueToBytes: ox,
            bytesToValue: SZ,
            validate: (n)=>{
                if (!Je(n)) throw new of(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: $J,
            name: "tcp",
            size: 16,
            valueToBytes: tc,
            bytesToValue: Qh,
            validate: C0
        },
        {
            code: MJ,
            name: "udp",
            size: 16,
            valueToBytes: tc,
            bytesToValue: Qh,
            validate: C0
        },
        {
            code: NJ,
            name: "dccp",
            size: 16,
            valueToBytes: tc,
            bytesToValue: Qh,
            validate: C0
        },
        {
            code: LJ,
            name: "ip6",
            size: 128,
            valueToBytes: AZ,
            bytesToValue: IZ,
            stringToValue: CZ,
            validate: (n)=>{
                if (!xn(n)) throw new of(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: UJ,
            name: "ip6zone",
            size: On
        },
        {
            code: zJ,
            name: "ipcidr",
            size: 8,
            bytesToValue: aE("base10"),
            valueToBytes: lE("base10")
        },
        {
            code: FJ,
            name: "dns",
            size: On
        },
        {
            code: VJ,
            name: "dns4",
            size: On
        },
        {
            code: HJ,
            name: "dns6",
            size: On
        },
        {
            code: QJ,
            name: "dnsaddr",
            size: On
        },
        {
            code: qJ,
            name: "sctp",
            size: 16,
            valueToBytes: tc,
            bytesToValue: Qh,
            validate: C0
        },
        {
            code: KJ,
            name: "udt"
        },
        {
            code: GJ,
            name: "utp"
        },
        {
            code: YJ,
            name: "unix",
            size: On,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: WJ,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: On,
            bytesToValue: aE("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? lE("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: jJ,
            name: "onion",
            size: 96,
            bytesToValue: cE,
            valueToBytes: vZ
        },
        {
            code: XJ,
            name: "onion3",
            size: 296,
            bytesToValue: cE,
            valueToBytes: EZ
        },
        {
            code: JJ,
            name: "garlic64",
            size: On
        },
        {
            code: ZJ,
            name: "garlic32",
            size: On
        },
        {
            code: eZ,
            name: "tls"
        },
        {
            code: tZ,
            name: "sni",
            size: On
        },
        {
            code: nZ,
            name: "noise"
        },
        {
            code: rZ,
            name: "quic"
        },
        {
            code: sZ,
            name: "quic-v1"
        },
        {
            code: iZ,
            name: "webtransport"
        },
        {
            code: oZ,
            name: "certhash",
            size: On,
            bytesToValue: xZ(yn),
            valueToBytes: _Z
        },
        {
            code: aZ,
            name: "http"
        },
        {
            code: lZ,
            name: "http-path",
            size: On,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: cZ,
            name: "https"
        },
        {
            code: uZ,
            name: "ws"
        },
        {
            code: hZ,
            name: "wss"
        },
        {
            code: dZ,
            name: "p2p-websocket-star"
        },
        {
            code: fZ,
            name: "p2p-stardust"
        },
        {
            code: pZ,
            name: "p2p-webrtc-star"
        },
        {
            code: gZ,
            name: "p2p-webrtc-direct"
        },
        {
            code: mZ,
            name: "webrtc-direct"
        },
        {
            code: yZ,
            name: "webrtc"
        },
        {
            code: wZ,
            name: "p2p-circuit"
        },
        {
            code: bZ,
            name: "memory",
            size: On
        }
    ];
    OZ.forEach((n)=>{
        uu.addProtocol(n);
    });
    function $Z(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = uu.getProtocol(r), i = be(r), l = UZ(s, n, t + i);
            let u = 0;
            l > 0 && s.size === On && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function MZ(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = uu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === On && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === On && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function NZ(n) {
        if (n.charAt(0) !== "/") throw new hs('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = uu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new hs(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new hs(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new hs("Incomplete multiaddr");
        return e;
    }
    function LZ(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = uu.getProtocol(e.code);
            if (t == null) throw new hs(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function UZ(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const zZ = Symbol.for("nodejs.util.inspect.custom"), ax = Symbol.for("@multiformats/multiaddr");
    function FZ(n) {
        if (n == null && (n = "/"), QZ(n)) return n.getComponents();
        if (n instanceof Uint8Array) return $Z(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), NZ(n);
        if (Array.isArray(n)) return n;
        throw new hs("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let VZ = class qh {
        [ax] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = FZ(e), t.validate !== !1 && HZ(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = MZ(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = LZ(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new qh(e);
            return new qh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new kJ(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new qh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new qh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [zZ]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function HZ(n) {
        n.getComponents().forEach((e)=>{
            const t = uu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function QZ(n) {
        return !!n?.[ax];
    }
    function qZ(n) {
        return new VZ(n);
    }
    const KZ = "libp2p-peer-record", GZ = Uint8Array.from([
        3,
        1
    ]);
    var zp;
    (function(n) {
        (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.multiaddr != null && s.multiaddr.byteLength > 0 && (i.uint32(10), i.bytes(s.multiaddr)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        multiaddr: je(0)
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        f >>> 3 === 1 ? u.multiaddr = s.bytes() : s.skipType(f & 7);
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.AddressInfo || (n.AddressInfo = {}));
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.peerId != null && t.peerId.byteLength > 0 && (r.uint32(10), r.bytes(t.peerId)), t.seq != null && t.seq !== 0n && (r.uint32(16), r.uint64(t.seq)), t.addresses != null) for (const i of t.addresses)r.uint32(26), n.AddressInfo.codec().encode(i, r);
                s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    peerId: je(0),
                    seq: 0n,
                    addresses: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.peerId = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.seq = t.uint64();
                                break;
                            }
                        case 3:
                            {
                                if (s.limits?.addresses != null && i.addresses.length === s.limits.addresses) throw new vt('Decode error - map field "addresses" had too many elements');
                                i.addresses.push(n.AddressInfo.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.addresses$
                                }));
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(zp || (zp = {}));
    function YZ(n, e) {
        const t = (r, s)=>r.toString().localeCompare(s.toString());
        return n.length !== e.length ? !1 : (e.sort(t), n.sort(t).every((r, s)=>e[s].equals(r)));
    }
    class Ur {
        static createFromProtobuf = (e)=>{
            const t = zp.decode(e), r = DJ(kt(t.peerId)), s = (t.addresses ?? []).map((l)=>qZ(l.multiaddr)), i = t.seq;
            return new Ur({
                peerId: r,
                multiaddrs: s,
                seqNumber: i
            });
        };
        static DOMAIN = KZ;
        static CODEC = GZ;
        peerId;
        multiaddrs;
        seqNumber;
        domain = Ur.DOMAIN;
        codec = Ur.CODEC;
        marshaled;
        constructor(e){
            const { peerId: t, multiaddrs: r, seqNumber: s } = e;
            this.peerId = t, this.multiaddrs = r ?? [], this.seqNumber = s ?? BigInt(Date.now());
        }
        marshal() {
            return this.marshaled == null && (this.marshaled = zp.encode({
                peerId: this.peerId.toMultihash().bytes,
                seq: BigInt(this.seqNumber),
                addresses: this.multiaddrs.map((e)=>({
                        multiaddr: e.bytes
                    }))
            })), this.marshaled;
        }
        equals(e) {
            return !(!(e instanceof Ur) || !this.peerId.equals(e.peerId) || this.seqNumber !== e.seqNumber || !YZ(this.multiaddrs, e.multiaddrs));
        }
    }
    function F3(n, e) {
        const t = {
            [Symbol.iterator]: ()=>t,
            next: ()=>{
                const r = n.next(), s = r.value;
                return r.done === !0 || s == null ? {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: e(s)
                };
            }
        };
        return t;
    }
    let lx = class {
        map;
        constructor(e){
            if (this.map = new Map, e != null) for (const [t, r] of e.entries())this.map.set(t.toString(), {
                key: t,
                value: r
            });
        }
        [Symbol.iterator]() {
            return this.entries();
        }
        clear() {
            this.map.clear();
        }
        delete(e) {
            return this.map.delete(e.toString());
        }
        entries() {
            return F3(this.map.entries(), (e)=>[
                    e[1].key,
                    e[1].value
                ]);
        }
        forEach(e) {
            this.map.forEach((t, r)=>{
                e(t.value, t.key, this);
            });
        }
        get(e) {
            return this.map.get(e.toString())?.value;
        }
        has(e) {
            return this.map.has(e.toString());
        }
        set(e, t) {
            this.map.set(e.toString(), {
                key: e,
                value: t
            });
        }
        keys() {
            return F3(this.map.values(), (e)=>e.key);
        }
        values() {
            return F3(this.map.values(), (e)=>e.value);
        }
        get size() {
            return this.map.size;
        }
    }, WZ = class extends lx {
        metric;
        constructor(e){
            super();
            const { name: t, metrics: r } = e;
            this.metric = r.registerMetric(t), this.updateComponentMetric();
        }
        set(e, t) {
            return super.set(e, t), this.updateComponentMetric(), this;
        }
        delete(e) {
            const t = super.delete(e);
            return this.updateComponentMetric(), t;
        }
        clear() {
            super.clear(), this.updateComponentMetric();
        }
        updateComponentMetric() {
            this.metric.update(this.size);
        }
    };
    function jZ(n) {
        const { name: e, metrics: t } = n;
        let r;
        return t != null ? r = new WZ({
            name: e,
            metrics: t
        }) : r = new lx, r;
    }
    const XZ = 36e5, JZ = 216e5;
    var Oa;
    (function(n) {
        (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.key != null && s.key !== "" && (i.uint32(10), i.string(s.key)), s.value != null && s.value.byteLength > 0 && (i.uint32(18), i.bytes(s.value)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        key: "",
                        value: je(0)
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.key = s.string();
                                    break;
                                }
                            case 2:
                                {
                                    u.value = s.bytes();
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.Peer$metadataEntry || (n.Peer$metadataEntry = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.key != null && s.key !== "" && (i.uint32(10), i.string(s.key)), s.value != null && (i.uint32(18), Vp.codec().encode(s.value, i)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        key: ""
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.key = s.string();
                                    break;
                                }
                            case 2:
                                {
                                    u.value = Vp.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.value
                                    });
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.Peer$tagsEntry || (n.Peer$tagsEntry = {}));
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.addresses != null) for (const i of t.addresses)r.uint32(10), Fp.codec().encode(i, r);
                if (t.protocols != null) for (const i of t.protocols)r.uint32(18), r.string(i);
                if (t.publicKey != null && (r.uint32(34), r.bytes(t.publicKey)), t.peerRecordEnvelope != null && (r.uint32(42), r.bytes(t.peerRecordEnvelope)), t.metadata != null && t.metadata.size !== 0) for (const [i, l] of t.metadata.entries())r.uint32(50), n.Peer$metadataEntry.codec().encode({
                    key: i,
                    value: l
                }, r);
                if (t.tags != null && t.tags.size !== 0) for (const [i, l] of t.tags.entries())r.uint32(58), n.Peer$tagsEntry.codec().encode({
                    key: i,
                    value: l
                }, r);
                t.updated != null && (r.uint32(64), r.uint64Number(t.updated)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    addresses: [],
                    protocols: [],
                    metadata: new Map,
                    tags: new Map
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                if (s.limits?.addresses != null && i.addresses.length === s.limits.addresses) throw new vt('Decode error - map field "addresses" had too many elements');
                                i.addresses.push(Fp.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.addresses$
                                }));
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.protocols != null && i.protocols.length === s.limits.protocols) throw new vt('Decode error - map field "protocols" had too many elements');
                                i.protocols.push(t.string());
                                break;
                            }
                        case 4:
                            {
                                i.publicKey = t.bytes();
                                break;
                            }
                        case 5:
                            {
                                i.peerRecordEnvelope = t.bytes();
                                break;
                            }
                        case 6:
                            {
                                if (s.limits?.metadata != null && i.metadata.size === s.limits.metadata) throw new V9('Decode error - map field "metadata" had too many elements');
                                const h = n.Peer$metadataEntry.codec().decode(t, t.uint32());
                                i.metadata.set(h.key, h.value);
                                break;
                            }
                        case 7:
                            {
                                if (s.limits?.tags != null && i.tags.size === s.limits.tags) throw new V9('Decode error - map field "tags" had too many elements');
                                const h = n.Peer$tagsEntry.codec().decode(t, t.uint32(), {
                                    limits: {
                                        value: s.limits?.tags$value
                                    }
                                });
                                i.tags.set(h.key, h.value);
                                break;
                            }
                        case 8:
                            {
                                i.updated = t.uint64Number();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Oa || (Oa = {}));
    var Fp;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.multiaddr != null && t.multiaddr.byteLength > 0 && (r.uint32(10), r.bytes(t.multiaddr)), t.isCertified != null && (r.uint32(16), r.bool(t.isCertified)), t.observed != null && (r.uint32(24), r.uint64Number(t.observed)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    multiaddr: je(0)
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.multiaddr = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.isCertified = t.bool();
                                break;
                            }
                        case 3:
                            {
                                i.observed = t.uint64Number();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Fp || (Fp = {}));
    var Vp;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.value != null && t.value !== 0 && (r.uint32(8), r.uint32(t.value)), t.expiry != null && (r.uint32(16), r.uint64(t.expiry)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    value: 0
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.value = t.uint32();
                                break;
                            }
                        case 2:
                            {
                                i.expiry = t.uint64();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Vp || (Vp = {}));
    let ds = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, af = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, ZZ = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, eee = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const tee = 4, nee = 6, ree = 273, see = 33, iee = 41, oee = 42, aee = 43, lee = 53, cee = 54, uee = 55, hee = 56, dee = 132, fee = 301, pee = 302, gee = 400, cx = 421, mee = 444, yee = 445, wee = 446, bee = 447, vee = 448, Eee = 449, Aee = 454, See = 460, Iee = 461, Cee = 465, Tee = 466, _ee = 480, xee = 481, Dee = 443, Bee = 477, Pee = 478, kee = 479, Ree = 277, Oee = 275, $ee = 276, Mee = 280, Nee = 281, Lee = 290, Uee = 777;
    function uE(n) {
        return (e)=>L(e, n);
    }
    function hE(n) {
        return (e)=>re(e, n);
    }
    function Kh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function nc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function zee(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = nc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Fee(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = nc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function dE(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Kh(t);
        return `${r}:${s}`;
    }
    const ux = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new ds("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, Vee = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = ux(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new ds("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, Hee = function(n) {
        if (n.byteLength !== 4) throw new ds("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, Qee = function(n) {
        if (n.byteLength !== 16) throw new ds("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new ds(`Invalid IPv6 address "${t}"`);
        }
    };
    function qee(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new ds(`Invalid IPv6 address "${n}"`);
        }
    }
    const V3 = Object.values(un).map((n)=>n.decoder), Kee = (function() {
        let n = V3[0].or(V3[1]);
        return V3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function Gee(n) {
        return Kee.decode(n);
    }
    function Yee(n) {
        return (e)=>n.encoder.encode(e);
    }
    function Wee(n) {
        if (parseInt(n).toString() !== n) throw new af("Value must be an integer");
    }
    function jee(n) {
        if (n < 0) throw new af("Value must be a positive integer, or zero");
    }
    function Xee(n) {
        return (e)=>{
            if (e > n) throw new af(`Value must be smaller than or equal to ${n}`);
        };
    }
    function Jee(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const T0 = Jee(Wee, jee, Xee(65535)), $n = -1;
    let Zee = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new eee(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const hu = new Zee, ete = [
        {
            code: tee,
            name: "ip4",
            size: 32,
            valueToBytes: ux,
            bytesToValue: Hee,
            validate: (n)=>{
                if (!Je(n)) throw new af(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: nee,
            name: "tcp",
            size: 16,
            valueToBytes: nc,
            bytesToValue: Kh,
            validate: T0
        },
        {
            code: ree,
            name: "udp",
            size: 16,
            valueToBytes: nc,
            bytesToValue: Kh,
            validate: T0
        },
        {
            code: see,
            name: "dccp",
            size: 16,
            valueToBytes: nc,
            bytesToValue: Kh,
            validate: T0
        },
        {
            code: iee,
            name: "ip6",
            size: 128,
            valueToBytes: Vee,
            bytesToValue: Qee,
            stringToValue: qee,
            validate: (n)=>{
                if (!xn(n)) throw new af(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: oee,
            name: "ip6zone",
            size: $n
        },
        {
            code: aee,
            name: "ipcidr",
            size: 8,
            bytesToValue: uE("base10"),
            valueToBytes: hE("base10")
        },
        {
            code: lee,
            name: "dns",
            size: $n
        },
        {
            code: cee,
            name: "dns4",
            size: $n
        },
        {
            code: uee,
            name: "dns6",
            size: $n
        },
        {
            code: hee,
            name: "dnsaddr",
            size: $n
        },
        {
            code: dee,
            name: "sctp",
            size: 16,
            valueToBytes: nc,
            bytesToValue: Kh,
            validate: T0
        },
        {
            code: fee,
            name: "udt"
        },
        {
            code: pee,
            name: "utp"
        },
        {
            code: gee,
            name: "unix",
            size: $n,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: cx,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: $n,
            bytesToValue: uE("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? hE("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: mee,
            name: "onion",
            size: 96,
            bytesToValue: dE,
            valueToBytes: zee
        },
        {
            code: yee,
            name: "onion3",
            size: 296,
            bytesToValue: dE,
            valueToBytes: Fee
        },
        {
            code: wee,
            name: "garlic64",
            size: $n
        },
        {
            code: bee,
            name: "garlic32",
            size: $n
        },
        {
            code: vee,
            name: "tls"
        },
        {
            code: Eee,
            name: "sni",
            size: $n
        },
        {
            code: Aee,
            name: "noise"
        },
        {
            code: See,
            name: "quic"
        },
        {
            code: Iee,
            name: "quic-v1"
        },
        {
            code: Cee,
            name: "webtransport"
        },
        {
            code: Tee,
            name: "certhash",
            size: $n,
            bytesToValue: Yee(yn),
            valueToBytes: Gee
        },
        {
            code: _ee,
            name: "http"
        },
        {
            code: xee,
            name: "http-path",
            size: $n,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Dee,
            name: "https"
        },
        {
            code: Bee,
            name: "ws"
        },
        {
            code: Pee,
            name: "wss"
        },
        {
            code: kee,
            name: "p2p-websocket-star"
        },
        {
            code: Ree,
            name: "p2p-stardust"
        },
        {
            code: Oee,
            name: "p2p-webrtc-star"
        },
        {
            code: $ee,
            name: "p2p-webrtc-direct"
        },
        {
            code: Mee,
            name: "webrtc-direct"
        },
        {
            code: Nee,
            name: "webrtc"
        },
        {
            code: Lee,
            name: "p2p-circuit"
        },
        {
            code: Uee,
            name: "memory",
            size: $n
        }
    ];
    ete.forEach((n)=>{
        hu.addProtocol(n);
    });
    function tte(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = hu.getProtocol(r), i = be(r), l = ite(s, n, t + i);
            let u = 0;
            l > 0 && s.size === $n && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function nte(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = hu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === $n && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === $n && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function rte(n) {
        if (n.charAt(0) !== "/") throw new ds('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = hu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new ds(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new ds(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new ds("Incomplete multiaddr");
        return e;
    }
    function ste(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = hu.getProtocol(e.code);
            if (t == null) throw new ds(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function ite(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const ote = Symbol.for("nodejs.util.inspect.custom"), hx = Symbol.for("@multiformats/multiaddr");
    function ate(n) {
        if (n == null && (n = "/"), dx(n)) return n.getComponents();
        if (n instanceof Uint8Array) return tte(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), rte(n);
        if (Array.isArray(n)) return n;
        throw new ds("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let lte = class Gh {
        [hx] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = ate(e), t.validate !== !1 && cte(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = nte(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = ste(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new Gh(e);
            return new Gh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new ZZ(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new Gh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new Gh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [ote]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function cte(n) {
        n.getComponents().forEach((e)=>{
            const t = hu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function dx(n) {
        return !!n?.[hx];
    }
    function a4(n) {
        return new lte(n);
    }
    function ute(n, e) {
        if (n.publicKey != null || e.publicKey == null) return n;
        let t;
        n.type === "RSA" && (t = n.toMultihash());
        const r = Er(e.publicKey, t);
        return yJ(r);
    }
    function hte(n, e, t) {
        const r = Oa.decode(e);
        return Yh(n, r, t);
    }
    function Yh(n, e, t) {
        const r = new Map, s = BigInt(Date.now());
        for (const [i, l] of e.tags.entries())l.expiry != null && l.expiry < s || r.set(i, l);
        return {
            ...e,
            id: ute(n, e),
            addresses: e.addresses.filter(({ observed: i })=>i != null && i > Date.now() - t).map(({ multiaddr: i, isCertified: l })=>({
                    multiaddr: a4(i),
                    isCertified: l ?? !1
                })),
            metadata: e.metadata,
            peerRecordEnvelope: e.peerRecordEnvelope ?? void 0,
            tags: r
        };
    }
    function dte(n, e) {
        return fte(n.addresses, e.addresses) && pte(n.protocols, e.protocols) && gte(n.publicKey, e.publicKey) && mte(n.peerRecordEnvelope, e.peerRecordEnvelope) && yte(n.metadata, e.metadata) && wte(n.tags, e.tags);
    }
    function fte(n, e) {
        return px(n, e, (t, r)=>!(t.isCertified !== r.isCertified || !Ee(t.multiaddr, r.multiaddr)));
    }
    function pte(n, e) {
        return px(n, e, (t, r)=>t === r);
    }
    function gte(n, e) {
        return fx(n, e);
    }
    function mte(n, e) {
        return fx(n, e);
    }
    function yte(n, e) {
        return gx(n, e, (t, r)=>Ee(t, r));
    }
    function wte(n, e) {
        return gx(n, e, (t, r)=>t.value === r.value && t.expiry === r.expiry);
    }
    function fx(n, e) {
        return n == null && e == null ? !0 : n != null && e != null ? Ee(n, e) : !1;
    }
    function px(n, e, t) {
        if (n.length !== e.length) return !1;
        for(let r = 0; r < n.length; r++)if (!t(n[r], e[r])) return !1;
        return !0;
    }
    function gx(n, e, t) {
        if (n.size !== e.size) return !1;
        for (const [r, s] of n.entries()){
            const i = e.get(r);
            if (i == null || !t(s, i)) return !1;
        }
        return !0;
    }
    const mx = "/peers/";
    function _0(n) {
        if (!ap(n) || n.type == null) throw new os("Invalid PeerId");
        const e = n.toCID().toString();
        return new Nt(`${mx}${e}`);
    }
    async function bte(n, e, t, r, s) {
        const i = new Map;
        for (const l of t){
            if (l == null) continue;
            if (l.multiaddr instanceof Uint8Array && (l.multiaddr = a4(l.multiaddr)), !dx(l.multiaddr)) throw new os("Multiaddr was invalid");
            if (!await e(n, l.multiaddr, s)) continue;
            const u = l.isCertified ?? !1, h = l.multiaddr.toString(), f = i.get(h);
            f != null ? l.isCertified = f.isCertified || u : i.set(h, {
                multiaddr: l.multiaddr,
                isCertified: u
            });
        }
        return [
            ...i.values()
        ].sort((l, u)=>l.multiaddr.toString().localeCompare(u.multiaddr.toString())).map(({ isCertified: l, multiaddr: u })=>{
            const h = u.getComponents().find((f)=>f.code === cx)?.value;
            return n.equals(h) && (u = u.decapsulate(a4(`/p2p/${n}`))), {
                isCertified: l,
                multiaddr: u.bytes
            };
        });
    }
    async function H3(n, e, t, r) {
        if (e == null) throw new os("Invalid PeerData");
        if (e.publicKey != null && n.publicKey != null && !e.publicKey.equals(n.publicKey)) throw new os("publicKey bytes do not match peer id publicKey bytes");
        const s = r.existingPeer?.peer;
        if (s != null && !n.equals(s.id)) throw new os("peer id did not match existing peer id");
        let i = s?.addresses ?? [], l = new Set(s?.protocols ?? []), u = s?.metadata ?? new Map, h = s?.tags ?? new Map, f = s?.peerRecordEnvelope;
        if (t === "patch") {
            if ((e.multiaddrs != null || e.addresses != null) && (i = [], e.multiaddrs != null && i.push(...e.multiaddrs.map((w)=>({
                    isCertified: !1,
                    multiaddr: w
                }))), e.addresses != null && i.push(...e.addresses)), e.protocols != null && (l = new Set(e.protocols)), e.metadata != null) {
                const w = e.metadata instanceof Map ? [
                    ...e.metadata.entries()
                ] : Object.entries(e.metadata);
                u = x0(w, {
                    validate: fE
                });
            }
            if (e.tags != null) {
                const w = e.tags instanceof Map ? [
                    ...e.tags.entries()
                ] : Object.entries(e.tags);
                h = x0(w, {
                    validate: pE,
                    map: gE
                });
            }
            e.peerRecordEnvelope != null && (f = e.peerRecordEnvelope);
        }
        if (t === "merge") {
            if (e.multiaddrs != null && i.push(...e.multiaddrs.map((w)=>({
                    isCertified: !1,
                    multiaddr: w
                }))), e.addresses != null && i.push(...e.addresses), e.protocols != null && (l = new Set([
                ...l,
                ...e.protocols
            ])), e.metadata != null) {
                const w = e.metadata instanceof Map ? [
                    ...e.metadata.entries()
                ] : Object.entries(e.metadata);
                for (const [A, S] of w)S == null ? u.delete(A) : u.set(A, S);
                u = x0([
                    ...u.entries()
                ], {
                    validate: fE
                });
            }
            if (e.tags != null) {
                const w = e.tags instanceof Map ? [
                    ...e.tags.entries()
                ] : Object.entries(e.tags), A = new Map(h);
                for (const [S, _] of w)_ == null ? A.delete(S) : A.set(S, _);
                h = x0([
                    ...A.entries()
                ], {
                    validate: pE,
                    map: gE
                });
            }
            e.peerRecordEnvelope != null && (f = e.peerRecordEnvelope);
        }
        let p;
        s?.id.publicKey != null ? p = Fr(s.id.publicKey) : e.publicKey != null ? p = Fr(e.publicKey) : n.publicKey != null && (p = Fr(n.publicKey));
        const m = {
            addresses: await bte(n, r.addressFilter ?? (async ()=>!0), i, r.existingPeer?.peerPB.addresses, r),
            protocols: [
                ...l.values()
            ].sort((w, A)=>w.localeCompare(A)),
            metadata: u,
            tags: h,
            publicKey: p,
            peerRecordEnvelope: f
        };
        return m.addresses.forEach((w)=>{
            w.observed = r.existingPeer?.peerPB.addresses?.find((A)=>Ee(A.multiaddr, A.multiaddr))?.observed ?? Date.now();
        }), n.type !== "RSA" && delete m.publicKey, m;
    }
    function x0(n, e) {
        const t = new Map;
        for (const [r, s] of n)s != null && e.validate(r, s);
        for (const [r, s] of n.sort(([i], [l])=>i.localeCompare(l)))s != null && t.set(r, e.map?.(r, s) ?? s);
        return t;
    }
    function fE(n, e) {
        if (typeof n != "string") throw new os("Metadata key must be a string");
        if (!(e instanceof Uint8Array)) throw new os("Metadata value must be a Uint8Array");
    }
    function pE(n, e) {
        if (typeof n != "string") throw new os("Tag name must be a string");
        if (e.value != null) {
            if (parseInt(`${e.value}`, 10) !== e.value) throw new os("Tag value must be an integer");
            if (e.value < 0 || e.value > 100) throw new os("Tag value must be between 0-100");
        }
        if (e.ttl != null) {
            if (parseInt(`${e.ttl}`, 10) !== e.ttl) throw new os("Tag ttl must be an integer");
            if (e.ttl < 0) throw new os("Tag ttl must be between greater than 0");
        }
    }
    function gE(n, e) {
        let t;
        e.expiry != null && (t = e.expiry), e.ttl != null && (t = BigInt(Date.now() + Number(e.ttl)));
        const r = {
            value: e.value ?? 0
        };
        return t != null && (r.expiry = t), r;
    }
    function yx(n) {
        const e = n.toString().split("/")[2], t = ge.parse(e, At);
        return rx(t);
    }
    function Q3(n, e, t) {
        const r = yx(n);
        return hte(r, e, t);
    }
    function vte(n, e) {
        return {
            prefix: mx,
            filters: (n.filters ?? []).map((t)=>({ key: r, value: s })=>t(Q3(r, s, e))),
            orders: (n.orders ?? []).map((t)=>(r, s)=>t(Q3(r.key, r.value, e), Q3(s.key, s.value, e)))
        };
    }
    class Ete {
        peerId;
        datastore;
        locks;
        addressFilter;
        log;
        maxAddressAge;
        maxPeerAge;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:peer-store"), this.peerId = e.peerId, this.datastore = e.datastore, this.addressFilter = t.addressFilter, this.locks = jZ({
                name: "libp2p_peer_store_locks",
                metrics: e.metrics
            }), this.maxAddressAge = t.maxAddressAge ?? XZ, this.maxPeerAge = t.maxPeerAge ?? JZ;
        }
        getLock(e) {
            let t = this.locks.get(e);
            return t == null && (t = {
                refs: 0,
                lock: fT({
                    name: e.toString(),
                    singleProcess: !0
                })
            }, this.locks.set(e, t)), t.refs++, t;
        }
        maybeRemoveLock(e, t) {
            t.refs--, t.refs === 0 && (t.lock.finalize(), this.locks.delete(e));
        }
        async getReadLock(e, t) {
            const r = this.getLock(e);
            try {
                const s = await r.lock.readLock(t);
                return ()=>{
                    s(), this.maybeRemoveLock(e, r);
                };
            } catch (s) {
                throw this.maybeRemoveLock(e, r), s;
            }
        }
        async getWriteLock(e, t) {
            const r = this.getLock(e);
            try {
                const s = await r.lock.writeLock(t);
                return ()=>{
                    s(), this.maybeRemoveLock(e, r);
                };
            } catch (s) {
                throw this.maybeRemoveLock(e, r), s;
            }
        }
        async has(e, t) {
            try {
                return await this.load(e, t), !0;
            } catch (r) {
                if (r.name !== "NotFoundError") throw r;
            }
            return !1;
        }
        async delete(e, t) {
            this.peerId.equals(e) || await this.datastore.delete(_0(e), t);
        }
        async load(e, t) {
            const r = _0(e), s = await this.datastore.get(r, t), i = Oa.decode(s);
            if (this.#n(e, i)) throw await this.datastore.delete(r, t), new sE;
            return Yh(e, i, this.peerId.equals(e) ? 1 / 0 : this.maxAddressAge);
        }
        async save(e, t, r) {
            const s = await this.#e(e, r), i = await H3(e, t, "patch", {
                ...r,
                addressFilter: this.addressFilter
            });
            return this.#t(e, i, s);
        }
        async patch(e, t, r) {
            const s = await this.#e(e, r), i = await H3(e, t, "patch", {
                ...r,
                addressFilter: this.addressFilter,
                existingPeer: s
            });
            return this.#t(e, i, s);
        }
        async merge(e, t, r) {
            const s = await this.#e(e, r), i = await H3(e, t, "merge", {
                addressFilter: this.addressFilter,
                existingPeer: s
            });
            return this.#t(e, i, s);
        }
        async *all(e) {
            for await (const { key: t, value: r } of this.datastore.query(vte(e ?? {}, this.maxAddressAge), e)){
                const s = yx(t);
                if (s.equals(this.peerId)) continue;
                const i = Oa.decode(r);
                if (this.#n(s, i)) {
                    await this.datastore.delete(t, e);
                    continue;
                }
                yield Yh(s, i, this.peerId.equals(s) ? 1 / 0 : this.maxAddressAge);
            }
        }
        async #e(e, t) {
            try {
                const r = _0(e), s = await this.datastore.get(r, t), i = Oa.decode(s);
                if (this.#n(e, i)) throw await this.datastore.delete(r, t), new sE;
                return {
                    peerPB: i,
                    peer: Yh(e, i, this.maxAddressAge)
                };
            } catch (r) {
                r.name !== "NotFoundError" && this.log.error("invalid peer data found in peer store - %e", r);
            }
        }
        async #t(e, t, r, s) {
            t.updated = Date.now();
            const i = Oa.encode(t);
            return await this.datastore.put(_0(e), i, s), {
                peer: Yh(e, t, this.maxAddressAge),
                previous: r?.peer,
                updated: r == null || !dte(t, r.peerPB)
            };
        }
        #n(e, t) {
            if (t.updated == null) return !0;
            if (this.peerId.equals(e)) return !1;
            const r = t.updated < Date.now() - this.maxPeerAge, s = Date.now() - this.maxAddressAge, i = t.addresses.filter((l)=>l.observed != null && l.observed > s);
            return r && i.length === 0;
        }
    }
    class Ate {
        store;
        events;
        peerId;
        log;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:peer-store"), this.events = e.events, this.peerId = e.peerId, this.store = new Ete(e, t);
        }
        [Symbol.toStringTag] = "@libp2p/peer-store";
        async forEach(e, t) {
            for await (const r of this.store.all(t))e(r);
        }
        async all(e) {
            return sf(this.store.all(e));
        }
        async delete(e, t) {
            const r = await this.store.getReadLock(e, t);
            try {
                await this.store.delete(e, t);
            } finally{
                r();
            }
        }
        async has(e, t) {
            const r = await this.store.getReadLock(e, t);
            try {
                return await this.store.has(e, t);
            } finally{
                this.log.trace("has release read lock"), r?.();
            }
        }
        async get(e, t) {
            const r = await this.store.getReadLock(e, t);
            try {
                return await this.store.load(e, t);
            } finally{
                r?.();
            }
        }
        async getInfo(e, t) {
            const r = await this.get(e, t);
            return {
                id: r.id,
                multiaddrs: r.addresses.map(({ multiaddr: s })=>s)
            };
        }
        async save(e, t, r) {
            const s = await this.store.getWriteLock(e, r);
            try {
                const i = await this.store.save(e, t, r);
                return this.#e(e, i), i.peer;
            } finally{
                s?.();
            }
        }
        async patch(e, t, r) {
            const s = await this.store.getWriteLock(e, r);
            try {
                const i = await this.store.patch(e, t, r);
                return this.#e(e, i), i.peer;
            } finally{
                s?.();
            }
        }
        async merge(e, t, r) {
            const s = await this.store.getWriteLock(e, r);
            try {
                const i = await this.store.merge(e, t, r);
                return this.#e(e, i), i.peer;
            } finally{
                s?.();
            }
        }
        async consumePeerRecord(e, t, r) {
            const s = ap(t) ? t : ap(t?.expectedPeer) ? t.expectedPeer : void 0, i = ap(t) || t === void 0 ? r : t, l = await ci.openAndCertify(e, Ur.DOMAIN, i), u = rx(l.publicKey.toCID());
            if (s?.equals(u) === !1) return this.log("envelope peer id was not the expected peer id - expected: %p received: %p", s, u), !1;
            const h = Ur.createFromProtobuf(l.payload);
            let f;
            try {
                f = await this.get(u, i);
            } catch (p) {
                if (p.name !== "NotFoundError") throw p;
            }
            if (f?.peerRecordEnvelope != null) {
                const p = ci.createFromProtobuf(f.peerRecordEnvelope), m = Ur.createFromProtobuf(p.payload);
                if (m.seqNumber >= h.seqNumber) return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", m.seqNumber, h.seqNumber), !1;
            }
            return await this.patch(h.peerId, {
                peerRecordEnvelope: e,
                addresses: h.multiaddrs.map((p)=>({
                        isCertified: !0,
                        multiaddr: p
                    }))
            }, i), !0;
        }
        #e(e, t) {
            t.updated && (this.peerId.equals(e) ? this.events.safeDispatchEvent("self:peer:update", {
                detail: t
            }) : this.events.safeDispatchEvent("peer:update", {
                detail: t
            }));
        }
    }
    function Ste(n, e = {}) {
        return new Ate(n, e);
    }
    let fs = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, lf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, Ite = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, Cte = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const l4 = 4, Tte = 6, _te = 273, xte = 33, c4 = 41, Dte = 42, Bte = 43, Pte = 53, kte = 54, Rte = 55, Ote = 56, $te = 132, Mte = 301, Nte = 302, Lte = 400, fi = 421, Ute = 444, zte = 445, Fte = 446, Vte = 447, wx = 448, u4 = 449, Hte = 454, Qte = 460, qte = 461, Kte = 465, Gte = 466, Yte = 480, Wte = 481, jte = 443, Xte = 477, Jte = 478, Zte = 479, ene = 277, tne = 275, nne = 276, rne = 280, sne = 281, ine = 290, one = 777;
    function mE(n) {
        return (e)=>L(e, n);
    }
    function yE(n) {
        return (e)=>re(e, n);
    }
    function Wh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function rc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function ane(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = rc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function lne(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = rc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function wE(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Wh(t);
        return `${r}:${s}`;
    }
    const bx = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new fs("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, cne = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = bx(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new fs("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, une = function(n) {
        if (n.byteLength !== 4) throw new fs("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, hne = function(n) {
        if (n.byteLength !== 16) throw new fs("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new fs(`Invalid IPv6 address "${t}"`);
        }
    };
    function dne(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new fs(`Invalid IPv6 address "${n}"`);
        }
    }
    const q3 = Object.values(un).map((n)=>n.decoder), fne = (function() {
        let n = q3[0].or(q3[1]);
        return q3.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function pne(n) {
        return fne.decode(n);
    }
    function gne(n) {
        return (e)=>n.encoder.encode(e);
    }
    function mne(n) {
        if (parseInt(n).toString() !== n) throw new lf("Value must be an integer");
    }
    function yne(n) {
        if (n < 0) throw new lf("Value must be a positive integer, or zero");
    }
    function wne(n) {
        return (e)=>{
            if (e > n) throw new lf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function bne(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const D0 = bne(mne, yne, wne(65535)), Mn = -1;
    let vne = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new Cte(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const du = new vne, Ene = [
        {
            code: l4,
            name: "ip4",
            size: 32,
            valueToBytes: bx,
            bytesToValue: une,
            validate: (n)=>{
                if (!Je(n)) throw new lf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: Tte,
            name: "tcp",
            size: 16,
            valueToBytes: rc,
            bytesToValue: Wh,
            validate: D0
        },
        {
            code: _te,
            name: "udp",
            size: 16,
            valueToBytes: rc,
            bytesToValue: Wh,
            validate: D0
        },
        {
            code: xte,
            name: "dccp",
            size: 16,
            valueToBytes: rc,
            bytesToValue: Wh,
            validate: D0
        },
        {
            code: c4,
            name: "ip6",
            size: 128,
            valueToBytes: cne,
            bytesToValue: hne,
            stringToValue: dne,
            validate: (n)=>{
                if (!xn(n)) throw new lf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: Dte,
            name: "ip6zone",
            size: Mn
        },
        {
            code: Bte,
            name: "ipcidr",
            size: 8,
            bytesToValue: mE("base10"),
            valueToBytes: yE("base10")
        },
        {
            code: Pte,
            name: "dns",
            size: Mn
        },
        {
            code: kte,
            name: "dns4",
            size: Mn
        },
        {
            code: Rte,
            name: "dns6",
            size: Mn
        },
        {
            code: Ote,
            name: "dnsaddr",
            size: Mn
        },
        {
            code: $te,
            name: "sctp",
            size: 16,
            valueToBytes: rc,
            bytesToValue: Wh,
            validate: D0
        },
        {
            code: Mte,
            name: "udt"
        },
        {
            code: Nte,
            name: "utp"
        },
        {
            code: Lte,
            name: "unix",
            size: Mn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: fi,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Mn,
            bytesToValue: mE("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? yE("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: Ute,
            name: "onion",
            size: 96,
            bytesToValue: wE,
            valueToBytes: ane
        },
        {
            code: zte,
            name: "onion3",
            size: 296,
            bytesToValue: wE,
            valueToBytes: lne
        },
        {
            code: Fte,
            name: "garlic64",
            size: Mn
        },
        {
            code: Vte,
            name: "garlic32",
            size: Mn
        },
        {
            code: wx,
            name: "tls"
        },
        {
            code: u4,
            name: "sni",
            size: Mn
        },
        {
            code: Hte,
            name: "noise"
        },
        {
            code: Qte,
            name: "quic"
        },
        {
            code: qte,
            name: "quic-v1"
        },
        {
            code: Kte,
            name: "webtransport"
        },
        {
            code: Gte,
            name: "certhash",
            size: Mn,
            bytesToValue: gne(yn),
            valueToBytes: pne
        },
        {
            code: Yte,
            name: "http"
        },
        {
            code: Wte,
            name: "http-path",
            size: Mn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: jte,
            name: "https"
        },
        {
            code: Xte,
            name: "ws"
        },
        {
            code: Jte,
            name: "wss"
        },
        {
            code: Zte,
            name: "p2p-websocket-star"
        },
        {
            code: ene,
            name: "p2p-stardust"
        },
        {
            code: tne,
            name: "p2p-webrtc-star"
        },
        {
            code: nne,
            name: "p2p-webrtc-direct"
        },
        {
            code: rne,
            name: "webrtc-direct"
        },
        {
            code: sne,
            name: "webrtc"
        },
        {
            code: ine,
            name: "p2p-circuit"
        },
        {
            code: one,
            name: "memory",
            size: Mn
        }
    ];
    Ene.forEach((n)=>{
        du.addProtocol(n);
    });
    function Ane(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = du.getProtocol(r), i = be(r), l = Tne(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Mn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function Sne(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = du.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Mn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Mn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function Ine(n) {
        if (n.charAt(0) !== "/") throw new fs('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = du.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new fs(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new fs(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new fs("Incomplete multiaddr");
        return e;
    }
    function Cne(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = du.getProtocol(e.code);
            if (t == null) throw new fs(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function Tne(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const _ne = Symbol.for("nodejs.util.inspect.custom"), vx = Symbol.for("@multiformats/multiaddr");
    function xne(n) {
        if (n == null && (n = "/"), w8(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Ane(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), Ine(n);
        if (Array.isArray(n)) return n;
        throw new fs("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let Dne = class jh {
        [vx] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = xne(e), t.validate !== !1 && Bne(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = Sne(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = Cne(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new jh(e);
            return new jh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new Ite(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new jh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new jh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [_ne]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function Bne(n) {
        n.getComponents().forEach((e)=>{
            const t = du.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function w8(n) {
        return !!n?.[vx];
    }
    function Yn(n) {
        return new Dne(n);
    }
    const bE = 864e13;
    class Pne {
        log;
        mappings;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:address-manager:dns-mappings"), this.mappings = Qs({
                name: "libp2p_address_manager_dns_mappings",
                metrics: e.metrics
            });
        }
        has(e) {
            const t = Xe(e);
            let r = t.host;
            (t.type === "ip4" || t.type === "ip6") && t.sni != null && (r = t.sni);
            for (const s of this.mappings.values())if (s.domain === r) return !0;
            return !1;
        }
        add(e, t) {
            t.forEach((r)=>{
                this.log("add DNS mapping %s to %s", r, e);
                const s = _6(r) === !0;
                this.mappings.set(r, {
                    domain: e,
                    verified: s,
                    expires: s ? bE - Date.now() : 0,
                    lastVerified: s ? bE - Date.now() : void 0
                });
            });
        }
        remove(e) {
            const t = Xe(e);
            if (t.type !== "ip4" && t.type !== "ip6") return !1;
            let r = !1;
            for (const [s, i] of this.mappings.entries())i.domain === t.sni && (this.log("removing %s to %s DNS mapping %e", s, i.domain), this.mappings.delete(s), r = r || i.verified);
            return r;
        }
        getAll(e) {
            const t = [];
            for(let r = 0; r < e.length; r++){
                const s = e[r].multiaddr;
                if (!zs(s)) continue;
                const i = Xe(s);
                for (const [l, u] of this.mappings.entries()){
                    if (i.host !== l) continue;
                    const h = this.maybeAddSNIComponent(s, u.domain);
                    h != null && (e.splice(r, 1), r--, t.push({
                        multiaddr: h,
                        verified: u.verified,
                        type: "dns-mapping",
                        expires: u.expires,
                        lastVerified: u.lastVerified
                    }));
                }
            }
            return t;
        }
        maybeAddSNIComponent(e, t) {
            const r = e.getComponents();
            for(let s = 0; s < r.length; s++)if (r[s].code === wx && r[s + 1]?.code !== u4) return r.splice(s + 1, 0, {
                name: "sni",
                code: u4,
                value: t
            }), Yn(r);
        }
        confirm(e, t) {
            const r = Xe(e);
            let s = r.host;
            (r.type === "ip4" || r.type === "ip6") && r.sni != null && (s = r.sni);
            let i = !1;
            for (const [l, u] of this.mappings.entries())u.domain === s && (this.log("marking %s to %s DNS mapping as verified", l, u.domain), i = u.verified, u.verified = !0, u.expires = Date.now() + t, u.lastVerified = Date.now());
            return i;
        }
        unconfirm(e, t) {
            const r = Xe(e);
            if (r.type !== "ip4" && r.type !== "ip6") return !1;
            const s = r.sni ?? r.host;
            let i = !1;
            for (const [l, u] of this.mappings.entries())u.domain === s && (this.log("removing verification of %s to %s DNS mapping", l, u.domain), i = i || u.verified, u.verified = !1, u.expires = Date.now() + t);
            return i;
        }
    }
    class kne {
        log;
        mappings;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:address-manager:ip-mappings"), this.mappings = Qs({
                name: "libp2p_address_manager_ip_mappings",
                metrics: e.metrics
            });
        }
        has(e) {
            const t = Xe(e);
            if (t.type !== "ip4" && t.type !== "ip6") return !1;
            for (const r of this.mappings.values())for (const s of r)if (s.externalIp === t.host) return !0;
            return !1;
        }
        add(e, t, r, s = t, i = "tcp") {
            const l = `${e}-${t}-${i}`, u = this.mappings.get(l) ?? [], h = {
                internalIp: e,
                internalPort: t,
                externalIp: r,
                externalPort: s,
                externalFamily: Je(r) ? 4 : 6,
                protocol: i,
                verified: !1,
                expires: 0
            };
            u.push(h), this.mappings.set(l, u);
        }
        remove(e) {
            const t = Xe(e);
            if (t.type !== "ip4" && t.type !== "ip6") return !1;
            let r = !1;
            for (const [s, i] of this.mappings.entries()){
                for(let l = 0; l < i.length; l++){
                    const u = i[l];
                    u.externalIp === t.host && u.externalPort === t.port && u.protocol === t.protocol && (this.log("removing %s:%s to %s:%s %s IP mapping", u.externalIp, u.externalPort, t.host, t.port, t.protocol), r = r || u.verified, i.splice(l, 1), l--);
                }
                i.length === 0 && this.mappings.delete(s);
            }
            return r;
        }
        getAll(e) {
            const t = [];
            for (const { multiaddr: r } of e){
                if (!zs(r)) continue;
                const s = Xe(r);
                if (s.type !== "ip4" && s.type !== "ip6") continue;
                let i;
                if (s.protocol === "tcp" ? i = `${s.host}-${s.port}-tcp` : s.protocol === "udp" && (i = `${s.host}-${s.port}-udp`), i == null) continue;
                const l = this.mappings.get(i);
                if (l != null) for (const u of l)t.push({
                    multiaddr: this.maybeOverrideIp(r, u.externalIp, u.externalFamily, u.protocol, u.externalPort),
                    verified: u.verified,
                    type: "ip-mapping",
                    expires: u.expires,
                    lastVerified: u.lastVerified
                });
            }
            return t;
        }
        maybeOverrideIp(e, t, r, s, i) {
            const l = e.getComponents(), u = l.findIndex((f)=>f.code === l4 || f.code === c4), h = l.findIndex((f)=>f.name === s);
            return u > -1 && h > -1 ? (l[u].value = t, l[u].code = r === 4 ? l4 : c4, l[h].value = `${i}`, Yn(l)) : e;
        }
        confirm(e, t) {
            if (!zs(e)) return !1;
            const r = Xe(e);
            let s = !1;
            for (const i of this.mappings.values())for (const l of i)l.externalIp === r.host && (this.log("marking %s to %s IP mapping as verified", l.internalIp, l.externalIp), s = l.verified, l.verified = !0, l.expires = Date.now() + t, l.lastVerified = Date.now());
            return s;
        }
        unconfirm(e, t) {
            if (!zs(e)) return !1;
            const r = Xe(e);
            let s = !1;
            for (const i of this.mappings.values())for(let l = 0; l < i.length; l++){
                const u = i[l];
                u.externalIp === r.host && u.externalPort === r.port && u.protocol === r.protocol && (this.log("removing verification of %s:%s to %s:%s %s IP mapping", u.externalIp, u.externalPort, r.host, r.port, r.protocol), s = s || u.verified, u.verified = !1, u.expires = Date.now() + t);
            }
            return s;
        }
    }
    const Rne = {
        maxObservedAddresses: 10
    };
    class One {
        log;
        addresses;
        maxObservedAddresses;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:address-manager:observed-addresses"), this.addresses = Qs({
                name: "libp2p_address_manager_observed_addresses",
                metrics: e.metrics
            }), this.maxObservedAddresses = t.maxObservedAddresses ?? Rne.maxObservedAddresses;
        }
        has(e) {
            return this.addresses.has(e.toString());
        }
        removePrefixed(e) {
            for (const t of this.addresses.keys())t.toString().startsWith(e) && this.addresses.delete(t);
        }
        add(e) {
            this.addresses.size !== this.maxObservedAddresses && (Is(e) || mz(e) || (this.log("adding observed address %a", e), this.addresses.set(e.toString(), {
                verified: !1,
                expires: 0
            })));
        }
        getAll() {
            return Array.from(this.addresses).map(([e, t])=>({
                    multiaddr: Yn(e),
                    verified: t.verified,
                    type: "observed",
                    expires: t.expires,
                    lastVerified: t.lastVerified
                }));
        }
        remove(e) {
            const t = this.addresses.get(e.toString())?.verified ?? !1;
            return this.log("removing observed address %a", e), this.addresses.delete(e.toString()), t;
        }
        confirm(e, t) {
            const r = e.toString(), s = this.addresses.get(r) ?? {
                verified: !1,
                expires: Date.now() + t,
                lastVerified: Date.now()
            }, i = s.verified;
            return s.verified = !0, s.expires = Date.now() + t, s.lastVerified = Date.now(), this.log("marking observed address %a as verified", r), this.addresses.set(r, s), i;
        }
    }
    const $ne = {
        maxObservedAddresses: 10
    };
    class Mne {
        log;
        addresses;
        maxObservedAddresses;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:address-manager:observed-addresses"), this.addresses = Qs({
                name: "libp2p_address_manager_transport_addresses",
                metrics: e.metrics
            }), this.maxObservedAddresses = t.maxObservedAddresses ?? $ne.maxObservedAddresses;
        }
        get(e, t) {
            if (Is(e)) return {
                multiaddr: e,
                verified: !0,
                type: "transport",
                expires: Date.now() + t,
                lastVerified: Date.now()
            };
            const r = this.toKey(e);
            let s = this.addresses.get(r);
            return s == null && (s = {
                verified: !zs(e),
                expires: 0
            }, this.addresses.set(r, s)), {
                multiaddr: e,
                verified: s.verified,
                type: "transport",
                expires: s.expires,
                lastVerified: s.lastVerified
            };
        }
        has(e) {
            const t = this.toKey(e);
            return this.addresses.has(t);
        }
        remove(e) {
            const t = this.toKey(e), r = this.addresses.get(t)?.verified ?? !1;
            return this.log("removing observed address %a", e), this.addresses.delete(t), r;
        }
        confirm(e, t) {
            const r = this.toKey(e), s = this.addresses.get(r) ?? {
                verified: !1,
                expires: 0,
                lastVerified: 0
            }, i = s.verified;
            return s.verified = !0, s.expires = Date.now() + t, s.lastVerified = Date.now(), this.addresses.set(r, s), i;
        }
        unconfirm(e, t) {
            const r = this.toKey(e), s = this.addresses.get(r) ?? {
                verified: !1,
                expires: 0
            }, i = s.verified;
            return s.verified = !1, s.expires = Date.now() + t, this.addresses.set(r, s), i;
        }
        toKey(e) {
            if (!zs(e)) return e.toString();
            const t = Xe(e);
            return `${t.host}-${t.port}-${t.protocol}`;
        }
    }
    const vE = 6e4, EE = {
        addressVerificationTTL: vE * 10,
        addressVerificationRetry: vE * 5
    }, Nne = (n)=>n;
    function K3(n, e) {
        const t = n.getComponents().findLast((r)=>r.code === fi)?.value;
        return t != null && Fc(t).equals(e) && (n = n.decapsulate(Yn(`/p2p/${e.toString()}`))), n;
    }
    class Lne {
        log;
        components;
        listen;
        announce;
        appendAnnounce;
        announceFilter;
        observed;
        dnsMappings;
        ipMappings;
        transportAddresses;
        observedAddressFilter;
        addressVerificationTTL;
        addressVerificationRetry;
        constructor(e, t = {}){
            const { listen: r = [], announce: s = [], appendAnnounce: i = [] } = t;
            this.components = e, this.log = e.logger.forComponent("libp2p:address-manager"), this.listen = r.map((l)=>l.toString()), this.announce = new Set(s.map((l)=>l.toString())), this.appendAnnounce = new Set(i.map((l)=>l.toString())), this.observed = new One(e, t), this.dnsMappings = new Pne(e, t), this.ipMappings = new kne(e, t), this.transportAddresses = new Mne(e, t), this.announceFilter = t.announceFilter ?? Nne, this.observedAddressFilter = Wi(1024), this.addressVerificationTTL = t.addressVerificationTTL ?? EE.addressVerificationTTL, this.addressVerificationRetry = t.addressVerificationRetry ?? EE.addressVerificationRetry, this._updatePeerStoreAddresses = zd(this._updatePeerStoreAddresses.bind(this), 1e3), e.events.addEventListener("transport:listening", ()=>{
                this._updatePeerStoreAddresses();
            }), e.events.addEventListener("transport:close", ()=>{
                this._updatePeerStoreAddresses();
            });
        }
        [Symbol.toStringTag] = "@libp2p/address-manager";
        _updatePeerStoreAddresses() {
            const e = this.getAddresses().map((t)=>t.getComponents().findLast((r)=>r.code === fi)?.value === this.components.peerId.toString() ? t.decapsulate(`/p2p/${this.components.peerId.toString()}`) : t);
            this.components.peerStore.patch(this.components.peerId, {
                multiaddrs: e
            }).catch((t)=>{
                this.log.error("error updating addresses - %e", t);
            });
        }
        getListenAddrs() {
            return Array.from(this.listen).map((e)=>Yn(e));
        }
        getAnnounceAddrs() {
            return Array.from(this.announce).map((e)=>Yn(e));
        }
        getAppendAnnounceAddrs() {
            return Array.from(this.appendAnnounce).map((e)=>Yn(e));
        }
        getObservedAddrs() {
            return this.observed.getAll().map((e)=>e.multiaddr);
        }
        addObservedAddr(e) {
            const t = Xe(e);
            let r;
            switch(t.type){
                case "ip4":
                    {
                        r = `${t.host}:${t.port}`;
                        break;
                    }
                case "ip6":
                    {
                        r = `[${t.host}]:${t.port}`;
                        break;
                    }
                default:
                    return;
            }
            this.observedAddressFilter.has(r) || (this.observedAddressFilter.add(r), e = K3(e, this.components.peerId), !this.ipMappings.has(e) && (this.dnsMappings.has(e) || this.observed.add(e)));
        }
        confirmObservedAddr(e, t) {
            e = K3(e, this.components.peerId);
            let r = !0;
            (t?.type === "transport" || this.transportAddresses.has(e)) && !this.transportAddresses.confirm(e, t?.ttl ?? this.addressVerificationTTL) && r && (r = !1), (t?.type === "dns-mapping" || this.dnsMappings.has(e)) && !this.dnsMappings.confirm(e, t?.ttl ?? this.addressVerificationTTL) && r && (r = !1), (t?.type === "ip-mapping" || this.ipMappings.has(e)) && !this.ipMappings.confirm(e, t?.ttl ?? this.addressVerificationTTL) && r && (r = !1), (t?.type === "observed" || this.observed.has(e)) && (this.maybeUpgradeToIPMapping(e) ? (this.ipMappings.confirm(e, t?.ttl ?? this.addressVerificationTTL), r = !1) : !this.observed.confirm(e, t?.ttl ?? this.addressVerificationTTL) && r && (r = !1)), r || this._updatePeerStoreAddresses();
        }
        removeObservedAddr(e, t) {
            e = K3(e, this.components.peerId), this.observed.has(e) && this.observed.remove(e), this.transportAddresses.has(e) && this.transportAddresses.unconfirm(e, t?.ttl ?? this.addressVerificationRetry), this.dnsMappings.has(e) && this.dnsMappings.unconfirm(e, t?.ttl ?? this.addressVerificationRetry), this.ipMappings.has(e) && this.ipMappings.unconfirm(e, t?.ttl ?? this.addressVerificationRetry);
        }
        getAddresses() {
            const e = new Set, t = this.getAddressesWithMetadata().filter((r)=>{
                if (!r.verified) return !1;
                const s = r.multiaddr.toString();
                return e.has(s) ? !1 : (e.add(s), !0);
            }).map((r)=>r.multiaddr);
            return this.announceFilter(t.map((r)=>{
                const s = Yn(r);
                return s.getComponents().pop()?.value === this.components.peerId.toString() ? s : s.encapsulate(`/p2p/${this.components.peerId.toString()}`);
            }));
        }
        getAddressesWithMetadata() {
            const e = this.getAnnounceAddrs();
            if (e.length > 0) return this.components.transportManager.getListeners().forEach((s)=>{
                s.updateAnnounceAddrs(e);
            }), e.map((s)=>({
                    multiaddr: s,
                    verified: !0,
                    type: "announce",
                    expires: Date.now() + this.addressVerificationTTL,
                    lastVerified: Date.now()
                }));
            let t = [];
            t = t.concat(this.components.transportManager.getAddrs().map((s)=>this.transportAddresses.get(s, this.addressVerificationTTL)));
            const r = this.getAppendAnnounceAddrs();
            return r.length > 0 && (this.components.transportManager.getListeners().forEach((s)=>{
                s.updateAnnounceAddrs(r);
            }), t = t.concat(r.map((s)=>({
                    multiaddr: s,
                    verified: !0,
                    type: "announce",
                    expires: Date.now() + this.addressVerificationTTL,
                    lastVerified: Date.now()
                })))), t = t.concat(this.observed.getAll()), t = t.concat(this.ipMappings.getAll(t)), t = t.concat(this.dnsMappings.getAll(t)), t;
        }
        addDNSMapping(e, t) {
            this.dnsMappings.add(e, t);
        }
        removeDNSMapping(e) {
            this.dnsMappings.remove(Yn(`/dns/${e}`)) && this._updatePeerStoreAddresses();
        }
        addPublicAddressMapping(e, t, r, s = t, i = "tcp") {
            this.ipMappings.add(e, t, r, s, i), this.observed.removePrefixed(`/ip${Je(r) ? 4 : 6}/${r}/${i}/${s}`);
        }
        removePublicAddressMapping(e, t, r, s = t, i = "tcp") {
            this.ipMappings.remove(Yn(`/ip${Je(r) ? 4 : 6}/${r}/${i}/${s}`)) && this._updatePeerStoreAddresses();
        }
        maybeUpgradeToIPMapping(e) {
            if (this.ipMappings.has(e) || !zs(e)) return !1;
            const t = Xe(e);
            if (t.type !== "ip4" || _6(t.host) === !0) return !1;
            const r = this.components.transportManager.getListeners(), s = [
                (i)=>tf.exactMatch(i) || $p.exactMatch(i),
                (i)=>Op.exactMatch(i),
                (i)=>SG.exactMatch(i)
            ];
            for (const i of s){
                if (!i(e)) continue;
                const l = r.filter((f)=>f.getAddrs().filter((p)=>Xe(p).type === "ip4" && i(p)).length > 0);
                if (l.length !== 1) continue;
                const u = l[0].getAddrs().filter((f)=>!Fy(f)).pop();
                if (u == null) continue;
                const h = Xe(u);
                return h.port == null ? !1 : (this.observed.remove(e), this.ipMappings.add(h.host, h.port, t.host, t.port, t.protocol), !0);
            }
            return !1;
        }
    }
    var AE;
    (function(n) {
        n.NOT_STARTED_YET = "The libp2p node is not started yet", n.NOT_FOUND = "Not found";
    })(AE || (AE = {}));
    class Une extends Error {
        constructor(e = "Missing service"){
            super(e), this.name = "MissingServiceError";
        }
    }
    class zne extends Error {
        constructor(e = "Unmet service dependencies"){
            super(e), this.name = "UnmetServiceDependenciesError";
        }
    }
    class G3 extends Error {
        constructor(e = "No content routers available"){
            super(e), this.name = "NoContentRoutersError";
        }
    }
    class SE extends Error {
        constructor(e = "No peer routers available"){
            super(e), this.name = "NoPeerRoutersError";
        }
    }
    class Fne extends Error {
        constructor(e = "Should not try to find self"){
            super(e), this.name = "QueriedForSelfError";
        }
    }
    class Vne extends Error {
        constructor(e = "Unhandled protocol error"){
            super(e), this.name = "UnhandledProtocolError";
        }
    }
    class Hne extends Error {
        constructor(e = "Duplicate protocol handler error"){
            super(e), this.name = "DuplicateProtocolHandlerError";
        }
    }
    class IE extends Error {
        constructor(e = "Dial denied error"){
            super(e), this.name = "DialDeniedError";
        }
    }
    class Qne extends Error {
        constructor(e = "No transport was configured to listen on this address"){
            super(e), this.name = "UnsupportedListenAddressError";
        }
    }
    class qne extends Error {
        constructor(e = "Configured listen addresses could not be listened on"){
            super(e), this.name = "UnsupportedListenAddressesError";
        }
    }
    class Kne extends Error {
        constructor(e = "No valid addresses"){
            super(e), this.name = "NoValidAddressesError";
        }
    }
    class Gne extends Error {
        constructor(e = "Connection intercepted"){
            super(e), this.name = "ConnectionInterceptedError";
        }
    }
    class Yne extends Error {
        constructor(e = "Connection denied"){
            super(e), this.name = "ConnectionDeniedError";
        }
    }
    class lp extends Error {
        constructor(e = "Stream is not multiplexed"){
            super(e), this.name = "MuxerUnavailableError";
        }
    }
    class B0 extends Error {
        constructor(e = "Encryption failed"){
            super(e), this.name = "EncryptionFailedError";
        }
    }
    class Wne extends Error {
        constructor(e = "Transport unavailable"){
            super(e), this.name = "TransportUnavailableError";
        }
    }
    class jne extends Error {
        constructor(e = "Max recursive depth reached"){
            super(e), this.name = "RecursionLimitError";
        }
    }
    class Xne {
        components = {};
        _started = !1;
        constructor(e = {}){
            this.components = {};
            for (const [t, r] of Object.entries(e))this.components[t] = r;
            this.components.logger == null && (this.components.logger = F6());
        }
        isStarted() {
            return this._started;
        }
        async _invokeStartableMethod(e) {
            await Promise.all(Object.values(this.components).filter((t)=>h8(t)).map(async (t)=>{
                await t[e]?.();
            }));
        }
        async beforeStart() {
            await this._invokeStartableMethod("beforeStart");
        }
        async start() {
            await this._invokeStartableMethod("start"), this._started = !0;
        }
        async afterStart() {
            await this._invokeStartableMethod("afterStart");
        }
        async beforeStop() {
            await this._invokeStartableMethod("beforeStop");
        }
        async stop() {
            await this._invokeStartableMethod("stop"), this._started = !1;
        }
        async afterStop() {
            await this._invokeStartableMethod("afterStop");
        }
    }
    const Jne = [
        "metrics",
        "connectionProtector",
        "dns"
    ], Zne = [
        "components",
        "isStarted",
        "beforeStart",
        "start",
        "afterStart",
        "beforeStop",
        "stop",
        "afterStop",
        "then",
        "_invokeStartableMethod"
    ];
    function ere(n = {}) {
        const e = new Xne(n);
        return new Proxy(e, {
            get (r, s, i) {
                if (typeof s == "string" && !Zne.includes(s)) {
                    const l = e.components[s];
                    if (l == null && !Jne.includes(s)) throw new Une(`${s} not set`);
                    return l;
                }
                return Reflect.get(r, s, i);
            },
            set (r, s, i) {
                return typeof s == "string" ? e.components[s] = i : Reflect.set(r, s, i), !0;
            }
        });
    }
    function tre(n) {
        const e = {};
        for (const t of Object.values(n.components))for (const r of nre(t))e[r] = !0;
        for (const t of Object.values(n.components))for (const r of rre(t))if (e[r] !== !0) throw new zne(`Service "${sre(t)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
    }
    function nre(n) {
        return Array.isArray(n?.[o4]) ? n[o4] : [];
    }
    function rre(n) {
        return Array.isArray(n?.[nE]) ? n[nE] : [];
    }
    function sre(n) {
        return n?.[Symbol.toStringTag] ?? n?.toString() ?? "unknown";
    }
    function ire(n = {}) {
        return n.denyDialMultiaddr == null && (n.denyDialMultiaddr = (e)=>tf.matches(e) ? !0 : Is(e)), n;
    }
    function Ex(n) {
        if (JX(n)) return {
            peerId: n,
            multiaddrs: []
        };
        let e = Array.isArray(n) ? n : [
            n
        ], t;
        if (e.length > 0) {
            const r = e[0].getComponents().findLast((s)=>s.code === fi)?.value;
            t = r == null ? void 0 : Fc(r), e.forEach((s)=>{
                if (!w8(s)) throw new c8("Invalid multiaddr");
                const i = s.getComponents().findLast((l)=>l.code === fi)?.value;
                if (i == null) {
                    if (t != null) throw new Vr("Multiaddrs must all have the same peer id or have no peer id");
                } else {
                    const l = Fc(i);
                    if (t?.equals(l) !== !0) throw new Vr("Multiaddrs must all have the same peer id or have no peer id");
                }
            });
        }
        return e = e.filter((r)=>!bG.exactMatch(r)), {
            peerId: t,
            multiaddrs: e
        };
    }
    const ore = [
        "/ipfs/id/1.0.0",
        "/ipfs/id/push/1.0.0",
        "/libp2p/autonat/1.0.0",
        "/libp2p/dcutr"
    ];
    async function are(n, e) {
        const t = n?.streams?.map((s)=>s.protocol) ?? [], r = e?.closableProtocols ?? ore;
        if (!(t.filter((s)=>s != null && !r.includes(s)).length > 0)) try {
            await n?.close(e);
        } catch (s) {
            n?.abort(s);
        }
    }
    function h4(n) {
        const e = Xe(n);
        let t = e.cidr;
        if (e.type !== "ip4" && e.type !== "ip6") throw new Vr(`Multiaddr ${n} was not an IPv4 or IPv6 address`);
        if (t == null) switch(e.type){
            case "ip4":
                {
                    t = 32;
                    break;
                }
            case "ip6":
                {
                    t = 128;
                    break;
                }
            default:
                throw new Vr(`Multiaddr ${n} was not an IPv4 or IPv6 address`);
        }
        return new TC(e.host, t);
    }
    function Ax(n) {
        return !di.exactMatch(n);
    }
    function Sx(n, e, t) {
        if (n == null || e == null) return;
        const r = e.sort((i, l)=>i.direct ? -1 : l.direct ? 1 : 0).find((i)=>i.limits == null);
        if (r == null || r.direct || t == null) return r;
        if (!t.some((i)=>Ax(i))) return r;
    }
    class lre {
        connectionManager;
        peerStore;
        allow;
        events;
        log;
        constructor(e, t = {}){
            this.allow = (t.allow ?? []).map((r)=>h4(r)), this.connectionManager = e.connectionManager, this.peerStore = e.peerStore, this.events = e.events, this.log = e.logger.forComponent("libp2p:connection-manager:connection-pruner"), this.maybePruneConnections = this.maybePruneConnections.bind(this);
        }
        start() {
            this.events.addEventListener("connection:open", this.maybePruneConnections);
        }
        stop() {
            this.events.removeEventListener("connection:open", this.maybePruneConnections);
        }
        maybePruneConnections() {
            this._maybePruneConnections().catch((e)=>{
                this.log.error("error while pruning connections - %e", e);
            });
        }
        async _maybePruneConnections() {
            const e = this.connectionManager.getConnections(), t = e.length, r = this.connectionManager.getMaxConnections();
            if (this.log("checking max connections limit %d/%d", t, r), t <= r) return;
            const s = new p8;
            for (const h of e){
                const f = h.remotePeer;
                if (!s.has(f)) {
                    s.set(f, 0);
                    try {
                        const p = await this.peerStore.get(f);
                        s.set(f, [
                            ...p.tags.values()
                        ].reduce((m, w)=>m + w.value, 0));
                    } catch (p) {
                        p.name !== "NotFoundError" && this.log.error("error loading peer tags - %e", p);
                    }
                }
            }
            const i = this.sortConnections(e, s), l = Math.max(t - r, 0), u = [];
            for (const h of i)if (this.log("too many connections open - closing a connection to %p", h.remotePeer), this.allow.some((p)=>{
                if (zs(h.remoteAddr)) {
                    const m = Xe(h.remoteAddr);
                    return p.contains(m.host);
                }
                return !0;
            }) || u.push(h), u.length === l) break;
            await Promise.all(u.map(async (h)=>{
                await are(h, {
                    signal: AbortSignal.timeout(1e3)
                });
            })), this.events.safeDispatchEvent("connection:prune", {
                detail: u
            });
        }
        sortConnections(e, t) {
            return e.sort((r, s)=>{
                const i = r.timeline.open, l = s.timeline.open;
                return i < l ? 1 : i > l ? -1 : 0;
            }).sort((r, s)=>r.direction === "outbound" && s.direction === "inbound" ? 1 : r.direction === "inbound" && s.direction === "outbound" ? -1 : 0).sort((r, s)=>r.streams.length > s.streams.length ? 1 : r.streams.length < s.streams.length ? -1 : 0).sort((r, s)=>{
                const i = t.get(r.remotePeer) ?? 0, l = t.get(s.remotePeer) ?? 0;
                return i > l ? 1 : i < l ? -1 : 0;
            });
        }
    }
    const Ix = 1e4, Cx = 1e3, cre = 1e4, Hp = 1e4, Tx = 25, ure = 5, hre = 10, dre = 5, fre = "last-dial-failure", pre = "last-dial-success", _x = 500, gre = 32, mre = 100, xx = 50;
    function yre(n, e) {
        const t = Op.exactMatch(n.multiaddr), r = Op.exactMatch(e.multiaddr);
        if (t && !r) return -1;
        if (!t && r) return 1;
        const s = $p.exactMatch(n.multiaddr), i = $p.exactMatch(e.multiaddr);
        if (s && !i) return -1;
        if (!s && i) return 1;
        const l = tf.exactMatch(n.multiaddr), u = tf.exactMatch(e.multiaddr);
        if (l && !u) return -1;
        if (!l && u) return 1;
        const h = t4.exactMatch(n.multiaddr), f = t4.exactMatch(e.multiaddr);
        if (h && !f) return -1;
        if (!h && f) return 1;
        const p = e4.exactMatch(n.multiaddr), m = e4.exactMatch(e.multiaddr);
        if (p && !m) return -1;
        if (!p && m) return 1;
        const w = Ov.exactMatch(n.multiaddr), A = Ov.exactMatch(e.multiaddr);
        return w && !A ? -1 : !w && A ? 1 : 0;
    }
    function wre(n, e) {
        const t = Fy(n.multiaddr), r = Fy(e.multiaddr);
        return t && !r ? 1 : !t && r ? -1 : 0;
    }
    function bre(n, e) {
        const t = Is(n.multiaddr), r = Is(e.multiaddr);
        return t && !r ? 1 : !t && r ? -1 : 0;
    }
    function vre(n, e) {
        return n.isCertified && !e.isCertified ? -1 : !n.isCertified && e.isCertified ? 1 : 0;
    }
    function Ere(n, e) {
        const t = di.exactMatch(n.multiaddr), r = di.exactMatch(e.multiaddr);
        return t && !r ? 1 : !t && r ? -1 : 0;
    }
    function Are(n) {
        return n.sort(yre).sort(vre).sort(Ere).sort(bre).sort(wre);
    }
    class Sre {
        dns;
        canResolve(e) {
            return e.getComponents().some(({ name: t })=>t === "dnsaddr");
        }
        async resolve(e, t) {
            const r = e.getComponents().find((h)=>h.name === "dnsaddr")?.value;
            if (r == null) return [
                e
            ];
            const i = await this.getDNS(t).query(`_dnsaddr.${r}`, {
                signal: t?.signal,
                types: [
                    Qo.TXT
                ]
            }), l = e.getComponents().find((h)=>h.name === "p2p")?.value, u = [];
            for (const h of i.Answer){
                const f = h.data.replace(/["']/g, "").trim().split("=")[1];
                f != null && (l != null && !f.includes(l) || u.push(Yn(f)));
            }
            return u;
        }
        getDNS(e) {
            return e.dns != null ? e.dns : (this.dns == null && (this.dns = dI()), this.dns);
        }
    }
    const Dx = new Sre;
    async function Bx(n, e, t) {
        const r = t.depth ?? 0;
        if (r > (t.maxRecursiveDepth ?? gre)) throw new jne("Max recursive depth reached");
        let s = !1;
        const i = [];
        for (const l of Object.values(e))if (l.canResolve(n)) {
            s = !0;
            const u = await l.resolve(n, t);
            for (const h of u)i.push(...await Bx(h, e, {
                ...t,
                depth: r + 1
            }));
        }
        return s === !1 && i.push(n), i;
    }
    const xh = {
        maxParallelDials: xx,
        maxDialQueueLength: _x,
        maxPeerAddrsToDial: Tx,
        dialTimeout: Ix,
        resolvers: {
            dnsaddr: Dx
        }
    };
    class Ire {
        queue;
        components;
        addressSorter;
        maxPeerAddrsToDial;
        maxDialQueueLength;
        dialTimeout;
        shutDownController;
        connections;
        log;
        resolvers;
        constructor(e, t = {}){
            this.addressSorter = t.addressSorter, this.maxPeerAddrsToDial = t.maxPeerAddrsToDial ?? xh.maxPeerAddrsToDial, this.maxDialQueueLength = t.maxDialQueueLength ?? xh.maxDialQueueLength, this.dialTimeout = t.dialTimeout ?? xh.dialTimeout, this.connections = t.connections ?? new p8, this.log = e.logger.forComponent("libp2p:connection-manager:dial-queue"), this.components = e, this.resolvers = t.resolvers ?? xh.resolvers, this.shutDownController = new AbortController, this.shutDownController.signal, this.queue = new JV({
                concurrency: t.maxParallelDials ?? xh.maxParallelDials,
                metricName: "libp2p_dial_queue",
                metrics: e.metrics
            }), this.queue.addEventListener("failure", (r)=>{
                r.detail?.error.name !== HX.name && this.log.error("error in dial queue - %e", r.detail.error);
            });
        }
        start() {
            this.shutDownController = new AbortController, this.shutDownController.signal;
        }
        stop() {
            this.shutDownController.abort(), this.queue.abort();
        }
        async dial(e, t = {}) {
            const { peerId: r, multiaddrs: s } = Ex(e);
            if (r != null && t.force !== !0) {
                const l = Sx(r, this.connections.get(r), s);
                if (l != null) return this.log("already connected to %a", l.remoteAddr), t.onProgress?.(new Be("dial-queue:already-connected")), l;
            }
            const i = this.queue.queue.find((l)=>{
                if (r?.equals(l.options.peerId) === !0) return !0;
                const u = l.options.multiaddrs;
                if (u == null) return !1;
                for (const h of s)if (u.has(h.toString())) return !0;
                return !1;
            });
            if (i != null) {
                this.log("joining existing dial target for %p", r);
                for (const l of s)i.options.multiaddrs.add(l.toString());
                return t.onProgress?.(new Be("dial-queue:already-in-dial-queue")), i.join(t);
            }
            if (this.queue.size >= this.maxDialQueueLength) throw new L3("Dial queue is full");
            return this.log("creating dial target for %p", r, s.map((l)=>l.toString())), t.onProgress?.(new Be("dial-queue:add-to-dial-queue")), this.queue.add(async (l)=>{
                l.onProgress?.(new Be("dial-queue:start-dial"));
                const u = gt([
                    this.shutDownController.signal,
                    l.signal
                ]);
                try {
                    return await this.dialPeer(l, u);
                } finally{
                    u.clear();
                }
            }, {
                peerId: r,
                priority: t.priority ?? Px,
                multiaddrs: new Set(s.map((l)=>l.toString())),
                signal: t.signal ?? AbortSignal.timeout(this.dialTimeout),
                onProgress: t.onProgress
            });
        }
        async dialPeer(e, t) {
            const r = e.peerId, s = e.multiaddrs, i = new Set;
            let l = e.multiaddrs.size === 0, u = 0, h = 0;
            const f = [];
            for(this.log("starting dial to %p", r); l || s.size > 0;){
                h++, l = !1;
                const p = [], m = new Set(e.multiaddrs);
                s.clear(), this.log("calculating addrs to dial %p from %s", r, [
                    ...m
                ]);
                const w = await this.calculateMultiaddrs(r, m, {
                    ...e,
                    signal: t
                });
                for (const A of w){
                    if (i.has(A.multiaddr.toString())) {
                        this.log.trace("skipping previously failed multiaddr %a while dialing %p", A.multiaddr, r);
                        continue;
                    }
                    p.push(A);
                }
                this.log("%s dial to %p with %s", h === 1 ? "starting" : "continuing", r, p.map((A)=>A.multiaddr.toString())), e?.onProgress?.(new Be("dial-queue:calculated-addresses", p));
                for (const A of p){
                    if (u === this.maxPeerAddrsToDial) throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", u, e.peerId), new L3("Peer had more than maxPeerAddrsToDial");
                    u++;
                    try {
                        const S = await this.components.transportManager.dial(A.multiaddr, {
                            ...e,
                            signal: t
                        });
                        this.log("dial to %a succeeded", A.multiaddr);
                        try {
                            await this.components.peerStore.merge(S.remotePeer, {
                                multiaddrs: [
                                    S.remoteAddr
                                ],
                                metadata: {
                                    [pre]: re(Date.now().toString())
                                }
                            });
                        } catch (_) {
                            this.log.error("could not update last dial failure key for %p - %e", r, _);
                        }
                        return S;
                    } catch (S) {
                        if (this.log.error("dial failed to %a - %e", A.multiaddr, S), i.add(A.multiaddr.toString()), r != null) try {
                            await this.components.peerStore.merge(r, {
                                metadata: {
                                    [fre]: re(Date.now().toString())
                                }
                            });
                        } catch (_) {
                            this.log.error("could not update last dial failure key for %p - %e", r, _);
                        }
                        if (t.aborted) throw new GX(S.message);
                        f.push(S);
                    }
                }
            }
            throw f.length === 1 ? f[0] : new AggregateError(f, "All multiaddr dials failed");
        }
        async calculateMultiaddrs(e, t = new Set, r = {}) {
            const s = [
                ...t
            ].map((m)=>({
                    multiaddr: Yn(m),
                    isCertified: !1
                }));
            if (e != null) {
                if (this.components.peerId.equals(e)) throw new L3("Tried to dial self");
                if (await this.components.connectionGater.denyDialPeer?.(e) === !0) throw new IE("The dial request is blocked by gater.allowDialPeer");
                if (s.length === 0) {
                    this.log("loading multiaddrs for %p", e);
                    try {
                        const m = await this.components.peerStore.get(e);
                        s.push(...m.addresses), this.log("loaded multiaddrs for %p", e, s.map(({ multiaddr: w })=>w.toString()));
                    } catch (m) {
                        if (m.name !== "NotFoundError") throw m;
                    }
                }
                if (s.length === 0) {
                    this.log("looking up multiaddrs for %p in the peer routing", e);
                    try {
                        const m = await this.components.peerRouting.findPeer(e, r);
                        this.log("found multiaddrs for %p in the peer routing", e, s.map(({ multiaddr: w })=>w.toString())), s.push(...m.multiaddrs.map((w)=>({
                                multiaddr: w,
                                isCertified: !1
                            })));
                    } catch (m) {
                        m.name === "NoPeerRoutersError" ? this.log("no peer routers configured", e) : this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", e, m);
                    }
                }
            }
            let i = (await Promise.all(s.map(async (m)=>{
                const w = await Bx(m.multiaddr, this.resolvers, {
                    dns: this.components.dns,
                    log: this.log,
                    ...r
                });
                return w.length === 1 && w[0].equals(m.multiaddr) ? m : w.map((A)=>({
                        multiaddr: A,
                        isCertified: !1
                    }));
            }))).flat();
            if (e != null) {
                const m = `/p2p/${e.toString()}`;
                i = i.map((w)=>w.multiaddr.getComponents().pop()?.name !== "p2p" ? {
                        multiaddr: w.multiaddr.encapsulate(m),
                        isCertified: w.isCertified
                    } : w);
            }
            const l = i.filter((m)=>{
                if (this.components.transportManager.dialTransportForMultiaddr(m.multiaddr) == null) return !1;
                const w = m.multiaddr.getComponents().findLast((A)=>A.code === fi)?.value;
                return e != null && w != null ? e.equals(w) : !0;
            }), u = new Map;
            for (const m of l){
                const w = m.multiaddr.toString(), A = u.get(w);
                if (A != null) {
                    A.isCertified = A.isCertified || m.isCertified || !1;
                    continue;
                }
                u.set(w, m);
            }
            const h = [
                ...u.values()
            ];
            if (h.length === 0) throw new Kne("The dial request has no valid addresses");
            const f = [];
            for (const m of h)this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(m.multiaddr) || f.push(m);
            const p = this.addressSorter == null ? Are(f) : f.sort(this.addressSorter);
            if (p.length === 0) throw new IE("The connection gater denied all addresses in the dial request");
            return this.log.trace("addresses for %p before filtering", e ?? "unknown peer", i.map(({ multiaddr: m })=>m.toString())), this.log.trace("addresses for %p after filtering", e ?? "unknown peer", p.map(({ multiaddr: m })=>m.toString())), p;
        }
        async isDialable(e, t = {}) {
            Array.isArray(e) || (e = [
                e
            ]);
            try {
                const r = await this.calculateMultiaddrs(void 0, new Set(e.map((s)=>s.toString())), t);
                return t.runOnLimitedConnection === !1 ? r.find((s)=>!di.matches(s.multiaddr)) != null : !0;
            } catch  {}
            return !1;
        }
    }
    const Cre = Object.prototype.toString, Tre = (n)=>Cre.call(n) === "[object Error]", _re = new Set([
        "network error",
        "Failed to fetch",
        "NetworkError when attempting to fetch resource.",
        "The Internet connection appears to be offline.",
        "Network request failed",
        "fetch failed",
        "terminated",
        " A network error occurred.",
        "Network connection lost"
    ]);
    function xre(n) {
        if (!(n && Tre(n) && n.name === "TypeError" && typeof n.message == "string")) return !1;
        const { message: t, stack: r } = n;
        return t === "Load failed" ? r === void 0 || "__sentry_captured__" in n : t.startsWith("error sending request for url") ? !0 : _re.has(t);
    }
    function Dre(n) {
        if (typeof n == "number") {
            if (n < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
            if (Number.isNaN(n)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
        } else if (n !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
    }
    function P0(n, e, { min: t = 0, allowInfinity: r = !1 } = {}) {
        if (e !== void 0) {
            if (typeof e != "number" || Number.isNaN(e)) throw new TypeError(`Expected \`${n}\` to be a number${r ? " or Infinity" : ""}.`);
            if (!r && !Number.isFinite(e)) throw new TypeError(`Expected \`${n}\` to be a finite number.`);
            if (e < t) throw new TypeError(`Expected \`${n}\` to be  ${t}.`);
        }
    }
    let Bre = class extends Error {
        constructor(e){
            super(), e instanceof Error ? (this.originalError = e, { message: e } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e;
        }
    };
    function Pre(n, e) {
        const t = Math.max(1, n + 1), r = e.randomize ? Math.random() + 1 : 1;
        let s = Math.round(r * e.minTimeout * e.factor ** (t - 1));
        return s = Math.min(s, e.maxTimeout), s;
    }
    function CE(n, e) {
        return Number.isFinite(e) ? e - (performance.now() - n) : e;
    }
    async function kre({ error: n, attemptNumber: e, retriesConsumed: t, startTime: r, options: s }) {
        const i = n instanceof Error ? n : new TypeError(`Non-error was thrown: "${n}". You should only throw errors.`);
        if (i instanceof Bre) throw i.originalError;
        const l = Number.isFinite(s.retries) ? Math.max(0, s.retries - t) : s.retries, u = s.maxRetryTime ?? Number.POSITIVE_INFINITY, h = Object.freeze({
            error: i,
            attemptNumber: e,
            retriesLeft: l,
            retriesConsumed: t
        });
        if (await s.onFailedAttempt(h), CE(r, u) <= 0) throw i;
        const f = await s.shouldConsumeRetry(h), p = CE(r, u);
        if (p <= 0 || l <= 0) throw i;
        if (i instanceof TypeError && !xre(i)) {
            if (f) throw i;
            return s.signal?.throwIfAborted(), !1;
        }
        if (!await s.shouldRetry(h)) throw i;
        if (!f) return s.signal?.throwIfAborted(), !1;
        const m = Pre(t, s), w = Math.min(m, p);
        return s.signal?.throwIfAborted(), w > 0 && await new Promise((A, S)=>{
            const _ = ()=>{
                clearTimeout(I), s.signal?.removeEventListener("abort", _), S(s.signal.reason);
            }, I = setTimeout(()=>{
                s.signal?.removeEventListener("abort", _), A();
            }, w);
            s.unref && I.unref?.(), s.signal?.addEventListener("abort", _, {
                once: !0
            });
        }), s.signal?.throwIfAborted(), !0;
    }
    async function Rre(n, e = {}) {
        if (e = {
            ...e
        }, Dre(e.retries), Object.hasOwn(e, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
        e.retries ??= 10, e.factor ??= 2, e.minTimeout ??= 1e3, e.maxTimeout ??= Number.POSITIVE_INFINITY, e.maxRetryTime ??= Number.POSITIVE_INFINITY, e.randomize ??= !1, e.onFailedAttempt ??= ()=>{}, e.shouldRetry ??= ()=>!0, e.shouldConsumeRetry ??= ()=>!0, P0("factor", e.factor, {
            min: 0,
            allowInfinity: !1
        }), P0("minTimeout", e.minTimeout, {
            min: 0,
            allowInfinity: !1
        }), P0("maxTimeout", e.maxTimeout, {
            min: 0,
            allowInfinity: !0
        }), P0("maxRetryTime", e.maxRetryTime, {
            min: 0,
            allowInfinity: !0
        }), e.factor > 0 || (e.factor = 1), e.signal?.throwIfAborted();
        let t = 0, r = 0;
        const s = performance.now();
        for(; !Number.isFinite(e.retries) || r <= e.retries;){
            t++;
            try {
                e.signal?.throwIfAborted();
                const i = await n(t);
                return e.signal?.throwIfAborted(), i;
            } catch (i) {
                await kre({
                    error: i,
                    attemptNumber: t,
                    retriesConsumed: r,
                    startTime: s,
                    options: e
                }) && r++;
            }
        }
        throw new Error("Retry attempts exhausted without throwing an error.");
    }
    class Ore {
        log;
        queue;
        started;
        peerStore;
        retries;
        retryInterval;
        backoffFactor;
        connectionManager;
        events;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:reconnect-queue"), this.peerStore = e.peerStore, this.connectionManager = e.connectionManager, this.queue = new Wo({
                concurrency: t.maxParallelReconnects ?? dre,
                metricName: "libp2p_reconnect_queue",
                metrics: e.metrics
            }), this.started = !1, this.retries = t.retries ?? 5, this.backoffFactor = t.backoffFactor, this.retryInterval = t.retryInterval, this.events = e.events, e.events.addEventListener("peer:disconnect", (r)=>{
                this.maybeReconnect(r.detail).catch((s)=>{
                    this.log.error("failed to maybe reconnect to %p - %e", r.detail, s);
                });
            });
        }
        async maybeReconnect(e) {
            if (!this.started) return;
            const t = await this.peerStore.get(e);
            TE(t) && (this.queue.has(e) || this.queue.add(async (r)=>{
                await Rre(async (s)=>{
                    if (this.started) try {
                        await this.connectionManager.openConnection(e, {
                            signal: r?.signal
                        });
                    } catch (i) {
                        throw this.log("reconnecting to %p attempt %d of %d failed - %e", e, s, this.retries, i), i;
                    }
                }, {
                    signal: r?.signal,
                    retries: this.retries,
                    factor: this.backoffFactor,
                    minTimeout: this.retryInterval
                });
            }, {
                peerId: e
            }).catch(async (r)=>{
                this.log.error("failed to reconnect to %p - %e", e, r);
                const s = {};
                [
                    ...t.tags.keys()
                ].forEach((i)=>{
                    i.startsWith(q_) && (s[i] = void 0);
                }), await this.peerStore.merge(e, {
                    tags: s
                }), this.events.safeDispatchEvent("peer:reconnect-failure", {
                    detail: e
                });
            }).catch(async (r)=>{
                this.log.error("failed to remove keep-alive tag from %p - %e", e, r);
            }));
        }
        start() {
            this.started = !0;
        }
        async afterStart() {
            Promise.resolve().then(async ()=>{
                const e = await this.peerStore.all({
                    filters: [
                        (t)=>TE(t)
                    ]
                });
                await Promise.all(e.map(async (t)=>{
                    await this.connectionManager.openConnection(t.id).catch((r)=>{
                        this.log.error("could not open connection to keepalive peer - %e", r);
                    });
                }));
            }).catch((e)=>{
                this.log.error("error reconnect to peers after start - %e", e);
            });
        }
        stop() {
            this.started = !1, this.queue.abort();
        }
    }
    function TE(n) {
        for (const e of n.tags.keys())if (e.startsWith(q_)) return !0;
        return !1;
    }
    const Px = 50, Y3 = {
        maxConnections: mre,
        inboundConnectionThreshold: ure,
        maxIncomingPendingConnections: hre
    };
    class $re {
        started;
        connections;
        allow;
        deny;
        maxIncomingPendingConnections;
        incomingPendingConnections;
        outboundPendingConnections;
        maxConnections;
        dialQueue;
        reconnectQueue;
        connectionPruner;
        inboundConnectionRateLimiter;
        peerStore;
        metrics;
        events;
        log;
        peerId;
        constructor(e, t = {}){
            if (this.maxConnections = t.maxConnections ?? Y3.maxConnections, this.maxConnections < 1) throw new Vr("Connection Manager maxConnections must be greater than 0");
            this.connections = new p8, this.started = !1, this.peerId = e.peerId, this.peerStore = e.peerStore, this.metrics = e.metrics, this.events = e.events, this.log = e.logger.forComponent("libp2p:connection-manager"), this.onConnect = this.onConnect.bind(this), this.onDisconnect = this.onDisconnect.bind(this), this.allow = (t.allow ?? []).map((r)=>h4(Yn(r))), this.deny = (t.deny ?? []).map((r)=>h4(Yn(r))), this.incomingPendingConnections = 0, this.maxIncomingPendingConnections = t.maxIncomingPendingConnections ?? Y3.maxIncomingPendingConnections, this.outboundPendingConnections = 0, this.inboundConnectionRateLimiter = new WC({
                points: t.inboundConnectionThreshold ?? Y3.inboundConnectionThreshold,
                duration: 1
            }), this.connectionPruner = new lre({
                connectionManager: this,
                peerStore: e.peerStore,
                events: e.events,
                logger: e.logger
            }, {
                allow: t.allow?.map((r)=>Yn(r))
            }), this.dialQueue = new Ire(e, {
                addressSorter: t.addressSorter,
                maxParallelDials: t.maxParallelDials ?? xx,
                maxDialQueueLength: t.maxDialQueueLength ?? _x,
                maxPeerAddrsToDial: t.maxPeerAddrsToDial ?? Tx,
                dialTimeout: t.dialTimeout ?? Ix,
                resolvers: t.resolvers ?? {
                    dnsaddr: Dx
                },
                connections: this.connections
            }), this.reconnectQueue = new Ore({
                events: e.events,
                peerStore: e.peerStore,
                logger: e.logger,
                connectionManager: this
            }, {
                retries: t.reconnectRetries,
                retryInterval: t.reconnectRetryInterval,
                backoffFactor: t.reconnectBackoffFactor,
                maxParallelReconnects: t.maxParallelReconnects
            });
        }
        [Symbol.toStringTag] = "@libp2p/connection-manager";
        async start() {
            this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
                calculate: ()=>{
                    const e = {
                        inbound: 0,
                        "inbound pending": this.incomingPendingConnections,
                        outbound: 0,
                        "outbound pending": this.outboundPendingConnections
                    };
                    for (const t of this.connections.values())for (const r of t)e[r.direction]++;
                    return e;
                }
            }), this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
                label: "protocol",
                calculate: ()=>{
                    const e = {};
                    for (const t of this.connections.values())for (const r of t)for (const s of r.streams){
                        const i = `${s.direction} ${s.protocol ?? "unnegotiated"}`;
                        e[i] = (e[i] ?? 0) + 1;
                    }
                    return e;
                }
            }), this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
                label: "protocol",
                calculate: ()=>{
                    const e = {};
                    for (const r of this.connections.values())for (const s of r){
                        const i = {};
                        for (const l of s.streams){
                            const u = `${l.direction} ${l.protocol ?? "unnegotiated"}`;
                            i[u] = (i[u] ?? 0) + 1;
                        }
                        for (const [l, u] of Object.entries(i))e[l] = e[l] ?? [], e[l].push(u);
                    }
                    const t = {};
                    for (let [r, s] of Object.entries(e)){
                        s = s.sort((l, u)=>l - u);
                        const i = Math.floor(s.length * .9);
                        t[r] = s[i];
                    }
                    return t;
                }
            }), this.events.addEventListener("connection:open", this.onConnect), this.events.addEventListener("connection:close", this.onDisconnect), await ZX(this.dialQueue, this.reconnectQueue, this.connectionPruner), this.started = !0, this.log("started");
        }
        async stop() {
            this.events.removeEventListener("connection:open", this.onConnect), this.events.removeEventListener("connection:close", this.onDisconnect), await eJ(this.reconnectQueue, this.dialQueue, this.connectionPruner);
            const e = [];
            for (const t of this.connections.values())for (const r of t)e.push(Promise.all([
                an(r, "close", {
                    signal: AbortSignal.timeout(500)
                }),
                r.close({
                    signal: AbortSignal.timeout(500)
                })
            ]).catch((s)=>{
                r.abort(s);
            }));
            this.log("closing %d connections", e.length), await Promise.all(e), this.connections.clear(), this.log("stopped");
        }
        getMaxConnections() {
            return this.maxConnections;
        }
        setMaxConnections(e) {
            if (this.maxConnections < 1) throw new Vr("Connection Manager maxConnections must be greater than 0");
            let t = !1;
            e < this.maxConnections && (t = !0), this.maxConnections = e, t && this.connectionPruner.maybePruneConnections();
        }
        onConnect(e) {
            this._onConnect(e).catch((t)=>{
                this.log.error("could not connect - %e", t);
            });
        }
        async _onConnect(e) {
            const { detail: t } = e;
            if (!this.started) {
                await t.close();
                return;
            }
            if (t.status !== "open") return;
            const r = t.remotePeer, s = !this.connections.has(r), i = this.connections.get(r) ?? [];
            i.push(t), this.connections.set(r, i), r.publicKey != null && r.type === "RSA" && await this.peerStore.patch(r, {
                publicKey: r.publicKey
            }), s && this.events.safeDispatchEvent("peer:connect", {
                detail: t.remotePeer
            });
        }
        onDisconnect(e) {
            const { detail: t } = e, r = t.remotePeer, i = (this.connections.get(r) ?? []).filter((l)=>l.id !== t.id);
            this.connections.set(r, i), i.length === 0 && (this.log.trace("peer %p disconnected, removing connection map entry", r), this.connections.delete(r), this.events.safeDispatchEvent("peer:disconnect", {
                detail: r
            }));
        }
        getConnections(e) {
            if (e != null) return this.connections.get(e) ?? [];
            let t = [];
            for (const r of this.connections.values())t = t.concat(r);
            return t;
        }
        getConnectionsMap() {
            return this.connections;
        }
        async openConnection(e, t = {}) {
            if (!this.started) throw new Np("Not started");
            this.outboundPendingConnections++;
            try {
                t.signal?.throwIfAborted();
                const { peerId: r, multiaddrs: s } = Ex(e);
                if (this.peerId.equals(r)) throw new Q_("Can not dial self");
                if (r != null && t.force !== !0) {
                    this.log("dial %p", r);
                    const h = Sx(r, this.getConnections(r), s);
                    if (h != null) return this.log("had an existing connection to %p as %a", r, h.remoteAddr), t.onProgress?.(new Be("dial-queue:already-connected")), h;
                }
                const i = await this.dialQueue.dial(e, {
                    ...t,
                    priority: t.priority ?? Px
                });
                if (i.status !== "open") throw new i4("Remote closed connection during opening");
                let l = this.connections.get(i.remotePeer);
                l == null && (l = [], this.connections.set(i.remotePeer, l));
                let u = !1;
                for (const h of l)if (h.id === i.id && (u = !0), t.force !== !0 && h.id !== i.id && h.remoteAddr.equals(i.remoteAddr)) return i.abort(new c8("Duplicate multiaddr connection")), h;
                return u || l.push(i), i;
            } finally{
                this.outboundPendingConnections--;
            }
        }
        async openStream(e, t, r = {}) {
            return (await this.openConnection(e, r)).newStream(t, r);
        }
        async closeConnections(e, t = {}) {
            const r = this.connections.get(e) ?? [];
            await Promise.all(r.map(async (s)=>{
                try {
                    await Promise.all([
                        an(s, "close", t),
                        s.close(t)
                    ]);
                } catch (i) {
                    s.abort(i);
                }
            }));
        }
        acceptIncomingConnection(e) {
            if (this.deny.some((s)=>{
                if (zs(e.remoteAddr)) {
                    const i = Xe(e.remoteAddr);
                    return s.contains(i.host);
                }
                return !1;
            })) return this.log("connection from %a refused - connection remote address was in deny list", e.remoteAddr), !1;
            if (this.allow.some((s)=>{
                if (zs(e.remoteAddr)) {
                    const i = Xe(e.remoteAddr);
                    return s.contains(i.host);
                }
                return !0;
            })) return this.incomingPendingConnections++, !0;
            if (this.incomingPendingConnections === this.maxIncomingPendingConnections) return this.log("connection from %a refused - incomingPendingConnections exceeded by host", e.remoteAddr), !1;
            if (zs(e.remoteAddr)) {
                const s = Xe(e.remoteAddr);
                try {
                    this.inboundConnectionRateLimiter.consume(s.host, 1);
                } catch  {
                    return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", e.remoteAddr, s.host), !1;
                }
            }
            return this.getConnections().length < this.maxConnections ? (this.incomingPendingConnections++, !0) : (this.log("connection from %a refused - maxConnections exceeded", e.remoteAddr), !1);
        }
        afterUpgradeInbound() {
            this.incomingPendingConnections--;
        }
        getDialQueue() {
            const e = {
                queued: "queued",
                running: "active",
                errored: "error",
                complete: "success"
            };
            return this.dialQueue.queue.queue.map((t)=>({
                    id: t.id,
                    status: e[t.status],
                    peerId: t.options.peerId,
                    multiaddrs: [
                        ...t.options.multiaddrs
                    ].map((r)=>Yn(r))
                }));
        }
        async isDialable(e, t = {}) {
            return this.dialQueue.isDialable(e, t);
        }
    }
    const Mre = 1e4, Nre = "1.0.0", Lre = "ping", Ure = "ipfs", _E = 32, zre = !0;
    class Fre {
        protocol;
        components;
        log;
        heartbeatInterval;
        pingIntervalMs;
        abortController;
        timeout;
        abortConnectionOnPingFailure;
        constructor(e, t = {}){
            this.components = e, this.protocol = `/${t.protocolPrefix ?? Ure}/${Lre}/${Nre}`, this.log = e.logger.forComponent("libp2p:connection-monitor"), this.pingIntervalMs = t.pingInterval ?? Mre, this.abortConnectionOnPingFailure = t.abortConnectionOnPingFailure ?? zre, this.timeout = new Fd({
                ...t.pingTimeout ?? {},
                metrics: e.metrics,
                metricName: "libp2p_connection_monitor_ping_time_milliseconds"
            });
        }
        [Symbol.toStringTag] = "@libp2p/connection-monitor";
        [o4] = [
            "@libp2p/connection-monitor"
        ];
        start() {
            this.abortController = new AbortController, this.abortController.signal, this.heartbeatInterval = setInterval(()=>{
                this.components.connectionManager.getConnections().forEach((e)=>{
                    Promise.resolve().then(async ()=>{
                        let t = Date.now();
                        try {
                            const r = this.timeout.getTimeoutSignal({
                                signal: this.abortController?.signal
                            }), s = await e.newStream(this.protocol, {
                                signal: r,
                                runOnLimitedConnection: !0
                            }), i = kC(s);
                            t = Date.now(), await Promise.all([
                                i.write(Go(_E), {
                                    signal: r
                                }),
                                i.read({
                                    bytes: _E,
                                    signal: r
                                })
                            ]), e.rtt = Date.now() - t, await s.close({
                                signal: r
                            });
                        } catch (r) {
                            if (r.name !== "UnsupportedProtocolError") throw r;
                            e.rtt = (Date.now() - t) / 2;
                        }
                    }).catch((t)=>{
                        this.log.error("error during heartbeat - %e", t), this.abortConnectionOnPingFailure ? (this.log.error("aborting connection due to ping failure"), e.abort(t)) : this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
                    });
                });
            }, this.pingIntervalMs);
        }
        stop() {
            this.abortController?.abort(), this.heartbeatInterval != null && clearInterval(this.heartbeatInterval);
        }
    }
    class Vre {
        routers;
        started;
        components;
        constructor(e, t){
            this.routers = t.routers ?? [], this.started = !1, this.components = e, this.findProviders = e.metrics?.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
                optionsIndex: 1,
                getAttributesFromArgs: ([r], s)=>({
                        ...s,
                        cid: r.toString()
                    }),
                getAttributesFromYieldedValue: (r, s)=>({
                        ...s,
                        providers: [
                            ...Array.isArray(s.providers) ? s.providers : [],
                            r.id.toString()
                        ]
                    })
            }) ?? this.findProviders, this.provide = e.metrics?.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
                optionsIndex: 1,
                getAttributesFromArgs: ([r], s)=>({
                        ...s,
                        cid: r.toString()
                    })
            }) ?? this.provide, this.cancelReprovide = e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
                optionsIndex: 1,
                getAttributesFromArgs: ([r], s)=>({
                        ...s,
                        cid: r.toString()
                    })
            }) ?? this.cancelReprovide, this.put = e.metrics?.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
                optionsIndex: 2,
                getAttributesFromArgs: ([r])=>({
                        key: L(r, "base36")
                    })
            }) ?? this.put, this.get = e.metrics?.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
                optionsIndex: 1,
                getAttributesFromArgs: ([r])=>({
                        key: L(r, "base36")
                    })
            }) ?? this.get;
        }
        [Symbol.toStringTag] = "@libp2p/content-routing";
        isStarted() {
            return this.started;
        }
        async start() {
            this.started = !0;
        }
        async stop() {
            this.started = !1;
        }
        async *findProviders(e, t = {}) {
            if (this.routers.length === 0) throw new G3("No content routers available");
            const r = this, s = new X_;
            for await (const i of Uo(...r.routers.filter((l)=>l.findProviders instanceof Function).map((l)=>l.findProviders(e, t))))i != null && (i.multiaddrs.length > 0 && await this.components.peerStore.merge(i.id, {
                multiaddrs: i.multiaddrs
            }, t), !s.has(i.id) && (s.add(i.id), yield i));
        }
        async provide(e, t = {}) {
            if (this.routers.length === 0) throw new G3("No content routers available");
            await Promise.all(this.routers.filter((r)=>r.provide instanceof Function).map(async (r)=>{
                await r.provide(e, t);
            }));
        }
        async cancelReprovide(e, t = {}) {
            if (this.routers.length === 0) throw new G3("No content routers available");
            await Promise.all(this.routers.filter((r)=>r.cancelReprovide instanceof Function).map(async (r)=>{
                await r.cancelReprovide(e, t);
            }));
        }
        async put(e, t, r) {
            if (!this.isStarted()) throw new Np;
            await Promise.all(this.routers.filter((s)=>s.put instanceof Function).map(async (s)=>{
                await s.put(e, t, r);
            }));
        }
        async get(e, t) {
            if (!this.isStarted()) throw new Np;
            return Promise.any(this.routers.filter((r)=>r.get instanceof Function).map(async (r)=>r.get(e, t)));
        }
    }
    const k0 = globalThis.CustomEvent ?? Event;
    async function* Bg(n, e = {}) {
        let t = e.concurrency ?? 1 / 0;
        t < 1 && (t = 1 / 0);
        const r = e.ordered ?? !1, s = new EventTarget, i = [];
        let l = xt(), u = xt(), h = !1, f, p = !1;
        s.addEventListener("task-complete", ()=>{
            u.resolve();
        }), Promise.resolve().then(async ()=>{
            try {
                for await (const S of n){
                    if (i.length === t && (l = xt(), await l.promise), p) break;
                    const _ = {
                        done: !1
                    };
                    i.push(_), S().then((I)=>{
                        _.done = !0, _.ok = !0, _.value = I, s.dispatchEvent(new k0("task-complete"));
                    }, (I)=>{
                        _.done = !0, _.err = I, s.dispatchEvent(new k0("task-complete"));
                    });
                }
                h = !0, s.dispatchEvent(new k0("task-complete"));
            } catch (S) {
                f = S, s.dispatchEvent(new k0("task-complete"));
            }
        });
        function m() {
            return r ? i[0]?.done : !!i.find((S)=>S.done);
        }
        function* w() {
            for(; i.length > 0 && i[0].done;){
                const S = i[0];
                if (i.shift(), S.ok) yield S.value;
                else throw p = !0, l.resolve(), S.err;
                l.resolve();
            }
        }
        function* A() {
            for(; m();)for(let S = 0; S < i.length; S++)if (i[S].done) {
                const _ = i[S];
                if (i.splice(S, 1), S--, _.ok) yield _.value;
                else throw p = !0, l.resolve(), _.err;
                l.resolve();
            }
        }
        for(;;){
            if (m() || (u = xt(), await u.promise), f != null || (r ? yield* w() : yield* A(), f != null)) throw f;
            if (h && i.length === 0) break;
        }
    }
    class Hre {
        log;
        peerId;
        peerStore;
        routers;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:peer-routing"), this.peerId = e.peerId, this.peerStore = e.peerStore, this.routers = t.routers ?? [], this.findPeer = e.metrics?.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
                optionsIndex: 1,
                getAttributesFromArgs: ([r], s)=>({
                        ...s,
                        peer: r.toString()
                    })
            }) ?? this.findPeer, this.getClosestPeers = e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
                optionsIndex: 1,
                getAttributesFromArgs: ([r], s)=>({
                        ...s,
                        key: L(r, "base36")
                    }),
                getAttributesFromYieldedValue: (r, s)=>({
                        ...s,
                        peers: [
                            ...Array.isArray(s.peers) ? s.peers : [],
                            r.id.toString()
                        ]
                    })
            }) ?? this.getClosestPeers;
        }
        [Symbol.toStringTag] = "@libp2p/peer-routing";
        async findPeer(e, t) {
            if (this.routers.length === 0) throw new SE("No peer routers available");
            if (e.toString() === this.peerId.toString()) throw new Fne("Should not try to find self");
            const r = this, s = Uo(...this.routers.filter((i)=>i.findPeer instanceof Function).map((i)=>(async function*() {
                    try {
                        yield await i.findPeer(e, t);
                    } catch (l) {
                        r.log.error("router failed to find peer - %e", l);
                    }
                })()));
            for await (const i of s)if (i != null) return i.multiaddrs.length > 0 && await this.peerStore.merge(i.id, {
                multiaddrs: i.multiaddrs
            }, t), i;
            throw new QX;
        }
        async *getClosestPeers(e, t = {}) {
            if (this.routers.length === 0) throw new SE("No peer routers available");
            const r = this, s = Wi(1024);
            for await (const i of Bg((async function*() {
                const l = Uo(...r.routers.filter((u)=>u.getClosestPeers instanceof Function).map((u)=>u.getClosestPeers(e, t)));
                for await (let u of l)yield async ()=>{
                    if (u.multiaddrs.length === 0) try {
                        u = await r.findPeer(u.id, {
                            ...t,
                            useCache: !1
                        });
                    } catch (h) {
                        r.log.error("could not find peer multiaddrs - %e", h);
                        return;
                    }
                    return u;
                };
            })()))i != null && (i.multiaddrs.length > 0 && await this.peerStore.merge(i.id, {
                multiaddrs: i.multiaddrs
            }, t), !s.has(i.id.toMultihash().bytes) && (s.add(i.id.toMultihash().bytes), yield i));
        }
    }
    class Qre extends Lt {
        peerRouting;
        log;
        walking;
        walkers;
        shutdownController;
        walkController;
        needNext;
        constructor(e){
            super(), this.log = e.logger.forComponent("libp2p:random-walk"), this.peerRouting = e.peerRouting, this.walkers = 0, this.walking = !1, this.shutdownController = new AbortController, this.shutdownController.signal;
        }
        [Symbol.toStringTag] = "@libp2p/random-walk";
        start() {
            this.shutdownController = new AbortController, this.shutdownController.signal;
        }
        stop() {
            this.shutdownController.abort();
        }
        async *walk(e) {
            this.walking || this.startWalk(), this.walkers++;
            const t = gt([
                this.shutdownController.signal,
                e?.signal
            ]);
            try {
                for(;;)this.needNext?.resolve(), this.needNext = xt(), yield (await an(this, "walk:peer", {
                    signal: t,
                    rejectionEvents: [
                        "walk:error"
                    ]
                })).detail;
            } catch (r) {
                throw r.detail != null ? r.detail : r;
            } finally{
                t.clear(), this.walkers--, this.walkers === 0 && (this.walkController?.abort(), this.walkController = void 0);
            }
        }
        startWalk() {
            this.walking = !0, this.walkController = new AbortController, this.walkController.signal;
            const e = gt([
                this.walkController.signal,
                this.shutdownController.signal
            ]), t = Date.now();
            let r = 0;
            Promise.resolve().then(async ()=>{
                for(this.log("start walk"); this.walkers > 0;)try {
                    const s = Go(32);
                    let i = Date.now();
                    for await (const l of this.peerRouting.getClosestPeers(s, {
                        signal: e
                    }))e.aborted && this.log("aborting walk"), e.throwIfAborted(), this.log("found peer %p after %dms for %d walkers", l.id, Date.now() - i, this.walkers), r++, this.safeDispatchEvent("walk:peer", {
                        detail: l
                    }), this.walkers === 1 && this.needNext != null && (this.log("wait for need next"), await Xn(this.needNext.promise, e)), i = Date.now();
                    this.log("walk iteration for %b and %d walkers finished, found %d peers", s, this.walkers, r);
                } catch (s) {
                    this.log.error("random walk errored - %e", s), this.safeDispatchEvent("walk:error", {
                        detail: s
                    });
                }
                this.log("no walkers left, ended walk");
            }).catch((s)=>{
                this.log.error("random walk errored - %e", s);
            }).finally(()=>{
                this.log("finished walk, found %d peers after %dms", r, Date.now() - t), this.walking = !1;
            });
        }
    }
    const kx = 32, Rx = 64;
    class qre {
        log;
        topologies;
        handlers;
        components;
        middleware;
        constructor(e){
            this.components = e, this.log = e.logger.forComponent("libp2p:registrar"), this.middleware = new Map, this.topologies = new Map, e.metrics?.registerMetricGroup("libp2p_registrar_topologies", {
                calculate: ()=>{
                    const t = {};
                    for (const [r, s] of this.topologies)t[r] = s.size;
                    return t;
                }
            }), this.handlers = Qs({
                name: "libp2p_registrar_protocol_handlers",
                metrics: e.metrics
            }), this._onDisconnect = this._onDisconnect.bind(this), this._onPeerUpdate = this._onPeerUpdate.bind(this), this._onPeerIdentify = this._onPeerIdentify.bind(this), this.components.events.addEventListener("peer:disconnect", this._onDisconnect), this.components.events.addEventListener("peer:update", this._onPeerUpdate), this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
        }
        [Symbol.toStringTag] = "@libp2p/registrar";
        getProtocols() {
            return Array.from(new Set([
                ...this.handlers.keys()
            ])).sort();
        }
        getHandler(e) {
            const t = this.handlers.get(e);
            if (t == null) throw new Vne(`No handler registered for protocol ${e}`);
            return t;
        }
        getTopologies(e) {
            const t = this.topologies.get(e);
            return t == null ? [] : [
                ...t.values()
            ];
        }
        async handle(e, t, r) {
            if (this.handlers.has(e) && r?.force !== !0) throw new Hne(`Handler already registered for protocol ${e}`);
            this.handlers.set(e, {
                handler: t,
                options: {
                    maxInboundStreams: kx,
                    maxOutboundStreams: Rx,
                    ...r
                }
            }), await this.components.peerStore.merge(this.components.peerId, {
                protocols: [
                    e
                ]
            }, r);
        }
        async unhandle(e, t) {
            (Array.isArray(e) ? e : [
                e
            ]).forEach((s)=>{
                this.handlers.delete(s);
            }), await this.components.peerStore.patch(this.components.peerId, {
                protocols: this.getProtocols()
            }, t);
        }
        async register(e, t) {
            if (t == null) throw new Vr("invalid topology");
            const r = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
            let s = this.topologies.get(e);
            return s == null && (s = new Map, this.topologies.set(e, s)), s.set(r, t), r;
        }
        unregister(e) {
            for (const [t, r] of this.topologies.entries())r.has(e) && (r.delete(e), r.size === 0 && this.topologies.delete(t));
        }
        use(e, t) {
            this.middleware.set(e, t);
        }
        unuse(e) {
            this.middleware.delete(e);
        }
        getMiddleware(e) {
            return this.middleware.get(e) ?? [];
        }
        async _onDisconnect(e) {
            const t = e.detail, r = {
                signal: AbortSignal.timeout(5e3)
            };
            try {
                const s = await this.components.peerStore.get(t, r);
                for (const i of s.protocols){
                    const l = this.topologies.get(i);
                    l != null && await Promise.all([
                        ...l.values()
                    ].map(async (u)=>{
                        u.filter?.has(t) !== !1 && (u.filter?.remove(t), await u.onDisconnect?.(t));
                    }));
                }
            } catch (s) {
                if (s.name === "NotFoundError") return;
                this.log.error("could not inform topologies of disconnecting peer %p - %e", t, s);
            }
        }
        async _onPeerUpdate(e) {
            const { peer: t, previous: r } = e.detail, s = (r?.protocols ?? []).filter((i)=>!t.protocols.includes(i));
            try {
                for (const i of s){
                    const l = this.topologies.get(i);
                    l != null && await Promise.all([
                        ...l.values()
                    ].map(async (u)=>{
                        u.filter?.has(t.id) !== !1 && (u.filter?.remove(t.id), await u.onDisconnect?.(t.id));
                    }));
                }
            } catch (i) {
                this.log.error("could not inform topologies of updated peer %p - %e", t.id, i);
            }
        }
        async _onPeerIdentify(e) {
            const t = e.detail.protocols, r = e.detail.connection, s = e.detail.peerId;
            try {
                for (const i of t){
                    const l = this.topologies.get(i);
                    l != null && await Promise.all([
                        ...l.values()
                    ].map(async (u)=>{
                        r.limits != null && u.notifyOnLimitedConnection !== !0 || u.filter?.has(s) !== !0 && (u.filter?.add(s), await u.onConnect?.(s, r));
                    }));
                }
            } catch (i) {
                this.log.error("could not inform topologies of updated peer after identify %p - %e", s, i);
            }
        }
    }
    class Kre {
        log;
        components;
        transports;
        listeners;
        faultTolerance;
        started;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:transports"), this.components = e, this.started = !1, this.transports = Qs({
                name: "libp2p_transport_manager_transports",
                metrics: this.components.metrics
            }), this.listeners = Qs({
                name: "libp2p_transport_manager_listeners",
                metrics: this.components.metrics
            }), this.faultTolerance = t.faultTolerance ?? Lp.FATAL_ALL;
        }
        [Symbol.toStringTag] = "@libp2p/transport-manager";
        add(e) {
            const t = e[Symbol.toStringTag];
            if (t == null) throw new Vr("Transport must have a valid tag");
            if (this.transports.has(t)) throw new Vr(`There is already a transport with the tag ${t}`);
            this.log("adding transport %s", t), this.transports.set(t, e), this.listeners.has(t) || this.listeners.set(t, []);
        }
        isStarted() {
            return this.started;
        }
        start() {
            this.started = !0;
        }
        async afterStart() {
            const e = this.components.addressManager.getListenAddrs();
            await this.listen(e);
        }
        async stop() {
            const e = [];
            for (const [t, r] of this.listeners)for(this.log("closing listeners for %s", t); r.length > 0;){
                const s = r.pop();
                s != null && e.push(s.close());
            }
            await Promise.all(e), this.log("all listeners closed");
            for (const t of this.listeners.keys())this.listeners.set(t, []);
            this.started = !1;
        }
        async dial(e, t) {
            const r = this.dialTransportForMultiaddr(e);
            if (r == null) throw new Wne(`No transport available for address ${String(e)}`);
            return t?.onProgress?.(new Be("transport-manager:selected-transport", r[Symbol.toStringTag])), r.dial(e, {
                ...t,
                upgrader: this.components.upgrader
            });
        }
        getAddrs() {
            let e = [];
            for (const t of this.listeners.values())for (const r of t)e = [
                ...e,
                ...r.getAddrs()
            ];
            return e;
        }
        getTransports() {
            return Array.of(...this.transports.values());
        }
        getListeners() {
            return Array.of(...this.listeners.values()).flat();
        }
        dialTransportForMultiaddr(e) {
            for (const t of this.transports.values())if (t.dialFilter([
                e
            ]).length > 0) return t;
        }
        listenTransportForMultiaddr(e) {
            for (const t of this.transports.values())if (t.listenFilter([
                e
            ]).length > 0) return t;
        }
        async listen(e) {
            if (!this.isStarted()) throw new Np("Not started");
            if (e == null || e.length === 0) {
                this.log("no addresses were provided for listening, this node is dial only");
                return;
            }
            const t = {
                errors: new Map,
                ipv4: {
                    success: 0,
                    attempts: 0
                },
                ipv6: {
                    success: 0,
                    attempts: 0
                }
            };
            e.forEach((i)=>{
                t.errors.set(i.toString(), new Qne);
            });
            const r = [];
            for (const [i, l] of this.transports.entries()){
                const u = l.listenFilter(e);
                for (const h of u){
                    this.log("creating listener for %s on %a", i, h);
                    const f = l.createListener({
                        upgrader: this.components.upgrader
                    });
                    let p = this.listeners.get(i) ?? [];
                    p == null && (p = [], this.listeners.set(i, p)), p.push(f), f.addEventListener("listening", ()=>{
                        this.components.events.safeDispatchEvent("transport:listening", {
                            detail: f
                        });
                    }), f.addEventListener("close", ()=>{
                        const m = p.findIndex((w)=>w === f);
                        p.splice(m, 1), this.components.events.safeDispatchEvent("transport:close", {
                            detail: f
                        });
                    }), kv.matches(h) ? t.ipv4.attempts++ : Rv.matches(h) && t.ipv6.attempts++, r.push(f.listen(h).then(()=>{
                        t.errors.delete(h.toString()), kv.matches(h) && t.ipv4.success++, Rv.matches(h) && t.ipv6.success++;
                    }, (m)=>{
                        throw this.log.error("transport %s could not listen on address %a - %e", i, h, m), t.errors.set(h.toString(), m), m;
                    }));
                }
            }
            const s = await Promise.allSettled(r);
            if (!(s.length > 0 && s.every((i)=>i.status === "fulfilled"))) {
                if (this.ipv6Unsupported(t)) {
                    this.log("all IPv4 addresses succeed but all IPv6 failed");
                    return;
                }
                if (this.faultTolerance === Lp.NO_FATAL) {
                    this.log("failed to listen on any address but fault tolerance allows this");
                    return;
                }
                throw new qne(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[
                    ...t.errors.entries()
                ].map(([i, l])=>`
  ${i}: ${`${Gre(l)}`.split(`
`).join(`
  `)}
`).join("")}`);
            }
        }
        ipv6Unsupported(e) {
            if (e.ipv4.attempts === 0 || e.ipv6.attempts === 0) return !1;
            const t = e.ipv4.attempts === e.ipv4.success, r = e.ipv6.success === 0;
            return t && r;
        }
        async remove(e) {
            const t = this.listeners.get(e) ?? [];
            this.log.trace("removing transport %s", e);
            const r = [];
            for(this.log.trace("closing listeners for %s", e); t.length > 0;){
                const s = t.pop();
                s != null && r.push(s.close());
            }
            await Promise.all(r), this.transports.delete(e), this.listeners.delete(e);
        }
        async removeAll() {
            const e = [];
            for (const t of this.transports.keys())e.push(this.remove(t));
            await Promise.all(e);
        }
    }
    function Gre(n) {
        return n.stack != null && n.stack.trim() !== "" ? n.stack : n.message != null ? n.message : n.toString();
    }
    const $a = "/multistream/1.0.0", Ox = 1024;
    class Yre extends Error {
        static name = "UnsupportedProtocolError";
        constructor(e = "Unsupported protocol error"){
            super(e), this.name = "UnsupportedProtocolError";
        }
    }
    let Wre = class extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    };
    const jre = re(`
`);
    async function d4(n, e) {
        const r = (await n.read(e)).subarray();
        if (r.byteLength === 0 || r[r.length - 1] !== jre[0]) throw new Wre("Missing newline");
        return L(r).trimEnd();
    }
    async function f4(n, e, t = {}) {
        if (e = Array.isArray(e) ? [
            ...e
        ] : [
            e
        ], e.length === 0) throw new Error("At least one protocol must be specified");
        const r = n.log.newScope("mss:select"), s = Vd(n, {
            ...t,
            maxDataLength: Ox
        });
        for(let i = 0; i < e.length; i++){
            const l = e[i];
            let u;
            if (i === 0) {
                r.trace('write ["%s", "%s"]', $a, l);
                const h = re(`${$a}
`), f = re(`${l}
`);
                if (await s.writeV([
                    h,
                    f
                ], t), r.trace("reading multistream-select header"), u = await d4(s, t), r.trace('read "%s"', u), u !== $a) {
                    r.error("did not read multistream-select header from response");
                    break;
                }
            } else r.trace('write "%s"', l), await s.write(re(`${l}
`), t);
            if (r.trace("reading protocol response"), u = await d4(s, t), r.trace('read "%s"', u), u === l) return r.trace('selected "%s" after negotiation', u), s.unwrap(), l;
        }
        throw new Yre(`Protocol selection failed - could not negotiate ${e}`);
    }
    const $x = 1024 * 1024 * 4;
    let Xre = class extends Error {
        name = "InvalidDataLengthError";
        code = "ERR_MSG_DATA_TOO_LONG";
    };
    function Jre(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function Mx(n, e) {
        if (n.byteLength > e) throw new Xre("Message length too long");
    }
    const Pg = (n)=>{
        const e = be(n), t = Wn(e);
        return zr(n, t), Pg.bytes = e, t;
    };
    Pg.bytes = 0;
    function Nx(n, e) {
        e = e ?? {};
        const t = e.lengthEncoder ?? Pg, r = e?.maxDataLength ?? $x;
        function* s(i) {
            Mx(i, r);
            const l = t(i.byteLength);
            l instanceof Uint8Array ? yield l : yield* l, i instanceof Uint8Array ? yield i : yield* i;
        }
        return Jre(n) ? (async function*() {
            for await (const i of n)yield* s(i);
        })() : (function*() {
            for (const i of n)yield* s(i);
        })();
    }
    Nx.single = (n, e)=>{
        e = e ?? {};
        const t = e.lengthEncoder ?? Pg, r = e?.maxDataLength ?? $x;
        return Mx(n, r), new Re(t(n.byteLength), n);
    };
    var xE;
    (function(n) {
        n[n.LENGTH = 0] = "LENGTH", n[n.DATA = 1] = "DATA";
    })(xE || (xE = {}));
    async function p4(n, e, t = {}) {
        e = Array.isArray(e) ? e : [
            e
        ];
        const r = n.log.newScope("mss:handle"), s = Vd(n, {
            ...t,
            maxDataLength: Ox,
            maxLengthLength: 2
        });
        for(;;){
            r.trace("reading incoming string");
            const i = await d4(s, t);
            if (r.trace('read "%s"', i), i === $a) {
                r.trace('respond with "%s" for "%s"', $a, i), await s.write(re(`${$a}
`), t), r.trace('responded with "%s" for "%s"', $a, i);
                continue;
            }
            if (e.includes(i)) return r.trace('respond with "%s" for "%s"', i, i), await s.write(re(`${i}
`), t), r.trace('responded with "%s" for "%s"', i, i), s.unwrap(), i;
            if (i === "ls") {
                const l = new Re(...e.map((u)=>Nx.single(re(`${u}
`))), re(`
`));
                r.trace('respond with "%s" for %s', e, i), await s.write(l, t), r.trace('responded with "%s" for %s', e, i);
                continue;
            }
            r.trace('respond with "na" for "%s"', i), await s.write(re(`na
`), t), r('responded with "na" for "%s"', i);
        }
    }
    class Zre extends Lt {
        id;
        remoteAddr;
        remotePeer;
        direction;
        timeline;
        direct;
        multiplexer;
        encryption;
        limits;
        log;
        maConn;
        muxer;
        components;
        outboundStreamProtocolNegotiationTimeout;
        inboundStreamProtocolNegotiationTimeout;
        closeTimeout;
        constructor(e, t){
            super(), this.components = e, this.id = t.id, this.remoteAddr = t.maConn.remoteAddr, this.remotePeer = t.remotePeer, this.direction = t.direction ?? "outbound", this.timeline = t.maConn.timeline, this.encryption = t.cryptoProtocol, this.limits = t.limits, this.maConn = t.maConn, this.log = t.maConn.log, this.outboundStreamProtocolNegotiationTimeout = t.outboundStreamProtocolNegotiationTimeout ?? Hp, this.inboundStreamProtocolNegotiationTimeout = t.inboundStreamProtocolNegotiationTimeout ?? Hp, this.closeTimeout = t.closeTimeout ?? Cx, this.direct = Ax(t.maConn.remoteAddr), this.onIncomingStream = this.onIncomingStream.bind(this), this.remoteAddr.getComponents().find((r)=>r.code === fi) == null && (this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)), t.muxer != null && (this.multiplexer = t.muxer.protocol, this.muxer = t.muxer, this.muxer.addEventListener("stream", this.onIncomingStream)), this.maConn.addEventListener("close", (r)=>{
                this.dispatchEvent(new XX(r.local, r.error));
            });
        }
        [Symbol.toStringTag] = "Connection";
        [VX] = !0;
        get streams() {
            return this.muxer?.streams ?? [];
        }
        get status() {
            return this.maConn.status;
        }
        newStream = async (e, t = {})=>{
            if (this.muxer == null) throw new lp("Connection is not multiplexed");
            if (this.muxer.status !== "open") throw new i4(`The connection muxer is "${this.muxer.status}" and not "open"`);
            if (this.maConn.status !== "open") throw new i4(`The connection is "${this.status}" and not "open"`);
            if (this.limits != null && t?.runOnLimitedConnection !== !0) throw new Zv("Cannot open protocol stream on limited connection");
            Array.isArray(e) || (e = [
                e
            ]), this.log.trace("starting new stream for protocols %s", e);
            const r = await this.muxer.createStream({
                ...t,
                protocol: e.length === 1 ? e[0] : void 0
            });
            this.log.trace("started new stream %s for protocols %s", r.id, e);
            try {
                if (t.signal == null) {
                    r.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", e);
                    const u = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
                    t = {
                        ...t,
                        signal: u
                    };
                }
                r.protocol === "" ? (r.log.trace("selecting protocol from protocols %s", e), r.protocol = await f4(r, e, t), r.log("negotiated protocol %s", r.protocol)) : r.log("pre-negotiated protocol %s", r.protocol);
                const s = nse(r.protocol, this.components.registrar, t), i = DE(r.protocol, "outbound", this);
                if (i > s) {
                    const u = new WX(`Too many outbound protocol streams for protocol "${r.protocol}" - ${i}/${s}`);
                    throw r.abort(u), u;
                }
                await this.components.peerStore.merge(this.remotePeer, {
                    protocols: [
                        r.protocol
                    ]
                }), this.components.metrics?.trackProtocolStream(r);
                const l = this.components.registrar.getMiddleware(r.protocol);
                return await this.runMiddlewareChain(r, this, l);
            } catch (s) {
                throw r.status === "open" ? r.abort(s) : this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", this.direction === "inbound" ? "from" : "to", this.remoteAddr, e, s), s;
            }
        };
        async onIncomingStream(e) {
            const t = e.detail, r = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
            t.log("start protocol negotiation, timing out after %dms", this.inboundStreamProtocolNegotiationTimeout);
            try {
                if (t.protocol === "") {
                    const f = this.components.registrar.getProtocols();
                    t.log.trace("selecting protocol from protocols %s", f), t.protocol = await p4(t, f, {
                        signal: r
                    }), t.log("negotiated protocol %s", t.protocol);
                } else t.log("pre-negotiated protocol %s", t.protocol);
                const s = tse(t.protocol, this.components.registrar);
                if (DE(t.protocol, "inbound", this) > s) throw new YX(`Too many inbound protocol streams for protocol "${t.protocol}" - limit ${s}`);
                await this.components.peerStore.merge(this.remotePeer, {
                    protocols: [
                        t.protocol
                    ]
                }, {
                    signal: r
                }), this.components.metrics?.trackProtocolStream(t);
                const { handler: l, options: u } = this.components.registrar.getHandler(t.protocol);
                if (this.limits != null && u.runOnLimitedConnection !== !0) throw new Zv("Cannot open protocol stream on limited connection");
                const h = this.components.registrar.getMiddleware(t.protocol);
                h.push(async (f, p, m)=>{
                    await l(f, p), m(f, p);
                }), await this.runMiddlewareChain(t, this, h);
            } catch (s) {
                t.abort(s);
            }
        }
        async runMiddlewareChain(e, t, r) {
            for(let s = 0; s < r.length; s++){
                const i = r[s];
                e.log.trace("running middleware", s, i), await new Promise((l, u)=>{
                    try {
                        const h = i(e, t, (f, p)=>{
                            e = f, t = p, l();
                        });
                        h instanceof Promise && h.catch(u);
                    } catch (h) {
                        u(h);
                    }
                }), e.log.trace("ran middleware", s, i);
            }
            return e;
        }
        async close(e = {}) {
            if (this.log("closing connection to %a", this.remoteAddr), e.signal == null) {
                const t = AbortSignal.timeout(this.closeTimeout);
                e = {
                    ...e,
                    signal: t
                };
            }
            await this.muxer?.close(e), await this.maConn.close(e);
        }
        abort(e) {
            this.muxer?.abort(e), this.maConn.abort(e);
        }
    }
    function ese(n, e) {
        return new Zre(n, e);
    }
    function tse(n, e) {
        try {
            const { options: t } = e.getHandler(n);
            if (t.maxInboundStreams != null) return t.maxInboundStreams;
        } catch (t) {
            if (t.name !== "UnhandledProtocolError") throw t;
        }
        return kx;
    }
    function nse(n, e, t = {}) {
        try {
            const { options: r } = e.getHandler(n);
            if (r.maxOutboundStreams != null) return r.maxOutboundStreams;
        } catch (r) {
            if (r.name !== "UnhandledProtocolError") throw r;
        }
        return t.maxOutboundStreams ?? Rx;
    }
    function DE(n, e, t) {
        let r = 0;
        return t.streams.forEach((s)=>{
            s.direction === e && s.protocol === n && r++;
        }), r;
    }
    class rse {
        components;
        connectionEncrypters;
        streamMuxers;
        inboundUpgradeTimeout;
        inboundStreamProtocolNegotiationTimeout;
        outboundStreamProtocolNegotiationTimeout;
        events;
        metrics;
        connectionCloseTimeout;
        constructor(e, t){
            this.components = e, this.connectionEncrypters = Qs({
                name: "libp2p_upgrader_connection_encrypters",
                metrics: this.components.metrics
            }), t.connectionEncrypters.forEach((r)=>{
                this.connectionEncrypters.set(r.protocol, r);
            }), this.streamMuxers = Qs({
                name: "libp2p_upgrader_stream_multiplexers",
                metrics: this.components.metrics
            }), t.streamMuxers.forEach((r)=>{
                this.streamMuxers.set(r.protocol, r);
            }), this.inboundUpgradeTimeout = t.inboundUpgradeTimeout ?? cre, this.inboundStreamProtocolNegotiationTimeout = t.inboundStreamProtocolNegotiationTimeout ?? Hp, this.outboundStreamProtocolNegotiationTimeout = t.outboundStreamProtocolNegotiationTimeout ?? Hp, this.connectionCloseTimeout = t.connectionCloseTimeout ?? Cx, this.events = e.events, this.metrics = {
                dials: e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),
                errors: e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
                inboundErrors: e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
                outboundErrors: e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
            };
        }
        [Symbol.toStringTag] = "@libp2p/upgrader";
        async shouldBlockConnection(e, ...t) {
            const r = this.components.connectionGater[e];
            if (r == null) return;
            if (await r.apply(this.components.connectionGater, t) === !0) throw new Gne(`The multiaddr connection is blocked by gater.${e}`);
        }
        createInboundAbortSignal(e) {
            return gt([
                AbortSignal.timeout(this.inboundUpgradeTimeout),
                e
            ]);
        }
        async upgradeInbound(e, t) {
            let r = !1;
            const s = this.createInboundAbortSignal(t.signal);
            try {
                if (this.metrics.dials?.increment({
                    inbound: !0
                }), r = this.components.connectionManager.acceptIncomingConnection(e), !r) throw new Yne("Connection denied");
                await Xn(this.shouldBlockConnection("denyInboundConnection", e), s), await this._performUpgrade(e, "inbound", {
                    ...t,
                    signal: s
                });
            } catch (i) {
                throw this.metrics.errors?.increment({
                    inbound: !0
                }), this.metrics.inboundErrors?.increment({
                    [i.name ?? "Error"]: !0
                }), i;
            } finally{
                s.clear(), r && this.components.connectionManager.afterUpgradeInbound();
            }
        }
        async upgradeOutbound(e, t) {
            try {
                this.metrics.dials?.increment({
                    outbound: !0
                });
                const r = e.remoteAddr.getComponents().findLast((l)=>l.code === fi)?.value;
                let s;
                r != null && (s = Fc(r), await Xn(this.shouldBlockConnection("denyOutboundConnection", s, e), t.signal));
                let i = "outbound";
                return t.initiator === !1 && (i = "inbound"), await this._performUpgrade(e, i, t);
            } catch (r) {
                throw this.metrics.errors?.increment({
                    outbound: !0
                }), this.metrics.outboundErrors?.increment({
                    [r.name ?? "Error"]: !0
                }), r;
            }
        }
        async _performUpgrade(e, t, r) {
            let s = e, i, l, u, h;
            const f = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
            if (e.log = e.log.newScope(`${t}:${f}`), this.components.metrics?.trackMultiaddrConnection(e), e.log.trace("starting the %s connection upgrade", t), r?.skipProtection !== !0) {
                const m = this.components.connectionProtector;
                m != null && (e.log("protecting the %s connection", t), s = await m.protect(s, r));
            }
            try {
                if (sse(r)) {
                    if (r.remotePeer == null) throw new c8(`${t} connection that skipped encryption must have a peer id`);
                    h = "native", i = r.remotePeer;
                } else {
                    const m = e.remoteAddr.getComponents().findLast((A)=>A.code === fi)?.value;
                    let w;
                    m != null && (w = Fc(m)), r?.onProgress?.(new Be(`upgrader:encrypt-${t}-connection`)), { connection: s, remotePeer: i, protocol: h, streamMuxer: l } = await (t === "inbound" ? this._encryptInbound(s, {
                        ...r,
                        remotePeer: w
                    }) : this._encryptOutbound(s, {
                        ...r,
                        remotePeer: w
                    }));
                }
                if (i.equals(this.components.peerId)) {
                    const m = new Q_("Can not dial self");
                    throw e.abort(m), m;
                }
                await this.shouldBlockConnection(t === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", i, e), r?.muxerFactory != null ? l = r.muxerFactory : l == null && this.streamMuxers.size > 0 && (r?.onProgress?.(new Be(`upgrader:multiplex-${t}-connection`)), l = await (t === "inbound" ? this._multiplexInbound(s, this.streamMuxers, r) : this._multiplexOutbound(s, this.streamMuxers, r)));
            } catch (m) {
                throw e.log.error("failed to upgrade %s connection %s %a - %e", t, t === "inbound" ? "from" : "to", e.remoteAddr, m), m;
            }
            l != null && (e.log("create muxer %s", l.protocol), u = l.createStreamMuxer(s)), await this.shouldBlockConnection(t === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", i, e);
            const p = this._createConnection({
                id: f,
                cryptoProtocol: h,
                direction: t,
                maConn: e,
                stream: s,
                muxer: u,
                remotePeer: i,
                limits: r?.limits,
                closeTimeout: this.connectionCloseTimeout
            });
            return p.log("successfully upgraded connection"), p;
        }
        _createConnection(e) {
            const t = ese(this.components, {
                ...e,
                outboundStreamProtocolNegotiationTimeout: this.outboundStreamProtocolNegotiationTimeout,
                inboundStreamProtocolNegotiationTimeout: this.inboundStreamProtocolNegotiationTimeout
            });
            return t.addEventListener("close", ()=>{
                this.events.safeDispatchEvent("connection:close", {
                    detail: t
                });
            }), this.events.safeDispatchEvent("connection:open", {
                detail: t
            }), t;
        }
        async _encryptInbound(e, t) {
            const r = Array.from(this.connectionEncrypters.keys());
            try {
                const s = await p4(e, r, t), i = this.connectionEncrypters.get(s);
                if (i == null) throw new B0(`no crypto module found for ${s}`);
                return e.log("encrypting inbound connection using %s", s), {
                    ...await i.secureInbound(e, t),
                    protocol: s
                };
            } catch (s) {
                throw new B0(s.message);
            }
        }
        async _encryptOutbound(e, t) {
            const r = Array.from(this.connectionEncrypters.keys());
            try {
                e.log.trace("selecting encrypter from %s", r);
                const s = await f4(e, r, t), i = this.connectionEncrypters.get(s);
                if (i == null) throw new B0(`no crypto module found for ${s}`);
                return e.log("encrypting outbound connection using %s", s), {
                    ...await i.secureOutbound(e, t),
                    protocol: s
                };
            } catch (s) {
                throw new B0(s.message);
            }
        }
        async _multiplexOutbound(e, t, r) {
            const s = Array.from(t.keys());
            e.log("outbound selecting muxer %s", s);
            try {
                e.log.trace("selecting stream muxer from %s", s);
                const i = await f4(e, s, r), l = t.get(i);
                if (l == null) throw new lp(`No muxer configured for protocol "${i}"`);
                return e.log("selected %s as muxer protocol", i), l;
            } catch (i) {
                throw e.log.error("error multiplexing outbound connection - %e", i), new lp(String(i));
            }
        }
        async _multiplexInbound(e, t, r) {
            const s = Array.from(t.keys());
            e.log("inbound handling muxers %s", s);
            try {
                e.log.trace("selecting stream muxer from %s", s);
                const i = await p4(e, s, r), l = t.get(i);
                if (l == null) throw new lp(`No muxer configured for protocol "${i}"`);
                return e.log("selected %s as muxer protocol", i), l;
            } catch (i) {
                throw e.log.error("error multiplexing inbound connection - %e", i), i;
            }
        }
        getConnectionEncrypters() {
            return this.connectionEncrypters;
        }
        getStreamMuxers() {
            return this.streamMuxers;
        }
    }
    function sse(n) {
        return n.skipEncryption === !0;
    }
    const Lx = "3.1.3", Ux = "js-libp2p";
    function zx(n, e) {
        return `${n ?? Ux}/${e ?? Lx} browser/${globalThis.navigator.userAgent}`;
    }
    class Fx extends Lt {
        peerId;
        peerStore;
        contentRouting;
        peerRouting;
        metrics;
        services;
        logger;
        status;
        components;
        log;
        constructor(e){
            super(), this.status = "stopped";
            const t = new Lt, r = t.dispatchEvent.bind(t);
            t.dispatchEvent = (f)=>{
                const p = r(f), m = this.dispatchEvent(new CustomEvent(f.type, {
                    detail: f.detail
                }));
                return p || m;
            }, this.peerId = e.peerId, this.logger = e.logger ?? F6(), this.log = this.logger.forComponent("libp2p"), this.services = {};
            const s = e.nodeInfo?.name ?? Ux, i = e.nodeInfo?.version ?? Lx, l = this.components = ere({
                peerId: e.peerId,
                privateKey: e.privateKey,
                nodeInfo: {
                    name: s,
                    version: i,
                    userAgent: e.nodeInfo?.userAgent ?? zx(s, i)
                },
                logger: this.logger,
                events: t,
                datastore: e.datastore ?? new l8,
                connectionGater: ire(e.connectionGater),
                dns: e.dns
            });
            e.metrics != null && (this.metrics = this.configureComponent("metrics", e.metrics(this.components))), this.peerStore = this.configureComponent("peerStore", Ste(l, {
                addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
                ...e.peerStore
            })), l.events.addEventListener("peer:update", (f)=>{
                if (f.detail.previous == null) {
                    const p = {
                        id: f.detail.peer.id,
                        multiaddrs: f.detail.peer.addresses.map((m)=>m.multiaddr)
                    };
                    l.events.safeDispatchEvent("peer:discovery", {
                        detail: p
                    });
                }
            }), e.connectionProtector != null && this.configureComponent("connectionProtector", e.connectionProtector(l)), this.components.upgrader = new rse(this.components, {
                connectionEncrypters: (e.connectionEncrypters ?? []).map((f, p)=>this.configureComponent(`connection-encryption-${p}`, f(this.components))),
                streamMuxers: (e.streamMuxers ?? []).map((f, p)=>this.configureComponent(`stream-muxers-${p}`, f(this.components))),
                inboundUpgradeTimeout: e.connectionManager?.inboundUpgradeTimeout,
                inboundStreamProtocolNegotiationTimeout: e.connectionManager?.inboundStreamProtocolNegotiationTimeout,
                outboundStreamProtocolNegotiationTimeout: e.connectionManager?.outboundStreamProtocolNegotiationTimeout,
                connectionCloseTimeout: e.connectionManager?.connectionCloseTimeout
            }), this.configureComponent("transportManager", new Kre(this.components, e.transportManager)), this.configureComponent("connectionManager", new $re(this.components, e.connectionManager)), e.connectionMonitor?.enabled !== !1 && this.configureComponent("connectionMonitor", new Fre(this.components, e.connectionMonitor)), this.configureComponent("registrar", new qre(this.components)), this.configureComponent("addressManager", new Lne(this.components, e.addresses));
            const u = (e.peerRouters ?? []).map((f, p)=>this.configureComponent(`peer-router-${p}`, f(this.components)));
            this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new Hre(this.components, {
                routers: u
            }));
            const h = (e.contentRouters ?? []).map((f, p)=>this.configureComponent(`content-router-${p}`, f(this.components)));
            if (this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new Vre(this.components, {
                routers: h
            })), this.configureComponent("randomWalk", new Qre(this.components)), (e.peerDiscovery ?? []).forEach((f, p)=>{
                this.configureComponent(`peer-discovery-${p}`, f(this.components)).addEventListener("peer", (w)=>{
                    this.#e(w);
                });
            }), e.transports?.forEach((f, p)=>{
                this.components.transportManager.add(this.configureComponent(`transport-${p}`, f(this.components)));
            }), e.services != null) for (const f of Object.keys(e.services)){
                const p = e.services[f], m = p(this.components);
                if (m == null) {
                    this.log.error("service factory %s returned null or undefined instance", f);
                    continue;
                }
                this.services[f] = m, this.configureComponent(f, m), m[Jv] != null && (this.log("registering service %s for content routing", f), h.push(m[Jv])), m[tE] != null && (this.log("registering service %s for peer routing", f), u.push(m[tE])), m[eE] != null && (this.log("registering service %s for peer discovery", f), m[eE].addEventListener?.("peer", (w)=>{
                    this.#e(w);
                }));
            }
            tre(l);
        }
        configureComponent(e, t) {
            return t == null && this.log.error("component %s was null or undefined", e), this.components[e] = t, t;
        }
        async start() {
            if (this.status === "stopped") {
                this.status = "starting", this.log("libp2p is starting");
                try {
                    await this.components.beforeStart?.(), await this.components.start(), await this.components.afterStart?.(), this.status = "started", this.safeDispatchEvent("start", {
                        detail: this
                    }), this.log("libp2p has started with peer id %p", this.peerId);
                } catch (e) {
                    throw this.log.error("an error occurred starting libp2p - %e", e), this.status = "started", await this.stop(), e;
                }
            }
        }
        async stop() {
            this.status === "started" && (this.log("libp2p is stopping"), this.status = "stopping", await this.components.beforeStop?.(), await this.components.stop(), await this.components.afterStop?.(), this.status = "stopped", this.safeDispatchEvent("stop", {
                detail: this
            }), this.log("libp2p has stopped"));
        }
        getConnections(e) {
            return this.components.connectionManager.getConnections(e);
        }
        getDialQueue() {
            return this.components.connectionManager.getDialQueue();
        }
        getPeers() {
            const e = new X_;
            for (const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);
            return Array.from(e);
        }
        async dial(e, t = {}) {
            return this.components.connectionManager.openConnection(e, {
                priority: 75,
                ...t
            });
        }
        async dialProtocol(e, t, r = {}) {
            if (t == null) throw new Vr("no protocols were provided to open a stream");
            if (t = Array.isArray(t) ? t : [
                t
            ], t.length === 0) throw new Vr("no protocols were provided to open a stream");
            return this.components.connectionManager.openStream(e, t, r);
        }
        getMultiaddrs() {
            return this.components.addressManager.getAddresses();
        }
        getProtocols() {
            return this.components.registrar.getProtocols();
        }
        async hangUp(e, t = {}) {
            w8(e) && (e = Fc(e.getComponents().findLast((r)=>r.code === fi)?.value ?? "")), await this.components.connectionManager.closeConnections(e, t);
        }
        async getPublicKey(e, t = {}) {
            if (this.log("getPublicKey %p", e), e.publicKey != null) return e.publicKey;
            try {
                const l = await this.peerStore.get(e, t);
                if (l.id.publicKey != null) return l.id.publicKey;
            } catch (l) {
                if (l.name !== "NotFoundError") throw l;
            }
            const r = xe([
                re("/pk/"),
                e.toMultihash().bytes
            ]), s = await this.contentRouting.get(r, t), i = Er(s);
            return await this.peerStore.patch(e, {
                publicKey: i
            }, t), i;
        }
        async handle(e, t, r) {
            Array.isArray(e) || (e = [
                e
            ]), await Promise.all(e.map(async (s)=>{
                await this.components.registrar.handle(s, t, r);
            }));
        }
        async unhandle(e, t) {
            Array.isArray(e) || (e = [
                e
            ]), await Promise.all(e.map(async (r)=>{
                await this.components.registrar.unhandle(r, t);
            }));
        }
        async register(e, t, r) {
            return this.components.registrar.register(e, t, r);
        }
        unregister(e) {
            this.components.registrar.unregister(e);
        }
        use(e, t) {
            this.components.registrar.use(e, Array.isArray(t) ? t : [
                t
            ]);
        }
        unuse(e) {
            this.components.registrar.unuse(e);
        }
        async isDialable(e, t = {}) {
            return this.components.connectionManager.isDialable(e, t);
        }
        #e(e) {
            const { detail: t } = e;
            if (t.id.toString() === this.peerId.toString()) {
                this.log.error("peer discovery mechanism discovered self");
                return;
            }
            this.components.peerStore.merge(t.id, {
                multiaddrs: t.multiaddrs
            }).catch((r)=>{
                this.log.error("could not update multiaddrs of discovered peer - %e", r);
            });
        }
    }
    async function Vx(n = {}) {
        n.privateKey ??= await E6("Ed25519");
        const e = new Fx({
            ...await uJ(n),
            peerId: iJ(n.privateKey)
        });
        return n.start !== !1 && await e.start(), e;
    }
    const ise = [
        "dial",
        "dialProtocol",
        "hangUp",
        "handle",
        "unhandle",
        "getMultiaddrs",
        "getProtocols"
    ];
    function ose(n) {
        return n == null ? !1 : n instanceof Fx ? !0 : ise.every((e)=>typeof n[e] == "function");
    }
    let _t = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, ase = class extends Error {
        static name = "NotFoundError";
        constructor(e = "Not found"){
            super(e), this.name = "NotFoundError";
        }
    }, lse = class extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    };
    const cse = Symbol.for("@libp2p/service-capabilities");
    var W3, BE;
    function use() {
        if (BE) return W3;
        BE = 1;
        function n(t) {
            return t >= 55296 && t <= 56319;
        }
        function e(t) {
            return t >= 56320 && t <= 57343;
        }
        return W3 = function(r, s, i) {
            if (typeof s != "string") throw new Error("Input must be string");
            for(var l = s.length, u = 0, h, f, p = 0; p < l; p += 1){
                if (h = s.charCodeAt(p), f = s[p], n(h) && e(s.charCodeAt(p + 1)) && (p += 1, f += s[p]), u += r(f), u === i) return s.slice(0, p + 1);
                if (u > i) return s.slice(0, p - f.length + 1);
            }
            return s;
        }, W3;
    }
    var j3, PE;
    function hse() {
        if (PE) return j3;
        PE = 1;
        function n(t) {
            return t >= 55296 && t <= 56319;
        }
        function e(t) {
            return t >= 56320 && t <= 57343;
        }
        return j3 = function(r) {
            if (typeof r != "string") throw new Error("Input must be string");
            for(var s = r.length, i = 0, l = null, u = null, h = 0; h < s; h++)l = r.charCodeAt(h), e(l) ? u != null && n(u) ? i += 1 : i += 3 : l <= 127 ? i += 1 : l >= 128 && l <= 2047 ? i += 2 : l >= 2048 && l <= 65535 && (i += 3), u = l;
            return i;
        }, j3;
    }
    var X3, kE;
    function dse() {
        if (kE) return X3;
        kE = 1;
        var n = use(), e = hse();
        return X3 = n.bind(null, e), X3;
    }
    var J3, RE;
    function fse() {
        if (RE) return J3;
        RE = 1;
        var n = dse(), e = /[\/\?<>\\:\*\|"]/g, t = /[\x00-\x1f\x80-\x9f]/g, r = /^\.+$/, s = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i, i = /[\. ]+$/;
        function l(u, h) {
            if (typeof u != "string") throw new Error("Input must be string");
            var f = u.replace(e, h).replace(t, h).replace(r, h).replace(s, h).replace(i, h);
            return n(f, 255);
        }
        return J3 = function(u, h) {
            var f = h && h.replacement || "", p = l(u, f);
            return f === "" ? p : l(p, "");
        }, J3;
    }
    var pse = fse();
    const gse = Zc(pse), OE = {
        keyLength: 512 / 8,
        iterationCount: 1e4,
        salt: "you should override this value with a crypto secure random number",
        hash: "sha2-512"
    }, Z3 = {
        alg: "A128GCM",
        ext: !0,
        k: "scm9jmO_4BJAgdwWGVulLg",
        key_ops: [
            "encrypt",
            "decrypt"
        ],
        kty: "oct"
    };
    function Hx(n) {
        const e = "AES-GCM";
        let t = 16;
        const r = 12, s = "SHA-256", i = 16, l = 32767, u = nr.get();
        t *= 8;
        async function h(m, w) {
            const A = u.getRandomValues(new Uint8Array(i)), S = u.getRandomValues(new Uint8Array(r)), _ = {
                name: e,
                iv: S
            };
            typeof w == "string" && (w = re(w));
            let I;
            if (w.length === 0) {
                I = await u.subtle.importKey("jwk", Z3, {
                    name: "AES-GCM"
                }, !0, [
                    "encrypt"
                ]);
                try {
                    const G = {
                        name: "PBKDF2",
                        salt: A,
                        iterations: l,
                        hash: {
                            name: s
                        }
                    }, P = await u.subtle.importKey("raw", w, {
                        name: "PBKDF2"
                    }, !1, [
                        "deriveKey"
                    ]);
                    I = await u.subtle.deriveKey(G, P, {
                        name: e,
                        length: t
                    }, !0, [
                        "encrypt"
                    ]);
                } catch  {
                    I = await u.subtle.importKey("jwk", Z3, {
                        name: "AES-GCM"
                    }, !0, [
                        "encrypt"
                    ]);
                }
            } else {
                const G = {
                    name: "PBKDF2",
                    salt: A,
                    iterations: l,
                    hash: {
                        name: s
                    }
                }, P = await u.subtle.importKey("raw", w, {
                    name: "PBKDF2"
                }, !1, [
                    "deriveKey"
                ]);
                I = await u.subtle.deriveKey(G, P, {
                    name: e,
                    length: t
                }, !0, [
                    "encrypt"
                ]);
            }
            const k = await u.subtle.encrypt(_, I, m);
            return xe([
                A,
                _.iv,
                new Uint8Array(k)
            ]);
        }
        async function f(m, w) {
            const A = m.subarray(0, i), S = m.subarray(i, i + r), _ = m.subarray(i + r), I = {
                name: e,
                iv: S
            };
            typeof w == "string" && (w = re(w));
            let k;
            if (w.length === 0) try {
                const P = {
                    name: "PBKDF2",
                    salt: A,
                    iterations: l,
                    hash: {
                        name: s
                    }
                }, J = await u.subtle.importKey("raw", w, {
                    name: "PBKDF2"
                }, !1, [
                    "deriveKey"
                ]);
                k = await u.subtle.deriveKey(P, J, {
                    name: e,
                    length: t
                }, !0, [
                    "decrypt"
                ]);
            } catch  {
                k = await u.subtle.importKey("jwk", Z3, {
                    name: "AES-GCM"
                }, !0, [
                    "decrypt"
                ]);
            }
            else {
                const P = {
                    name: "PBKDF2",
                    salt: A,
                    iterations: l,
                    hash: {
                        name: s
                    }
                }, J = await u.subtle.importKey("raw", w, {
                    name: "PBKDF2"
                }, !1, [
                    "deriveKey"
                ]);
                k = await u.subtle.deriveKey(P, J, {
                    name: e,
                    length: t
                }, !0, [
                    "decrypt"
                ]);
            }
            const G = await u.subtle.decrypt(I, k, _);
            return new Uint8Array(G);
        }
        return {
            encrypt: h,
            decrypt: f
        };
    }
    var Qx = {}, kg = {};
    kg.byteLength = wse;
    kg.toByteArray = vse;
    kg.fromByteArray = Sse;
    var ni = [], ss = [], mse = typeof Uint8Array < "u" ? Uint8Array : Array, ey = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(var Ql = 0, yse = ey.length; Ql < yse; ++Ql)ni[Ql] = ey[Ql], ss[ey.charCodeAt(Ql)] = Ql;
    ss[45] = 62;
    ss[95] = 63;
    function qx(n) {
        var e = n.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = n.indexOf("=");
        t === -1 && (t = e);
        var r = t === e ? 0 : 4 - t % 4;
        return [
            t,
            r
        ];
    }
    function wse(n) {
        var e = qx(n), t = e[0], r = e[1];
        return (t + r) * 3 / 4 - r;
    }
    function bse(n, e, t) {
        return (e + t) * 3 / 4 - t;
    }
    function vse(n) {
        var e, t = qx(n), r = t[0], s = t[1], i = new mse(bse(n, r, s)), l = 0, u = s > 0 ? r - 4 : r, h;
        for(h = 0; h < u; h += 4)e = ss[n.charCodeAt(h)] << 18 | ss[n.charCodeAt(h + 1)] << 12 | ss[n.charCodeAt(h + 2)] << 6 | ss[n.charCodeAt(h + 3)], i[l++] = e >> 16 & 255, i[l++] = e >> 8 & 255, i[l++] = e & 255;
        return s === 2 && (e = ss[n.charCodeAt(h)] << 2 | ss[n.charCodeAt(h + 1)] >> 4, i[l++] = e & 255), s === 1 && (e = ss[n.charCodeAt(h)] << 10 | ss[n.charCodeAt(h + 1)] << 4 | ss[n.charCodeAt(h + 2)] >> 2, i[l++] = e >> 8 & 255, i[l++] = e & 255), i;
    }
    function Ese(n) {
        return ni[n >> 18 & 63] + ni[n >> 12 & 63] + ni[n >> 6 & 63] + ni[n & 63];
    }
    function Ase(n, e, t) {
        for(var r, s = [], i = e; i < t; i += 3)r = (n[i] << 16 & 16711680) + (n[i + 1] << 8 & 65280) + (n[i + 2] & 255), s.push(Ese(r));
        return s.join("");
    }
    function Sse(n) {
        for(var e, t = n.length, r = t % 3, s = [], i = 16383, l = 0, u = t - r; l < u; l += i)s.push(Ase(n, l, l + i > u ? u : l + i));
        return r === 1 ? (e = n[t - 1], s.push(ni[e >> 2] + ni[e << 4 & 63] + "==")) : r === 2 && (e = (n[t - 2] << 8) + n[t - 1], s.push(ni[e >> 10] + ni[e >> 4 & 63] + ni[e << 2 & 63] + "=")), s.join("");
    }
    var b8 = {};
    b8.read = function(n, e, t, r, s) {
        var i, l, u = s * 8 - r - 1, h = (1 << u) - 1, f = h >> 1, p = -7, m = t ? s - 1 : 0, w = t ? -1 : 1, A = n[e + m];
        for(m += w, i = A & (1 << -p) - 1, A >>= -p, p += u; p > 0; i = i * 256 + n[e + m], m += w, p -= 8);
        for(l = i & (1 << -p) - 1, i >>= -p, p += r; p > 0; l = l * 256 + n[e + m], m += w, p -= 8);
        if (i === 0) i = 1 - f;
        else {
            if (i === h) return l ? NaN : (A ? -1 : 1) * (1 / 0);
            l = l + Math.pow(2, r), i = i - f;
        }
        return (A ? -1 : 1) * l * Math.pow(2, i - r);
    };
    b8.write = function(n, e, t, r, s, i) {
        var l, u, h, f = i * 8 - s - 1, p = (1 << f) - 1, m = p >> 1, w = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, A = r ? 0 : i - 1, S = r ? 1 : -1, _ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, l = p) : (l = Math.floor(Math.log(e) / Math.LN2), e * (h = Math.pow(2, -l)) < 1 && (l--, h *= 2), l + m >= 1 ? e += w / h : e += w * Math.pow(2, 1 - m), e * h >= 2 && (l++, h /= 2), l + m >= p ? (u = 0, l = p) : l + m >= 1 ? (u = (e * h - 1) * Math.pow(2, s), l = l + m) : (u = e * Math.pow(2, m - 1) * Math.pow(2, s), l = 0)); s >= 8; n[t + A] = u & 255, A += S, u /= 256, s -= 8);
        for(l = l << s | u, f += s; f > 0; n[t + A] = l & 255, A += S, l /= 256, f -= 8);
        n[t + A - S] |= _ * 128;
    };
    (function(n) {
        const e = kg, t = b8, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        n.Buffer = p, n.SlowBuffer = H, n.INSPECT_MAX_BYTES = 50;
        const s = 2147483647;
        n.kMaxLength = s;
        const { Uint8Array: i, ArrayBuffer: l, SharedArrayBuffer: u } = globalThis;
        p.TYPED_ARRAY_SUPPORT = h(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        function h() {
            try {
                const T = new i(1), b = {
                    foo: function() {
                        return 42;
                    }
                };
                return Object.setPrototypeOf(b, i.prototype), Object.setPrototypeOf(T, b), T.foo() === 42;
            } catch  {
                return !1;
            }
        }
        Object.defineProperty(p.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (p.isBuffer(this)) return this.buffer;
            }
        }), Object.defineProperty(p.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (p.isBuffer(this)) return this.byteOffset;
            }
        });
        function f(T) {
            if (T > s) throw new RangeError('The value "' + T + '" is invalid for option "size"');
            const b = new i(T);
            return Object.setPrototypeOf(b, p.prototype), b;
        }
        function p(T, b, v) {
            if (typeof T == "number") {
                if (typeof b == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return S(T);
            }
            return m(T, b, v);
        }
        p.poolSize = 8192;
        function m(T, b, v) {
            if (typeof T == "string") return _(T, b);
            if (l.isView(T)) return k(T);
            if (T == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T);
            if (Kr(T, l) || T && Kr(T.buffer, l) || typeof u < "u" && (Kr(T, u) || T && Kr(T.buffer, u))) return G(T, b, v);
            if (typeof T == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            const D = T.valueOf && T.valueOf();
            if (D != null && D !== T) return p.from(D, b, v);
            const N = P(T);
            if (N) return N;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof T[Symbol.toPrimitive] == "function") return p.from(T[Symbol.toPrimitive]("string"), b, v);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T);
        }
        p.from = function(T, b, v) {
            return m(T, b, v);
        }, Object.setPrototypeOf(p.prototype, i.prototype), Object.setPrototypeOf(p, i);
        function w(T) {
            if (typeof T != "number") throw new TypeError('"size" argument must be of type number');
            if (T < 0) throw new RangeError('The value "' + T + '" is invalid for option "size"');
        }
        function A(T, b, v) {
            return w(T), T <= 0 ? f(T) : b !== void 0 ? typeof v == "string" ? f(T).fill(b, v) : f(T).fill(b) : f(T);
        }
        p.alloc = function(T, b, v) {
            return A(T, b, v);
        };
        function S(T) {
            return w(T), f(T < 0 ? 0 : J(T) | 0);
        }
        p.allocUnsafe = function(T) {
            return S(T);
        }, p.allocUnsafeSlow = function(T) {
            return S(T);
        };
        function _(T, b) {
            if ((typeof b != "string" || b === "") && (b = "utf8"), !p.isEncoding(b)) throw new TypeError("Unknown encoding: " + b);
            const v = F(T, b) | 0;
            let D = f(v);
            const N = D.write(T, b);
            return N !== v && (D = D.slice(0, N)), D;
        }
        function I(T) {
            const b = T.length < 0 ? 0 : J(T.length) | 0, v = f(b);
            for(let D = 0; D < b; D += 1)v[D] = T[D] & 255;
            return v;
        }
        function k(T) {
            if (Kr(T, i)) {
                const b = new i(T);
                return G(b.buffer, b.byteOffset, b.byteLength);
            }
            return I(T);
        }
        function G(T, b, v) {
            if (b < 0 || T.byteLength < b) throw new RangeError('"offset" is outside of buffer bounds');
            if (T.byteLength < b + (v || 0)) throw new RangeError('"length" is outside of buffer bounds');
            let D;
            return b === void 0 && v === void 0 ? D = new i(T) : v === void 0 ? D = new i(T, b) : D = new i(T, b, v), Object.setPrototypeOf(D, p.prototype), D;
        }
        function P(T) {
            if (p.isBuffer(T)) {
                const b = J(T.length) | 0, v = f(b);
                return v.length === 0 || T.copy(v, 0, 0, b), v;
            }
            if (T.length !== void 0) return typeof T.length != "number" || tl(T.length) ? f(0) : I(T);
            if (T.type === "Buffer" && Array.isArray(T.data)) return I(T.data);
        }
        function J(T) {
            if (T >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
            return T | 0;
        }
        function H(T) {
            return +T != T && (T = 0), p.alloc(+T);
        }
        p.isBuffer = function(b) {
            return b != null && b._isBuffer === !0 && b !== p.prototype;
        }, p.compare = function(b, v) {
            if (Kr(b, i) && (b = p.from(b, b.offset, b.byteLength)), Kr(v, i) && (v = p.from(v, v.offset, v.byteLength)), !p.isBuffer(b) || !p.isBuffer(v)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (b === v) return 0;
            let D = b.length, N = v.length;
            for(let ne = 0, le = Math.min(D, N); ne < le; ++ne)if (b[ne] !== v[ne]) {
                D = b[ne], N = v[ne];
                break;
            }
            return D < N ? -1 : N < D ? 1 : 0;
        }, p.isEncoding = function(b) {
            switch(String(b).toLowerCase()){
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1;
            }
        }, p.concat = function(b, v) {
            if (!Array.isArray(b)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (b.length === 0) return p.alloc(0);
            let D;
            if (v === void 0) for(v = 0, D = 0; D < b.length; ++D)v += b[D].length;
            const N = p.allocUnsafe(v);
            let ne = 0;
            for(D = 0; D < b.length; ++D){
                let le = b[D];
                if (Kr(le, i)) ne + le.length > N.length ? (p.isBuffer(le) || (le = p.from(le)), le.copy(N, ne)) : i.prototype.set.call(N, le, ne);
                else if (p.isBuffer(le)) le.copy(N, ne);
                else throw new TypeError('"list" argument must be an Array of Buffers');
                ne += le.length;
            }
            return N;
        };
        function F(T, b) {
            if (p.isBuffer(T)) return T.length;
            if (l.isView(T) || Kr(T, l)) return T.byteLength;
            if (typeof T != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof T);
            const v = T.length, D = arguments.length > 2 && arguments[2] === !0;
            if (!D && v === 0) return 0;
            let N = !1;
            for(;;)switch(b){
                case "ascii":
                case "latin1":
                case "binary":
                    return v;
                case "utf8":
                case "utf-8":
                    return ea(T).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return v * 2;
                case "hex":
                    return v >>> 1;
                case "base64":
                    return Uf(T).length;
                default:
                    if (N) return D ? -1 : ea(T).length;
                    b = ("" + b).toLowerCase(), N = !0;
            }
        }
        p.byteLength = F;
        function $(T, b, v) {
            let D = !1;
            if ((b === void 0 || b < 0) && (b = 0), b > this.length || ((v === void 0 || v > this.length) && (v = this.length), v <= 0) || (v >>>= 0, b >>>= 0, v <= b)) return "";
            for(T || (T = "utf8");;)switch(T){
                case "hex":
                    return Q(this, b, v);
                case "utf8":
                case "utf-8":
                    return z(this, b, v);
                case "ascii":
                    return ce(this, b, v);
                case "latin1":
                case "binary":
                    return x(this, b, v);
                case "base64":
                    return B(this, b, v);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return pe(this, b, v);
                default:
                    if (D) throw new TypeError("Unknown encoding: " + T);
                    T = (T + "").toLowerCase(), D = !0;
            }
        }
        p.prototype._isBuffer = !0;
        function Y(T, b, v) {
            const D = T[b];
            T[b] = T[v], T[v] = D;
        }
        p.prototype.swap16 = function() {
            const b = this.length;
            if (b % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for(let v = 0; v < b; v += 2)Y(this, v, v + 1);
            return this;
        }, p.prototype.swap32 = function() {
            const b = this.length;
            if (b % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for(let v = 0; v < b; v += 4)Y(this, v, v + 3), Y(this, v + 1, v + 2);
            return this;
        }, p.prototype.swap64 = function() {
            const b = this.length;
            if (b % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for(let v = 0; v < b; v += 8)Y(this, v, v + 7), Y(this, v + 1, v + 6), Y(this, v + 2, v + 5), Y(this, v + 3, v + 4);
            return this;
        }, p.prototype.toString = function() {
            const b = this.length;
            return b === 0 ? "" : arguments.length === 0 ? z(this, 0, b) : $.apply(this, arguments);
        }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(b) {
            if (!p.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            return this === b ? !0 : p.compare(this, b) === 0;
        }, p.prototype.inspect = function() {
            let b = "";
            const v = n.INSPECT_MAX_BYTES;
            return b = this.toString("hex", 0, v).replace(/(.{2})/g, "$1 ").trim(), this.length > v && (b += " ... "), "<Buffer " + b + ">";
        }, r && (p.prototype[r] = p.prototype.inspect), p.prototype.compare = function(b, v, D, N, ne) {
            if (Kr(b, i) && (b = p.from(b, b.offset, b.byteLength)), !p.isBuffer(b)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof b);
            if (v === void 0 && (v = 0), D === void 0 && (D = b ? b.length : 0), N === void 0 && (N = 0), ne === void 0 && (ne = this.length), v < 0 || D > b.length || N < 0 || ne > this.length) throw new RangeError("out of range index");
            if (N >= ne && v >= D) return 0;
            if (N >= ne) return -1;
            if (v >= D) return 1;
            if (v >>>= 0, D >>>= 0, N >>>= 0, ne >>>= 0, this === b) return 0;
            let le = ne - N, Qe = D - v;
            const zt = Math.min(le, Qe), Ot = this.slice(N, ne), It = b.slice(v, D);
            for(let rt = 0; rt < zt; ++rt)if (Ot[rt] !== It[rt]) {
                le = Ot[rt], Qe = It[rt];
                break;
            }
            return le < Qe ? -1 : Qe < le ? 1 : 0;
        };
        function O(T, b, v, D, N) {
            if (T.length === 0) return -1;
            if (typeof v == "string" ? (D = v, v = 0) : v > 2147483647 ? v = 2147483647 : v < -2147483648 && (v = -2147483648), v = +v, tl(v) && (v = N ? 0 : T.length - 1), v < 0 && (v = T.length + v), v >= T.length) {
                if (N) return -1;
                v = T.length - 1;
            } else if (v < 0) if (N) v = 0;
            else return -1;
            if (typeof b == "string" && (b = p.from(b, D)), p.isBuffer(b)) return b.length === 0 ? -1 : se(T, b, v, D, N);
            if (typeof b == "number") return b = b & 255, typeof i.prototype.indexOf == "function" ? N ? i.prototype.indexOf.call(T, b, v) : i.prototype.lastIndexOf.call(T, b, v) : se(T, [
                b
            ], v, D, N);
            throw new TypeError("val must be string, number or Buffer");
        }
        function se(T, b, v, D, N) {
            let ne = 1, le = T.length, Qe = b.length;
            if (D !== void 0 && (D = String(D).toLowerCase(), D === "ucs2" || D === "ucs-2" || D === "utf16le" || D === "utf-16le")) {
                if (T.length < 2 || b.length < 2) return -1;
                ne = 2, le /= 2, Qe /= 2, v /= 2;
            }
            function zt(It, rt) {
                return ne === 1 ? It[rt] : It.readUInt16BE(rt * ne);
            }
            let Ot;
            if (N) {
                let It = -1;
                for(Ot = v; Ot < le; Ot++)if (zt(T, Ot) === zt(b, It === -1 ? 0 : Ot - It)) {
                    if (It === -1 && (It = Ot), Ot - It + 1 === Qe) return It * ne;
                } else It !== -1 && (Ot -= Ot - It), It = -1;
            } else for(v + Qe > le && (v = le - Qe), Ot = v; Ot >= 0; Ot--){
                let It = !0;
                for(let rt = 0; rt < Qe; rt++)if (zt(T, Ot + rt) !== zt(b, rt)) {
                    It = !1;
                    break;
                }
                if (It) return Ot;
            }
            return -1;
        }
        p.prototype.includes = function(b, v, D) {
            return this.indexOf(b, v, D) !== -1;
        }, p.prototype.indexOf = function(b, v, D) {
            return O(this, b, v, D, !0);
        }, p.prototype.lastIndexOf = function(b, v, D) {
            return O(this, b, v, D, !1);
        };
        function ae(T, b, v, D) {
            v = Number(v) || 0;
            const N = T.length - v;
            D ? (D = Number(D), D > N && (D = N)) : D = N;
            const ne = b.length;
            D > ne / 2 && (D = ne / 2);
            let le;
            for(le = 0; le < D; ++le){
                const Qe = parseInt(b.substr(le * 2, 2), 16);
                if (tl(Qe)) return le;
                T[v + le] = Qe;
            }
            return le;
        }
        function oe(T, b, v, D) {
            return dn(ea(b, T.length - v), T, v, D);
        }
        function K(T, b, v, D) {
            return dn(_u(b), T, v, D);
        }
        function V(T, b, v, D) {
            return dn(Uf(b), T, v, D);
        }
        function q(T, b, v, D) {
            return dn(Qg(b, T.length - v), T, v, D);
        }
        p.prototype.write = function(b, v, D, N) {
            if (v === void 0) N = "utf8", D = this.length, v = 0;
            else if (D === void 0 && typeof v == "string") N = v, D = this.length, v = 0;
            else if (isFinite(v)) v = v >>> 0, isFinite(D) ? (D = D >>> 0, N === void 0 && (N = "utf8")) : (N = D, D = void 0);
            else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            const ne = this.length - v;
            if ((D === void 0 || D > ne) && (D = ne), b.length > 0 && (D < 0 || v < 0) || v > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            N || (N = "utf8");
            let le = !1;
            for(;;)switch(N){
                case "hex":
                    return ae(this, b, v, D);
                case "utf8":
                case "utf-8":
                    return oe(this, b, v, D);
                case "ascii":
                case "latin1":
                case "binary":
                    return K(this, b, v, D);
                case "base64":
                    return V(this, b, v, D);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return q(this, b, v, D);
                default:
                    if (le) throw new TypeError("Unknown encoding: " + N);
                    N = ("" + N).toLowerCase(), le = !0;
            }
        }, p.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function B(T, b, v) {
            return b === 0 && v === T.length ? e.fromByteArray(T) : e.fromByteArray(T.slice(b, v));
        }
        function z(T, b, v) {
            v = Math.min(T.length, v);
            const D = [];
            let N = b;
            for(; N < v;){
                const ne = T[N];
                let le = null, Qe = ne > 239 ? 4 : ne > 223 ? 3 : ne > 191 ? 2 : 1;
                if (N + Qe <= v) {
                    let zt, Ot, It, rt;
                    switch(Qe){
                        case 1:
                            ne < 128 && (le = ne);
                            break;
                        case 2:
                            zt = T[N + 1], (zt & 192) === 128 && (rt = (ne & 31) << 6 | zt & 63, rt > 127 && (le = rt));
                            break;
                        case 3:
                            zt = T[N + 1], Ot = T[N + 2], (zt & 192) === 128 && (Ot & 192) === 128 && (rt = (ne & 15) << 12 | (zt & 63) << 6 | Ot & 63, rt > 2047 && (rt < 55296 || rt > 57343) && (le = rt));
                            break;
                        case 4:
                            zt = T[N + 1], Ot = T[N + 2], It = T[N + 3], (zt & 192) === 128 && (Ot & 192) === 128 && (It & 192) === 128 && (rt = (ne & 15) << 18 | (zt & 63) << 12 | (Ot & 63) << 6 | It & 63, rt > 65535 && rt < 1114112 && (le = rt));
                    }
                }
                le === null ? (le = 65533, Qe = 1) : le > 65535 && (le -= 65536, D.push(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), D.push(le), N += Qe;
            }
            return j(D);
        }
        const ee = 4096;
        function j(T) {
            const b = T.length;
            if (b <= ee) return String.fromCharCode.apply(String, T);
            let v = "", D = 0;
            for(; D < b;)v += String.fromCharCode.apply(String, T.slice(D, D += ee));
            return v;
        }
        function ce(T, b, v) {
            let D = "";
            v = Math.min(T.length, v);
            for(let N = b; N < v; ++N)D += String.fromCharCode(T[N] & 127);
            return D;
        }
        function x(T, b, v) {
            let D = "";
            v = Math.min(T.length, v);
            for(let N = b; N < v; ++N)D += String.fromCharCode(T[N]);
            return D;
        }
        function Q(T, b, v) {
            const D = T.length;
            (!b || b < 0) && (b = 0), (!v || v < 0 || v > D) && (v = D);
            let N = "";
            for(let ne = b; ne < v; ++ne)N += zf[T[ne]];
            return N;
        }
        function pe(T, b, v) {
            const D = T.slice(b, v);
            let N = "";
            for(let ne = 0; ne < D.length - 1; ne += 2)N += String.fromCharCode(D[ne] + D[ne + 1] * 256);
            return N;
        }
        p.prototype.slice = function(b, v) {
            const D = this.length;
            b = ~~b, v = v === void 0 ? D : ~~v, b < 0 ? (b += D, b < 0 && (b = 0)) : b > D && (b = D), v < 0 ? (v += D, v < 0 && (v = 0)) : v > D && (v = D), v < b && (v = b);
            const N = this.subarray(b, v);
            return Object.setPrototypeOf(N, p.prototype), N;
        };
        function de(T, b, v) {
            if (T % 1 !== 0 || T < 0) throw new RangeError("offset is not uint");
            if (T + b > v) throw new RangeError("Trying to access beyond buffer length");
        }
        p.prototype.readUintLE = p.prototype.readUIntLE = function(b, v, D) {
            b = b >>> 0, v = v >>> 0, D || de(b, v, this.length);
            let N = this[b], ne = 1, le = 0;
            for(; ++le < v && (ne *= 256);)N += this[b + le] * ne;
            return N;
        }, p.prototype.readUintBE = p.prototype.readUIntBE = function(b, v, D) {
            b = b >>> 0, v = v >>> 0, D || de(b, v, this.length);
            let N = this[b + --v], ne = 1;
            for(; v > 0 && (ne *= 256);)N += this[b + --v] * ne;
            return N;
        }, p.prototype.readUint8 = p.prototype.readUInt8 = function(b, v) {
            return b = b >>> 0, v || de(b, 1, this.length), this[b];
        }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(b, v) {
            return b = b >>> 0, v || de(b, 2, this.length), this[b] | this[b + 1] << 8;
        }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(b, v) {
            return b = b >>> 0, v || de(b, 2, this.length), this[b] << 8 | this[b + 1];
        }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(b, v) {
            return b = b >>> 0, v || de(b, 4, this.length), (this[b] | this[b + 1] << 8 | this[b + 2] << 16) + this[b + 3] * 16777216;
        }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(b, v) {
            return b = b >>> 0, v || de(b, 4, this.length), this[b] * 16777216 + (this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3]);
        }, p.prototype.readBigUInt64LE = Ir(function(b) {
            b = b >>> 0, Sr(b, "offset");
            const v = this[b], D = this[b + 7];
            (v === void 0 || D === void 0) && Zo(b, this.length - 8);
            const N = v + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24, ne = this[++b] + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + D * 2 ** 24;
            return BigInt(N) + (BigInt(ne) << BigInt(32));
        }), p.prototype.readBigUInt64BE = Ir(function(b) {
            b = b >>> 0, Sr(b, "offset");
            const v = this[b], D = this[b + 7];
            (v === void 0 || D === void 0) && Zo(b, this.length - 8);
            const N = v * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b], ne = this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + D;
            return (BigInt(N) << BigInt(32)) + BigInt(ne);
        }), p.prototype.readIntLE = function(b, v, D) {
            b = b >>> 0, v = v >>> 0, D || de(b, v, this.length);
            let N = this[b], ne = 1, le = 0;
            for(; ++le < v && (ne *= 256);)N += this[b + le] * ne;
            return ne *= 128, N >= ne && (N -= Math.pow(2, 8 * v)), N;
        }, p.prototype.readIntBE = function(b, v, D) {
            b = b >>> 0, v = v >>> 0, D || de(b, v, this.length);
            let N = v, ne = 1, le = this[b + --N];
            for(; N > 0 && (ne *= 256);)le += this[b + --N] * ne;
            return ne *= 128, le >= ne && (le -= Math.pow(2, 8 * v)), le;
        }, p.prototype.readInt8 = function(b, v) {
            return b = b >>> 0, v || de(b, 1, this.length), this[b] & 128 ? (255 - this[b] + 1) * -1 : this[b];
        }, p.prototype.readInt16LE = function(b, v) {
            b = b >>> 0, v || de(b, 2, this.length);
            const D = this[b] | this[b + 1] << 8;
            return D & 32768 ? D | 4294901760 : D;
        }, p.prototype.readInt16BE = function(b, v) {
            b = b >>> 0, v || de(b, 2, this.length);
            const D = this[b + 1] | this[b] << 8;
            return D & 32768 ? D | 4294901760 : D;
        }, p.prototype.readInt32LE = function(b, v) {
            return b = b >>> 0, v || de(b, 4, this.length), this[b] | this[b + 1] << 8 | this[b + 2] << 16 | this[b + 3] << 24;
        }, p.prototype.readInt32BE = function(b, v) {
            return b = b >>> 0, v || de(b, 4, this.length), this[b] << 24 | this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3];
        }, p.prototype.readBigInt64LE = Ir(function(b) {
            b = b >>> 0, Sr(b, "offset");
            const v = this[b], D = this[b + 7];
            (v === void 0 || D === void 0) && Zo(b, this.length - 8);
            const N = this[b + 4] + this[b + 5] * 2 ** 8 + this[b + 6] * 2 ** 16 + (D << 24);
            return (BigInt(N) << BigInt(32)) + BigInt(v + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24);
        }), p.prototype.readBigInt64BE = Ir(function(b) {
            b = b >>> 0, Sr(b, "offset");
            const v = this[b], D = this[b + 7];
            (v === void 0 || D === void 0) && Zo(b, this.length - 8);
            const N = (v << 24) + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b];
            return (BigInt(N) << BigInt(32)) + BigInt(this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + D);
        }), p.prototype.readFloatLE = function(b, v) {
            return b = b >>> 0, v || de(b, 4, this.length), t.read(this, b, !0, 23, 4);
        }, p.prototype.readFloatBE = function(b, v) {
            return b = b >>> 0, v || de(b, 4, this.length), t.read(this, b, !1, 23, 4);
        }, p.prototype.readDoubleLE = function(b, v) {
            return b = b >>> 0, v || de(b, 8, this.length), t.read(this, b, !0, 52, 8);
        }, p.prototype.readDoubleBE = function(b, v) {
            return b = b >>> 0, v || de(b, 8, this.length), t.read(this, b, !1, 52, 8);
        };
        function me(T, b, v, D, N, ne) {
            if (!p.isBuffer(T)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (b > N || b < ne) throw new RangeError('"value" argument is out of bounds');
            if (v + D > T.length) throw new RangeError("Index out of range");
        }
        p.prototype.writeUintLE = p.prototype.writeUIntLE = function(b, v, D, N) {
            if (b = +b, v = v >>> 0, D = D >>> 0, !N) {
                const Qe = Math.pow(2, 8 * D) - 1;
                me(this, b, v, D, Qe, 0);
            }
            let ne = 1, le = 0;
            for(this[v] = b & 255; ++le < D && (ne *= 256);)this[v + le] = b / ne & 255;
            return v + D;
        }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(b, v, D, N) {
            if (b = +b, v = v >>> 0, D = D >>> 0, !N) {
                const Qe = Math.pow(2, 8 * D) - 1;
                me(this, b, v, D, Qe, 0);
            }
            let ne = D - 1, le = 1;
            for(this[v + ne] = b & 255; --ne >= 0 && (le *= 256);)this[v + ne] = b / le & 255;
            return v + D;
        }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 1, 255, 0), this[v] = b & 255, v + 1;
        }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 2, 65535, 0), this[v] = b & 255, this[v + 1] = b >>> 8, v + 2;
        }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 2, 65535, 0), this[v] = b >>> 8, this[v + 1] = b & 255, v + 2;
        }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 4, 4294967295, 0), this[v + 3] = b >>> 24, this[v + 2] = b >>> 16, this[v + 1] = b >>> 8, this[v] = b & 255, v + 4;
        }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 4, 4294967295, 0), this[v] = b >>> 24, this[v + 1] = b >>> 16, this[v + 2] = b >>> 8, this[v + 3] = b & 255, v + 4;
        };
        function Ae(T, b, v, D, N) {
            mi(b, D, N, T, v, 7);
            let ne = Number(b & BigInt(4294967295));
            T[v++] = ne, ne = ne >> 8, T[v++] = ne, ne = ne >> 8, T[v++] = ne, ne = ne >> 8, T[v++] = ne;
            let le = Number(b >> BigInt(32) & BigInt(4294967295));
            return T[v++] = le, le = le >> 8, T[v++] = le, le = le >> 8, T[v++] = le, le = le >> 8, T[v++] = le, v;
        }
        function Te(T, b, v, D, N) {
            mi(b, D, N, T, v, 7);
            let ne = Number(b & BigInt(4294967295));
            T[v + 7] = ne, ne = ne >> 8, T[v + 6] = ne, ne = ne >> 8, T[v + 5] = ne, ne = ne >> 8, T[v + 4] = ne;
            let le = Number(b >> BigInt(32) & BigInt(4294967295));
            return T[v + 3] = le, le = le >> 8, T[v + 2] = le, le = le >> 8, T[v + 1] = le, le = le >> 8, T[v] = le, v + 8;
        }
        p.prototype.writeBigUInt64LE = Ir(function(b, v = 0) {
            return Ae(this, b, v, BigInt(0), BigInt("0xffffffffffffffff"));
        }), p.prototype.writeBigUInt64BE = Ir(function(b, v = 0) {
            return Te(this, b, v, BigInt(0), BigInt("0xffffffffffffffff"));
        }), p.prototype.writeIntLE = function(b, v, D, N) {
            if (b = +b, v = v >>> 0, !N) {
                const zt = Math.pow(2, 8 * D - 1);
                me(this, b, v, D, zt - 1, -zt);
            }
            let ne = 0, le = 1, Qe = 0;
            for(this[v] = b & 255; ++ne < D && (le *= 256);)b < 0 && Qe === 0 && this[v + ne - 1] !== 0 && (Qe = 1), this[v + ne] = (b / le >> 0) - Qe & 255;
            return v + D;
        }, p.prototype.writeIntBE = function(b, v, D, N) {
            if (b = +b, v = v >>> 0, !N) {
                const zt = Math.pow(2, 8 * D - 1);
                me(this, b, v, D, zt - 1, -zt);
            }
            let ne = D - 1, le = 1, Qe = 0;
            for(this[v + ne] = b & 255; --ne >= 0 && (le *= 256);)b < 0 && Qe === 0 && this[v + ne + 1] !== 0 && (Qe = 1), this[v + ne] = (b / le >> 0) - Qe & 255;
            return v + D;
        }, p.prototype.writeInt8 = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 1, 127, -128), b < 0 && (b = 255 + b + 1), this[v] = b & 255, v + 1;
        }, p.prototype.writeInt16LE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 2, 32767, -32768), this[v] = b & 255, this[v + 1] = b >>> 8, v + 2;
        }, p.prototype.writeInt16BE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 2, 32767, -32768), this[v] = b >>> 8, this[v + 1] = b & 255, v + 2;
        }, p.prototype.writeInt32LE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 4, 2147483647, -2147483648), this[v] = b & 255, this[v + 1] = b >>> 8, this[v + 2] = b >>> 16, this[v + 3] = b >>> 24, v + 4;
        }, p.prototype.writeInt32BE = function(b, v, D) {
            return b = +b, v = v >>> 0, D || me(this, b, v, 4, 2147483647, -2147483648), b < 0 && (b = 4294967295 + b + 1), this[v] = b >>> 24, this[v + 1] = b >>> 16, this[v + 2] = b >>> 8, this[v + 3] = b & 255, v + 4;
        }, p.prototype.writeBigInt64LE = Ir(function(b, v = 0) {
            return Ae(this, b, v, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), p.prototype.writeBigInt64BE = Ir(function(b, v = 0) {
            return Te(this, b, v, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        });
        function Ve(T, b, v, D, N, ne) {
            if (v + D > T.length) throw new RangeError("Index out of range");
            if (v < 0) throw new RangeError("Index out of range");
        }
        function De(T, b, v, D, N) {
            return b = +b, v = v >>> 0, N || Ve(T, b, v, 4), t.write(T, b, v, D, 23, 4), v + 4;
        }
        p.prototype.writeFloatLE = function(b, v, D) {
            return De(this, b, v, !0, D);
        }, p.prototype.writeFloatBE = function(b, v, D) {
            return De(this, b, v, !1, D);
        };
        function mt(T, b, v, D, N) {
            return b = +b, v = v >>> 0, N || Ve(T, b, v, 8), t.write(T, b, v, D, 52, 8), v + 8;
        }
        p.prototype.writeDoubleLE = function(b, v, D) {
            return mt(this, b, v, !0, D);
        }, p.prototype.writeDoubleBE = function(b, v, D) {
            return mt(this, b, v, !1, D);
        }, p.prototype.copy = function(b, v, D, N) {
            if (!p.isBuffer(b)) throw new TypeError("argument should be a Buffer");
            if (D || (D = 0), !N && N !== 0 && (N = this.length), v >= b.length && (v = b.length), v || (v = 0), N > 0 && N < D && (N = D), N === D || b.length === 0 || this.length === 0) return 0;
            if (v < 0) throw new RangeError("targetStart out of bounds");
            if (D < 0 || D >= this.length) throw new RangeError("Index out of range");
            if (N < 0) throw new RangeError("sourceEnd out of bounds");
            N > this.length && (N = this.length), b.length - v < N - D && (N = b.length - v + D);
            const ne = N - D;
            return this === b && typeof i.prototype.copyWithin == "function" ? this.copyWithin(v, D, N) : i.prototype.set.call(b, this.subarray(D, N), v), ne;
        }, p.prototype.fill = function(b, v, D, N) {
            if (typeof b == "string") {
                if (typeof v == "string" ? (N = v, v = 0, D = this.length) : typeof D == "string" && (N = D, D = this.length), N !== void 0 && typeof N != "string") throw new TypeError("encoding must be a string");
                if (typeof N == "string" && !p.isEncoding(N)) throw new TypeError("Unknown encoding: " + N);
                if (b.length === 1) {
                    const le = b.charCodeAt(0);
                    (N === "utf8" && le < 128 || N === "latin1") && (b = le);
                }
            } else typeof b == "number" ? b = b & 255 : typeof b == "boolean" && (b = Number(b));
            if (v < 0 || this.length < v || this.length < D) throw new RangeError("Out of range index");
            if (D <= v) return this;
            v = v >>> 0, D = D === void 0 ? this.length : D >>> 0, b || (b = 0);
            let ne;
            if (typeof b == "number") for(ne = v; ne < D; ++ne)this[ne] = b;
            else {
                const le = p.isBuffer(b) ? b : p.from(b, N), Qe = le.length;
                if (Qe === 0) throw new TypeError('The value "' + b + '" is invalid for argument "value"');
                for(ne = 0; ne < D - v; ++ne)this[ne + v] = le[ne % Qe];
            }
            return this;
        };
        const hn = {};
        function Qr(T, b, v) {
            hn[T] = class extends v {
                constructor(){
                    super(), Object.defineProperty(this, "message", {
                        value: b.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }), this.name = `${this.name} [${T}]`, this.stack, delete this.name;
                }
                get code() {
                    return T;
                }
                set code(N) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: N,
                        writable: !0
                    });
                }
                toString() {
                    return `${this.name} [${T}]: ${this.message}`;
                }
            };
        }
        Qr("ERR_BUFFER_OUT_OF_BOUNDS", function(T) {
            return T ? `${T} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), Qr("ERR_INVALID_ARG_TYPE", function(T, b) {
            return `The "${T}" argument must be of type number. Received type ${typeof b}`;
        }, TypeError), Qr("ERR_OUT_OF_RANGE", function(T, b, v) {
            let D = `The value of "${T}" is out of range.`, N = v;
            return Number.isInteger(v) && Math.abs(v) > 2 ** 32 ? N = Ts(String(v)) : typeof v == "bigint" && (N = String(v), (v > BigInt(2) ** BigInt(32) || v < -(BigInt(2) ** BigInt(32))) && (N = Ts(N)), N += "n"), D += ` It must be ${b}. Received ${N}`, D;
        }, RangeError);
        function Ts(T) {
            let b = "", v = T.length;
            const D = T[0] === "-" ? 1 : 0;
            for(; v >= D + 4; v -= 3)b = `_${T.slice(v - 3, v)}${b}`;
            return `${T.slice(0, v)}${b}`;
        }
        function qr(T, b, v) {
            Sr(b, "offset"), (T[b] === void 0 || T[b + v] === void 0) && Zo(b, T.length - (v + 1));
        }
        function mi(T, b, v, D, N, ne) {
            if (T > v || T < b) {
                const le = typeof b == "bigint" ? "n" : "";
                let Qe;
                throw b === 0 || b === BigInt(0) ? Qe = `>= 0${le} and < 2${le} ** ${(ne + 1) * 8}${le}` : Qe = `>= -(2${le} ** ${(ne + 1) * 8 - 1}${le}) and < 2 ** ${(ne + 1) * 8 - 1}${le}`, new hn.ERR_OUT_OF_RANGE("value", Qe, T);
            }
            qr(D, N, ne);
        }
        function Sr(T, b) {
            if (typeof T != "number") throw new hn.ERR_INVALID_ARG_TYPE(b, "number", T);
        }
        function Zo(T, b, v) {
            throw Math.floor(T) !== T ? (Sr(T, v), new hn.ERR_OUT_OF_RANGE("offset", "an integer", T)) : b < 0 ? new hn.ERR_BUFFER_OUT_OF_BOUNDS : new hn.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${b}`, T);
        }
        const Lf = /[^+/0-9A-Za-z-_]/g;
        function Tu(T) {
            if (T = T.split("=")[0], T = T.trim().replace(Lf, ""), T.length < 2) return "";
            for(; T.length % 4 !== 0;)T = T + "=";
            return T;
        }
        function ea(T, b) {
            b = b || 1 / 0;
            let v;
            const D = T.length;
            let N = null;
            const ne = [];
            for(let le = 0; le < D; ++le){
                if (v = T.charCodeAt(le), v > 55295 && v < 57344) {
                    if (!N) {
                        if (v > 56319) {
                            (b -= 3) > -1 && ne.push(239, 191, 189);
                            continue;
                        } else if (le + 1 === D) {
                            (b -= 3) > -1 && ne.push(239, 191, 189);
                            continue;
                        }
                        N = v;
                        continue;
                    }
                    if (v < 56320) {
                        (b -= 3) > -1 && ne.push(239, 191, 189), N = v;
                        continue;
                    }
                    v = (N - 55296 << 10 | v - 56320) + 65536;
                } else N && (b -= 3) > -1 && ne.push(239, 191, 189);
                if (N = null, v < 128) {
                    if ((b -= 1) < 0) break;
                    ne.push(v);
                } else if (v < 2048) {
                    if ((b -= 2) < 0) break;
                    ne.push(v >> 6 | 192, v & 63 | 128);
                } else if (v < 65536) {
                    if ((b -= 3) < 0) break;
                    ne.push(v >> 12 | 224, v >> 6 & 63 | 128, v & 63 | 128);
                } else if (v < 1114112) {
                    if ((b -= 4) < 0) break;
                    ne.push(v >> 18 | 240, v >> 12 & 63 | 128, v >> 6 & 63 | 128, v & 63 | 128);
                } else throw new Error("Invalid code point");
            }
            return ne;
        }
        function _u(T) {
            const b = [];
            for(let v = 0; v < T.length; ++v)b.push(T.charCodeAt(v) & 255);
            return b;
        }
        function Qg(T, b) {
            let v, D, N;
            const ne = [];
            for(let le = 0; le < T.length && !((b -= 2) < 0); ++le)v = T.charCodeAt(le), D = v >> 8, N = v % 256, ne.push(N), ne.push(D);
            return ne;
        }
        function Uf(T) {
            return e.toByteArray(Tu(T));
        }
        function dn(T, b, v, D) {
            let N;
            for(N = 0; N < D && !(N + v >= b.length || N >= T.length); ++N)b[N + v] = T[N];
            return N;
        }
        function Kr(T, b) {
            return T instanceof b || T != null && T.constructor != null && T.constructor.name != null && T.constructor.name === b.name;
        }
        function tl(T) {
            return T !== T;
        }
        const zf = (function() {
            const T = "0123456789abcdef", b = new Array(256);
            for(let v = 0; v < 16; ++v){
                const D = v * 16;
                for(let N = 0; N < 16; ++N)b[D + N] = T[v] + T[N];
            }
            return b;
        })();
        function Ir(T) {
            return typeof BigInt > "u" ? qg : T;
        }
        function qg() {
            throw new Error("BigInt not supported");
        }
    })(Qx);
    const $E = Qx.Buffer;
    const Ise = "[object ArrayBuffer]";
    class Pt {
        static isArrayBuffer(e) {
            return Object.prototype.toString.call(e) === Ise;
        }
        static toArrayBuffer(e) {
            return this.isArrayBuffer(e) ? e : e.byteLength === e.buffer.byteLength || e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : this.toUint8Array(e.buffer).slice(e.byteOffset, e.byteOffset + e.byteLength).buffer;
        }
        static toUint8Array(e) {
            return this.toView(e, Uint8Array);
        }
        static toView(e, t) {
            if (e.constructor === t) return e;
            if (this.isArrayBuffer(e)) return new t(e);
            if (this.isArrayBufferView(e)) return new t(e.buffer, e.byteOffset, e.byteLength);
            throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        static isBufferSource(e) {
            return this.isArrayBufferView(e) || this.isArrayBuffer(e);
        }
        static isArrayBufferView(e) {
            return ArrayBuffer.isView(e) || e && this.isArrayBuffer(e.buffer);
        }
        static isEqual(e, t) {
            const r = Pt.toUint8Array(e), s = Pt.toUint8Array(t);
            if (r.length !== s.byteLength) return !1;
            for(let i = 0; i < r.length; i++)if (r[i] !== s[i]) return !1;
            return !0;
        }
        static concat(...e) {
            let t;
            Array.isArray(e[0]) && !(e[1] instanceof Function) || Array.isArray(e[0]) && e[1] instanceof Function ? t = e[0] : e[e.length - 1] instanceof Function ? t = e.slice(0, e.length - 1) : t = e;
            let r = 0;
            for (const l of t)r += l.byteLength;
            const s = new Uint8Array(r);
            let i = 0;
            for (const l of t){
                const u = this.toUint8Array(l);
                s.set(u, i), i += u.length;
            }
            return e[e.length - 1] instanceof Function ? this.toView(s, e[e.length - 1]) : s.buffer;
        }
    }
    const ty = "string", Cse = /^[0-9a-f\s]+$/i, Tse = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/, _se = /^[a-zA-Z0-9-_]+$/;
    class ME {
        static fromString(e) {
            const t = unescape(encodeURIComponent(e)), r = new Uint8Array(t.length);
            for(let s = 0; s < t.length; s++)r[s] = t.charCodeAt(s);
            return r.buffer;
        }
        static toString(e) {
            const t = Pt.toUint8Array(e);
            let r = "";
            for(let i = 0; i < t.length; i++)r += String.fromCharCode(t[i]);
            return decodeURIComponent(escape(r));
        }
    }
    class js {
        static toString(e, t = !1) {
            const r = Pt.toArrayBuffer(e), s = new DataView(r);
            let i = "";
            for(let l = 0; l < r.byteLength; l += 2){
                const u = s.getUint16(l, t);
                i += String.fromCharCode(u);
            }
            return i;
        }
        static fromString(e, t = !1) {
            const r = new ArrayBuffer(e.length * 2), s = new DataView(r);
            for(let i = 0; i < e.length; i++)s.setUint16(i * 2, e.charCodeAt(i), t);
            return r;
        }
    }
    class jt {
        static isHex(e) {
            return typeof e === ty && Cse.test(e);
        }
        static isBase64(e) {
            return typeof e === ty && Tse.test(e);
        }
        static isBase64Url(e) {
            return typeof e === ty && _se.test(e);
        }
        static ToString(e, t = "utf8") {
            const r = Pt.toUint8Array(e);
            switch(t.toLowerCase()){
                case "utf8":
                    return this.ToUtf8String(r);
                case "binary":
                    return this.ToBinary(r);
                case "hex":
                    return this.ToHex(r);
                case "base64":
                    return this.ToBase64(r);
                case "base64url":
                    return this.ToBase64Url(r);
                case "utf16le":
                    return js.toString(r, !0);
                case "utf16":
                case "utf16be":
                    return js.toString(r);
                default:
                    throw new Error(`Unknown type of encoding '${t}'`);
            }
        }
        static FromString(e, t = "utf8") {
            if (!e) return new ArrayBuffer(0);
            switch(t.toLowerCase()){
                case "utf8":
                    return this.FromUtf8String(e);
                case "binary":
                    return this.FromBinary(e);
                case "hex":
                    return this.FromHex(e);
                case "base64":
                    return this.FromBase64(e);
                case "base64url":
                    return this.FromBase64Url(e);
                case "utf16le":
                    return js.fromString(e, !0);
                case "utf16":
                case "utf16be":
                    return js.fromString(e);
                default:
                    throw new Error(`Unknown type of encoding '${t}'`);
            }
        }
        static ToBase64(e) {
            const t = Pt.toUint8Array(e);
            if (typeof btoa < "u") {
                const r = this.ToString(t, "binary");
                return btoa(r);
            } else return $E.from(t).toString("base64");
        }
        static FromBase64(e) {
            const t = this.formatString(e);
            if (!t) return new ArrayBuffer(0);
            if (!jt.isBase64(t)) throw new TypeError("Argument 'base64Text' is not Base64 encoded");
            return typeof atob < "u" ? this.FromBinary(atob(t)) : new Uint8Array($E.from(t, "base64")).buffer;
        }
        static FromBase64Url(e) {
            const t = this.formatString(e);
            if (!t) return new ArrayBuffer(0);
            if (!jt.isBase64Url(t)) throw new TypeError("Argument 'base64url' is not Base64Url encoded");
            return this.FromBase64(this.Base64Padding(t.replace(/\-/g, "+").replace(/\_/g, "/")));
        }
        static ToBase64Url(e) {
            return this.ToBase64(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
        }
        static FromUtf8String(e, t = jt.DEFAULT_UTF8_ENCODING) {
            switch(t){
                case "ascii":
                    return this.FromBinary(e);
                case "utf8":
                    return ME.fromString(e);
                case "utf16":
                case "utf16be":
                    return js.fromString(e);
                case "utf16le":
                case "usc2":
                    return js.fromString(e, !0);
                default:
                    throw new Error(`Unknown type of encoding '${t}'`);
            }
        }
        static ToUtf8String(e, t = jt.DEFAULT_UTF8_ENCODING) {
            switch(t){
                case "ascii":
                    return this.ToBinary(e);
                case "utf8":
                    return ME.toString(e);
                case "utf16":
                case "utf16be":
                    return js.toString(e);
                case "utf16le":
                case "usc2":
                    return js.toString(e, !0);
                default:
                    throw new Error(`Unknown type of encoding '${t}'`);
            }
        }
        static FromBinary(e) {
            const t = e.length, r = new Uint8Array(t);
            for(let s = 0; s < t; s++)r[s] = e.charCodeAt(s);
            return r.buffer;
        }
        static ToBinary(e) {
            const t = Pt.toUint8Array(e);
            let r = "";
            for(let s = 0; s < t.length; s++)r += String.fromCharCode(t[s]);
            return r;
        }
        static ToHex(e) {
            const t = Pt.toUint8Array(e);
            let r = "";
            const s = t.length;
            for(let i = 0; i < s; i++){
                const l = t[i];
                l < 16 && (r += "0"), r += l.toString(16);
            }
            return r;
        }
        static FromHex(e) {
            let t = this.formatString(e);
            if (!t) return new ArrayBuffer(0);
            if (!jt.isHex(t)) throw new TypeError("Argument 'hexString' is not HEX encoded");
            t.length % 2 && (t = `0${t}`);
            const r = new Uint8Array(t.length / 2);
            for(let s = 0; s < t.length; s = s + 2){
                const i = t.slice(s, s + 2);
                r[s / 2] = parseInt(i, 16);
            }
            return r.buffer;
        }
        static ToUtf16String(e, t = !1) {
            return js.toString(e, t);
        }
        static FromUtf16String(e, t = !1) {
            return js.fromString(e, t);
        }
        static Base64Padding(e) {
            const t = 4 - e.length % 4;
            if (t < 4) for(let r = 0; r < t; r++)e += "=";
            return e;
        }
        static formatString(e) {
            return e?.replace(/[\n\r\t ]/g, "") || "";
        }
    }
    jt.DEFAULT_UTF8_ENCODING = "utf8";
    function Vc(n, e) {
        let t = 0;
        if (n.length === 1) return n[0];
        for(let r = n.length - 1; r >= 0; r--)t += n[n.length - 1 - r] * Math.pow(2, e * r);
        return t;
    }
    function Ka(n, e, t = -1) {
        const r = t;
        let s = n, i = 0, l = Math.pow(2, e);
        for(let u = 1; u < 8; u++){
            if (n < l) {
                let h;
                if (r < 0) h = new ArrayBuffer(u), i = u;
                else {
                    if (r < u) return new ArrayBuffer(0);
                    h = new ArrayBuffer(r), i = r;
                }
                const f = new Uint8Array(h);
                for(let p = u - 1; p >= 0; p--){
                    const m = Math.pow(2, p * e);
                    f[i - p - 1] = Math.floor(s / m), s -= f[i - p - 1] * m;
                }
                return h;
            }
            l *= Math.pow(2, e);
        }
        return new ArrayBuffer(0);
    }
    function g4(...n) {
        let e = 0, t = 0;
        for (const i of n)e += i.length;
        const r = new ArrayBuffer(e), s = new Uint8Array(r);
        for (const i of n)s.set(i, t), t += i.length;
        return s;
    }
    function Kx() {
        const n = new Uint8Array(this.valueHex);
        if (this.valueHex.byteLength >= 2) {
            const u = n[0] === 255 && n[1] & 128, h = n[0] === 0 && (n[1] & 128) === 0;
            (u || h) && this.warnings.push("Needlessly long format");
        }
        const e = new ArrayBuffer(this.valueHex.byteLength), t = new Uint8Array(e);
        for(let u = 0; u < this.valueHex.byteLength; u++)t[u] = 0;
        t[0] = n[0] & 128;
        const r = Vc(t, 8), s = new ArrayBuffer(this.valueHex.byteLength), i = new Uint8Array(s);
        for(let u = 0; u < this.valueHex.byteLength; u++)i[u] = n[u];
        return i[0] &= 127, Vc(i, 8) - r;
    }
    function xse(n) {
        const e = n < 0 ? n * -1 : n;
        let t = 128;
        for(let r = 1; r < 8; r++){
            if (e <= t) {
                if (n < 0) {
                    const l = t - e, u = Ka(l, 8, r), h = new Uint8Array(u);
                    return h[0] |= 128, u;
                }
                let s = Ka(e, 8, r), i = new Uint8Array(s);
                if (i[0] & 128) {
                    const l = s.slice(0), u = new Uint8Array(l);
                    s = new ArrayBuffer(s.byteLength + 1), i = new Uint8Array(s);
                    for(let h = 0; h < l.byteLength; h++)i[h + 1] = u[h];
                    i[0] = 0;
                }
                return s;
            }
            t *= Math.pow(2, 8);
        }
        return new ArrayBuffer(0);
    }
    function Dse(n, e) {
        if (n.byteLength !== e.byteLength) return !1;
        const t = new Uint8Array(n), r = new Uint8Array(e);
        for(let s = 0; s < t.length; s++)if (t[s] !== r[s]) return !1;
        return !0;
    }
    function Mr(n, e) {
        const t = n.toString(10);
        if (e < t.length) return "";
        const r = e - t.length, s = new Array(r);
        for(let l = 0; l < r; l++)s[l] = "0";
        return s.join("").concat(t);
    }
    function Qp() {
        if (typeof BigInt > "u") throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
    }
    function v8(n) {
        let e = 0, t = 0;
        for(let s = 0; s < n.length; s++){
            const i = n[s];
            e += i.byteLength;
        }
        const r = new Uint8Array(e);
        for(let s = 0; s < n.length; s++){
            const i = n[s];
            r.set(new Uint8Array(i), t), t += i.byteLength;
        }
        return r.buffer;
    }
    function Ji(n, e, t, r) {
        return e instanceof Uint8Array ? e.byteLength ? t < 0 ? (n.error = "Wrong parameter: inputOffset less than zero", !1) : r < 0 ? (n.error = "Wrong parameter: inputLength less than zero", !1) : e.byteLength - t - r < 0 ? (n.error = "End of input reached before message was fully decoded (inconsistent offset and length values)", !1) : !0 : (n.error = "Wrong parameter: inputBuffer has zero length", !1) : (n.error = "Wrong parameter: inputBuffer must be 'Uint8Array'", !1);
    }
    class E8 {
        constructor(){
            this.items = [];
        }
        write(e) {
            this.items.push(e);
        }
        final() {
            return v8(this.items);
        }
    }
    const Dh = [
        new Uint8Array([
            1
        ])
    ], NE = "0123456789", fu = "", gi = new ArrayBuffer(0), A8 = new Uint8Array(0), cf = "EndOfContent", Gx = "OCTET STRING", Yx = "BIT STRING";
    function Zi(n) {
        var e;
        return e = class extends n {
            get valueHex() {
                return this.valueHexView.slice().buffer;
            }
            set valueHex(r) {
                this.valueHexView = new Uint8Array(r);
            }
            constructor(...r){
                var s;
                super(...r);
                const i = r[0] || {};
                this.isHexOnly = (s = i.isHexOnly) !== null && s !== void 0 ? s : !1, this.valueHexView = i.valueHex ? Pt.toUint8Array(i.valueHex) : A8;
            }
            fromBER(r, s, i) {
                const l = r instanceof ArrayBuffer ? new Uint8Array(r) : r;
                if (!Ji(this, l, s, i)) return -1;
                const u = s + i;
                return this.valueHexView = l.subarray(s, u), this.valueHexView.length ? (this.blockLength = i, u) : (this.warnings.push("Zero buffer length"), s);
            }
            toBER(r = !1) {
                return this.isHexOnly ? r ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer : (this.error = "Flag 'isHexOnly' is not set, abort", gi);
            }
            toJSON() {
                return {
                    ...super.toJSON(),
                    isHexOnly: this.isHexOnly,
                    valueHex: jt.ToHex(this.valueHexView)
                };
            }
        }, e.NAME = "hexBlock", e;
    }
    class Za {
        static blockName() {
            return this.NAME;
        }
        get valueBeforeDecode() {
            return this.valueBeforeDecodeView.slice().buffer;
        }
        set valueBeforeDecode(e) {
            this.valueBeforeDecodeView = new Uint8Array(e);
        }
        constructor({ blockLength: e = 0, error: t = fu, warnings: r = [], valueBeforeDecode: s = A8 } = {}){
            this.blockLength = e, this.error = t, this.warnings = r, this.valueBeforeDecodeView = Pt.toUint8Array(s);
        }
        toJSON() {
            return {
                blockName: this.constructor.NAME,
                blockLength: this.blockLength,
                error: this.error,
                warnings: this.warnings,
                valueBeforeDecode: jt.ToHex(this.valueBeforeDecodeView)
            };
        }
    }
    Za.NAME = "baseBlock";
    class Ar extends Za {
        fromBER(e, t, r) {
            throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
        }
        toBER(e, t) {
            throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
        }
    }
    Ar.NAME = "valueBlock";
    class Wx extends Zi(Za) {
        constructor({ idBlock: e = {} } = {}){
            var t, r, s, i;
            super(), e ? (this.isHexOnly = (t = e.isHexOnly) !== null && t !== void 0 ? t : !1, this.valueHexView = e.valueHex ? Pt.toUint8Array(e.valueHex) : A8, this.tagClass = (r = e.tagClass) !== null && r !== void 0 ? r : -1, this.tagNumber = (s = e.tagNumber) !== null && s !== void 0 ? s : -1, this.isConstructed = (i = e.isConstructed) !== null && i !== void 0 ? i : !1) : (this.tagClass = -1, this.tagNumber = -1, this.isConstructed = !1);
        }
        toBER(e = !1) {
            let t = 0;
            switch(this.tagClass){
                case 1:
                    t |= 0;
                    break;
                case 2:
                    t |= 64;
                    break;
                case 3:
                    t |= 128;
                    break;
                case 4:
                    t |= 192;
                    break;
                default:
                    return this.error = "Unknown tag class", gi;
            }
            if (this.isConstructed && (t |= 32), this.tagNumber < 31 && !this.isHexOnly) {
                const s = new Uint8Array(1);
                if (!e) {
                    let i = this.tagNumber;
                    i &= 31, t |= i, s[0] = t;
                }
                return s.buffer;
            }
            if (!this.isHexOnly) {
                const s = Ka(this.tagNumber, 7), i = new Uint8Array(s), l = s.byteLength, u = new Uint8Array(l + 1);
                if (u[0] = t | 31, !e) {
                    for(let h = 0; h < l - 1; h++)u[h + 1] = i[h] | 128;
                    u[l] = i[l - 1];
                }
                return u.buffer;
            }
            const r = new Uint8Array(this.valueHexView.byteLength + 1);
            if (r[0] = t | 31, !e) {
                const s = this.valueHexView;
                for(let i = 0; i < s.length - 1; i++)r[i + 1] = s[i] | 128;
                r[this.valueHexView.byteLength] = s[s.length - 1];
            }
            return r.buffer;
        }
        fromBER(e, t, r) {
            const s = Pt.toUint8Array(e);
            if (!Ji(this, s, t, r)) return -1;
            const i = s.subarray(t, t + r);
            if (i.length === 0) return this.error = "Zero buffer length", -1;
            switch(i[0] & 192){
                case 0:
                    this.tagClass = 1;
                    break;
                case 64:
                    this.tagClass = 2;
                    break;
                case 128:
                    this.tagClass = 3;
                    break;
                case 192:
                    this.tagClass = 4;
                    break;
                default:
                    return this.error = "Unknown tag class", -1;
            }
            this.isConstructed = (i[0] & 32) === 32, this.isHexOnly = !1;
            const u = i[0] & 31;
            if (u !== 31) this.tagNumber = u, this.blockLength = 1;
            else {
                let h = 1, f = this.valueHexView = new Uint8Array(255), p = 255;
                for(; i[h] & 128;){
                    if (f[h - 1] = i[h] & 127, h++, h >= i.length) return this.error = "End of input reached before message was fully decoded", -1;
                    if (h === p) {
                        p += 255;
                        const w = new Uint8Array(p);
                        for(let A = 0; A < f.length; A++)w[A] = f[A];
                        f = this.valueHexView = new Uint8Array(p);
                    }
                }
                this.blockLength = h + 1, f[h - 1] = i[h] & 127;
                const m = new Uint8Array(h);
                for(let w = 0; w < h; w++)m[w] = f[w];
                f = this.valueHexView = new Uint8Array(h), f.set(m), this.blockLength <= 9 ? this.tagNumber = Vc(f, 7) : (this.isHexOnly = !0, this.warnings.push("Tag too long, represented as hex-coded"));
            }
            if (this.tagClass === 1 && this.isConstructed) switch(this.tagNumber){
                case 1:
                case 2:
                case 5:
                case 6:
                case 9:
                case 13:
                case 14:
                case 23:
                case 24:
                case 31:
                case 32:
                case 33:
                case 34:
                    return this.error = "Constructed encoding used for primitive type", -1;
            }
            return t + this.blockLength;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                tagClass: this.tagClass,
                tagNumber: this.tagNumber,
                isConstructed: this.isConstructed
            };
        }
    }
    Wx.NAME = "identificationBlock";
    class jx extends Za {
        constructor({ lenBlock: e = {} } = {}){
            var t, r, s;
            super(), this.isIndefiniteForm = (t = e.isIndefiniteForm) !== null && t !== void 0 ? t : !1, this.longFormUsed = (r = e.longFormUsed) !== null && r !== void 0 ? r : !1, this.length = (s = e.length) !== null && s !== void 0 ? s : 0;
        }
        fromBER(e, t, r) {
            const s = Pt.toUint8Array(e);
            if (!Ji(this, s, t, r)) return -1;
            const i = s.subarray(t, t + r);
            if (i.length === 0) return this.error = "Zero buffer length", -1;
            if (i[0] === 255) return this.error = "Length block 0xFF is reserved by standard", -1;
            if (this.isIndefiniteForm = i[0] === 128, this.isIndefiniteForm) return this.blockLength = 1, t + this.blockLength;
            if (this.longFormUsed = !!(i[0] & 128), this.longFormUsed === !1) return this.length = i[0], this.blockLength = 1, t + this.blockLength;
            const l = i[0] & 127;
            if (l > 8) return this.error = "Too big integer", -1;
            if (l + 1 > i.length) return this.error = "End of input reached before message was fully decoded", -1;
            const u = t + 1, h = s.subarray(u, u + l);
            return h[l - 1] === 0 && this.warnings.push("Needlessly long encoded length"), this.length = Vc(h, 8), this.longFormUsed && this.length <= 127 && this.warnings.push("Unnecessary usage of long length form"), this.blockLength = l + 1, t + this.blockLength;
        }
        toBER(e = !1) {
            let t, r;
            if (this.length > 127 && (this.longFormUsed = !0), this.isIndefiniteForm) return t = new ArrayBuffer(1), e === !1 && (r = new Uint8Array(t), r[0] = 128), t;
            if (this.longFormUsed) {
                const s = Ka(this.length, 8);
                if (s.byteLength > 127) return this.error = "Too big length", gi;
                if (t = new ArrayBuffer(s.byteLength + 1), e) return t;
                const i = new Uint8Array(s);
                r = new Uint8Array(t), r[0] = s.byteLength | 128;
                for(let l = 0; l < s.byteLength; l++)r[l + 1] = i[l];
                return t;
            }
            return t = new ArrayBuffer(1), e === !1 && (r = new Uint8Array(t), r[0] = this.length), t;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                isIndefiniteForm: this.isIndefiniteForm,
                longFormUsed: this.longFormUsed,
                length: this.length
            };
        }
    }
    jx.NAME = "lengthBlock";
    const Se = {};
    class sr extends Za {
        constructor({ name: e = fu, optional: t = !1, primitiveSchema: r, ...s } = {}, i){
            super(s), this.name = e, this.optional = t, r && (this.primitiveSchema = r), this.idBlock = new Wx(s), this.lenBlock = new jx(s), this.valueBlock = i ? new i(s) : new Ar(s);
        }
        fromBER(e, t, r) {
            const s = this.valueBlock.fromBER(e, t, this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length);
            return s === -1 ? (this.error = this.valueBlock.error, s) : (this.idBlock.error.length || (this.blockLength += this.idBlock.blockLength), this.lenBlock.error.length || (this.blockLength += this.lenBlock.blockLength), this.valueBlock.error.length || (this.blockLength += this.valueBlock.blockLength), s);
        }
        toBER(e, t) {
            const r = t || new E8;
            t || Xx(this);
            const s = this.idBlock.toBER(e);
            if (r.write(s), this.lenBlock.isIndefiniteForm) r.write(new Uint8Array([
                128
            ]).buffer), this.valueBlock.toBER(e, r), r.write(new ArrayBuffer(2));
            else {
                const i = this.valueBlock.toBER(e);
                this.lenBlock.length = i.byteLength;
                const l = this.lenBlock.toBER(e);
                r.write(l), r.write(i);
            }
            return t ? gi : r.final();
        }
        toJSON() {
            const e = {
                ...super.toJSON(),
                idBlock: this.idBlock.toJSON(),
                lenBlock: this.lenBlock.toJSON(),
                valueBlock: this.valueBlock.toJSON(),
                name: this.name,
                optional: this.optional
            };
            return this.primitiveSchema && (e.primitiveSchema = this.primitiveSchema.toJSON()), e;
        }
        toString(e = "ascii") {
            return e === "ascii" ? this.onAsciiEncoding() : jt.ToHex(this.toBER());
        }
        onAsciiEncoding() {
            const e = this.constructor.NAME, t = jt.ToHex(this.valueBlock.valueBeforeDecodeView);
            return `${e} : ${t}`;
        }
        isEqual(e) {
            if (this === e) return !0;
            if (!(e instanceof this.constructor)) return !1;
            const t = this.toBER(), r = e.toBER();
            return Dse(t, r);
        }
    }
    sr.NAME = "BaseBlock";
    function Xx(n) {
        var e;
        if (n instanceof Se.Constructed) for (const t of n.valueBlock.value)Xx(t) && (n.lenBlock.isIndefiniteForm = !0);
        return !!(!((e = n.lenBlock) === null || e === void 0) && e.isIndefiniteForm);
    }
    class Jx extends sr {
        getValue() {
            return this.valueBlock.value;
        }
        setValue(e) {
            this.valueBlock.value = e;
        }
        constructor({ value: e = fu, ...t } = {}, r){
            super(t, r), e && this.fromString(e);
        }
        fromBER(e, t, r) {
            const s = this.valueBlock.fromBER(e, t, this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length);
            return s === -1 ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHexView), this.idBlock.error.length || (this.blockLength += this.idBlock.blockLength), this.lenBlock.error.length || (this.blockLength += this.lenBlock.blockLength), this.valueBlock.error.length || (this.blockLength += this.valueBlock.blockLength), s);
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
        }
    }
    Jx.NAME = "BaseStringBlock";
    class Zx extends Zi(Ar) {
        constructor({ isHexOnly: e = !0, ...t } = {}){
            super(t), this.isHexOnly = e;
        }
    }
    Zx.NAME = "PrimitiveValueBlock";
    var eD;
    class tD extends sr {
        constructor(e = {}){
            super(e, Zx), this.idBlock.isConstructed = !1;
        }
    }
    eD = tD;
    Se.Primitive = eD;
    tD.NAME = "PRIMITIVE";
    function Bse(n, e) {
        if (n instanceof e) return n;
        const t = new e;
        return t.idBlock = n.idBlock, t.lenBlock = n.lenBlock, t.warnings = n.warnings, t.valueBeforeDecodeView = n.valueBeforeDecodeView, t;
    }
    function Rg(n, e = 0, t = n.length) {
        const r = e;
        let s = new sr({}, Ar);
        const i = new Za;
        if (!Ji(i, n, e, t)) return s.error = i.error, {
            offset: -1,
            result: s
        };
        if (!n.subarray(e, e + t).length) return s.error = "Zero buffer length", {
            offset: -1,
            result: s
        };
        let u = s.idBlock.fromBER(n, e, t);
        if (s.idBlock.warnings.length && s.warnings.concat(s.idBlock.warnings), u === -1) return s.error = s.idBlock.error, {
            offset: -1,
            result: s
        };
        if (e = u, t -= s.idBlock.blockLength, u = s.lenBlock.fromBER(n, e, t), s.lenBlock.warnings.length && s.warnings.concat(s.lenBlock.warnings), u === -1) return s.error = s.lenBlock.error, {
            offset: -1,
            result: s
        };
        if (e = u, t -= s.lenBlock.blockLength, !s.idBlock.isConstructed && s.lenBlock.isIndefiniteForm) return s.error = "Indefinite length form used for primitive encoding form", {
            offset: -1,
            result: s
        };
        let h = sr;
        switch(s.idBlock.tagClass){
            case 1:
                if (s.idBlock.tagNumber >= 37 && s.idBlock.isHexOnly === !1) return s.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard", {
                    offset: -1,
                    result: s
                };
                switch(s.idBlock.tagNumber){
                    case 0:
                        if (s.idBlock.isConstructed && s.lenBlock.length > 0) return s.error = "Type [UNIVERSAL 0] is reserved", {
                            offset: -1,
                            result: s
                        };
                        h = Se.EndOfContent;
                        break;
                    case 1:
                        h = Se.Boolean;
                        break;
                    case 2:
                        h = Se.Integer;
                        break;
                    case 3:
                        h = Se.BitString;
                        break;
                    case 4:
                        h = Se.OctetString;
                        break;
                    case 5:
                        h = Se.Null;
                        break;
                    case 6:
                        h = Se.ObjectIdentifier;
                        break;
                    case 10:
                        h = Se.Enumerated;
                        break;
                    case 12:
                        h = Se.Utf8String;
                        break;
                    case 13:
                        h = Se.RelativeObjectIdentifier;
                        break;
                    case 14:
                        h = Se.TIME;
                        break;
                    case 15:
                        return s.error = "[UNIVERSAL 15] is reserved by ASN.1 standard", {
                            offset: -1,
                            result: s
                        };
                    case 16:
                        h = Se.Sequence;
                        break;
                    case 17:
                        h = Se.Set;
                        break;
                    case 18:
                        h = Se.NumericString;
                        break;
                    case 19:
                        h = Se.PrintableString;
                        break;
                    case 20:
                        h = Se.TeletexString;
                        break;
                    case 21:
                        h = Se.VideotexString;
                        break;
                    case 22:
                        h = Se.IA5String;
                        break;
                    case 23:
                        h = Se.UTCTime;
                        break;
                    case 24:
                        h = Se.GeneralizedTime;
                        break;
                    case 25:
                        h = Se.GraphicString;
                        break;
                    case 26:
                        h = Se.VisibleString;
                        break;
                    case 27:
                        h = Se.GeneralString;
                        break;
                    case 28:
                        h = Se.UniversalString;
                        break;
                    case 29:
                        h = Se.CharacterString;
                        break;
                    case 30:
                        h = Se.BmpString;
                        break;
                    case 31:
                        h = Se.DATE;
                        break;
                    case 32:
                        h = Se.TimeOfDay;
                        break;
                    case 33:
                        h = Se.DateTime;
                        break;
                    case 34:
                        h = Se.Duration;
                        break;
                    default:
                        {
                            const f = s.idBlock.isConstructed ? new Se.Constructed : new Se.Primitive;
                            f.idBlock = s.idBlock, f.lenBlock = s.lenBlock, f.warnings = s.warnings, s = f;
                        }
                }
                break;
            default:
                h = s.idBlock.isConstructed ? Se.Constructed : Se.Primitive;
        }
        return s = Bse(s, h), u = s.fromBER(n, e, s.lenBlock.isIndefiniteForm ? t : s.lenBlock.length), s.valueBeforeDecodeView = n.subarray(r, r + s.blockLength), {
            offset: u,
            result: s
        };
    }
    function ny(n) {
        if (!n.byteLength) {
            const e = new sr({}, Ar);
            return e.error = "Input buffer has zero length", {
                offset: -1,
                result: e
            };
        }
        return Rg(Pt.toUint8Array(n).slice(), 0, n.byteLength);
    }
    function Pse(n, e) {
        return n ? 1 : e;
    }
    class Fo extends Ar {
        constructor({ value: e = [], isIndefiniteForm: t = !1, ...r } = {}){
            super(r), this.value = e, this.isIndefiniteForm = t;
        }
        fromBER(e, t, r) {
            const s = Pt.toUint8Array(e);
            if (!Ji(this, s, t, r)) return -1;
            if (this.valueBeforeDecodeView = s.subarray(t, t + r), this.valueBeforeDecodeView.length === 0) return this.warnings.push("Zero buffer length"), t;
            let i = t;
            for(; Pse(this.isIndefiniteForm, r) > 0;){
                const l = Rg(s, i, r);
                if (l.offset === -1) return this.error = l.result.error, this.warnings.concat(l.result.warnings), -1;
                if (i = l.offset, this.blockLength += l.result.blockLength, r -= l.result.blockLength, this.value.push(l.result), this.isIndefiniteForm && l.result.constructor.NAME === cf) break;
            }
            return this.isIndefiniteForm && (this.value[this.value.length - 1].constructor.NAME === cf ? this.value.pop() : this.warnings.push("No EndOfContent block encoded")), i;
        }
        toBER(e, t) {
            const r = t || new E8;
            for(let s = 0; s < this.value.length; s++)this.value[s].toBER(e, r);
            return t ? gi : r.final();
        }
        toJSON() {
            const e = {
                ...super.toJSON(),
                isIndefiniteForm: this.isIndefiniteForm,
                value: []
            };
            for (const t of this.value)e.value.push(t.toJSON());
            return e;
        }
    }
    Fo.NAME = "ConstructedValueBlock";
    var nD;
    class pu extends sr {
        constructor(e = {}){
            super(e, Fo), this.idBlock.isConstructed = !0;
        }
        fromBER(e, t, r) {
            this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
            const s = this.valueBlock.fromBER(e, t, this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length);
            return s === -1 ? (this.error = this.valueBlock.error, s) : (this.idBlock.error.length || (this.blockLength += this.idBlock.blockLength), this.lenBlock.error.length || (this.blockLength += this.lenBlock.blockLength), this.valueBlock.error.length || (this.blockLength += this.valueBlock.blockLength), s);
        }
        onAsciiEncoding() {
            const e = [];
            for (const r of this.valueBlock.value)e.push(r.toString("ascii").split(`
`).map((s)=>`  ${s}`).join(`
`));
            const t = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
            return e.length ? `${t} :
${e.join(`
`)}` : `${t} :`;
        }
    }
    nD = pu;
    Se.Constructed = nD;
    pu.NAME = "CONSTRUCTED";
    class rD extends Ar {
        fromBER(e, t, r) {
            return t;
        }
        toBER(e) {
            return gi;
        }
    }
    rD.override = "EndOfContentValueBlock";
    var sD;
    class iD extends sr {
        constructor(e = {}){
            super(e, rD), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 0;
        }
    }
    sD = iD;
    Se.EndOfContent = sD;
    iD.NAME = cf;
    var oD;
    class qp extends sr {
        constructor(e = {}){
            super(e, Ar), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 5;
        }
        fromBER(e, t, r) {
            return this.lenBlock.length > 0 && this.warnings.push("Non-zero length of value block for Null type"), this.idBlock.error.length || (this.blockLength += this.idBlock.blockLength), this.lenBlock.error.length || (this.blockLength += this.lenBlock.blockLength), this.blockLength += r, t + r > e.byteLength ? (this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)", -1) : t + r;
        }
        toBER(e, t) {
            const r = new ArrayBuffer(2);
            if (!e) {
                const s = new Uint8Array(r);
                s[0] = 5, s[1] = 0;
            }
            return t && t.write(r), r;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME}`;
        }
    }
    oD = qp;
    Se.Null = oD;
    qp.NAME = "NULL";
    class aD extends Zi(Ar) {
        get value() {
            for (const e of this.valueHexView)if (e > 0) return !0;
            return !1;
        }
        set value(e) {
            this.valueHexView[0] = e ? 255 : 0;
        }
        constructor({ value: e, ...t } = {}){
            super(t), t.valueHex ? this.valueHexView = Pt.toUint8Array(t.valueHex) : this.valueHexView = new Uint8Array(1), e && (this.value = e);
        }
        fromBER(e, t, r) {
            const s = Pt.toUint8Array(e);
            return Ji(this, s, t, r) ? (this.valueHexView = s.subarray(t, t + r), r > 1 && this.warnings.push("Boolean value encoded in more then 1 octet"), this.isHexOnly = !0, Kx.call(this), this.blockLength = r, t + r) : -1;
        }
        toBER() {
            return this.valueHexView.slice();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.value
            };
        }
    }
    aD.NAME = "BooleanValueBlock";
    var lD;
    let cD = class extends sr {
        getValue() {
            return this.valueBlock.value;
        }
        setValue(e) {
            this.valueBlock.value = e;
        }
        constructor(e = {}){
            super(e, aD), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 1;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.getValue}`;
        }
    };
    lD = cD;
    Se.Boolean = lD;
    cD.NAME = "BOOLEAN";
    class uD extends Zi(Fo) {
        constructor({ isConstructed: e = !1, ...t } = {}){
            super(t), this.isConstructed = e;
        }
        fromBER(e, t, r) {
            let s = 0;
            if (this.isConstructed) {
                if (this.isHexOnly = !1, s = Fo.prototype.fromBER.call(this, e, t, r), s === -1) return s;
                for(let i = 0; i < this.value.length; i++){
                    const l = this.value[i].constructor.NAME;
                    if (l === cf) {
                        if (this.isIndefiniteForm) break;
                        return this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only", -1;
                    }
                    if (l !== Gx) return this.error = "OCTET STRING may consists of OCTET STRINGs only", -1;
                }
            } else this.isHexOnly = !0, s = super.fromBER(e, t, r), this.blockLength = r;
            return s;
        }
        toBER(e, t) {
            return this.isConstructed ? Fo.prototype.toBER.call(this, e, t) : e ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                isConstructed: this.isConstructed
            };
        }
    }
    uD.NAME = "OctetStringValueBlock";
    var S8;
    class sc extends sr {
        constructor({ idBlock: e = {}, lenBlock: t = {}, ...r } = {}){
            var s, i;
            (s = r.isConstructed) !== null && s !== void 0 || (r.isConstructed = !!(!((i = r.value) === null || i === void 0) && i.length)), super({
                idBlock: {
                    isConstructed: r.isConstructed,
                    ...e
                },
                lenBlock: {
                    ...t,
                    isIndefiniteForm: !!r.isIndefiniteForm
                },
                ...r
            }, uD), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 4;
        }
        fromBER(e, t, r) {
            if (this.valueBlock.isConstructed = this.idBlock.isConstructed, this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm, r === 0) return this.idBlock.error.length === 0 && (this.blockLength += this.idBlock.blockLength), this.lenBlock.error.length === 0 && (this.blockLength += this.lenBlock.blockLength), t;
            if (!this.valueBlock.isConstructed) {
                const i = (e instanceof ArrayBuffer ? new Uint8Array(e) : e).subarray(t, t + r);
                try {
                    if (i.byteLength) {
                        const l = Rg(i, 0, i.byteLength);
                        l.offset !== -1 && l.offset === r && (this.valueBlock.value = [
                            l.result
                        ]);
                    }
                } catch  {}
            }
            return super.fromBER(e, t, r);
        }
        onAsciiEncoding() {
            if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) return pu.prototype.onAsciiEncoding.call(this);
            const e = this.constructor.NAME, t = jt.ToHex(this.valueBlock.valueHexView);
            return `${e} : ${t}`;
        }
        getValue() {
            if (!this.idBlock.isConstructed) return this.valueBlock.valueHexView.slice().buffer;
            const e = [];
            for (const t of this.valueBlock.value)t instanceof S8 && e.push(t.valueBlock.valueHexView);
            return Pt.concat(e);
        }
    }
    S8 = sc;
    Se.OctetString = S8;
    sc.NAME = Gx;
    class hD extends Zi(Fo) {
        constructor({ unusedBits: e = 0, isConstructed: t = !1, ...r } = {}){
            super(r), this.unusedBits = e, this.isConstructed = t, this.blockLength = this.valueHexView.byteLength;
        }
        fromBER(e, t, r) {
            if (!r) return t;
            let s = -1;
            if (this.isConstructed) {
                if (s = Fo.prototype.fromBER.call(this, e, t, r), s === -1) return s;
                for (const u of this.value){
                    const h = u.constructor.NAME;
                    if (h === cf) {
                        if (this.isIndefiniteForm) break;
                        return this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only", -1;
                    }
                    if (h !== Yx) return this.error = "BIT STRING may consists of BIT STRINGs only", -1;
                    const f = u.valueBlock;
                    if (this.unusedBits > 0 && f.unusedBits > 0) return this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only', -1;
                    this.unusedBits = f.unusedBits;
                }
                return s;
            }
            const i = Pt.toUint8Array(e);
            if (!Ji(this, i, t, r)) return -1;
            const l = i.subarray(t, t + r);
            if (this.unusedBits = l[0], this.unusedBits > 7) return this.error = "Unused bits for BitString must be in range 0-7", -1;
            if (!this.unusedBits) {
                const u = l.subarray(1);
                try {
                    if (u.byteLength) {
                        const h = Rg(u, 0, u.byteLength);
                        h.offset !== -1 && h.offset === r - 1 && (this.value = [
                            h.result
                        ]);
                    }
                } catch  {}
            }
            return this.valueHexView = l.subarray(1), this.blockLength = l.length, t + r;
        }
        toBER(e, t) {
            if (this.isConstructed) return Fo.prototype.toBER.call(this, e, t);
            if (e) return new ArrayBuffer(this.valueHexView.byteLength + 1);
            if (!this.valueHexView.byteLength) {
                const s = new Uint8Array(1);
                return s[0] = 0, s.buffer;
            }
            const r = new Uint8Array(this.valueHexView.length + 1);
            return r[0] = this.unusedBits, r.set(this.valueHexView, 1), r.buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                unusedBits: this.unusedBits,
                isConstructed: this.isConstructed
            };
        }
    }
    hD.NAME = "BitStringValueBlock";
    var dD;
    class fD extends sr {
        constructor({ idBlock: e = {}, lenBlock: t = {}, ...r } = {}){
            var s, i;
            (s = r.isConstructed) !== null && s !== void 0 || (r.isConstructed = !!(!((i = r.value) === null || i === void 0) && i.length)), super({
                idBlock: {
                    isConstructed: r.isConstructed,
                    ...e
                },
                lenBlock: {
                    ...t,
                    isIndefiniteForm: !!r.isIndefiniteForm
                },
                ...r
            }, hD), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 3;
        }
        fromBER(e, t, r) {
            return this.valueBlock.isConstructed = this.idBlock.isConstructed, this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm, super.fromBER(e, t, r);
        }
        onAsciiEncoding() {
            if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) return pu.prototype.onAsciiEncoding.call(this);
            {
                const e = [], t = this.valueBlock.valueHexView;
                for (const l of t)e.push(l.toString(2).padStart(8, "0"));
                const r = e.join(""), s = this.constructor.NAME, i = r.substring(0, r.length - this.valueBlock.unusedBits);
                return `${s} : ${i}`;
            }
        }
    }
    dD = fD;
    Se.BitString = dD;
    fD.NAME = Yx;
    var pD;
    function kse(n, e) {
        const t = new Uint8Array([
            0
        ]), r = new Uint8Array(n), s = new Uint8Array(e);
        let i = r.slice(0);
        const l = i.length - 1, u = s.slice(0), h = u.length - 1;
        let f = 0;
        const p = h < l ? l : h;
        let m = 0;
        for(let w = p; w >= 0; w--, m++)!0 === m < u.length ? f = i[l - m] + u[h - m] + t[0] : f = i[l - m] + t[0], t[0] = f / 10, !0 === m >= i.length ? i = g4(new Uint8Array([
            f % 10
        ]), i) : i[l - m] = f % 10;
        return t[0] > 0 && (i = g4(t, i)), i;
    }
    function LE(n) {
        if (n >= Dh.length) for(let e = Dh.length; e <= n; e++){
            const t = new Uint8Array([
                0
            ]);
            let r = Dh[e - 1].slice(0);
            for(let s = r.length - 1; s >= 0; s--){
                const i = new Uint8Array([
                    (r[s] << 1) + t[0]
                ]);
                t[0] = i[0] / 10, r[s] = i[0] % 10;
            }
            t[0] > 0 && (r = g4(t, r)), Dh.push(r);
        }
        return Dh[n];
    }
    function Rse(n, e) {
        let t = 0;
        const r = new Uint8Array(n), s = new Uint8Array(e), i = r.slice(0), l = i.length - 1, u = s.slice(0), h = u.length - 1;
        let f, p = 0;
        for(let m = h; m >= 0; m--, p++)f = i[l - p] - u[h - p] - t, !0 === f < 0 ? (t = 1, i[l - p] = f + 10) : (t = 0, i[l - p] = f);
        if (t > 0) for(let m = l - h + 1; m >= 0; m--, p++)if (f = i[l - p] - t, f < 0) t = 1, i[l - p] = f + 10;
        else {
            t = 0, i[l - p] = f;
            break;
        }
        return i.slice();
    }
    class I8 extends Zi(Ar) {
        setValueHex() {
            this.valueHexView.length >= 4 ? (this.warnings.push("Too big Integer for decoding, hex only"), this.isHexOnly = !0, this._valueDec = 0) : (this.isHexOnly = !1, this.valueHexView.length > 0 && (this._valueDec = Kx.call(this)));
        }
        constructor({ value: e, ...t } = {}){
            super(t), this._valueDec = 0, t.valueHex && this.setValueHex(), e !== void 0 && (this.valueDec = e);
        }
        set valueDec(e) {
            this._valueDec = e, this.isHexOnly = !1, this.valueHexView = new Uint8Array(xse(e));
        }
        get valueDec() {
            return this._valueDec;
        }
        fromDER(e, t, r, s = 0) {
            const i = this.fromBER(e, t, r);
            if (i === -1) return i;
            const l = this.valueHexView;
            return l[0] === 0 && (l[1] & 128) !== 0 ? this.valueHexView = l.subarray(1) : s !== 0 && l.length < s && (s - l.length > 1 && (s = l.length + 1), this.valueHexView = l.subarray(s - l.length)), i;
        }
        toDER(e = !1) {
            const t = this.valueHexView;
            switch(!0){
                case (t[0] & 128) !== 0:
                    {
                        const r = new Uint8Array(this.valueHexView.length + 1);
                        r[0] = 0, r.set(t, 1), this.valueHexView = r;
                    }
                    break;
                case (t[0] === 0 && (t[1] & 128) === 0):
                    this.valueHexView = this.valueHexView.subarray(1);
                    break;
            }
            return this.toBER(e);
        }
        fromBER(e, t, r) {
            const s = super.fromBER(e, t, r);
            return s === -1 || this.setValueHex(), s;
        }
        toBER(e) {
            return e ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                valueDec: this.valueDec
            };
        }
        toString() {
            const e = this.valueHexView.length * 8 - 1;
            let t = new Uint8Array(this.valueHexView.length * 8 / 3), r = 0, s;
            const i = this.valueHexView;
            let l = "", u = !1;
            for(let h = i.byteLength - 1; h >= 0; h--){
                s = i[h];
                for(let f = 0; f < 8; f++)(s & 1) === 1 && (r === e ? (t = Rse(LE(r), t), l = "-") : t = kse(t, LE(r))), r++, s >>= 1;
            }
            for(let h = 0; h < t.length; h++)t[h] && (u = !0), u && (l += NE.charAt(t[h]));
            return u === !1 && (l += NE.charAt(0)), l;
        }
    }
    pD = I8;
    I8.NAME = "IntegerValueBlock";
    Object.defineProperty(pD.prototype, "valueHex", {
        set: function(n) {
            this.valueHexView = new Uint8Array(n), this.setValueHex();
        },
        get: function() {
            return this.valueHexView.slice().buffer;
        }
    });
    var Ad;
    class xc extends sr {
        constructor(e = {}){
            super(e, I8), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 2;
        }
        toBigInt() {
            return Qp(), BigInt(this.valueBlock.toString());
        }
        static fromBigInt(e) {
            Qp();
            const t = BigInt(e), r = new E8, s = t.toString(16).replace(/^-/, ""), i = new Uint8Array(jt.FromHex(s));
            if (t < 0) {
                const u = new Uint8Array(i.length + (i[0] & 128 ? 1 : 0));
                u[0] |= 128;
                const f = BigInt(`0x${jt.ToHex(u)}`) + t, p = Pt.toUint8Array(jt.FromHex(f.toString(16)));
                p[0] |= 128, r.write(p);
            } else i[0] & 128 && r.write(new Uint8Array([
                0
            ])), r.write(i);
            return new Ad({
                valueHex: r.final()
            });
        }
        convertToDER() {
            const e = new Ad({
                valueHex: this.valueBlock.valueHexView
            });
            return e.valueBlock.toDER(), e;
        }
        convertFromDER() {
            return new Ad({
                valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
            });
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
        }
    }
    Ad = xc;
    Se.Integer = Ad;
    xc.NAME = "INTEGER";
    var gD;
    class mD extends xc {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 10;
        }
    }
    gD = mD;
    Se.Enumerated = gD;
    mD.NAME = "ENUMERATED";
    class m4 extends Zi(Ar) {
        constructor({ valueDec: e = -1, isFirstSid: t = !1, ...r } = {}){
            super(r), this.valueDec = e, this.isFirstSid = t;
        }
        fromBER(e, t, r) {
            if (!r) return t;
            const s = Pt.toUint8Array(e);
            if (!Ji(this, s, t, r)) return -1;
            const i = s.subarray(t, t + r);
            this.valueHexView = new Uint8Array(r);
            for(let u = 0; u < r && (this.valueHexView[u] = i[u] & 127, this.blockLength++, (i[u] & 128) !== 0); u++);
            const l = new Uint8Array(this.blockLength);
            for(let u = 0; u < this.blockLength; u++)l[u] = this.valueHexView[u];
            return this.valueHexView = l, (i[this.blockLength - 1] & 128) !== 0 ? (this.error = "End of input reached before message was fully decoded", -1) : (this.valueHexView[0] === 0 && this.warnings.push("Needlessly long format of SID encoding"), this.blockLength <= 8 ? this.valueDec = Vc(this.valueHexView, 7) : (this.isHexOnly = !0, this.warnings.push("Too big SID for decoding, hex only")), t + this.blockLength);
        }
        set valueBigInt(e) {
            Qp();
            let t = BigInt(e).toString(2);
            for(; t.length % 7;)t = "0" + t;
            const r = new Uint8Array(t.length / 7);
            for(let s = 0; s < r.length; s++)r[s] = parseInt(t.slice(s * 7, s * 7 + 7), 2) + (s + 1 < r.length ? 128 : 0);
            this.fromBER(r.buffer, 0, r.length);
        }
        toBER(e) {
            if (this.isHexOnly) {
                if (e) return new ArrayBuffer(this.valueHexView.byteLength);
                const s = this.valueHexView, i = new Uint8Array(this.blockLength);
                for(let l = 0; l < this.blockLength - 1; l++)i[l] = s[l] | 128;
                return i[this.blockLength - 1] = s[this.blockLength - 1], i.buffer;
            }
            const t = Ka(this.valueDec, 7);
            if (t.byteLength === 0) return this.error = "Error during encoding SID value", gi;
            const r = new Uint8Array(t.byteLength);
            if (!e) {
                const s = new Uint8Array(t), i = t.byteLength - 1;
                for(let l = 0; l < i; l++)r[l] = s[l] | 128;
                r[i] = s[i];
            }
            return r;
        }
        toString() {
            let e = "";
            if (this.isHexOnly) e = jt.ToHex(this.valueHexView);
            else if (this.isFirstSid) {
                let t = this.valueDec;
                this.valueDec <= 39 ? e = "0." : this.valueDec <= 79 ? (e = "1.", t -= 40) : (e = "2.", t -= 80), e += t.toString();
            } else e = this.valueDec.toString();
            return e;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                valueDec: this.valueDec,
                isFirstSid: this.isFirstSid
            };
        }
    }
    m4.NAME = "sidBlock";
    class yD extends Ar {
        constructor({ value: e = fu, ...t } = {}){
            super(t), this.value = [], e && this.fromString(e);
        }
        fromBER(e, t, r) {
            let s = t;
            for(; r > 0;){
                const i = new m4;
                if (s = i.fromBER(e, s, r), s === -1) return this.blockLength = 0, this.error = i.error, s;
                this.value.length === 0 && (i.isFirstSid = !0), this.blockLength += i.blockLength, r -= i.blockLength, this.value.push(i);
            }
            return s;
        }
        toBER(e) {
            const t = [];
            for(let r = 0; r < this.value.length; r++){
                const s = this.value[r].toBER(e);
                if (s.byteLength === 0) return this.error = this.value[r].error, gi;
                t.push(s);
            }
            return v8(t);
        }
        fromString(e) {
            this.value = [];
            let t = 0, r = 0, s = "", i = !1;
            do if (r = e.indexOf(".", t), r === -1 ? s = e.substring(t) : s = e.substring(t, r), t = r + 1, i) {
                const l = this.value[0];
                let u = 0;
                switch(l.valueDec){
                    case 0:
                        break;
                    case 1:
                        u = 40;
                        break;
                    case 2:
                        u = 80;
                        break;
                    default:
                        this.value = [];
                        return;
                }
                const h = parseInt(s, 10);
                if (isNaN(h)) return;
                l.valueDec = h + u, i = !1;
            } else {
                const l = new m4;
                if (s > Number.MAX_SAFE_INTEGER) {
                    Qp();
                    const u = BigInt(s);
                    l.valueBigInt = u;
                } else if (l.valueDec = parseInt(s, 10), isNaN(l.valueDec)) return;
                this.value.length || (l.isFirstSid = !0, i = !0), this.value.push(l);
            }
            while (r !== -1);
        }
        toString() {
            let e = "", t = !1;
            for(let r = 0; r < this.value.length; r++){
                t = this.value[r].isHexOnly;
                let s = this.value[r].toString();
                r !== 0 && (e = `${e}.`), t ? (s = `{${s}}`, this.value[r].isFirstSid ? e = `2.{${s} - 80}` : e += s) : e += s;
            }
            return e;
        }
        toJSON() {
            const e = {
                ...super.toJSON(),
                value: this.toString(),
                sidArray: []
            };
            for(let t = 0; t < this.value.length; t++)e.sidArray.push(this.value[t].toJSON());
            return e;
        }
    }
    yD.NAME = "ObjectIdentifierValueBlock";
    var wD;
    class Ta extends sr {
        getValue() {
            return this.valueBlock.toString();
        }
        setValue(e) {
            this.valueBlock.fromString(e);
        }
        constructor(e = {}){
            super(e, yD), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 6;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.getValue()
            };
        }
    }
    wD = Ta;
    Se.ObjectIdentifier = wD;
    Ta.NAME = "OBJECT IDENTIFIER";
    class y4 extends Zi(Za) {
        constructor({ valueDec: e = 0, ...t } = {}){
            super(t), this.valueDec = e;
        }
        fromBER(e, t, r) {
            if (r === 0) return t;
            const s = Pt.toUint8Array(e);
            if (!Ji(this, s, t, r)) return -1;
            const i = s.subarray(t, t + r);
            this.valueHexView = new Uint8Array(r);
            for(let u = 0; u < r && (this.valueHexView[u] = i[u] & 127, this.blockLength++, (i[u] & 128) !== 0); u++);
            const l = new Uint8Array(this.blockLength);
            for(let u = 0; u < this.blockLength; u++)l[u] = this.valueHexView[u];
            return this.valueHexView = l, (i[this.blockLength - 1] & 128) !== 0 ? (this.error = "End of input reached before message was fully decoded", -1) : (this.valueHexView[0] === 0 && this.warnings.push("Needlessly long format of SID encoding"), this.blockLength <= 8 ? this.valueDec = Vc(this.valueHexView, 7) : (this.isHexOnly = !0, this.warnings.push("Too big SID for decoding, hex only")), t + this.blockLength);
        }
        toBER(e) {
            if (this.isHexOnly) {
                if (e) return new ArrayBuffer(this.valueHexView.byteLength);
                const s = this.valueHexView, i = new Uint8Array(this.blockLength);
                for(let l = 0; l < this.blockLength - 1; l++)i[l] = s[l] | 128;
                return i[this.blockLength - 1] = s[this.blockLength - 1], i.buffer;
            }
            const t = Ka(this.valueDec, 7);
            if (t.byteLength === 0) return this.error = "Error during encoding SID value", gi;
            const r = new Uint8Array(t.byteLength);
            if (!e) {
                const s = new Uint8Array(t), i = t.byteLength - 1;
                for(let l = 0; l < i; l++)r[l] = s[l] | 128;
                r[i] = s[i];
            }
            return r.buffer;
        }
        toString() {
            let e = "";
            return this.isHexOnly ? e = jt.ToHex(this.valueHexView) : e = this.valueDec.toString(), e;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                valueDec: this.valueDec
            };
        }
    }
    y4.NAME = "relativeSidBlock";
    class bD extends Ar {
        constructor({ value: e = fu, ...t } = {}){
            super(t), this.value = [], e && this.fromString(e);
        }
        fromBER(e, t, r) {
            let s = t;
            for(; r > 0;){
                const i = new y4;
                if (s = i.fromBER(e, s, r), s === -1) return this.blockLength = 0, this.error = i.error, s;
                this.blockLength += i.blockLength, r -= i.blockLength, this.value.push(i);
            }
            return s;
        }
        toBER(e, t) {
            const r = [];
            for(let s = 0; s < this.value.length; s++){
                const i = this.value[s].toBER(e);
                if (i.byteLength === 0) return this.error = this.value[s].error, gi;
                r.push(i);
            }
            return v8(r);
        }
        fromString(e) {
            this.value = [];
            let t = 0, r = 0, s = "";
            do {
                r = e.indexOf(".", t), r === -1 ? s = e.substring(t) : s = e.substring(t, r), t = r + 1;
                const i = new y4;
                if (i.valueDec = parseInt(s, 10), isNaN(i.valueDec)) return !0;
                this.value.push(i);
            }while (r !== -1);
            return !0;
        }
        toString() {
            let e = "", t = !1;
            for(let r = 0; r < this.value.length; r++){
                t = this.value[r].isHexOnly;
                let s = this.value[r].toString();
                r !== 0 && (e = `${e}.`), t && (s = `{${s}}`), e += s;
            }
            return e;
        }
        toJSON() {
            const e = {
                ...super.toJSON(),
                value: this.toString(),
                sidArray: []
            };
            for(let t = 0; t < this.value.length; t++)e.sidArray.push(this.value[t].toJSON());
            return e;
        }
    }
    bD.NAME = "RelativeObjectIdentifierValueBlock";
    var vD;
    class ED extends sr {
        getValue() {
            return this.valueBlock.toString();
        }
        setValue(e) {
            this.valueBlock.fromString(e);
        }
        constructor(e = {}){
            super(e, bD), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 13;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.getValue()
            };
        }
    }
    vD = ED;
    Se.RelativeObjectIdentifier = vD;
    ED.NAME = "RelativeObjectIdentifier";
    var AD;
    class $s extends pu {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 16;
        }
    }
    AD = $s;
    Se.Sequence = AD;
    $s.NAME = "SEQUENCE";
    var SD;
    let ID = class extends pu {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 17;
        }
    };
    SD = ID;
    Se.Set = SD;
    ID.NAME = "SET";
    class CD extends Zi(Ar) {
        constructor({ ...e } = {}){
            super(e), this.isHexOnly = !0, this.value = fu;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.value
            };
        }
    }
    CD.NAME = "StringValueBlock";
    class TD extends CD {
    }
    TD.NAME = "SimpleStringValueBlock";
    class Hr extends Jx {
        constructor({ ...e } = {}){
            super(e, TD);
        }
        fromBuffer(e) {
            this.valueBlock.value = String.fromCharCode.apply(null, Pt.toUint8Array(e));
        }
        fromString(e) {
            const t = e.length, r = this.valueBlock.valueHexView = new Uint8Array(t);
            for(let s = 0; s < t; s++)r[s] = e.charCodeAt(s);
            this.valueBlock.value = e;
        }
    }
    Hr.NAME = "SIMPLE STRING";
    class _D extends Hr {
        fromBuffer(e) {
            this.valueBlock.valueHexView = Pt.toUint8Array(e);
            try {
                this.valueBlock.value = jt.ToUtf8String(e);
            } catch (t) {
                this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`), this.valueBlock.value = jt.ToBinary(e);
            }
        }
        fromString(e) {
            this.valueBlock.valueHexView = new Uint8Array(jt.FromUtf8String(e)), this.valueBlock.value = e;
        }
    }
    _D.NAME = "Utf8StringValueBlock";
    var xD;
    class el extends _D {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 12;
        }
    }
    xD = el;
    Se.Utf8String = xD;
    el.NAME = "UTF8String";
    class DD extends Hr {
        fromBuffer(e) {
            this.valueBlock.value = jt.ToUtf16String(e), this.valueBlock.valueHexView = Pt.toUint8Array(e);
        }
        fromString(e) {
            this.valueBlock.value = e, this.valueBlock.valueHexView = new Uint8Array(jt.FromUtf16String(e));
        }
    }
    DD.NAME = "BmpStringValueBlock";
    var BD;
    class PD extends DD {
        constructor({ ...e } = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 30;
        }
    }
    BD = PD;
    Se.BmpString = BD;
    PD.NAME = "BMPString";
    class kD extends Hr {
        fromBuffer(e) {
            const t = ArrayBuffer.isView(e) ? e.slice().buffer : e.slice(0), r = new Uint8Array(t);
            for(let s = 0; s < r.length; s += 4)r[s] = r[s + 3], r[s + 1] = r[s + 2], r[s + 2] = 0, r[s + 3] = 0;
            this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(t));
        }
        fromString(e) {
            const t = e.length, r = this.valueBlock.valueHexView = new Uint8Array(t * 4);
            for(let s = 0; s < t; s++){
                const i = Ka(e.charCodeAt(s), 8), l = new Uint8Array(i);
                if (l.length > 4) continue;
                const u = 4 - l.length;
                for(let h = l.length - 1; h >= 0; h--)r[s * 4 + h + u] = l[h];
            }
            this.valueBlock.value = e;
        }
    }
    kD.NAME = "UniversalStringValueBlock";
    var RD;
    class OD extends kD {
        constructor({ ...e } = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 28;
        }
    }
    RD = OD;
    Se.UniversalString = RD;
    OD.NAME = "UniversalString";
    var $D;
    class MD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 18;
        }
    }
    $D = MD;
    Se.NumericString = $D;
    MD.NAME = "NumericString";
    var ND;
    class LD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 19;
        }
    }
    ND = LD;
    Se.PrintableString = ND;
    LD.NAME = "PrintableString";
    var UD;
    class zD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 20;
        }
    }
    UD = zD;
    Se.TeletexString = UD;
    zD.NAME = "TeletexString";
    var FD;
    class VD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 21;
        }
    }
    FD = VD;
    Se.VideotexString = FD;
    VD.NAME = "VideotexString";
    var HD;
    class QD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 22;
        }
    }
    HD = QD;
    Se.IA5String = HD;
    QD.NAME = "IA5String";
    var qD;
    class KD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 25;
        }
    }
    qD = KD;
    Se.GraphicString = qD;
    KD.NAME = "GraphicString";
    var GD;
    class C8 extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 26;
        }
    }
    GD = C8;
    Se.VisibleString = GD;
    C8.NAME = "VisibleString";
    var YD;
    class WD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 27;
        }
    }
    YD = WD;
    Se.GeneralString = YD;
    WD.NAME = "GeneralString";
    var jD;
    class XD extends Hr {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 29;
        }
    }
    jD = XD;
    Se.CharacterString = jD;
    XD.NAME = "CharacterString";
    var JD;
    class T8 extends C8 {
        constructor({ value: e, valueDate: t, ...r } = {}){
            if (super(r), this.year = 0, this.month = 0, this.day = 0, this.hour = 0, this.minute = 0, this.second = 0, e) {
                this.fromString(e), this.valueBlock.valueHexView = new Uint8Array(e.length);
                for(let s = 0; s < e.length; s++)this.valueBlock.valueHexView[s] = e.charCodeAt(s);
            }
            t && (this.fromDate(t), this.valueBlock.valueHexView = new Uint8Array(this.toBuffer())), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 23;
        }
        fromBuffer(e) {
            this.fromString(String.fromCharCode.apply(null, Pt.toUint8Array(e)));
        }
        toBuffer() {
            const e = this.toString(), t = new ArrayBuffer(e.length), r = new Uint8Array(t);
            for(let s = 0; s < e.length; s++)r[s] = e.charCodeAt(s);
            return t;
        }
        fromDate(e) {
            this.year = e.getUTCFullYear(), this.month = e.getUTCMonth() + 1, this.day = e.getUTCDate(), this.hour = e.getUTCHours(), this.minute = e.getUTCMinutes(), this.second = e.getUTCSeconds();
        }
        toDate() {
            return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
        }
        fromString(e) {
            const r = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);
            if (r === null) {
                this.error = "Wrong input string for conversion";
                return;
            }
            const s = parseInt(r[1], 10);
            s >= 50 ? this.year = 1900 + s : this.year = 2e3 + s, this.month = parseInt(r[2], 10), this.day = parseInt(r[3], 10), this.hour = parseInt(r[4], 10), this.minute = parseInt(r[5], 10), this.second = parseInt(r[6], 10);
        }
        toString(e = "iso") {
            if (e === "iso") {
                const t = new Array(7);
                return t[0] = Mr(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2), t[1] = Mr(this.month, 2), t[2] = Mr(this.day, 2), t[3] = Mr(this.hour, 2), t[4] = Mr(this.minute, 2), t[5] = Mr(this.second, 2), t[6] = "Z", t.join("");
            }
            return super.toString(e);
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                year: this.year,
                month: this.month,
                day: this.day,
                hour: this.hour,
                minute: this.minute,
                second: this.second
            };
        }
    }
    JD = T8;
    Se.UTCTime = JD;
    T8.NAME = "UTCTime";
    var ZD;
    class eB extends T8 {
        constructor(e = {}){
            var t;
            super(e), (t = this.millisecond) !== null && t !== void 0 || (this.millisecond = 0), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 24;
        }
        fromDate(e) {
            super.fromDate(e), this.millisecond = e.getUTCMilliseconds();
        }
        toDate() {
            const e = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
            return new Date(e);
        }
        fromString(e) {
            let t = !1, r = "", s = "", i = 0, l, u = 0, h = 0;
            if (e[e.length - 1] === "Z") r = e.substring(0, e.length - 1), t = !0;
            else {
                const m = new Number(e[e.length - 1]);
                if (isNaN(m.valueOf())) throw new Error("Wrong input string for conversion");
                r = e;
            }
            if (t) {
                if (r.indexOf("+") !== -1) throw new Error("Wrong input string for conversion");
                if (r.indexOf("-") !== -1) throw new Error("Wrong input string for conversion");
            } else {
                let m = 1, w = r.indexOf("+"), A = "";
                if (w === -1 && (w = r.indexOf("-"), m = -1), w !== -1) {
                    if (A = r.substring(w + 1), r = r.substring(0, w), A.length !== 2 && A.length !== 4) throw new Error("Wrong input string for conversion");
                    let S = parseInt(A.substring(0, 2), 10);
                    if (isNaN(S.valueOf())) throw new Error("Wrong input string for conversion");
                    if (u = m * S, A.length === 4) {
                        if (S = parseInt(A.substring(2, 4), 10), isNaN(S.valueOf())) throw new Error("Wrong input string for conversion");
                        h = m * S;
                    }
                }
            }
            let f = r.indexOf(".");
            if (f === -1 && (f = r.indexOf(",")), f !== -1) {
                const m = new Number(`0${r.substring(f)}`);
                if (isNaN(m.valueOf())) throw new Error("Wrong input string for conversion");
                i = m.valueOf(), s = r.substring(0, f);
            } else s = r;
            switch(!0){
                case s.length === 8:
                    if (l = /(\d{4})(\d{2})(\d{2})/ig, f !== -1) throw new Error("Wrong input string for conversion");
                    break;
                case s.length === 10:
                    if (l = /(\d{4})(\d{2})(\d{2})(\d{2})/ig, f !== -1) {
                        let m = 60 * i;
                        this.minute = Math.floor(m), m = 60 * (m - this.minute), this.second = Math.floor(m), m = 1e3 * (m - this.second), this.millisecond = Math.floor(m);
                    }
                    break;
                case s.length === 12:
                    if (l = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig, f !== -1) {
                        let m = 60 * i;
                        this.second = Math.floor(m), m = 1e3 * (m - this.second), this.millisecond = Math.floor(m);
                    }
                    break;
                case s.length === 14:
                    if (l = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig, f !== -1) {
                        const m = 1e3 * i;
                        this.millisecond = Math.floor(m);
                    }
                    break;
                default:
                    throw new Error("Wrong input string for conversion");
            }
            const p = l.exec(s);
            if (p === null) throw new Error("Wrong input string for conversion");
            for(let m = 1; m < p.length; m++)switch(m){
                case 1:
                    this.year = parseInt(p[m], 10);
                    break;
                case 2:
                    this.month = parseInt(p[m], 10);
                    break;
                case 3:
                    this.day = parseInt(p[m], 10);
                    break;
                case 4:
                    this.hour = parseInt(p[m], 10) + u;
                    break;
                case 5:
                    this.minute = parseInt(p[m], 10) + h;
                    break;
                case 6:
                    this.second = parseInt(p[m], 10);
                    break;
                default:
                    throw new Error("Wrong input string for conversion");
            }
            if (t === !1) {
                const m = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
                this.year = m.getUTCFullYear(), this.month = m.getUTCMonth(), this.day = m.getUTCDay(), this.hour = m.getUTCHours(), this.minute = m.getUTCMinutes(), this.second = m.getUTCSeconds(), this.millisecond = m.getUTCMilliseconds();
            }
        }
        toString(e = "iso") {
            if (e === "iso") {
                const t = [];
                return t.push(Mr(this.year, 4)), t.push(Mr(this.month, 2)), t.push(Mr(this.day, 2)), t.push(Mr(this.hour, 2)), t.push(Mr(this.minute, 2)), t.push(Mr(this.second, 2)), this.millisecond !== 0 && (t.push("."), t.push(Mr(this.millisecond, 3))), t.push("Z"), t.join("");
            }
            return super.toString(e);
        }
        toJSON() {
            return {
                ...super.toJSON(),
                millisecond: this.millisecond
            };
        }
    }
    ZD = eB;
    Se.GeneralizedTime = ZD;
    eB.NAME = "GeneralizedTime";
    var tB;
    class nB extends el {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 31;
        }
    }
    tB = nB;
    Se.DATE = tB;
    nB.NAME = "DATE";
    var rB;
    class sB extends el {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 32;
        }
    }
    rB = sB;
    Se.TimeOfDay = rB;
    sB.NAME = "TimeOfDay";
    var iB;
    class oB extends el {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 33;
        }
    }
    iB = oB;
    Se.DateTime = iB;
    oB.NAME = "DateTime";
    var aB;
    class lB extends el {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 34;
        }
    }
    aB = lB;
    Se.Duration = aB;
    lB.NAME = "Duration";
    var cB;
    class uB extends el {
        constructor(e = {}){
            super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 14;
        }
    }
    cB = uB;
    Se.TIME = cB;
    uB.NAME = "TIME";
    const Ose = 16, w4 = 32, b4 = 1e4;
    async function Og(n, e) {
        const r = await Hx().encrypt(n, e);
        return As.encode(r);
    }
    async function UE(n, e, t) {
        if (n.type === "RSA") return Lse(n, e, t);
        if (n.type === "Ed25519") return $se(n, e, t);
        if (n.type === "secp256k1") return Mse(n, e, t);
        if (n.type === "ECDSA") return Nse(n, e, t);
        throw new lse;
    }
    async function $se(n, e, t = "libp2p-key") {
        if (t === "libp2p-key") return Og(nu(n), e);
        throw new _t(`export format '${t}' is not supported`);
    }
    async function Mse(n, e, t = "libp2p-key") {
        if (t === "libp2p-key") return Og(nu(n), e);
        throw new _t("Export format is not supported");
    }
    async function Nse(n, e, t = "libp2p-key") {
        if (t === "libp2p-key") return Og(nu(n), e);
        throw new _t(`export format '${t}' is not supported`);
    }
    async function Lse(n, e, t = "pkcs-8") {
        if (t === "pkcs-8") return Use(n, e);
        if (t === "libp2p-key") return Og(nu(n), e);
        throw new _t("Export format is not supported");
    }
    async function Use(n, e) {
        const t = nr.get(), s = new $s({
            value: [
                new xc({
                    value: 0
                }),
                new $s({
                    value: [
                        new Ta({
                            value: "1.2.840.113549.1.1.1"
                        }),
                        new qp
                    ]
                }),
                new sc({
                    valueHex: n.raw
                })
            ]
        }).toBER(), i = new Uint8Array(s, 0, s.byteLength), l = Go(Ose), u = await yC(dg, e, l, {
            c: b4,
            dkLen: w4
        }), h = Go(16), f = await t.subtle.importKey("raw", u, "AES-CBC", !1, [
            "encrypt"
        ]), p = await t.subtle.encrypt({
            name: "AES-CBC",
            iv: h
        }, f, i), m = new $s({
            value: [
                new sc({
                    valueHex: l
                }),
                new xc({
                    value: b4
                }),
                new xc({
                    value: w4
                }),
                new $s({
                    value: [
                        new Ta({
                            value: "1.2.840.113549.2.11"
                        }),
                        new qp
                    ]
                })
            ]
        }), w = new $s({
            value: [
                new Ta({
                    value: "1.2.840.113549.1.5.13"
                }),
                new $s({
                    value: [
                        new $s({
                            value: [
                                new Ta({
                                    value: "1.2.840.113549.1.5.12"
                                }),
                                m
                            ]
                        }),
                        new $s({
                            value: [
                                new Ta({
                                    value: "2.16.840.1.101.3.4.1.42"
                                }),
                                new sc({
                                    valueHex: h
                                })
                            ]
                        })
                    ]
                })
            ]
        }), S = new $s({
            value: [
                w,
                new sc({
                    valueHex: p
                })
            ]
        }).toBER(), _ = new Uint8Array(S, 0, S.byteLength);
        return [
            "-----BEGIN ENCRYPTED PRIVATE KEY-----",
            ...L(_, "base64pad").split(/(.{64})/).filter(Boolean),
            "-----END ENCRYPTED PRIVATE KEY-----"
        ].join(`
`);
    }
    async function zE(n, e) {
        try {
            const t = await zse(n, e);
            return fC(t);
        } catch  {}
        if (!n.includes("BEGIN")) throw new _t("Encrypted key was not a libp2p-key or a PEM file");
        return Fse(n, e);
    }
    async function zse(n, e) {
        const t = As.decode(n);
        return Hx().decrypt(t, e);
    }
    async function Fse(n, e) {
        const t = nr.get();
        let r;
        if (n.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
            const i = re(n.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "").replace("-----END ENCRYPTED PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad"), { result: l } = ny(i), { iv: u, salt: h, iterations: f, keySize: p, cipherText: m } = Vse(l), w = await yC(dg, e, h, {
                c: f,
                dkLen: p
            }), A = await t.subtle.importKey("raw", w, "AES-CBC", !1, [
                "decrypt"
            ]), S = Sd(await t.subtle.decrypt({
                name: "AES-CBC",
                iv: u
            }, A, m)), { result: _ } = ny(S);
            r = FE(_);
        } else if (n.includes("-----BEGIN PRIVATE KEY-----")) {
            const i = re(n.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad"), { result: l } = ny(i);
            r = FE(l);
        } else throw new _t("Could not parse private key from PEM data");
        const s = pC(r);
        if (s.type !== "RSA") throw new _t("Could not parse RSA private key from PEM data");
        return s;
    }
    function Vse(n) {
        const e = n.valueBlock.value[0];
        if (e.valueBlock.value[0].toString() !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.13") throw new _t("Only pkcs5PBES2 encrypted private keys are supported");
        const r = e.valueBlock.value[1].valueBlock.value[0];
        if (r.valueBlock.value[0].toString() !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.12") throw new _t("Only pkcs5PBKDF2 key derivation functions are supported");
        const i = r.valueBlock.value[1], l = Sd(i.valueBlock.value[0].getValue());
        let u = b4, h = w4;
        if (i.valueBlock.value.length === 3) u = Number(i.valueBlock.value[1].toBigInt()), h = Number(i.valueBlock.value[2].toBigInt());
        else if (i.valueBlock.value.length === 2) throw new _t("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");
        const f = e.valueBlock.value[1].valueBlock.value[1], p = f.valueBlock.value[0].toString();
        if (p !== "OBJECT IDENTIFIER : 1.2.840.113549.3.7") {
            if (p !== "OBJECT IDENTIFIER : 1.3.14.3.2.7") {
                if (p !== "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2") {
                    if (p !== "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22") {
                        if (p !== "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42") throw new _t("Only AES-CBC encryption schemes are supported");
                    }
                }
            }
        }
        const m = Sd(f.valueBlock.value[1].getValue());
        return {
            cipherText: Sd(n.valueBlock.value[1].getValue()),
            salt: l,
            iterations: u,
            keySize: h,
            iv: m
        };
    }
    function FE(n) {
        return Sd(n.valueBlock.value[2].getValue());
    }
    function Sd(n) {
        return new Uint8Array(n, 0, n.byteLength);
    }
    const Hse = "/pkcs8/", v4 = "/info/", Bh = new WeakMap, Ea = {
        minKeyLength: 112 / 8,
        minSaltLength: 128 / 8,
        minIterationCount: 1e3
    };
    function ql(n) {
        return n == null || typeof n != "string" ? !1 : n === gse(n.trim()) && n.length > 0;
    }
    async function Sn() {
        const t = Math.random() * 800 + 200;
        await new Promise((r)=>setTimeout(r, t));
    }
    function Aa(n) {
        return new Nt(Hse + n);
    }
    function Kl(n) {
        return new Nt(v4 + n);
    }
    async function Qse(n) {
        const e = nu(n), t = await Ut.digest(e);
        return He.encode(t.bytes).substring(1);
    }
    class qse {
        components;
        init;
        log;
        self;
        constructor(e, t){
            if (this.components = e, this.log = e.logger.forComponent("libp2p:keychain"), this.init = {
                ...t,
                dek: {
                    ...OE,
                    ...t.dek
                }
            }, this.self = t.selfKey ?? "self", this.init.pass != null && this.init.pass?.length < 20) throw new Error("pass must be least 20 characters");
            if (this.init.dek?.keyLength != null && this.init.dek.keyLength < Ea.minKeyLength) throw new Error(`dek.keyLength must be least ${Ea.minKeyLength} bytes`);
            if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < Ea.minSaltLength) throw new Error(`dek.saltLength must be least ${Ea.minSaltLength} bytes`);
            if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < Ea.minIterationCount) throw new Error(`dek.iterationCount must be least ${Ea.minIterationCount}`);
            const r = this.init.pass != null && this.init.dek?.salt != null ? K9(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
            Bh.set(this, {
                dek: r
            });
        }
        [Symbol.toStringTag] = "@libp2p/keychain";
        [cse] = [
            "@libp2p/keychain"
        ];
        static generateOptions() {
            const e = Object.assign({}, this.options), t = Math.ceil(Ea.minSaltLength / 3) * 3;
            return e.dek != null && (e.dek.salt = L(Go(t), "base64")), e;
        }
        static get options() {
            return {
                dek: {
                    ...OE
                }
            };
        }
        async findKeyByName(e) {
            if (!ql(e)) throw await Sn(), new _t(`Invalid key name '${e}'`);
            const t = Kl(e);
            try {
                const r = await this.components.datastore.get(t);
                return JSON.parse(L(r));
            } catch (r) {
                throw await Sn(), this.log.error("could not read key from datastore - %e", r), new ase(`Key '${e}' does not exist.`);
            }
        }
        async findKeyById(e) {
            try {
                const t = {
                    prefix: v4
                };
                for await (const r of this.components.datastore.query(t)){
                    const s = JSON.parse(L(r.value));
                    if (s.id === e) return s;
                }
                throw new _t(`Key with id '${e}' does not exist.`);
            } catch (t) {
                throw await Sn(), t;
            }
        }
        async importKey(e, t) {
            if (!ql(e)) throw await Sn(), new _t(`Invalid key name '${e}'`);
            if (t == null) throw await Sn(), new _t("Key is required");
            const r = Aa(e);
            if (await this.components.datastore.has(r)) throw await Sn(), new _t(`Key '${e}' already exists`);
            let i, l;
            try {
                i = await Qse(t);
                const f = Bh.get(this);
                if (f == null) throw new _t("dek missing");
                const p = f.dek;
                l = await UE(t, p, t.type === "RSA" ? "pkcs-8" : "libp2p-key");
            } catch (f) {
                throw await Sn(), f;
            }
            const u = {
                name: e,
                id: i
            }, h = this.components.datastore.batch();
            return h.put(r, re(l)), h.put(Kl(e), re(JSON.stringify(u))), await h.commit(), u;
        }
        async exportKey(e) {
            if (!ql(e)) throw await Sn(), new _t(`Invalid key name '${e}'`);
            const t = Aa(e);
            try {
                const r = await this.components.datastore.get(t), s = L(r), i = Bh.get(this);
                if (i == null) throw new _t("dek missing");
                const l = i.dek;
                return await zE(s, l);
            } catch (r) {
                throw await Sn(), r;
            }
        }
        async removeKey(e) {
            if (!ql(e) || e === this.self) throw await Sn(), new _t(`Invalid key name '${e}'`);
            const t = Aa(e), r = await this.findKeyByName(e), s = this.components.datastore.batch();
            return s.delete(t), s.delete(Kl(e)), await s.commit(), r;
        }
        async listKeys() {
            const e = {
                prefix: v4
            }, t = [];
            for await (const r of this.components.datastore.query(e))t.push(JSON.parse(L(r.value)));
            return t;
        }
        async renameKey(e, t) {
            if (!ql(e) || e === this.self) throw await Sn(), new _t(`Invalid old key name '${e}'`);
            if (!ql(t) || t === this.self) throw await Sn(), new _t(`Invalid new key name '${t}'`);
            const r = Aa(e), s = Aa(t), i = Kl(e), l = Kl(t);
            if (await this.components.datastore.has(s)) throw await Sn(), new _t(`Key '${t}' already exists`);
            try {
                const h = await this.components.datastore.get(r), f = await this.components.datastore.get(i), p = JSON.parse(L(f));
                p.name = t;
                const m = this.components.datastore.batch();
                return m.put(s, h), m.put(l, re(JSON.stringify(p))), m.delete(r), m.delete(i), await m.commit(), p;
            } catch (h) {
                throw await Sn(), h;
            }
        }
        async rotateKeychainPass(e, t) {
            if (typeof e != "string") throw await Sn(), new _t(`Invalid old pass type '${typeof e}'`);
            if (typeof t != "string") throw await Sn(), new _t(`Invalid new pass type '${typeof t}'`);
            if (t.length < 20) throw await Sn(), new _t(`Invalid pass length ${t.length}`);
            this.log("recreating keychain");
            const r = Bh.get(this);
            if (r == null) throw new _t("dek missing");
            const s = r.dek;
            this.init.pass = t;
            const i = t != null && this.init.dek?.salt != null ? K9(t, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
            Bh.set(this, {
                dek: i
            });
            const l = await this.listKeys();
            for (const u of l){
                const h = await this.components.datastore.get(Aa(u.name)), f = L(h), p = await zE(f, s), m = i.toString(), w = await UE(p, m, p.type === "RSA" ? "pkcs-8" : "libp2p-key"), A = this.components.datastore.batch(), S = {
                    name: u.name,
                    id: u.id
                };
                A.put(Aa(u.name), re(w)), A.put(Kl(u.name), re(JSON.stringify(S))), await A.commit();
            }
            this.log("keychain reconstructed");
        }
    }
    function hB(n = {}) {
        return (e)=>new qse(e, n);
    }
    async function Kse(n, e = {}) {
        const t = e.selfKey ?? "self", r = hB(e)({
            datastore: n,
            logger: F6()
        });
        let s;
        return await n.has(new Nt(`/pkcs8/${t}`)) ? s = await r.exportKey(t) : (s = await E6(e.keyType ?? "Ed25519"), await r.importKey(t, s)), s;
    }
    class Gse extends Error {
        static name = "UnexpectedPeerError";
        constructor(e = "Unexpected Peer"){
            super(e), this.name = "UnexpectedPeerError";
        }
    }
    let Yse = class extends Error {
        static name = "InvalidCryptoExchangeError";
        constructor(e = "Invalid crypto exchange"){
            super(e), this.name = "InvalidCryptoExchangeError";
        }
    }, Wse = class extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    };
    const jse = Symbol.for("@libp2p/peer-id"), Xse = Symbol.for("@libp2p/service-capabilities"), Jse = Symbol.for("nodejs.util.inspect.custom"), Zse = 114;
    let _8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [jse] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Zse, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [Jse]() {
            return `PeerId(${this.toString()})`;
        }
    }, eie = class extends _8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, tie = class extends _8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, nie = class extends _8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    function VE(n) {
        if (n.type === "Ed25519") return new tie({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "secp256k1") return new nie({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "RSA") return new eie({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        throw new Wse;
    }
    var rie = {};
    const uf = 65535, HE = uf - 16, $f = !!rie?.DUMP_SESSION_KEYS, QE = 16;
    function sie(n) {
        return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array";
    }
    function E4(n) {
        if (typeof n != "boolean") throw new Error(`boolean expected, not ${n}`);
    }
    function ry(n) {
        if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
    }
    function er(n, e, t = "") {
        const r = sie(n), s = n?.length, i = e !== void 0;
        if (!r || i && s !== e) {
            const l = t && `"${t}" `, u = i ? ` of length ${e}` : "", h = r ? `length=${s}` : `type=${typeof n}`;
            throw new Error(l + "expected Uint8Array" + u + ", got " + h);
        }
        return n;
    }
    function qE(n, e = !0) {
        if (n.destroyed) throw new Error("Hash instance has been destroyed");
        if (e && n.finished) throw new Error("Hash#digest() has already been called");
    }
    function iie(n, e) {
        er(n, void 0, "output");
        const t = e.outputLen;
        if (n.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
    }
    function Vo(n) {
        return new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4));
    }
    function Hc(...n) {
        for(let e = 0; e < n.length; e++)n[e].fill(0);
    }
    function oie(n) {
        return new DataView(n.buffer, n.byteOffset, n.byteLength);
    }
    const aie = new Uint8Array(new Uint32Array([
        287454020
    ]).buffer)[0] === 68;
    function lie(n, e) {
        if (e == null || typeof e != "object") throw new Error("options must be defined");
        return Object.assign(n, e);
    }
    function cie(n, e) {
        if (n.length !== e.length) return !1;
        let t = 0;
        for(let r = 0; r < n.length; r++)t |= n[r] ^ e[r];
        return t === 0;
    }
    const uie = (n, e)=>{
        function t(r, ...s) {
            if (er(r, void 0, "key"), !aie) throw new Error("Non little-endian hardware is not yet supported");
            if (n.nonceLength !== void 0) {
                const p = s[0];
                er(p, n.varSizeNonce ? void 0 : n.nonceLength, "nonce");
            }
            const i = n.tagLength;
            i && s[1] !== void 0 && er(s[1], void 0, "AAD");
            const l = e(r, ...s), u = (p, m)=>{
                if (m !== void 0) {
                    if (p !== 2) throw new Error("cipher output not supported");
                    er(m, void 0, "output");
                }
            };
            let h = !1;
            return {
                encrypt (p, m) {
                    if (h) throw new Error("cannot encrypt() twice with same key + nonce");
                    return h = !0, er(p), u(l.encrypt.length, m), l.encrypt(p, m);
                },
                decrypt (p, m) {
                    if (er(p), i && p.length < i) throw new Error('"ciphertext" expected length bigger than tagLength=' + i);
                    return u(l.decrypt.length, m), l.decrypt(p, m);
                }
            };
        }
        return Object.assign(t, n), t;
    };
    function KE(n, e, t = !0) {
        if (e === void 0) return new Uint8Array(n);
        if (e.length !== n) throw new Error('"output" expected Uint8Array of length ' + n + ", got: " + e.length);
        if (t && !die(e)) throw new Error("invalid output, must be aligned");
        return e;
    }
    function hie(n, e, t) {
        E4(t);
        const r = new Uint8Array(16), s = oie(r);
        return s.setBigUint64(0, BigInt(e), t), s.setBigUint64(8, BigInt(n), t), r;
    }
    function die(n) {
        return n.byteOffset % 4 === 0;
    }
    function Kp(n) {
        return Uint8Array.from(n);
    }
    const dB = (n)=>Uint8Array.from(n.split(""), (e)=>e.charCodeAt(0)), fie = dB("expand 16-byte k"), pie = dB("expand 32-byte k"), gie = Vo(fie), mie = Vo(pie);
    function ot(n, e) {
        return n << e | n >>> 32 - e;
    }
    function A4(n) {
        return n.byteOffset % 4 === 0;
    }
    const R0 = 64, yie = 16, fB = 2 ** 32 - 1, GE = Uint32Array.of();
    function wie(n, e, t, r, s, i, l, u) {
        const h = s.length, f = new Uint8Array(R0), p = Vo(f), m = A4(s) && A4(i), w = m ? Vo(s) : GE, A = m ? Vo(i) : GE;
        for(let S = 0; S < h; l++){
            if (n(e, t, r, p, l, u), l >= fB) throw new Error("arx: counter overflow");
            const _ = Math.min(R0, h - S);
            if (m && _ === R0) {
                const I = S / 4;
                if (S % 4 !== 0) throw new Error("arx: invalid block position");
                for(let k = 0, G; k < yie; k++)G = I + k, A[G] = w[G] ^ p[k];
                S += R0;
                continue;
            }
            for(let I = 0, k; I < _; I++)k = S + I, i[k] = s[k] ^ f[I];
            S += _;
        }
    }
    function bie(n, e) {
        const { allowShortKeys: t, extendNonceFn: r, counterLength: s, counterRight: i, rounds: l } = lie({
            allowShortKeys: !1,
            counterLength: 8,
            counterRight: !1,
            rounds: 20
        }, e);
        if (typeof n != "function") throw new Error("core must be a function");
        return ry(s), ry(l), E4(i), E4(t), (u, h, f, p, m = 0)=>{
            er(u, void 0, "key"), er(h, void 0, "nonce"), er(f, void 0, "data");
            const w = f.length;
            if (p === void 0 && (p = new Uint8Array(w)), er(p, void 0, "output"), ry(m), m < 0 || m >= fB) throw new Error("arx: counter overflow");
            if (p.length < w) throw new Error(`arx: output (${p.length}) is shorter than data (${w})`);
            const A = [];
            let S = u.length, _, I;
            if (S === 32) A.push(_ = Kp(u)), I = mie;
            else if (S === 16 && t) _ = new Uint8Array(32), _.set(u), _.set(u, 16), I = gie, A.push(_);
            else throw er(u, 32, "arx key"), new Error("invalid key size");
            A4(h) || A.push(h = Kp(h));
            const k = Vo(_);
            if (r) {
                if (h.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
                r(I, k, Vo(h.subarray(0, 16)), k), h = h.subarray(16);
            }
            const G = 16 - s;
            if (G !== h.length) throw new Error(`arx: nonce must be ${G} or 16 bytes`);
            if (G !== 12) {
                const J = new Uint8Array(12);
                J.set(h, i ? 0 : 12 - h.length), h = J, A.push(h);
            }
            const P = Vo(h);
            return wie(n, I, k, P, f, p, m, l), Hc(...A), p;
        };
    }
    function In(n, e) {
        return n[e++] & 255 | (n[e++] & 255) << 8;
    }
    class vie {
        blockLen = 16;
        outputLen = 16;
        buffer = new Uint8Array(16);
        r = new Uint16Array(10);
        h = new Uint16Array(10);
        pad = new Uint16Array(8);
        pos = 0;
        finished = !1;
        constructor(e){
            e = Kp(er(e, 32, "key"));
            const t = In(e, 0), r = In(e, 2), s = In(e, 4), i = In(e, 6), l = In(e, 8), u = In(e, 10), h = In(e, 12), f = In(e, 14);
            this.r[0] = t & 8191, this.r[1] = (t >>> 13 | r << 3) & 8191, this.r[2] = (r >>> 10 | s << 6) & 7939, this.r[3] = (s >>> 7 | i << 9) & 8191, this.r[4] = (i >>> 4 | l << 12) & 255, this.r[5] = l >>> 1 & 8190, this.r[6] = (l >>> 14 | u << 2) & 8191, this.r[7] = (u >>> 11 | h << 5) & 8065, this.r[8] = (h >>> 8 | f << 8) & 8191, this.r[9] = f >>> 5 & 127;
            for(let p = 0; p < 8; p++)this.pad[p] = In(e, 16 + 2 * p);
        }
        process(e, t, r = !1) {
            const s = r ? 0 : 2048, { h: i, r: l } = this, u = l[0], h = l[1], f = l[2], p = l[3], m = l[4], w = l[5], A = l[6], S = l[7], _ = l[8], I = l[9], k = In(e, t + 0), G = In(e, t + 2), P = In(e, t + 4), J = In(e, t + 6), H = In(e, t + 8), F = In(e, t + 10), $ = In(e, t + 12), Y = In(e, t + 14);
            let O = i[0] + (k & 8191), se = i[1] + ((k >>> 13 | G << 3) & 8191), ae = i[2] + ((G >>> 10 | P << 6) & 8191), oe = i[3] + ((P >>> 7 | J << 9) & 8191), K = i[4] + ((J >>> 4 | H << 12) & 8191), V = i[5] + (H >>> 1 & 8191), q = i[6] + ((H >>> 14 | F << 2) & 8191), B = i[7] + ((F >>> 11 | $ << 5) & 8191), z = i[8] + (($ >>> 8 | Y << 8) & 8191), ee = i[9] + (Y >>> 5 | s), j = 0, ce = j + O * u + se * (5 * I) + ae * (5 * _) + oe * (5 * S) + K * (5 * A);
            j = ce >>> 13, ce &= 8191, ce += V * (5 * w) + q * (5 * m) + B * (5 * p) + z * (5 * f) + ee * (5 * h), j += ce >>> 13, ce &= 8191;
            let x = j + O * h + se * u + ae * (5 * I) + oe * (5 * _) + K * (5 * S);
            j = x >>> 13, x &= 8191, x += V * (5 * A) + q * (5 * w) + B * (5 * m) + z * (5 * p) + ee * (5 * f), j += x >>> 13, x &= 8191;
            let Q = j + O * f + se * h + ae * u + oe * (5 * I) + K * (5 * _);
            j = Q >>> 13, Q &= 8191, Q += V * (5 * S) + q * (5 * A) + B * (5 * w) + z * (5 * m) + ee * (5 * p), j += Q >>> 13, Q &= 8191;
            let pe = j + O * p + se * f + ae * h + oe * u + K * (5 * I);
            j = pe >>> 13, pe &= 8191, pe += V * (5 * _) + q * (5 * S) + B * (5 * A) + z * (5 * w) + ee * (5 * m), j += pe >>> 13, pe &= 8191;
            let de = j + O * m + se * p + ae * f + oe * h + K * u;
            j = de >>> 13, de &= 8191, de += V * (5 * I) + q * (5 * _) + B * (5 * S) + z * (5 * A) + ee * (5 * w), j += de >>> 13, de &= 8191;
            let me = j + O * w + se * m + ae * p + oe * f + K * h;
            j = me >>> 13, me &= 8191, me += V * u + q * (5 * I) + B * (5 * _) + z * (5 * S) + ee * (5 * A), j += me >>> 13, me &= 8191;
            let Ae = j + O * A + se * w + ae * m + oe * p + K * f;
            j = Ae >>> 13, Ae &= 8191, Ae += V * h + q * u + B * (5 * I) + z * (5 * _) + ee * (5 * S), j += Ae >>> 13, Ae &= 8191;
            let Te = j + O * S + se * A + ae * w + oe * m + K * p;
            j = Te >>> 13, Te &= 8191, Te += V * f + q * h + B * u + z * (5 * I) + ee * (5 * _), j += Te >>> 13, Te &= 8191;
            let Ve = j + O * _ + se * S + ae * A + oe * w + K * m;
            j = Ve >>> 13, Ve &= 8191, Ve += V * p + q * f + B * h + z * u + ee * (5 * I), j += Ve >>> 13, Ve &= 8191;
            let De = j + O * I + se * _ + ae * S + oe * A + K * w;
            j = De >>> 13, De &= 8191, De += V * m + q * p + B * f + z * h + ee * u, j += De >>> 13, De &= 8191, j = (j << 2) + j | 0, j = j + ce | 0, ce = j & 8191, j = j >>> 13, x += j, i[0] = ce, i[1] = x, i[2] = Q, i[3] = pe, i[4] = de, i[5] = me, i[6] = Ae, i[7] = Te, i[8] = Ve, i[9] = De;
        }
        finalize() {
            const { h: e, pad: t } = this, r = new Uint16Array(10);
            let s = e[1] >>> 13;
            e[1] &= 8191;
            for(let u = 2; u < 10; u++)e[u] += s, s = e[u] >>> 13, e[u] &= 8191;
            e[0] += s * 5, s = e[0] >>> 13, e[0] &= 8191, e[1] += s, s = e[1] >>> 13, e[1] &= 8191, e[2] += s, r[0] = e[0] + 5, s = r[0] >>> 13, r[0] &= 8191;
            for(let u = 1; u < 10; u++)r[u] = e[u] + s, s = r[u] >>> 13, r[u] &= 8191;
            r[9] -= 8192;
            let i = (s ^ 1) - 1;
            for(let u = 0; u < 10; u++)r[u] &= i;
            i = ~i;
            for(let u = 0; u < 10; u++)e[u] = e[u] & i | r[u];
            e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
            let l = e[0] + t[0];
            e[0] = l & 65535;
            for(let u = 1; u < 8; u++)l = (e[u] + t[u] | 0) + (l >>> 16) | 0, e[u] = l & 65535;
            Hc(r);
        }
        update(e) {
            qE(this), er(e), e = Kp(e);
            const { buffer: t, blockLen: r } = this, s = e.length;
            for(let i = 0; i < s;){
                const l = Math.min(r - this.pos, s - i);
                if (l === r) {
                    for(; r <= s - i; i += r)this.process(e, i);
                    continue;
                }
                t.set(e.subarray(i, i + l), this.pos), this.pos += l, i += l, this.pos === r && (this.process(t, 0, !1), this.pos = 0);
            }
            return this;
        }
        destroy() {
            Hc(this.h, this.r, this.buffer, this.pad);
        }
        digestInto(e) {
            qE(this), iie(e, this), this.finished = !0;
            const { buffer: t, h: r } = this;
            let { pos: s } = this;
            if (s) {
                for(t[s++] = 1; s < 16; s++)t[s] = 0;
                this.process(t, 0, !0);
            }
            this.finalize();
            let i = 0;
            for(let l = 0; l < 8; l++)e[i++] = r[l] >>> 0, e[i++] = r[l] >>> 8;
            return e;
        }
        digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const r = e.slice(0, t);
            return this.destroy(), r;
        }
    }
    function Eie(n) {
        const e = (r, s)=>n(s).update(r).digest(), t = n(new Uint8Array(32));
        return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (r)=>n(r), e;
    }
    const Aie = Eie((n)=>new vie(n));
    function Sie(n, e, t, r, s, i = 20) {
        let l = n[0], u = n[1], h = n[2], f = n[3], p = e[0], m = e[1], w = e[2], A = e[3], S = e[4], _ = e[5], I = e[6], k = e[7], G = s, P = t[0], J = t[1], H = t[2], F = l, $ = u, Y = h, O = f, se = p, ae = m, oe = w, K = A, V = S, q = _, B = I, z = k, ee = G, j = P, ce = J, x = H;
        for(let pe = 0; pe < i; pe += 2)F = F + se | 0, ee = ot(ee ^ F, 16), V = V + ee | 0, se = ot(se ^ V, 12), F = F + se | 0, ee = ot(ee ^ F, 8), V = V + ee | 0, se = ot(se ^ V, 7), $ = $ + ae | 0, j = ot(j ^ $, 16), q = q + j | 0, ae = ot(ae ^ q, 12), $ = $ + ae | 0, j = ot(j ^ $, 8), q = q + j | 0, ae = ot(ae ^ q, 7), Y = Y + oe | 0, ce = ot(ce ^ Y, 16), B = B + ce | 0, oe = ot(oe ^ B, 12), Y = Y + oe | 0, ce = ot(ce ^ Y, 8), B = B + ce | 0, oe = ot(oe ^ B, 7), O = O + K | 0, x = ot(x ^ O, 16), z = z + x | 0, K = ot(K ^ z, 12), O = O + K | 0, x = ot(x ^ O, 8), z = z + x | 0, K = ot(K ^ z, 7), F = F + ae | 0, x = ot(x ^ F, 16), B = B + x | 0, ae = ot(ae ^ B, 12), F = F + ae | 0, x = ot(x ^ F, 8), B = B + x | 0, ae = ot(ae ^ B, 7), $ = $ + oe | 0, ee = ot(ee ^ $, 16), z = z + ee | 0, oe = ot(oe ^ z, 12), $ = $ + oe | 0, ee = ot(ee ^ $, 8), z = z + ee | 0, oe = ot(oe ^ z, 7), Y = Y + K | 0, j = ot(j ^ Y, 16), V = V + j | 0, K = ot(K ^ V, 12), Y = Y + K | 0, j = ot(j ^ Y, 8), V = V + j | 0, K = ot(K ^ V, 7), O = O + se | 0, ce = ot(ce ^ O, 16), q = q + ce | 0, se = ot(se ^ q, 12), O = O + se | 0, ce = ot(ce ^ O, 8), q = q + ce | 0, se = ot(se ^ q, 7);
        let Q = 0;
        r[Q++] = l + F | 0, r[Q++] = u + $ | 0, r[Q++] = h + Y | 0, r[Q++] = f + O | 0, r[Q++] = p + se | 0, r[Q++] = m + ae | 0, r[Q++] = w + oe | 0, r[Q++] = A + K | 0, r[Q++] = S + V | 0, r[Q++] = _ + q | 0, r[Q++] = I + B | 0, r[Q++] = k + z | 0, r[Q++] = G + ee | 0, r[Q++] = P + j | 0, r[Q++] = J + ce | 0, r[Q++] = H + x | 0;
    }
    const Iie = bie(Sie, {
        counterRight: !1,
        counterLength: 4,
        allowShortKeys: !1
    }), Cie = new Uint8Array(16), YE = (n, e)=>{
        n.update(e);
        const t = e.length % 16;
        t && n.update(Cie.subarray(t));
    }, Tie = new Uint8Array(32);
    function WE(n, e, t, r, s) {
        s !== void 0 && er(s, void 0, "AAD");
        const i = n(e, t, Tie), l = hie(r.length, s ? s.length : 0, !0), u = Aie.create(i);
        s && YE(u, s), YE(u, r), u.update(l);
        const h = u.digest();
        return Hc(i, l), h;
    }
    const _ie = (n)=>(e, t, r)=>({
                encrypt (i, l) {
                    const u = i.length;
                    l = KE(u + 16, l, !1), l.set(i);
                    const h = l.subarray(0, -16);
                    n(e, t, h, h, 1);
                    const f = WE(n, e, t, h, r);
                    return l.set(f, u), Hc(f), l;
                },
                decrypt (i, l) {
                    l = KE(i.length - 16, l, !1);
                    const u = i.subarray(0, -16), h = i.subarray(-16), f = WE(n, e, t, u, r);
                    if (!cie(h, f)) throw new Error("invalid tag");
                    return l.set(i.subarray(0, -16)), n(e, t, l, l, 1), Hc(f), l;
                }
            }), jE = uie({
        blockSize: 64,
        nonceLength: 12,
        tagLength: 16
    }, _ie(Iie));
    function xie(n, e, t) {
        return Cf(n), t === void 0 && (t = new Uint8Array(n.outputLen)), xf(n, t, e);
    }
    const sy = Uint8Array.of(0), XE = Uint8Array.of();
    function Die(n, e, t, r = 32) {
        Cf(n), Us(r, "length");
        const s = n.outputLen;
        if (r > 255 * s) throw new Error("Length must be <= 255*HashLen");
        const i = Math.ceil(r / s);
        t === void 0 ? t = XE : Ge(t, void 0, "info");
        const l = new Uint8Array(i * s), u = xf.create(n, e), h = u._cloneInto(), f = new Uint8Array(u.outputLen);
        for(let p = 0; p < i; p++)sy[0] = p + 1, h.update(p === 0 ? XE : f).update(t).update(sy).digestInto(f), l.set(f, s * p), u._cloneInto(h);
        return u.destroy(), h.destroy(), ui(f, sy), l.slice(0, r);
    }
    const Bie = {
        hashSHA256 (n) {
            return Lo(n.subarray());
        },
        getHKDF (n, e) {
            const t = xie(Lo, e, n), s = Die(Lo, t, void 0, 96), i = s.subarray(0, 32), l = s.subarray(32, 64), u = s.subarray(64, 96);
            return [
                i,
                l,
                u
            ];
        },
        generateX25519KeyPair () {
            const n = o0.utils.randomSecretKey();
            return {
                publicKey: o0.getPublicKey(n),
                privateKey: n
            };
        },
        generateX25519KeyPairFromSeed (n) {
            return {
                publicKey: o0.getPublicKey(n),
                privateKey: n
            };
        },
        generateX25519SharedKey (n, e) {
            return o0.getSharedSecret(n.subarray(), e.subarray());
        },
        chaCha20Poly1305Encrypt (n, e, t, r) {
            return jE(r, e, t).encrypt(n.subarray());
        },
        chaCha20Poly1305Decrypt (n, e, t, r, s) {
            return jE(r, e, t).decrypt(n.subarray(), s);
        }
    }, Pie = Bie;
    function kie(n) {
        return {
            generateKeypair: n.generateX25519KeyPair,
            dh: (e, t)=>n.generateX25519SharedKey(e.privateKey, t).subarray(0, 32),
            encrypt: n.chaCha20Poly1305Encrypt,
            decrypt: n.chaCha20Poly1305Decrypt,
            hash: n.hashSHA256,
            hkdf: n.getHKDF
        };
    }
    const Gp = (n)=>{
        const e = Wn(2);
        return e[0] = n >> 8, e[1] = n, e;
    };
    Gp.bytes = 2;
    const Yp = (n)=>{
        if (n.length < 2) throw RangeError("Could not decode int16BE");
        if (n instanceof Uint8Array) {
            let e = 0;
            return e += n[0] << 8, e += n[1], e;
        }
        return n.getUint16(0);
    };
    Yp.bytes = 2;
    function Rie(n) {
        return {
            xxHandshakeSuccesses: n.registerCounter("libp2p_noise_xxhandshake_successes_total", {
                help: "Total count of noise xxHandshakes successes_"
            }),
            xxHandshakeErrors: n.registerCounter("libp2p_noise_xxhandshake_error_total", {
                help: "Total count of noise xxHandshakes errors"
            }),
            encryptedPackets: n.registerCounter("libp2p_noise_encrypted_packets_total", {
                help: "Total count of noise encrypted packets successfully"
            }),
            decryptedPackets: n.registerCounter("libp2p_noise_decrypted_packets_total", {
                help: "Total count of noise decrypted packets"
            }),
            decryptErrors: n.registerCounter("libp2p_noise_decrypt_errors_total", {
                help: "Total count of noise decrypt errors"
            })
        };
    }
    function pB(n, e) {
        !e.enabled || !$f || (n ? (e(`LOCAL_STATIC_PUBLIC_KEY ${L(n.publicKey, "hex")}`), e(`LOCAL_STATIC_PRIVATE_KEY ${L(n.privateKey, "hex")}`)) : e("Missing local static keys."));
    }
    function gB(n, e) {
        !e.enabled || !$f || (n ? (e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${L(n.publicKey, "hex")}`), e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${L(n.privateKey, "hex")}`)) : e("Missing local ephemeral keys."));
    }
    function Oie(n, e) {
        !e.enabled || !$f || e(n ? `REMOTE_STATIC_PUBLIC_KEY ${L(n.subarray(), "hex")}` : "Missing remote static public key.");
    }
    function mB(n, e) {
        !e.enabled || !$f || e(n ? `REMOTE_EPHEMERAL_PUBLIC_KEY ${L(n.subarray(), "hex")}` : "Missing remote ephemeral keys.");
    }
    function yB(n, e, t) {
        !t.enabled || !$f || (t(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k && L(n.k, "hex")}`), t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k && L(e.k, "hex")}`));
    }
    function Qc(n, e) {
        if (n.length !== e.length) throw new Error("Inputs should have the same length");
        const t = Wn(n.length);
        for(let r = 0; r < n.length; r++)t[r] = n[r] ^ e[r];
        return t;
    }
    class Id extends Error {
        code;
        constructor(e = "Invalid crypto exchange"){
            super(e), this.code = Id.code;
        }
        static code = "ERR_INVALID_CRYPTO_EXCHANGE";
    }
    const $ie = 0, Mie = 4294967295, Nie = "Cipherstate has reached maximum n, a new handshake must be performed";
    class Lie {
        n;
        bytes;
        view;
        constructor(e = $ie){
            this.n = e, this.bytes = je(12), this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength), this.view.setUint32(4, e, !0);
        }
        increment() {
            this.n++, this.view.setUint32(4, this.n, !0);
        }
        getBytes() {
            return this.bytes;
        }
        getUint64() {
            return this.n;
        }
        assertValue() {
            if (this.n > Mie) throw new Error(Nie);
        }
    }
    const Dc = je(0);
    class O0 {
        k;
        n;
        crypto;
        constructor(e, t = void 0, r = 0){
            this.crypto = e, this.k = t, this.n = new Lie(r);
        }
        hasKey() {
            return !!this.k;
        }
        encryptWithAd(e, t) {
            if (!this.hasKey()) return t;
            this.n.assertValue();
            const r = this.crypto.encrypt(t, this.n.getBytes(), e, this.k);
            return this.n.increment(), r;
        }
        decryptWithAd(e, t, r) {
            if (!this.hasKey()) return t;
            this.n.assertValue();
            const s = this.crypto.decrypt(t, this.n.getBytes(), e, this.k, r);
            return this.n.increment(), s;
        }
    }
    class Uie {
        cs;
        ck;
        h;
        crypto;
        constructor(e, t){
            this.crypto = e;
            const r = re(t, "utf-8");
            this.h = Fie(e, r), this.ck = this.h, this.cs = new O0(e);
        }
        mixKey(e) {
            const [t, r] = this.crypto.hkdf(this.ck, e);
            this.ck = t, this.cs = new O0(this.crypto, r);
        }
        mixHash(e) {
            this.h = this.crypto.hash(new Re(this.h, e));
        }
        encryptAndHash(e) {
            const t = this.cs.encryptWithAd(this.h, e);
            return this.mixHash(t), t;
        }
        decryptAndHash(e) {
            const t = this.cs.decryptWithAd(this.h, e);
            return this.mixHash(e), t;
        }
        split() {
            const [e, t] = this.crypto.hkdf(this.ck, Dc);
            return [
                new O0(this.crypto, e),
                new O0(this.crypto, t)
            ];
        }
    }
    class zie {
        ss;
        s;
        e;
        rs;
        re;
        initiator;
        crypto;
        constructor(e){
            const { crypto: t, protocolName: r, prologue: s, initiator: i, s: l, e: u, rs: h, re: f } = e;
            this.crypto = t, this.ss = new Uie(t, r), this.ss.mixHash(s), this.initiator = i, this.s = l, this.e = u, this.rs = h, this.re = f;
        }
        writeE() {
            if (this.e) throw new Error("ephemeral keypair is already set");
            const e = this.crypto.generateKeypair();
            return this.ss.mixHash(e.publicKey), this.e = e, e.publicKey;
        }
        writeS() {
            if (!this.s) throw new Error("static keypair is not set");
            return this.ss.encryptAndHash(this.s.publicKey);
        }
        writeEE() {
            if (!this.e) throw new Error("ephemeral keypair is not set");
            if (!this.re) throw new Error("remote ephemeral public key is not set");
            this.ss.mixKey(this.crypto.dh(this.e, this.re));
        }
        writeES() {
            if (this.initiator) {
                if (!this.e) throw new Error("ephemeral keypair is not set");
                if (!this.rs) throw new Error("remote static public key is not set");
                this.ss.mixKey(this.crypto.dh(this.e, this.rs));
            } else {
                if (!this.s) throw new Error("static keypair is not set");
                if (!this.re) throw new Error("remote ephemeral public key is not set");
                this.ss.mixKey(this.crypto.dh(this.s, this.re));
            }
        }
        writeSE() {
            if (this.initiator) {
                if (!this.s) throw new Error("static keypair is not set");
                if (!this.re) throw new Error("remote ephemeral public key is not set");
                this.ss.mixKey(this.crypto.dh(this.s, this.re));
            } else {
                if (!this.e) throw new Error("ephemeral keypair is not set");
                if (!this.rs) throw new Error("remote static public key is not set");
                this.ss.mixKey(this.crypto.dh(this.e, this.rs));
            }
        }
        readE(e, t = 0) {
            if (this.re) throw new Error("remote ephemeral public key is already set");
            if (e.byteLength < t + 32) throw new Error("message is not long enough");
            this.re = e.sublist(t, t + 32), this.ss.mixHash(this.re);
        }
        readS(e, t = 0) {
            if (this.rs) throw new Error("remote static public key is already set");
            const r = 32 + (this.ss.cs.hasKey() ? 16 : 0);
            if (e.byteLength < t + r) throw new Error("message is not long enough");
            const s = e.sublist(t, t + r);
            return this.rs = this.ss.decryptAndHash(s), r;
        }
        readEE() {
            this.writeEE();
        }
        readES() {
            this.writeES();
        }
        readSE() {
            this.writeSE();
        }
    }
    class wB extends zie {
        writeMessageA(e) {
            return new Re(this.writeE(), this.ss.encryptAndHash(e));
        }
        writeMessageB(e) {
            const t = this.writeE();
            this.writeEE();
            const r = this.writeS();
            return this.writeES(), new Re(t, r, this.ss.encryptAndHash(e));
        }
        writeMessageC(e) {
            const t = this.writeS();
            return this.writeSE(), new Re(t, this.ss.encryptAndHash(e));
        }
        readMessageA(e) {
            try {
                return this.readE(e), this.ss.decryptAndHash(e.sublist(32));
            } catch (t) {
                throw new Id(`handshake stage 0 validation fail: ${t.message}`);
            }
        }
        readMessageB(e) {
            try {
                this.readE(e), this.readEE();
                const t = this.readS(e, 32);
                return this.readES(), this.ss.decryptAndHash(e.sublist(32 + t));
            } catch (t) {
                throw new Id(`handshake stage 1 validation fail: ${t.message}`);
            }
        }
        readMessageC(e) {
            try {
                const t = this.readS(e);
                return this.readSE(), this.ss.decryptAndHash(e.sublist(t));
            } catch (t) {
                throw new Id(`handshake stage 2 validation fail: ${t.message}`);
            }
        }
    }
    function Fie(n, e) {
        if (e.length <= 32) {
            const t = je(32);
            return t.set(e), t;
        } else return n.hash(e);
    }
    var Wp;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.webtransportCerthashes != null) for (const i of t.webtransportCerthashes)r.uint32(10), r.bytes(i);
                if (t.streamMuxers != null) for (const i of t.streamMuxers)r.uint32(18), r.string(i);
                s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    webtransportCerthashes: [],
                    streamMuxers: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                if (s.limits?.webtransportCerthashes != null && i.webtransportCerthashes.length === s.limits.webtransportCerthashes) throw new vt('Decode error - map field "webtransportCerthashes" had too many elements');
                                i.webtransportCerthashes.push(t.bytes());
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.streamMuxers != null && i.streamMuxers.length === s.limits.streamMuxers) throw new vt('Decode error - map field "streamMuxers" had too many elements');
                                i.streamMuxers.push(t.string());
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Wp || (Wp = {}));
    var jp;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.identityKey != null && t.identityKey.byteLength > 0 && (r.uint32(10), r.bytes(t.identityKey)), t.identitySig != null && t.identitySig.byteLength > 0 && (r.uint32(18), r.bytes(t.identitySig)), t.extensions != null && (r.uint32(34), Wp.codec().encode(t.extensions, r)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    identityKey: je(0),
                    identitySig: je(0)
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.identityKey = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.identitySig = t.bytes();
                                break;
                            }
                        case 4:
                            {
                                i.extensions = Wp.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.extensions
                                });
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(jp || (jp = {}));
    async function bB(n, e, t) {
        const r = await n.sign(EB(e));
        return jp.encode({
            identityKey: Fr(n.publicKey),
            identitySig: r,
            extensions: t
        });
    }
    async function vB(n, e, t) {
        try {
            const r = jp.decode(n), s = Er(r.identityKey);
            if (t?.equals(s) === !1) throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);
            if (!e) throw new Error("Remote static does not exist");
            const i = EB(e);
            if (!await s.verify(i, r.identitySig)) throw new Error("Invalid payload signature");
            return r;
        } catch (r) {
            throw new Gse(r.message);
        }
    }
    function EB(n) {
        const e = re("noise-libp2p-static-key:");
        return n instanceof Uint8Array ? xe([
            e,
            n
        ], e.length + n.length) : (n.prepend(e), n);
    }
    class Vie extends x6 {
        stream;
        handshake;
        metrics;
        decoder;
        constructor(e, t, r){
            super({
                log: e.log,
                inactivityTimeout: e.inactivityTimeout,
                maxReadBufferLength: e.maxReadBufferLength,
                direction: e.direction
            }), this.stream = e, this.handshake = t, this.metrics = r, this.decoder = new aF({
                lengthDecoder: Yp,
                maxBufferSize: 16 * 1024 * 1024,
                encodingLength: ()=>2
            });
            const s = (h)=>{
                try {
                    for (const f of this.decoder.decode(h.data))this.onData(this.decrypt(f));
                } catch (f) {
                    this.abort(f);
                }
            };
            this.stream.addEventListener("message", s);
            const i = (h)=>{
                h.error != null ? h.local === !0 ? this.abort(h.error) : this.onRemoteReset() : this.onTransportClosed();
            };
            this.stream.addEventListener("close", i);
            const l = ()=>{
                this.safeDispatchEvent("drain");
            };
            this.stream.addEventListener("drain", l);
            const u = ()=>{
                this.onRemoteCloseWrite();
            };
            this.stream.addEventListener("remoteCloseWrite", u);
        }
        encrypt(e) {
            const t = new Re;
            for(let r = 0; r < e.byteLength; r += HE){
                let s = r + HE;
                s > e.byteLength && (s = e.byteLength);
                let i;
                e instanceof Uint8Array ? i = this.handshake.encrypt(e.subarray(r, s)) : i = this.handshake.encrypt(e.sublist(r, s)), this.metrics?.encryptedPackets.increment(), t.append(Gp(i.byteLength)), t.append(i);
            }
            return t;
        }
        decrypt(e) {
            const t = new Re;
            for(let r = 0; r < e.byteLength; r += uf){
                let s = r + uf;
                if (s > e.byteLength && (s = e.byteLength), s - QE < r) throw new Error("Invalid chunk");
                let i;
                e instanceof Uint8Array ? i = e.subarray(r, s) : i = e.sublist(r, s);
                const l = e.subarray(r, s - QE);
                try {
                    const u = this.handshake.decrypt(i, l);
                    this.metrics?.decryptedPackets.increment(), t.append(u);
                } catch (u) {
                    throw this.metrics?.decryptErrors.increment(), u;
                }
            }
            return t;
        }
        close(e) {
            return this.stream.close(e);
        }
        sendPause() {
            this.stream.pause();
        }
        sendResume() {
            this.stream.resume();
        }
        sendReset(e) {
            this.stream.abort(e);
        }
        sendData(e) {
            return {
                sentBytes: e.byteLength,
                canSendMore: this.stream.send(this.encrypt(e))
            };
        }
    }
    function JE(n, e, t) {
        return new Vie(n, e, t);
    }
    async function Hie(n, e) {
        const { log: t, connection: r, crypto: s, privateKey: i, prologue: l, s: u, remoteIdentityKey: h, extensions: f } = n, p = await bB(i, u.publicKey, f), m = new wB({
            crypto: s,
            protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
            initiator: !0,
            prologue: l,
            s: u
        });
        pB(m.s, t), t.trace("Stage 0 - Initiator starting to send first message."), await r.write(m.writeMessageA(Dc), e), t.trace("Stage 0 - Initiator finished sending first message."), gB(m.e, t), t.trace("Stage 1 - Initiator waiting to receive first message from responder...");
        const w = m.readMessageB(await r.read(e));
        t.trace("Stage 1 - Initiator received the message."), mB(m.re, t), Oie(m.rs, t), t.trace("Initiator going to check remote's signature...");
        const A = await vB(w, m.rs, h);
        t.trace("All good with the signature!"), t.trace("Stage 2 - Initiator sending third handshake message."), await r.write(m.writeMessageC(p), e), t.trace("Stage 2 - Initiator sent message with signed payload.");
        const [S, _] = m.ss.split();
        return yB(S, _, t), {
            payload: A,
            encrypt: (I)=>S.encryptWithAd(Dc, I),
            decrypt: (I, k)=>_.decryptWithAd(Dc, I, k)
        };
    }
    async function Qie(n, e) {
        const { log: t, connection: r, crypto: s, privateKey: i, prologue: l, s: u, remoteIdentityKey: h, extensions: f } = n, p = await bB(i, u.publicKey, f), m = new wB({
            crypto: s,
            protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
            initiator: !1,
            prologue: l,
            s: u
        });
        pB(m.s, t), t.trace("Stage 0 - Responder waiting to receive first message."), m.readMessageA(await r.read(e)), t.trace("Stage 0 - Responder received first message."), mB(m.re, t), t.trace("Stage 1 - Responder sending out first message with signed payload and static key."), await r.write(m.writeMessageB(p), e), t.trace("Stage 1 - Responder sent the second handshake message with signed payload."), gB(m.e, t), t.trace("Stage 2 - Responder waiting for third handshake message...");
        const w = m.readMessageC(await r.read(e));
        t.trace("Stage 2 - Responder received the message, finished handshake.");
        const A = await vB(w, m.rs, h), [S, _] = m.ss.split();
        return yB(S, _, t), {
            payload: A,
            encrypt: (I)=>_.encryptWithAd(Dc, I),
            decrypt: (I, k)=>S.decryptWithAd(Dc, I, k)
        };
    }
    class qie {
        protocol = "/noise";
        crypto;
        prologue;
        staticKey;
        extensions;
        metrics;
        components;
        log;
        constructor(e, t = {}){
            const { staticNoiseKey: r, extensions: s, crypto: i, prologueBytes: l } = t, { metrics: u } = e;
            this.components = e, this.log = e.logger.forComponent("libp2p:noise");
            const h = i ?? Pie;
            this.crypto = kie(h), this.extensions = {
                webtransportCerthashes: [],
                ...s
            }, this.metrics = u ? Rie(u) : void 0, r ? this.staticKey = h.generateX25519KeyPairFromSeed(r) : this.staticKey = h.generateX25519KeyPair(), this.prologue = l ?? je(0);
        }
        [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
        [Xse] = [
            "@libp2p/connection-encryption",
            "@chainsafe/libp2p-noise"
        ];
        async secureOutbound(e, t) {
            const r = e.log?.newScope("noise") ?? this.log, s = Vd(e, {
                lengthEncoder: Gp,
                lengthDecoder: Yp,
                maxDataLength: uf
            }), i = await this.performHandshakeInitiator(s, this.components.privateKey, r, t?.remotePeer?.publicKey, t), l = Er(i.payload.identityKey);
            return {
                connection: JE(s.unwrap(), i, this.metrics),
                remoteExtensions: i.payload.extensions,
                remotePeer: VE(l),
                streamMuxer: t?.skipStreamMuxerNegotiation === !0 ? void 0 : this.getStreamMuxer(i.payload.extensions?.streamMuxers)
            };
        }
        getStreamMuxer(e) {
            if (e == null || e.length === 0) return;
            const t = this.components.upgrader.getStreamMuxers();
            if (t != null) for (const r of e){
                const s = t.get(r);
                if (s != null) return s;
            }
            if (e.length) throw new Yse("Early muxer negotiation was requested but the initiator and responder had no common muxers");
        }
        async secureInbound(e, t) {
            const r = e.log?.newScope("noise") ?? this.log, s = Vd(e, {
                lengthEncoder: Gp,
                lengthDecoder: Yp,
                maxDataLength: uf
            }), i = await this.performHandshakeResponder(s, this.components.privateKey, r, t?.remotePeer?.publicKey, t), l = Er(i.payload.identityKey);
            return {
                connection: JE(s.unwrap(), i, this.metrics),
                remoteExtensions: i.payload.extensions,
                remotePeer: VE(l),
                streamMuxer: t?.skipStreamMuxerNegotiation === !0 ? void 0 : this.getStreamMuxer(i.payload.extensions?.streamMuxers)
            };
        }
        async performHandshakeInitiator(e, t, r, s, i) {
            let l;
            const u = i?.skipStreamMuxerNegotiation === !0 ? [] : [
                ...this.components.upgrader.getStreamMuxers().keys()
            ];
            try {
                l = await Hie({
                    connection: e,
                    privateKey: t,
                    remoteIdentityKey: s,
                    log: r.newScope("xxhandshake"),
                    crypto: this.crypto,
                    prologue: this.prologue,
                    s: this.staticKey,
                    extensions: {
                        streamMuxers: u,
                        webtransportCerthashes: [],
                        ...this.extensions
                    }
                }, i), this.metrics?.xxHandshakeSuccesses.increment();
            } catch (h) {
                throw this.metrics?.xxHandshakeErrors.increment(), h;
            }
            return l;
        }
        async performHandshakeResponder(e, t, r, s, i) {
            let l;
            const u = i?.skipStreamMuxerNegotiation === !0 ? [] : [
                ...this.components.upgrader.getStreamMuxers().keys()
            ];
            try {
                l = await Qie({
                    connection: e,
                    privateKey: t,
                    remoteIdentityKey: s,
                    log: r.newScope("xxhandshake"),
                    crypto: this.crypto,
                    prologue: this.prologue,
                    s: this.staticKey,
                    extensions: {
                        streamMuxers: u,
                        webtransportCerthashes: [],
                        ...this.extensions
                    }
                }, i), this.metrics?.xxHandshakeSuccesses.increment();
            } catch (h) {
                throw this.metrics?.xxHandshakeErrors.increment(), h;
            }
            return l;
        }
    }
    function x8(n = {}) {
        return (e)=>new qie(e, n);
    }
    let Fi = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, $0 = class extends Error {
        static name = "MuxerClosedError";
        constructor(e = "The muxer is closed"){
            super(e), this.name = "MuxerClosedError";
        }
    };
    class Kie extends Error {
        static name = "TooManyOutboundProtocolStreamsError";
        constructor(e = "Too many outbound protocol streams"){
            super(e), this.name = "TooManyOutboundProtocolStreamsError";
        }
    }
    const Gie = Symbol.for("@libp2p/service-capabilities");
    var on;
    (function(n) {
        n[n.Data = 0] = "Data", n[n.WindowUpdate = 1] = "WindowUpdate", n[n.Ping = 2] = "Ping", n[n.GoAway = 3] = "GoAway";
    })(on || (on = {}));
    var ct;
    (function(n) {
        n[n.SYN = 1] = "SYN", n[n.ACK = 2] = "ACK", n[n.FIN = 4] = "FIN", n[n.RST = 8] = "RST";
    })(ct || (ct = {}));
    Object.values(ct).filter((n)=>typeof n != "string");
    const Yie = 0;
    var Nr;
    (function(n) {
        n[n.NormalTermination = 0] = "NormalTermination", n[n.ProtocolError = 1] = "ProtocolError", n[n.InternalError = 2] = "InternalError";
    })(Nr || (Nr = {}));
    const Ma = 12;
    let $g = class extends Error {
        static name = "ProtocolError";
        reason;
        constructor(e, t){
            super(e), this.name = "ProtocolError", this.reason = t;
        }
    };
    function Wie(n) {
        return n?.reason !== null;
    }
    class ic extends $g {
        static name = "InvalidFrameError";
        constructor(e = "The frame was invalid"){
            super(e, Nr.ProtocolError), this.name = "InvalidFrameError";
        }
    }
    class jie extends $g {
        static name = "UnRequestedPingError";
        constructor(e = "Un-requested ping error"){
            super(e, Nr.ProtocolError), this.name = "UnRequestedPingError";
        }
    }
    class Xie extends $g {
        static name = "NotMatchingPingError";
        constructor(e = "Not matching ping error"){
            super(e, Nr.ProtocolError), this.name = "NotMatchingPingError";
        }
    }
    class Jie extends $g {
        static name = "ReceiveWindowExceededError";
        constructor(e = "Receive window exceeded"){
            super(e, Nr.ProtocolError), this.name = "ReceiveWindowExceededError";
        }
    }
    const AB = 256 * 1024, Zie = 16 * 1024 * 1024, M0 = {
        enableKeepAlive: !0,
        keepAliveInterval: 3e4,
        maxInboundStreams: 1e3,
        maxOutboundStreams: 1e3
    };
    function eoe(n) {
        if (n.keepAliveInterval != null && n.keepAliveInterval <= 0) throw new Fi("keep-alive interval must be positive");
        if (n.maxInboundStreams != null && n.maxInboundStreams < 0) throw new Fi("max inbound streams must be larger or equal 0");
        if (n.maxOutboundStreams != null && n.maxOutboundStreams < 0) throw new Fi("max outbound streams must be larger or equal 0");
        if (n.maxMessageSize != null && n.maxMessageSize < 1024) throw new Fi("MaxMessageSize must be greater than a kilobyte");
        if (n.streamOptions?.initialStreamWindowSize != null && n.streamOptions?.initialStreamWindowSize < AB) throw new Fi("InitialStreamWindowSize must be larger or equal 256 kB");
        if (n.streamOptions?.maxStreamWindowSize != null && n.streamOptions?.initialStreamWindowSize != null && n.streamOptions?.maxStreamWindowSize < n.streamOptions?.initialStreamWindowSize) throw new Fi("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
        if (n.streamOptions?.maxStreamWindowSize != null && n.streamOptions?.maxStreamWindowSize > 2 ** 32 - 1) throw new Fi("MaxStreamWindowSize must be less than equal MAX_UINT32");
    }
    function toe(n) {
        return n.header.type === on.Data && n.data !== null;
    }
    const ZE = 2 ** 24;
    function noe(n) {
        if (n[0] !== Yie) throw new ic("Invalid frame version");
        return {
            type: n[1],
            flag: (n[2] << 8) + n[3],
            streamID: n[4] * ZE + (n[5] << 16) + (n[6] << 8) + n[7],
            length: n[8] * ZE + (n[9] << 16) + (n[10] << 8) + n[11]
        };
    }
    let roe = class {
        buffer;
        constructor(){
            this.buffer = new Re;
        }
        *emitFrames(e) {
            for(this.buffer.append(e);;){
                const t = this.readFrame();
                if (t === void 0) break;
                yield t;
            }
        }
        readFrame() {
            let e = Ma;
            if (this.buffer.byteLength < Ma) return;
            const t = noe(this.buffer.subarray(0, Ma));
            if (t.type === on.Data) {
                if (e += t.length, this.buffer.byteLength < e) return;
                const r = this.buffer.sublist(Ma, e);
                return this.buffer.consume(e), {
                    header: t,
                    data: r
                };
            }
            return this.buffer.consume(e), {
                header: t
            };
        }
    };
    function eA(n) {
        const e = new Uint8Array(Ma);
        return e[1] = n.type, e[2] = n.flag >>> 8, e[3] = n.flag, e[4] = n.streamID >>> 24, e[5] = n.streamID >>> 16, e[6] = n.streamID >>> 8, e[7] = n.streamID, e[8] = n.length >>> 24, e[9] = n.length >>> 16, e[10] = n.length >>> 8, e[11] = n.length, e;
    }
    var mr;
    (function(n) {
        n[n.Init = 0] = "Init", n[n.SYNSent = 1] = "SYNSent", n[n.SYNReceived = 2] = "SYNReceived", n[n.Established = 3] = "Established", n[n.Finished = 4] = "Finished", n[n.Paused = 5] = "Paused";
    })(mr || (mr = {}));
    class soe extends P6 {
        streamId;
        state;
        sendWindowCapacity;
        recvWindow;
        recvWindowCapacity;
        maxStreamWindowSize;
        epochStart;
        getRTT;
        sendFrame;
        constructor(e){
            const t = e.initialStreamWindowSize ?? AB;
            super({
                ...e,
                maxMessageSize: t - Ma
            }), this.streamId = e.streamId, this.state = e.state, this.sendWindowCapacity = t, this.recvWindow = t, this.recvWindowCapacity = this.recvWindow, this.maxStreamWindowSize = e.maxStreamWindowSize ?? Zie, this.epochStart = Date.now(), this.getRTT = e.getRTT, this.sendFrame = e.sendFrame;
            const r = ()=>{
                this.state = mr.Finished;
            };
            this.addEventListener("close", r);
        }
        sendData(e) {
            const t = e.byteLength;
            let r = 0, s = !0;
            for(this.log?.trace("send window capacity is %d bytes", this.sendWindowCapacity); e.byteLength > 0;){
                if (this.sendWindowCapacity === 0) {
                    s = !1, this.log?.trace("sent %d/%d bytes, exhausted send window, waiting for window update", r, t);
                    break;
                }
                const i = Math.min(this.sendWindowCapacity, e.byteLength), l = this.getSendFlags(), u = e.sublist(0, i);
                e.consume(i);
                const h = this.sendFrame({
                    type: on.Data,
                    flag: l,
                    streamID: this.streamId,
                    length: i
                }, u);
                if (this.sendWindowCapacity -= i, r += i, !h) {
                    s = h, this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity", r, t);
                    break;
                }
            }
            return {
                sentBytes: r,
                canSendMore: s
            };
        }
        sendReset() {
            this.sendFrame({
                type: on.WindowUpdate,
                flag: ct.RST,
                streamID: this.streamId,
                length: 0
            });
        }
        async sendCloseWrite() {
            const e = this.getSendFlags() | ct.FIN;
            this.sendFrame({
                type: on.WindowUpdate,
                flag: e,
                streamID: this.streamId,
                length: 0
            });
        }
        async sendCloseRead(e) {
            e?.signal?.throwIfAborted();
        }
        sendPause() {
            this.state = mr.Paused;
        }
        sendResume() {
            this.state = mr.Established, this.sendWindowUpdate();
        }
        handleWindowUpdate(e) {
            this.processFlags(e.header.flag), this.sendWindowCapacity += e.header.length, this.maxMessageSize = this.sendWindowCapacity - Ma, this.maxMessageSize < 0 && (this.maxMessageSize = 0), this.maxMessageSize !== 0 && this.writeBuffer.byteLength > 0 && (this.log?.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s", e.header.length, this.writeBuffer.byteLength, this.sendingData), this.safeDispatchEvent("drain"));
        }
        handleData(e) {
            if (!toe(e)) throw new ic("Frame was not data frame");
            if (this.processFlags(e.header.flag), this.recvWindowCapacity < e.header.length) throw new Jie("Receive window exceeded");
            this.recvWindowCapacity -= e.header.length, this.onData(e.data), this.sendWindowUpdate();
        }
        processFlags(e) {
            (e & ct.ACK) === ct.ACK && this.state === mr.SYNSent && (this.state = mr.Established), (e & ct.FIN) === ct.FIN && this.onRemoteCloseWrite(), (e & ct.RST) === ct.RST && this.onRemoteReset();
        }
        getSendFlags() {
            switch(this.state){
                case mr.Init:
                    return this.state = mr.SYNSent, ct.SYN;
                case mr.SYNReceived:
                    return this.state = mr.Established, ct.ACK;
                default:
                    return 0;
            }
        }
        sendWindowUpdate() {
            if (this.state === mr.Paused) {
                this.epochStart = Date.now();
                return;
            }
            const e = this.getSendFlags(), t = Date.now(), r = this.getRTT();
            if (e === 0 && r > -1 && t - this.epochStart <= r * 4 && (this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize)), this.recvWindowCapacity >= this.recvWindow && e === 0) return;
            const s = this.recvWindow - this.recvWindowCapacity;
            this.recvWindowCapacity = this.recvWindow, this.epochStart = t, this.sendFrame({
                type: on.WindowUpdate,
                flag: e,
                streamID: this.streamId,
                length: s
            });
        }
    }
    function tA(n) {
        return {
            type: on[n.type],
            flags: [
                (n.flag & ct.SYN) === ct.SYN ? "SYN" : void 0,
                (n.flag & ct.ACK) === ct.ACK ? "ACK" : void 0,
                (n.flag & ct.FIN) === ct.FIN ? "FIN" : void 0,
                (n.flag & ct.RST) === ct.RST ? "RST" : void 0
            ].filter(Boolean),
            streamID: n.streamID,
            length: n.length
        };
    }
    const SB = "/yamux/1.0.0";
    class ioe {
        protocol = SB;
        _init;
        constructor(e = {}){
            this._init = e;
        }
        [Symbol.toStringTag] = "@chainsafe/libp2p-yamux";
        [Gie] = [
            "@libp2p/stream-multiplexing"
        ];
        createStreamMuxer(e) {
            return new ooe(e, {
                ...this._init
            });
        }
    }
    class ooe extends B6 {
        nextStreamID;
        nextPingID;
        activePing;
        rtt;
        client;
        localGoAway;
        remoteGoAway;
        numInboundStreams;
        numOutboundStreams;
        decoder;
        keepAlive;
        enableKeepAlive;
        keepAliveInterval;
        maxInboundStreams;
        maxOutboundStreams;
        constructor(e, t = {}){
            super(e, {
                ...t,
                protocol: SB,
                name: "yamux"
            }), this.client = e.direction === "outbound", eoe(t), this.enableKeepAlive = t.enableKeepAlive ?? M0.enableKeepAlive, this.keepAliveInterval = t.keepAliveInterval ?? M0.keepAliveInterval, this.maxInboundStreams = t.maxInboundStreams ?? M0.maxInboundStreams, this.maxOutboundStreams = t.maxOutboundStreams ?? M0.maxOutboundStreams, this.decoder = new roe, this.numInboundStreams = 0, this.numOutboundStreams = 0, this.nextStreamID = this.client ? 1 : 2, this.nextPingID = 0, this.rtt = -1, this.log.trace("muxer created"), this.enableKeepAlive && (this.log.trace("muxer keepalive enabled interval=%s", this.keepAliveInterval), this.keepAlive = V6(async (r)=>{
                try {
                    await this.ping(r);
                } catch (s) {
                    this.log.error("ping error: %s", s);
                }
            }, this.keepAliveInterval, {
                runImmediately: !0
            }), this.keepAlive.start());
        }
        onData(e) {
            for (const t of this.decoder.emitFrames(e))this.handleFrame(t);
        }
        onCreateStream() {
            if (this.remoteGoAway !== void 0) throw new $0("Muxer closed remotely");
            if (this.localGoAway !== void 0) throw new $0("Muxer closed locally");
            const e = this.nextStreamID;
            if (this.nextStreamID += 2, this.numOutboundStreams >= this.maxOutboundStreams) throw new Kie("max outbound streams exceeded");
            this.log.trace("new outgoing stream id=%s", e);
            const t = this._newStream(e, mr.Init, "outbound");
            return this.numOutboundStreams++, queueMicrotask(()=>{
                t.sendWindowUpdate();
            }), t;
        }
        async ping(e) {
            if (this.remoteGoAway !== void 0) throw new $0("Muxer closed remotely");
            if (this.localGoAway !== void 0) throw new $0("Muxer closed locally");
            if (this.activePing != null) return Xn(this.activePing.promise, e?.signal);
            this.activePing = Object.assign(Promise.withResolvers(), {
                id: this.nextPingID++,
                start: Date.now()
            }), this.sendPing(this.activePing.id);
            try {
                this.rtt = await Xn(this.activePing.promise, e?.signal);
            } finally{
                this.activePing = void 0;
            }
            return this.rtt;
        }
        getRTT() {
            return this.rtt;
        }
        async close(e = {}) {
            if (this.status === "open") try {
                const t = e?.reason ?? Nr.NormalTermination;
                this.log.trace("muxer close reason=%s", Nr[t]), await super.close(e), this.sendGoAway(t);
            } finally{
                this.keepAlive?.stop();
            }
        }
        abort(e) {
            if (this.status === "open") try {
                super.abort(e);
                let t = Nr.InternalError;
                Wie(e) && (t = e.reason), this.log.error("muxer abort reason=%s error=%s", t, e), this.sendGoAway(t);
            } finally{
                this.keepAlive?.stop();
            }
        }
        onTransportClosed() {
            try {
                super.onTransportClosed();
            } finally{
                this.keepAlive?.stop();
            }
        }
        _newStream(e, t, r) {
            if (this.streams.find((i)=>i.streamId === e) != null) throw new Fi("Stream already exists with that id");
            const s = new soe({
                ...this.streamOptions,
                id: `${e}`,
                streamId: e,
                state: t,
                direction: r,
                sendFrame: this.sendFrame.bind(this),
                log: this.log.newScope(`${r}:${e}`),
                getRTT: this.getRTT.bind(this)
            });
            return s.addEventListener("close", ()=>{
                this.closeStream(e);
            }, {
                once: !0
            }), s;
        }
        closeStream(e) {
            this.client === (e % 2 === 0) ? this.numInboundStreams-- : this.numOutboundStreams--;
        }
        handleFrame(e) {
            const { streamID: t, type: r, length: s } = e.header;
            if (this.log.trace("received frame %o", tA(e.header)), t === 0) switch(r){
                case on.Ping:
                    {
                        this.handlePing(e.header);
                        return;
                    }
                case on.GoAway:
                    {
                        this.handleGoAway(s);
                        return;
                    }
                default:
                    throw new ic("Invalid frame type");
            }
            else switch(e.header.type){
                case on.Data:
                case on.WindowUpdate:
                    {
                        this.handleStreamMessage(e);
                        return;
                    }
                default:
                    throw new ic("Invalid frame type");
            }
        }
        handlePing(e) {
            if (e.flag === ct.SYN) this.log.trace("received ping request pingId=%s", e.length), this.sendPing(e.length, ct.ACK);
            else if (e.flag === ct.ACK) this.log.trace("received ping response pingId=%s", e.length), this.handlePingResponse(e.length);
            else throw new ic("Invalid frame flag");
        }
        handlePingResponse(e) {
            if (this.activePing === void 0) throw new jie("ping not requested");
            if (this.activePing.id !== e) throw new Xie("ping doesn't match our id");
            this.activePing.resolve(Date.now() - this.activePing.start);
        }
        handleGoAway(e) {
            this.log.trace("received GoAway reason=%s", Nr[e] ?? "unknown"), this.remoteGoAway = e, e === Nr.NormalTermination ? this.onTransportClosed() : this.abort(new Error("Remote sent GoAway"));
        }
        handleStreamMessage(e) {
            const { streamID: t, flag: r, type: s } = e.header;
            (r & ct.SYN) === ct.SYN && this.incomingStream(t);
            const i = this.streams.find((l)=>l.streamId === t);
            if (i === void 0) {
                this.log.trace("frame for missing stream id=%s", t);
                return;
            }
            switch(s){
                case on.WindowUpdate:
                    {
                        i.handleWindowUpdate(e);
                        return;
                    }
                case on.Data:
                    {
                        i.handleData(e);
                        return;
                    }
                default:
                    throw new Error("unreachable");
            }
        }
        incomingStream(e) {
            if (this.client !== (e % 2 === 0)) throw new Fi("Both endpoints are clients");
            if (this.streams.find((r)=>r.streamId === e)) return;
            if (this.log.trace("new incoming stream id=%s", e), this.localGoAway !== void 0) {
                this.sendFrame({
                    type: on.WindowUpdate,
                    flag: ct.RST,
                    streamID: e,
                    length: 0
                });
                return;
            }
            if (this.numInboundStreams >= this.maxInboundStreams) {
                this.log("maxIncomingStreams exceeded, forcing stream reset"), this.sendFrame({
                    type: on.WindowUpdate,
                    flag: ct.RST,
                    streamID: e,
                    length: 0
                });
                return;
            }
            const t = this._newStream(e, mr.SYNReceived, "inbound");
            this.numInboundStreams++, this.onRemoteStream(t);
        }
        sendFrame(e, t) {
            let r;
            if (e.type === on.Data) {
                if (t == null) throw new ic("Invalid frame");
                r = new Re(eA(e), t);
            } else r = eA(e);
            return this.log.trace("sending frame %o", tA(e)), this.send(r);
        }
        sendPing(e, t = ct.SYN) {
            t === ct.SYN ? this.log.trace("sending ping request pingId=%s", e) : this.log.trace("sending ping response pingId=%s", e), this.sendFrame({
                type: on.Ping,
                flag: t,
                streamID: 0,
                length: e
            });
        }
        sendGoAway(e = Nr.NormalTermination) {
            this.log("sending GoAway reason=%s", Nr[e]), this.localGoAway = e, this.sendFrame({
                type: on.GoAway,
                flag: 0,
                streamID: 0,
                length: e
            });
        }
    }
    function IB(n = {}) {
        return ()=>new ioe(n);
    }
    let aoe = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, loe = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const CB = Symbol.for("@libp2p/peer-id"), coe = Symbol.for("@libp2p/service-capabilities"), uoe = Symbol.for("@libp2p/service-dependencies"), TB = Symbol.for("nodejs.util.inspect.custom"), hoe = 114;
    let D8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [CB] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(hoe, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [TB]() {
            return `PeerId(${this.toString()})`;
        }
    }, doe = class extends D8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, foe = class extends D8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, poe = class extends D8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const goe = 2336;
    let moe = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [TB]() {
            return `PeerId(${this.url})`;
        }
        [CB] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(goe, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    function _B(n) {
        if (woe(n)) return new doe({
            multihash: n
        });
        if (yoe(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new foe({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new poe({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new moe(new URL(t));
        }
        throw new loe("Supplied PeerID Multihash is invalid");
    }
    function yoe(n) {
        return n.code === nt.code;
    }
    function woe(n) {
        return n.code === Ut.code;
    }
    function nA(n, e) {
        const t = {
            [Symbol.iterator]: ()=>t,
            next: ()=>{
                const r = n.next(), s = r.value;
                return r.done === !0 || s == null ? {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: e(s)
                };
            }
        };
        return t;
    }
    function iy(n) {
        const e = kt(He.decode(`z${n}`));
        return _B(e);
    }
    let boe = class cp {
        set;
        constructor(e){
            if (this.set = new Set, e != null) for (const t of e)this.set.add(t.toString());
        }
        get size() {
            return this.set.size;
        }
        [Symbol.iterator]() {
            return this.values();
        }
        add(e) {
            this.set.add(e.toString());
        }
        clear() {
            this.set.clear();
        }
        delete(e) {
            this.set.delete(e.toString());
        }
        entries() {
            return nA(this.set.entries(), (e)=>{
                const t = iy(e[0]);
                return [
                    t,
                    t
                ];
            });
        }
        forEach(e) {
            this.set.forEach((t)=>{
                const r = iy(t);
                e(r, r, this);
            });
        }
        has(e) {
            return this.set.has(e.toString());
        }
        values() {
            return nA(this.set.values(), (e)=>iy(e));
        }
        intersection(e) {
            const t = new cp;
            for (const r of e)this.has(r) && t.add(r);
            return t;
        }
        difference(e) {
            const t = new cp;
            for (const r of this)e.has(r) || t.add(r);
            return t;
        }
        union(e) {
            const t = new cp;
            for (const r of e)t.add(r);
            for (const r of this)t.add(r);
            return t;
        }
    };
    function voe() {
        return new boe;
    }
    let ps = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, hf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, Eoe = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, Aoe = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const Soe = 4, Ioe = 6, Coe = 273, Toe = 33, _oe = 41, xoe = 42, Doe = 43, Boe = 53, Poe = 54, koe = 55, Roe = 56, Ooe = 132, $oe = 301, Moe = 302, Noe = 400, S4 = 421, Loe = 444, Uoe = 445, zoe = 446, Foe = 447, Voe = 448, Hoe = 449, Qoe = 454, qoe = 460, Koe = 461, Goe = 465, Yoe = 466, Woe = 480, joe = 481, Xoe = 443, Joe = 477, Zoe = 478, eae = 479, tae = 277, nae = 275, rae = 276, sae = 280, iae = 281, oae = 290, aae = 777;
    function rA(n) {
        return (e)=>L(e, n);
    }
    function sA(n) {
        return (e)=>re(e, n);
    }
    function Xh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function oc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function lae(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = oc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function cae(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = oc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function iA(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Xh(t);
        return `${r}:${s}`;
    }
    const xB = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new ps("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, uae = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = xB(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new ps("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, hae = function(n) {
        if (n.byteLength !== 4) throw new ps("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, dae = function(n) {
        if (n.byteLength !== 16) throw new ps("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new ps(`Invalid IPv6 address "${t}"`);
        }
    };
    function fae(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new ps(`Invalid IPv6 address "${n}"`);
        }
    }
    const oy = Object.values(un).map((n)=>n.decoder), pae = (function() {
        let n = oy[0].or(oy[1]);
        return oy.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function gae(n) {
        return pae.decode(n);
    }
    function mae(n) {
        return (e)=>n.encoder.encode(e);
    }
    function yae(n) {
        if (parseInt(n).toString() !== n) throw new hf("Value must be an integer");
    }
    function wae(n) {
        if (n < 0) throw new hf("Value must be a positive integer, or zero");
    }
    function bae(n) {
        return (e)=>{
            if (e > n) throw new hf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function vae(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const N0 = vae(yae, wae, bae(65535)), Nn = -1;
    let Eae = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new Aoe(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const gu = new Eae, Aae = [
        {
            code: Soe,
            name: "ip4",
            size: 32,
            valueToBytes: xB,
            bytesToValue: hae,
            validate: (n)=>{
                if (!Je(n)) throw new hf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: Ioe,
            name: "tcp",
            size: 16,
            valueToBytes: oc,
            bytesToValue: Xh,
            validate: N0
        },
        {
            code: Coe,
            name: "udp",
            size: 16,
            valueToBytes: oc,
            bytesToValue: Xh,
            validate: N0
        },
        {
            code: Toe,
            name: "dccp",
            size: 16,
            valueToBytes: oc,
            bytesToValue: Xh,
            validate: N0
        },
        {
            code: _oe,
            name: "ip6",
            size: 128,
            valueToBytes: uae,
            bytesToValue: dae,
            stringToValue: fae,
            validate: (n)=>{
                if (!xn(n)) throw new hf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: xoe,
            name: "ip6zone",
            size: Nn
        },
        {
            code: Doe,
            name: "ipcidr",
            size: 8,
            bytesToValue: rA("base10"),
            valueToBytes: sA("base10")
        },
        {
            code: Boe,
            name: "dns",
            size: Nn
        },
        {
            code: Poe,
            name: "dns4",
            size: Nn
        },
        {
            code: koe,
            name: "dns6",
            size: Nn
        },
        {
            code: Roe,
            name: "dnsaddr",
            size: Nn
        },
        {
            code: Ooe,
            name: "sctp",
            size: 16,
            valueToBytes: oc,
            bytesToValue: Xh,
            validate: N0
        },
        {
            code: $oe,
            name: "udt"
        },
        {
            code: Moe,
            name: "utp"
        },
        {
            code: Noe,
            name: "unix",
            size: Nn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: S4,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Nn,
            bytesToValue: rA("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? sA("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: Loe,
            name: "onion",
            size: 96,
            bytesToValue: iA,
            valueToBytes: lae
        },
        {
            code: Uoe,
            name: "onion3",
            size: 296,
            bytesToValue: iA,
            valueToBytes: cae
        },
        {
            code: zoe,
            name: "garlic64",
            size: Nn
        },
        {
            code: Foe,
            name: "garlic32",
            size: Nn
        },
        {
            code: Voe,
            name: "tls"
        },
        {
            code: Hoe,
            name: "sni",
            size: Nn
        },
        {
            code: Qoe,
            name: "noise"
        },
        {
            code: qoe,
            name: "quic"
        },
        {
            code: Koe,
            name: "quic-v1"
        },
        {
            code: Goe,
            name: "webtransport"
        },
        {
            code: Yoe,
            name: "certhash",
            size: Nn,
            bytesToValue: mae(yn),
            valueToBytes: gae
        },
        {
            code: Woe,
            name: "http"
        },
        {
            code: joe,
            name: "http-path",
            size: Nn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Xoe,
            name: "https"
        },
        {
            code: Joe,
            name: "ws"
        },
        {
            code: Zoe,
            name: "wss"
        },
        {
            code: eae,
            name: "p2p-websocket-star"
        },
        {
            code: tae,
            name: "p2p-stardust"
        },
        {
            code: nae,
            name: "p2p-webrtc-star"
        },
        {
            code: rae,
            name: "p2p-webrtc-direct"
        },
        {
            code: sae,
            name: "webrtc-direct"
        },
        {
            code: iae,
            name: "webrtc"
        },
        {
            code: oae,
            name: "p2p-circuit"
        },
        {
            code: aae,
            name: "memory",
            size: Nn
        }
    ];
    Aae.forEach((n)=>{
        gu.addProtocol(n);
    });
    function Sae(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = gu.getProtocol(r), i = be(r), l = _ae(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Nn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function Iae(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = gu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Nn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Nn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function Cae(n) {
        if (n.charAt(0) !== "/") throw new ps('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = gu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new ps(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new ps(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new ps("Incomplete multiaddr");
        return e;
    }
    function Tae(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = gu.getProtocol(e.code);
            if (t == null) throw new ps(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function _ae(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const xae = Symbol.for("nodejs.util.inspect.custom"), DB = Symbol.for("@multiformats/multiaddr");
    function Dae(n) {
        if (n == null && (n = "/"), kae(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Sae(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), Cae(n);
        if (Array.isArray(n)) return n;
        throw new ps("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let Bae = class Jh {
        [DB] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = Dae(e), t.validate !== !1 && Pae(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = Iae(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = Tae(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new Jh(e);
            return new Jh([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new Eoe(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new Jh(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new Jh(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [xae]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function Pae(n) {
        n.getComponents().forEach((e)=>{
            const t = gu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function kae(n) {
        return !!n?.[DB];
    }
    function Rae(n) {
        return new Bae(n);
    }
    const Oae = "libp2p", $ae = "autonat", Mae = "1.0.0", Nae = 3e4, Lae = 2, Uae = 20, zae = 80, Fae = 8192;
    var Vt;
    (function(n) {
        (function(s) {
            s.DIAL = "DIAL", s.DIAL_RESPONSE = "DIAL_RESPONSE";
        })(n.MessageType || (n.MessageType = {}));
        let e;
        (function(s) {
            s[s.DIAL = 0] = "DIAL", s[s.DIAL_RESPONSE = 1] = "DIAL_RESPONSE";
        })(e || (e = {})), (function(s) {
            s.codec = ()=>vr(e);
        })(n.MessageType || (n.MessageType = {})), (function(s) {
            s.OK = "OK", s.E_DIAL_ERROR = "E_DIAL_ERROR", s.E_DIAL_REFUSED = "E_DIAL_REFUSED", s.E_BAD_REQUEST = "E_BAD_REQUEST", s.E_INTERNAL_ERROR = "E_INTERNAL_ERROR";
        })(n.ResponseStatus || (n.ResponseStatus = {}));
        let t;
        (function(s) {
            s[s.OK = 0] = "OK", s[s.E_DIAL_ERROR = 100] = "E_DIAL_ERROR", s[s.E_DIAL_REFUSED = 101] = "E_DIAL_REFUSED", s[s.E_BAD_REQUEST = 200] = "E_BAD_REQUEST", s[s.E_INTERNAL_ERROR = 300] = "E_INTERNAL_ERROR";
        })(t || (t = {})), (function(s) {
            s.codec = ()=>vr(t);
        })(n.ResponseStatus || (n.ResponseStatus = {})), (function(s) {
            let i;
            s.codec = ()=>(i == null && (i = Le((l, u, h = {})=>{
                    if (h.lengthDelimited !== !1 && u.fork(), l.id != null && (u.uint32(10), u.bytes(l.id)), l.addrs != null) for (const f of l.addrs)u.uint32(18), u.bytes(f);
                    h.lengthDelimited !== !1 && u.ldelim();
                }, (l, u, h = {})=>{
                    const f = {
                        addrs: []
                    }, p = u == null ? l.len : l.pos + u;
                    for(; l.pos < p;){
                        const m = l.uint32();
                        switch(m >>> 3){
                            case 1:
                                {
                                    f.id = l.bytes();
                                    break;
                                }
                            case 2:
                                {
                                    if (h.limits?.addrs != null && f.addrs.length === h.limits.addrs) throw new vt('Decode error - map field "addrs" had too many elements');
                                    f.addrs.push(l.bytes());
                                    break;
                                }
                            default:
                                {
                                    l.skipType(m & 7);
                                    break;
                                }
                        }
                    }
                    return f;
                })), i), s.encode = (l)=>Ne(l, s.codec()), s.decode = (l, u)=>Me(l, s.codec(), u);
        })(n.PeerInfo || (n.PeerInfo = {})), (function(s) {
            let i;
            s.codec = ()=>(i == null && (i = Le((l, u, h = {})=>{
                    h.lengthDelimited !== !1 && u.fork(), l.peer != null && (u.uint32(10), n.PeerInfo.codec().encode(l.peer, u)), h.lengthDelimited !== !1 && u.ldelim();
                }, (l, u, h = {})=>{
                    const f = {}, p = u == null ? l.len : l.pos + u;
                    for(; l.pos < p;){
                        const m = l.uint32();
                        m >>> 3 === 1 ? f.peer = n.PeerInfo.codec().decode(l, l.uint32(), {
                            limits: h.limits?.peer
                        }) : l.skipType(m & 7);
                    }
                    return f;
                })), i), s.encode = (l)=>Ne(l, s.codec()), s.decode = (l, u)=>Me(l, s.codec(), u);
        })(n.Dial || (n.Dial = {})), (function(s) {
            let i;
            s.codec = ()=>(i == null && (i = Le((l, u, h = {})=>{
                    h.lengthDelimited !== !1 && u.fork(), l.status != null && (u.uint32(8), n.ResponseStatus.codec().encode(l.status, u)), l.statusText != null && (u.uint32(18), u.string(l.statusText)), l.addr != null && (u.uint32(26), u.bytes(l.addr)), h.lengthDelimited !== !1 && u.ldelim();
                }, (l, u, h = {})=>{
                    const f = {}, p = u == null ? l.len : l.pos + u;
                    for(; l.pos < p;){
                        const m = l.uint32();
                        switch(m >>> 3){
                            case 1:
                                {
                                    f.status = n.ResponseStatus.codec().decode(l);
                                    break;
                                }
                            case 2:
                                {
                                    f.statusText = l.string();
                                    break;
                                }
                            case 3:
                                {
                                    f.addr = l.bytes();
                                    break;
                                }
                            default:
                                {
                                    l.skipType(m & 7);
                                    break;
                                }
                        }
                    }
                    return f;
                })), i), s.encode = (l)=>Ne(l, s.codec()), s.decode = (l, u)=>Me(l, s.codec(), u);
        })(n.DialResponse || (n.DialResponse = {}));
        let r;
        n.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                l.lengthDelimited !== !1 && i.fork(), s.type != null && (i.uint32(8), n.MessageType.codec().encode(s.type, i)), s.dial != null && (i.uint32(18), n.Dial.codec().encode(s.dial, i)), s.dialResponse != null && (i.uint32(26), n.DialResponse.codec().encode(s.dialResponse, i)), l.lengthDelimited !== !1 && i.ldelim();
            }, (s, i, l = {})=>{
                const u = {}, h = i == null ? s.len : s.pos + i;
                for(; s.pos < h;){
                    const f = s.uint32();
                    switch(f >>> 3){
                        case 1:
                            {
                                u.type = n.MessageType.codec().decode(s);
                                break;
                            }
                        case 2:
                            {
                                u.dial = n.Dial.codec().decode(s, s.uint32(), {
                                    limits: l.limits?.dial
                                });
                                break;
                            }
                        case 3:
                            {
                                u.dialResponse = n.DialResponse.codec().decode(s, s.uint32(), {
                                    limits: l.limits?.dialResponse
                                });
                                break;
                            }
                        default:
                            {
                                s.skipType(f & 7);
                                break;
                            }
                    }
                }
                return u;
            })), r), n.encode = (s)=>Ne(s, n.codec()), n.decode = (s, i)=>Me(s, n.codec(), i);
    })(Vt || (Vt = {}));
    const Vae = 4, Hae = 8;
    class Qae {
        components;
        protocol;
        timeout;
        maxInboundStreams;
        maxOutboundStreams;
        maxMessageSize;
        started;
        log;
        topologyId;
        dialResults;
        findPeers;
        addressFilter;
        connectionThreshold;
        constructor(e, t){
            this.components = e, this.log = e.logger.forComponent("libp2p:auto-nat"), this.started = !1, this.protocol = `/${t.protocolPrefix ?? Oae}/${$ae}/${Mae}`, this.timeout = t.timeout ?? Nae, this.maxInboundStreams = t.maxInboundStreams ?? Lae, this.maxOutboundStreams = t.maxOutboundStreams ?? Uae, this.connectionThreshold = t.connectionThreshold ?? zae, this.maxMessageSize = t.maxMessageSize ?? Fae, this.dialResults = Qs({
                name: "libp2p_autonat_dial_results",
                metrics: e.metrics
            }), this.findPeers = V6(this.findRandomPeers.bind(this), 6e4), this.addressFilter = Wi(1024);
        }
        [Symbol.toStringTag] = "@libp2p/autonat";
        [coe] = [
            "@libp2p/autonat"
        ];
        get [uoe]() {
            return [
                "@libp2p/identify"
            ];
        }
        isStarted() {
            return this.started;
        }
        async start() {
            this.started || (await this.components.registrar.handle(this.protocol, (e, t)=>{
                this.handleIncomingAutonatStream(e, t).catch((r)=>{
                    this.log.error("error handling incoming autonat stream - %e", r);
                });
            }, {
                maxInboundStreams: this.maxInboundStreams,
                maxOutboundStreams: this.maxOutboundStreams
            }), this.topologyId = await this.components.registrar.register(this.protocol, {
                onConnect: (e, t)=>{
                    this.verifyExternalAddresses(t).catch((r)=>{
                        this.log.error("could not verify addresses - %e", r);
                    });
                }
            }), this.findPeers.start(), this.started = !0);
        }
        async stop() {
            await this.components.registrar.unhandle(this.protocol), this.topologyId != null && await this.components.registrar.unhandle(this.topologyId), this.dialResults.clear(), this.findPeers.stop(), this.started = !1;
        }
        allAddressesAreVerified() {
            return this.components.addressManager.getAddressesWithMetadata().every((e)=>e.expires > Date.now() ? !0 : e.verified);
        }
        async findRandomPeers(e) {
            if (this.allAddressesAreVerified()) return;
            const t = gt([
                AbortSignal.timeout(1e4),
                e?.signal
            ]);
            try {
                this.log("starting random walk to find peers to run AutoNAT");
                for await (const r of this.components.randomWalk.walk({
                    signal: t
                })){
                    if (!await this.components.connectionManager.isDialable(r.multiaddrs)) {
                        this.log.trace("random peer %p was not dialable %s", r.id, r.multiaddrs.map((s)=>s.toString()).join(", "));
                        continue;
                    }
                    try {
                        this.log.trace("dial random peer %p", r.id), await this.components.connectionManager.openConnection(r.multiaddrs, {
                            signal: t
                        });
                    } catch  {}
                    if (this.allAddressesAreVerified()) {
                        this.log("stopping random walk, all addresses are verified");
                        return;
                    }
                    if (!this.hasConnectionCapacity()) {
                        this.log("stopping random walk, too close to max connections");
                        return;
                    }
                }
            } catch  {}
        }
        async handleIncomingAutonatStream(e, t) {
            const r = AbortSignal.timeout(this.timeout);
            try {
                const s = Jn(e, {
                    maxDataLength: this.maxMessageSize
                }).pb(Vt), i = await s.read({
                    signal: r
                }), l = await this.handleAutonatMessage(i, t, {
                    signal: r
                });
                await s.write(l, {
                    signal: r
                }), await e.close({
                    signal: r
                });
            } catch (s) {
                this.log.error("error handling incoming autonat stream - %e", s), e.abort(s);
            }
        }
        async handleAutonatMessage(e, t, r) {
            const s = this.components.addressManager.getAddresses().map((m)=>Xe(m).host), i = e.dial;
            if (i == null) return this.log.error("dial was missing from message"), {
                type: Vt.MessageType.DIAL_RESPONSE,
                dialResponse: {
                    status: Vt.ResponseStatus.E_BAD_REQUEST,
                    statusText: "No Dial message found in message"
                }
            };
            let l;
            const u = i.peer;
            if (u?.id == null) return this.log.error("peerId missing from message"), {
                type: Vt.MessageType.DIAL_RESPONSE,
                dialResponse: {
                    status: Vt.ResponseStatus.E_BAD_REQUEST,
                    statusText: "missing peer info"
                }
            };
            try {
                const m = kt(u.id);
                l = _B(m);
            } catch (m) {
                return this.log.error("invalid PeerId - %e", m), {
                    type: Vt.MessageType.DIAL_RESPONSE,
                    dialResponse: {
                        status: Vt.ResponseStatus.E_BAD_REQUEST,
                        statusText: "bad peer id"
                    }
                };
            }
            if (this.log("incoming request from %p", l), !t.remotePeer.equals(l)) return this.log("target peer %p did not equal sending peer %p", l, t.remotePeer), {
                type: Vt.MessageType.DIAL_RESPONSE,
                dialResponse: {
                    status: Vt.ResponseStatus.E_BAD_REQUEST,
                    statusText: "peer id mismatch"
                }
            };
            const h = u.addrs.map((m)=>Rae(m)).filter((m)=>{
                try {
                    const w = Xe(m);
                    return Is(m) ? !1 : w.host !== Xe(t.remoteAddr).host ? (this.log.trace("not dialing %a - target host did not match remote host %a", m, t.remoteAddr), !1) : s.includes(w.host) ? !1 : this.components.transportManager.dialTransportForMultiaddr(m) == null ? (this.log.trace("not dialing %a - transport unsupported", m), !1) : !0;
                } catch  {
                    return !1;
                }
            }).map((m)=>(m.getComponents().find((w)=>w.code === S4)?.value == null && (m = m.encapsulate(`/p2p/${l.toString()}`)), m));
            if (h.length === 0) return this.log("refused to dial all multiaddrs for %p from message", l), {
                type: Vt.MessageType.DIAL_RESPONSE,
                dialResponse: {
                    status: Vt.ResponseStatus.E_DIAL_REFUSED,
                    statusText: "no dialable addresses"
                }
            };
            this.log("dial multiaddrs %s for peer %p", h.map((m)=>m.toString()).join(", "), l);
            let f = "", p = h[0];
            for (const m of h){
                let w;
                p = m;
                try {
                    if (w = await this.components.connectionManager.openConnection(m, r), !w.remoteAddr.equals(m)) throw this.log.error("tried to dial %a but dialed %a", m, w.remoteAddr), new Error("Unexpected remote address");
                    return this.log("successfully dialed %p via %a", l, m), {
                        type: Vt.MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: Vt.ResponseStatus.OK,
                            addr: w.remoteAddr.decapsulateCode(S4).bytes
                        }
                    };
                } catch (A) {
                    this.log.error("could not dial %p - %e", l, A), f = A.message;
                } finally{
                    w != null && await w.close();
                }
            }
            return {
                type: Vt.MessageType.DIAL_RESPONSE,
                dialResponse: {
                    status: Vt.ResponseStatus.E_DIAL_ERROR,
                    statusText: f,
                    addr: p.bytes
                }
            };
        }
        getFirstUnverifiedMultiaddr(e, t) {
            const r = this.components.addressManager.getAddressesWithMetadata().sort((s, i)=>s.type === "observed" && i.type !== "observed" ? 1 : i.type === "observed" && s.type !== "observed" ? -1 : 0).filter((s)=>!(!(s.expires < Date.now()) || Xe(s.multiaddr).type === "ip6" && (!t || !_C(s.multiaddr)) || Is(s.multiaddr)));
            for (const s of r){
                const i = s.multiaddr.toString();
                let l = this.dialResults.get(i);
                if (l != null) {
                    if (l.networkSegments.includes(e)) {
                        this.log.trace("%a already has a network segment result from %s", l.multiaddr, e);
                        continue;
                    }
                    if (l.queue.size > 10) {
                        this.log.trace("%a already has enough peers queued", l.multiaddr);
                        continue;
                    }
                }
                if (l == null) {
                    const u = s.expires < Date.now();
                    if (u && this.addressFilter.remove?.(i), this.addressFilter.has(i)) continue;
                    this.addressFilter.add(i), this.log.trace("creating dial result %s %s", u ? "to revalidate" : "for", i), l = {
                        multiaddr: s.multiaddr,
                        success: 0,
                        failure: 0,
                        networkSegments: [],
                        verifyingPeers: voe(),
                        queue: new Wo({
                            concurrency: 3,
                            maxSize: 50
                        }),
                        type: s.type,
                        lastVerified: s.lastVerified
                    }, this.dialResults.set(i, l);
                }
                return l;
            }
        }
        removeOutdatedMultiaddrResults() {
            const e = new Set(this.components.addressManager.getAddressesWithMetadata().filter(({ expires: t })=>t < Date.now()).map(({ multiaddr: t })=>t.toString()));
            for (const t of this.dialResults.keys())e.has(t) || (this.log.trace("remove results for %a", t), this.dialResults.delete(t));
        }
        async verifyExternalAddresses(e) {
            if (!this.isStarted()) return;
            this.removeOutdatedMultiaddrResults();
            const r = (await this.components.peerStore.get(e.remotePeer)).addresses.some(({ multiaddr: l })=>Xe(l).type === "ip6"), s = this.getNetworkSegment(e.remoteAddr), i = this.getFirstUnverifiedMultiaddr(s, r);
            if (i == null) {
                this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification", e.remotePeer);
                return;
            }
            if (!this.hasConnectionCapacity()) {
                i.lastVerified != null ? (this.log("automatically re-verifying %a because we are too close to the connection limit", i.multiaddr), this.confirmAddress(i)) : this.log("skipping verifying %a because we are too close to the connection limit", i.multiaddr);
                return;
            }
            i.queue.add(async (l)=>{
                await this.askPeerToVerify(e, s, l);
            }, {
                peerId: e.remotePeer,
                multiaddr: i.multiaddr
            }).catch((l)=>{
                i?.result == null && this.log.error("error from %p verifying address %a - %e", e.remotePeer, i?.multiaddr, l);
            });
        }
        async askPeerToVerify(e, t, r) {
            let s = this.dialResults.get(r.multiaddr.toString());
            if (s == null) {
                this.log("%a was verified while %p was queued", r.multiaddr, e.remotePeer);
                return;
            }
            const i = AbortSignal.timeout(this.timeout);
            this.log.trace("asking %a to verify multiaddr %s", e.remoteAddr, r.multiaddr);
            const l = await e.newStream(this.protocol, {
                signal: i
            });
            try {
                const u = Jn(l).pb(Vt), [, h] = await Promise.all([
                    u.write({
                        type: Vt.MessageType.DIAL,
                        dial: {
                            peer: {
                                id: this.components.peerId.toMultihash().bytes,
                                addrs: [
                                    r.multiaddr.bytes
                                ]
                            }
                        }
                    }, {
                        signal: i
                    }),
                    u.read({
                        signal: i
                    })
                ]);
                if (h.type !== Vt.MessageType.DIAL_RESPONSE || h.dialResponse == null) {
                    this.log("invalid autonat response from %p - %j", e.remotePeer, h);
                    return;
                }
                const f = h.dialResponse.status;
                if (this.log.trace("autonat response from %p for %a is %s", e.remotePeer, r.multiaddr, f), f !== Vt.ResponseStatus.OK && f !== Vt.ResponseStatus.E_DIAL_ERROR) return;
                if (s = this.dialResults.get(r.multiaddr.toString()), s == null) {
                    this.log.trace("peer reported %a as %s but there is no result object", r.multiaddr, h.dialResponse.status);
                    return;
                }
                if (s.networkSegments.includes(t)) {
                    this.log.trace("%a results included network segment %s", r.multiaddr, t);
                    return;
                }
                if (s.result != null) {
                    this.log.trace("already resolved result for %a, ignoring response from", r.multiaddr, e.remotePeer);
                    return;
                }
                if (s.verifyingPeers.has(e.remotePeer)) {
                    this.log.trace("peer %p has already verified %a, ignoring response", e.remotePeer, r.multiaddr);
                    return;
                }
                if (s.verifyingPeers.add(e.remotePeer), s.networkSegments.push(t), f === Vt.ResponseStatus.OK) {
                    if (s.success++, s.type !== "observed") {
                        this.confirmAddress(s);
                        return;
                    }
                } else f === Vt.ResponseStatus.E_DIAL_ERROR && s.failure++;
                this.log("%a success %d failure %d", s.multiaddr, s.success, s.failure), s.success === Vae && this.confirmAddress(s), s.failure === Hae && this.unconfirmAddress(s);
            } finally{
                try {
                    await l.close({
                        signal: i
                    });
                } catch (u) {
                    l.abort(u);
                }
            }
        }
        hasConnectionCapacity() {
            const t = this.components.connectionManager.getConnections().length, r = this.components.connectionManager.getMaxConnections();
            return t / r * 100 < this.connectionThreshold;
        }
        confirmAddress(e) {
            this.log("%s address %a is externally dialable", e.type, e.multiaddr), this.components.addressManager.confirmObservedAddr(e.multiaddr), this.dialResults.delete(e.multiaddr.toString()), e.result = !0, e.queue.abort();
        }
        unconfirmAddress(e) {
            this.log("%s address %a is not externally dialable", e.type, e.multiaddr), this.components.addressManager.removeObservedAddr(e.multiaddr), this.dialResults.delete(e.multiaddr.toString()), e.result = !1, e.queue.abort();
        }
        getNetworkSegment(e) {
            const t = Xe(e);
            switch(t.type){
                case "ip4":
                    return t.host.split(".")[0].padStart(3, "0");
                case "ip6":
                    return t.host.split(":")[0].padStart(4, "0");
                default:
                    throw new aoe(`Remote address ${e} was not an IPv4 or Ipv6 address`);
            }
        }
    }
    function qae(n = {}) {
        return (e)=>new Qae(e, n);
    }
    let Kae = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, Gae = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, Yae = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    const Wae = Symbol.for("@libp2p/peer-discovery"), BB = Symbol.for("@libp2p/peer-id"), jae = Symbol.for("@libp2p/service-capabilities"), PB = Symbol.for("nodejs.util.inspect.custom"), Xae = 114;
    let B8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [BB] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Xae, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [PB]() {
            return `PeerId(${this.toString()})`;
        }
    }, Jae = class extends B8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, Zae = class extends B8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, ele = class extends B8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const tle = 2336;
    let kB = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [PB]() {
            return `PeerId(${this.url})`;
        }
        [BB] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(tle, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const nle = 114, oA = 2336;
    function rle(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return sle(ge.parse(n));
            throw new Kae('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return RB(t);
    }
    function RB(n) {
        if (ole(n)) return new Jae({
            multihash: n
        });
        if (ile(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new Zae({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new ele({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new kB(new URL(t));
        }
        throw new Yae("Supplied PeerID Multihash is invalid");
    }
    function sle(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== nle && n.code !== oA) throw new Gae("Supplied PeerID CID is invalid");
        if (n.code === oA) {
            const e = L(n.multihash.digest);
            return new kB(new URL(e));
        }
        return RB(n.multihash);
    }
    function ile(n) {
        return n.code === nt.code;
    }
    function ole(n) {
        return n.code === Ut.code;
    }
    let gs = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, df = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, ale = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, lle = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const cle = 4, ule = 6, hle = 273, dle = 33, fle = 41, ple = 42, gle = 43, mle = 53, yle = 54, wle = 55, ble = 56, vle = 132, Ele = 301, Ale = 302, Sle = 400, I4 = 421, Ile = 444, Cle = 445, Tle = 446, _le = 447, xle = 448, Dle = 449, Ble = 454, Ple = 460, kle = 461, Rle = 465, Ole = 466, $le = 480, Mle = 481, Nle = 443, Lle = 477, Ule = 478, zle = 479, Fle = 277, Vle = 275, Hle = 276, Qle = 280, qle = 281, Kle = 290, Gle = 777;
    function aA(n) {
        return (e)=>L(e, n);
    }
    function lA(n) {
        return (e)=>re(e, n);
    }
    function Zh(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function ac(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function Yle(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = ac(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Wle(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = ac(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function cA(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = Zh(t);
        return `${r}:${s}`;
    }
    const OB = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new gs("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, jle = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = OB(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new gs("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, Xle = function(n) {
        if (n.byteLength !== 4) throw new gs("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, Jle = function(n) {
        if (n.byteLength !== 16) throw new gs("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new gs(`Invalid IPv6 address "${t}"`);
        }
    };
    function Zle(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new gs(`Invalid IPv6 address "${n}"`);
        }
    }
    const ay = Object.values(un).map((n)=>n.decoder), ece = (function() {
        let n = ay[0].or(ay[1]);
        return ay.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function tce(n) {
        return ece.decode(n);
    }
    function nce(n) {
        return (e)=>n.encoder.encode(e);
    }
    function rce(n) {
        if (parseInt(n).toString() !== n) throw new df("Value must be an integer");
    }
    function sce(n) {
        if (n < 0) throw new df("Value must be a positive integer, or zero");
    }
    function ice(n) {
        return (e)=>{
            if (e > n) throw new df(`Value must be smaller than or equal to ${n}`);
        };
    }
    function oce(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const L0 = oce(rce, sce, ice(65535)), Ln = -1;
    let ace = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new lle(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const mu = new ace, lce = [
        {
            code: cle,
            name: "ip4",
            size: 32,
            valueToBytes: OB,
            bytesToValue: Xle,
            validate: (n)=>{
                if (!Je(n)) throw new df(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: ule,
            name: "tcp",
            size: 16,
            valueToBytes: ac,
            bytesToValue: Zh,
            validate: L0
        },
        {
            code: hle,
            name: "udp",
            size: 16,
            valueToBytes: ac,
            bytesToValue: Zh,
            validate: L0
        },
        {
            code: dle,
            name: "dccp",
            size: 16,
            valueToBytes: ac,
            bytesToValue: Zh,
            validate: L0
        },
        {
            code: fle,
            name: "ip6",
            size: 128,
            valueToBytes: jle,
            bytesToValue: Jle,
            stringToValue: Zle,
            validate: (n)=>{
                if (!xn(n)) throw new df(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: ple,
            name: "ip6zone",
            size: Ln
        },
        {
            code: gle,
            name: "ipcidr",
            size: 8,
            bytesToValue: aA("base10"),
            valueToBytes: lA("base10")
        },
        {
            code: mle,
            name: "dns",
            size: Ln
        },
        {
            code: yle,
            name: "dns4",
            size: Ln
        },
        {
            code: wle,
            name: "dns6",
            size: Ln
        },
        {
            code: ble,
            name: "dnsaddr",
            size: Ln
        },
        {
            code: vle,
            name: "sctp",
            size: 16,
            valueToBytes: ac,
            bytesToValue: Zh,
            validate: L0
        },
        {
            code: Ele,
            name: "udt"
        },
        {
            code: Ale,
            name: "utp"
        },
        {
            code: Sle,
            name: "unix",
            size: Ln,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: I4,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Ln,
            bytesToValue: aA("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? lA("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: Ile,
            name: "onion",
            size: 96,
            bytesToValue: cA,
            valueToBytes: Yle
        },
        {
            code: Cle,
            name: "onion3",
            size: 296,
            bytesToValue: cA,
            valueToBytes: Wle
        },
        {
            code: Tle,
            name: "garlic64",
            size: Ln
        },
        {
            code: _le,
            name: "garlic32",
            size: Ln
        },
        {
            code: xle,
            name: "tls"
        },
        {
            code: Dle,
            name: "sni",
            size: Ln
        },
        {
            code: Ble,
            name: "noise"
        },
        {
            code: Ple,
            name: "quic"
        },
        {
            code: kle,
            name: "quic-v1"
        },
        {
            code: Rle,
            name: "webtransport"
        },
        {
            code: Ole,
            name: "certhash",
            size: Ln,
            bytesToValue: nce(yn),
            valueToBytes: tce
        },
        {
            code: $le,
            name: "http"
        },
        {
            code: Mle,
            name: "http-path",
            size: Ln,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Nle,
            name: "https"
        },
        {
            code: Lle,
            name: "ws"
        },
        {
            code: Ule,
            name: "wss"
        },
        {
            code: zle,
            name: "p2p-websocket-star"
        },
        {
            code: Fle,
            name: "p2p-stardust"
        },
        {
            code: Vle,
            name: "p2p-webrtc-star"
        },
        {
            code: Hle,
            name: "p2p-webrtc-direct"
        },
        {
            code: Qle,
            name: "webrtc-direct"
        },
        {
            code: qle,
            name: "webrtc"
        },
        {
            code: Kle,
            name: "p2p-circuit"
        },
        {
            code: Gle,
            name: "memory",
            size: Ln
        }
    ];
    lce.forEach((n)=>{
        mu.addProtocol(n);
    });
    function cce(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = mu.getProtocol(r), i = be(r), l = fce(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Ln && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function uce(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = mu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Ln && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Ln && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function hce(n) {
        if (n.charAt(0) !== "/") throw new gs('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = mu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new gs(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new gs(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new gs("Incomplete multiaddr");
        return e;
    }
    function dce(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = mu.getProtocol(e.code);
            if (t == null) throw new gs(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function fce(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const pce = Symbol.for("nodejs.util.inspect.custom"), $B = Symbol.for("@multiformats/multiaddr");
    function gce(n) {
        if (n == null && (n = "/"), wce(n)) return n.getComponents();
        if (n instanceof Uint8Array) return cce(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), hce(n);
        if (Array.isArray(n)) return n;
        throw new gs("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let mce = class ed {
        [$B] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = gce(e), t.validate !== !1 && yce(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = uce(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = dce(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new ed(e);
            return new ed([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new ale(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new ed(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new ed(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [pce]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function yce(n) {
        n.getComponents().forEach((e)=>{
            const t = mu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function wce(n) {
        return !!n?.[$B];
    }
    function bce(n) {
        return new mce(n);
    }
    const vce = "bootstrap", Ece = 50, Ace = 1e3;
    class Sce extends Lt {
        static tag = "bootstrap";
        log;
        timer;
        list;
        timeout;
        components;
        _init;
        constructor(e, t = {
            list: []
        }){
            if (t.list == null || t.list.length === 0) throw new Error("Bootstrap requires a list of peer addresses");
            super(), this.components = e, this.log = e.logger.forComponent("libp2p:bootstrap"), this.timeout = t.timeout ?? Ace, this.list = t.list.map((r)=>bce(r)).filter((r)=>r8.matches(r) ? r.getComponents().findLast((i)=>i.code === I4)?.value == null ? (this.log.error("invalid bootstrap multiaddr without peer id"), !1) : !0 : (this.log.error("invalid multiaddr %a", r), !1)).map((r)=>({
                    id: rle(r.getComponents().findLast((s)=>s.code === I4)?.value ?? ""),
                    multiaddrs: [
                        r
                    ]
                })), this._init = t;
        }
        [Wae] = this;
        [Symbol.toStringTag] = "@libp2p/bootstrap";
        [jae] = [
            "@libp2p/peer-discovery"
        ];
        isStarted() {
            return !!this.timer;
        }
        start() {
            this.isStarted() || (this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout), this.timer = setTimeout(()=>{
                this._discoverBootstrapPeers().catch((e)=>{
                    this.log.error("failed to discover bootstrap peers - %e", e);
                });
            }, this.timeout));
        }
        async _discoverBootstrapPeers() {
            if (this.timer != null) for (const e of this.list){
                if (await this.components.peerStore.merge(e.id, {
                    tags: {
                        [this._init.tagName ?? vce]: {
                            value: this._init.tagValue ?? Ece,
                            ttl: this._init.tagTTL
                        }
                    },
                    multiaddrs: e.multiaddrs
                }), this.timer == null) return;
                this.safeDispatchEvent("peer", {
                    detail: e
                }), this.components.connectionManager.openConnection(e.id).catch((t)=>{
                    this.log.error("could not dial bootstrap peer %p - %e", e.id, t);
                });
            }
        }
        stop() {
            this.timer != null && clearTimeout(this.timer), this.timer = void 0;
        }
    }
    function Ice(n) {
        return (e)=>new Sce(e, n);
    }
    let Cce = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, Tce = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, _ce = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }, xce = class extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    };
    class Dce extends Error {
        static name = "DialError";
        constructor(e = "Dial error"){
            super(e), this.name = "DialError";
        }
    }
    class C4 extends Error {
        static name = "ListenError";
        constructor(e = "Listen error"){
            super(e), this.name = "ListenError";
        }
    }
    const MB = Symbol.for("@libp2p/peer-id"), Bce = "keep-alive";
    function NB(n) {
        return n != null && typeof n.start == "function" && typeof n.stop == "function";
    }
    async function Pce(...n) {
        const e = [];
        for (const t of n)NB(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStart != null && await t.beforeStart();
        })), await Promise.all(e.map(async (t)=>{
            await t.start();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStart != null && await t.afterStart();
        }));
    }
    async function kce(...n) {
        const e = [];
        for (const t of n)NB(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStop != null && await t.beforeStop();
        })), await Promise.all(e.map(async (t)=>{
            await t.stop();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStop != null && await t.afterStop();
        }));
    }
    const Rce = Symbol.for("@libp2p/transport");
    var uA;
    (function(n) {
        n[n.FATAL_ALL = 0] = "FATAL_ALL", n[n.NO_FATAL = 1] = "NO_FATAL";
    })(uA || (uA = {}));
    const Oce = Symbol.for("@libp2p/service-capabilities"), $ce = Symbol.for("@libp2p/service-dependencies"), LB = Symbol.for("nodejs.util.inspect.custom"), Mce = 114;
    let P8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [MB] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Mce, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [LB]() {
            return `PeerId(${this.toString()})`;
        }
    }, Nce = class extends P8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, Lce = class extends P8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, Uce = class extends P8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const zce = 2336;
    let UB = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [LB]() {
            return `PeerId(${this.url})`;
        }
        [MB] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(zce, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const Fce = 114, hA = 2336;
    function dA(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return Vce(ge.parse(n));
            throw new Cce('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return k8(t);
    }
    function k8(n) {
        if (Qce(n)) return new Nce({
            multihash: n
        });
        if (Hce(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new Lce({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new Uce({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new UB(new URL(t));
        }
        throw new _ce("Supplied PeerID Multihash is invalid");
    }
    function Vce(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== Fce && n.code !== hA) throw new Tce("Supplied PeerID CID is invalid");
        if (n.code === hA) {
            const e = L(n.multihash.digest);
            return new UB(new URL(e));
        }
        return k8(n.multihash);
    }
    function Hce(n) {
        return n.code === nt.code;
    }
    function Qce(n) {
        return n.code === Ut.code;
    }
    let ms = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, ff = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, qce = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, Kce = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const Gce = 4, Yce = 6, Wce = 273, jce = 33, Xce = 41, Jce = 42, Zce = 43, eue = 53, tue = 54, nue = 55, rue = 56, sue = 132, iue = 301, oue = 302, aue = 400, Xp = 421, lue = 444, cue = 445, uue = 446, hue = 447, due = 448, fue = 449, pue = 454, gue = 460, mue = 461, yue = 465, wue = 466, bue = 480, vue = 481, Eue = 443, Aue = 477, Sue = 478, Iue = 479, Cue = 277, Tue = 275, _ue = 276, xue = 280, Due = 281, R8 = 290, Bue = 777;
    function fA(n) {
        return (e)=>L(e, n);
    }
    function pA(n) {
        return (e)=>re(e, n);
    }
    function td(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function lc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function Pue(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = lc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function kue(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = lc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function gA(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = td(t);
        return `${r}:${s}`;
    }
    const zB = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new ms("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, Rue = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = zB(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new ms("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, Oue = function(n) {
        if (n.byteLength !== 4) throw new ms("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, $ue = function(n) {
        if (n.byteLength !== 16) throw new ms("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new ms(`Invalid IPv6 address "${t}"`);
        }
    };
    function Mue(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new ms(`Invalid IPv6 address "${n}"`);
        }
    }
    const ly = Object.values(un).map((n)=>n.decoder), Nue = (function() {
        let n = ly[0].or(ly[1]);
        return ly.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function Lue(n) {
        return Nue.decode(n);
    }
    function Uue(n) {
        return (e)=>n.encoder.encode(e);
    }
    function zue(n) {
        if (parseInt(n).toString() !== n) throw new ff("Value must be an integer");
    }
    function Fue(n) {
        if (n < 0) throw new ff("Value must be a positive integer, or zero");
    }
    function Vue(n) {
        return (e)=>{
            if (e > n) throw new ff(`Value must be smaller than or equal to ${n}`);
        };
    }
    function Hue(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const U0 = Hue(zue, Fue, Vue(65535)), Un = -1;
    let Que = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new Kce(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const yu = new Que, que = [
        {
            code: Gce,
            name: "ip4",
            size: 32,
            valueToBytes: zB,
            bytesToValue: Oue,
            validate: (n)=>{
                if (!Je(n)) throw new ff(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: Yce,
            name: "tcp",
            size: 16,
            valueToBytes: lc,
            bytesToValue: td,
            validate: U0
        },
        {
            code: Wce,
            name: "udp",
            size: 16,
            valueToBytes: lc,
            bytesToValue: td,
            validate: U0
        },
        {
            code: jce,
            name: "dccp",
            size: 16,
            valueToBytes: lc,
            bytesToValue: td,
            validate: U0
        },
        {
            code: Xce,
            name: "ip6",
            size: 128,
            valueToBytes: Rue,
            bytesToValue: $ue,
            stringToValue: Mue,
            validate: (n)=>{
                if (!xn(n)) throw new ff(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: Jce,
            name: "ip6zone",
            size: Un
        },
        {
            code: Zce,
            name: "ipcidr",
            size: 8,
            bytesToValue: fA("base10"),
            valueToBytes: pA("base10")
        },
        {
            code: eue,
            name: "dns",
            size: Un
        },
        {
            code: tue,
            name: "dns4",
            size: Un
        },
        {
            code: nue,
            name: "dns6",
            size: Un
        },
        {
            code: rue,
            name: "dnsaddr",
            size: Un
        },
        {
            code: sue,
            name: "sctp",
            size: 16,
            valueToBytes: lc,
            bytesToValue: td,
            validate: U0
        },
        {
            code: iue,
            name: "udt"
        },
        {
            code: oue,
            name: "utp"
        },
        {
            code: aue,
            name: "unix",
            size: Un,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: Xp,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Un,
            bytesToValue: fA("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? pA("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: lue,
            name: "onion",
            size: 96,
            bytesToValue: gA,
            valueToBytes: Pue
        },
        {
            code: cue,
            name: "onion3",
            size: 296,
            bytesToValue: gA,
            valueToBytes: kue
        },
        {
            code: uue,
            name: "garlic64",
            size: Un
        },
        {
            code: hue,
            name: "garlic32",
            size: Un
        },
        {
            code: due,
            name: "tls"
        },
        {
            code: fue,
            name: "sni",
            size: Un
        },
        {
            code: pue,
            name: "noise"
        },
        {
            code: gue,
            name: "quic"
        },
        {
            code: mue,
            name: "quic-v1"
        },
        {
            code: yue,
            name: "webtransport"
        },
        {
            code: wue,
            name: "certhash",
            size: Un,
            bytesToValue: Uue(yn),
            valueToBytes: Lue
        },
        {
            code: bue,
            name: "http"
        },
        {
            code: vue,
            name: "http-path",
            size: Un,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Eue,
            name: "https"
        },
        {
            code: Aue,
            name: "ws"
        },
        {
            code: Sue,
            name: "wss"
        },
        {
            code: Iue,
            name: "p2p-websocket-star"
        },
        {
            code: Cue,
            name: "p2p-stardust"
        },
        {
            code: Tue,
            name: "p2p-webrtc-star"
        },
        {
            code: _ue,
            name: "p2p-webrtc-direct"
        },
        {
            code: xue,
            name: "webrtc-direct"
        },
        {
            code: Due,
            name: "webrtc"
        },
        {
            code: R8,
            name: "p2p-circuit"
        },
        {
            code: Bue,
            name: "memory",
            size: Un
        }
    ];
    que.forEach((n)=>{
        yu.addProtocol(n);
    });
    function Kue(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = yu.getProtocol(r), i = be(r), l = jue(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Un && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function Gue(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = yu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Un && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Un && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function Yue(n) {
        if (n.charAt(0) !== "/") throw new ms('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = yu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new ms(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new ms(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new ms("Incomplete multiaddr");
        return e;
    }
    function Wue(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = yu.getProtocol(e.code);
            if (t == null) throw new ms(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function jue(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const Xue = Symbol.for("nodejs.util.inspect.custom"), FB = Symbol.for("@multiformats/multiaddr");
    function Jue(n) {
        if (n == null && (n = "/"), the(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Kue(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), Yue(n);
        if (Array.isArray(n)) return n;
        throw new ms("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let Zue = class nd {
        [FB] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = Jue(e), t.validate !== !1 && ehe(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = Gue(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = Wue(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new nd(e);
            return new nd([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new qce(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new nd(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new nd(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [Xue]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function ehe(n) {
        n.getComponents().forEach((e)=>{
            const t = yu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function the(n) {
        return !!n?.[FB];
    }
    function Ho(n) {
        return new Zue(n);
    }
    const nhe = 1, VB = 5e3, rhe = 100, z0 = `${Bce}-circuit-relay`;
    BigInt(1 << 17);
    const Jp = "/libp2p/circuit/relay/0.2.0/hop", mA = "/libp2p/circuit/relay/0.2.0/stop", yA = 300, she = 4096, ihe = .001;
    var qc;
    (function(n) {
        (function(r) {
            r.RESERVE = "RESERVE", r.CONNECT = "CONNECT", r.STATUS = "STATUS";
        })(n.Type || (n.Type = {}));
        let e;
        (function(r) {
            r[r.RESERVE = 0] = "RESERVE", r[r.CONNECT = 1] = "CONNECT", r[r.STATUS = 2] = "STATUS";
        })(e || (e = {})), (function(r) {
            r.codec = ()=>vr(e);
        })(n.Type || (n.Type = {}));
        let t;
        n.codec = ()=>(t == null && (t = Le((r, s, i = {})=>{
                i.lengthDelimited !== !1 && s.fork(), r.type != null && (s.uint32(8), n.Type.codec().encode(r.type, s)), r.peer != null && (s.uint32(18), Kc.codec().encode(r.peer, s)), r.reservation != null && (s.uint32(26), Zp.codec().encode(r.reservation, s)), r.limit != null && (s.uint32(34), Gc.codec().encode(r.limit, s)), r.status != null && (s.uint32(40), tr.codec().encode(r.status, s)), i.lengthDelimited !== !1 && s.ldelim();
            }, (r, s, i = {})=>{
                const l = {}, u = s == null ? r.len : r.pos + s;
                for(; r.pos < u;){
                    const h = r.uint32();
                    switch(h >>> 3){
                        case 1:
                            {
                                l.type = n.Type.codec().decode(r);
                                break;
                            }
                        case 2:
                            {
                                l.peer = Kc.codec().decode(r, r.uint32(), {
                                    limits: i.limits?.peer
                                });
                                break;
                            }
                        case 3:
                            {
                                l.reservation = Zp.codec().decode(r, r.uint32(), {
                                    limits: i.limits?.reservation
                                });
                                break;
                            }
                        case 4:
                            {
                                l.limit = Gc.codec().decode(r, r.uint32(), {
                                    limits: i.limits?.limit
                                });
                                break;
                            }
                        case 5:
                            {
                                l.status = tr.codec().decode(r);
                                break;
                            }
                        default:
                            {
                                r.skipType(h & 7);
                                break;
                            }
                    }
                }
                return l;
            })), t), n.encode = (r)=>Ne(r, n.codec()), n.decode = (r, s)=>Me(r, n.codec(), s);
    })(qc || (qc = {}));
    var Vi;
    (function(n) {
        (function(r) {
            r.CONNECT = "CONNECT", r.STATUS = "STATUS";
        })(n.Type || (n.Type = {}));
        let e;
        (function(r) {
            r[r.CONNECT = 0] = "CONNECT", r[r.STATUS = 1] = "STATUS";
        })(e || (e = {})), (function(r) {
            r.codec = ()=>vr(e);
        })(n.Type || (n.Type = {}));
        let t;
        n.codec = ()=>(t == null && (t = Le((r, s, i = {})=>{
                i.lengthDelimited !== !1 && s.fork(), r.type != null && (s.uint32(8), n.Type.codec().encode(r.type, s)), r.peer != null && (s.uint32(18), Kc.codec().encode(r.peer, s)), r.limit != null && (s.uint32(26), Gc.codec().encode(r.limit, s)), r.status != null && (s.uint32(32), tr.codec().encode(r.status, s)), i.lengthDelimited !== !1 && s.ldelim();
            }, (r, s, i = {})=>{
                const l = {}, u = s == null ? r.len : r.pos + s;
                for(; r.pos < u;){
                    const h = r.uint32();
                    switch(h >>> 3){
                        case 1:
                            {
                                l.type = n.Type.codec().decode(r);
                                break;
                            }
                        case 2:
                            {
                                l.peer = Kc.codec().decode(r, r.uint32(), {
                                    limits: i.limits?.peer
                                });
                                break;
                            }
                        case 3:
                            {
                                l.limit = Gc.codec().decode(r, r.uint32(), {
                                    limits: i.limits?.limit
                                });
                                break;
                            }
                        case 4:
                            {
                                l.status = tr.codec().decode(r);
                                break;
                            }
                        default:
                            {
                                r.skipType(h & 7);
                                break;
                            }
                    }
                }
                return l;
            })), t), n.encode = (r)=>Ne(r, n.codec()), n.decode = (r, s)=>Me(r, n.codec(), s);
    })(Vi || (Vi = {}));
    var Kc;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.id != null && t.id.byteLength > 0 && (r.uint32(10), r.bytes(t.id)), t.addrs != null) for (const i of t.addrs)r.uint32(18), r.bytes(i);
                s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    id: je(0),
                    addrs: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.id = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.addrs != null && i.addrs.length === s.limits.addrs) throw new vt('Decode error - map field "addrs" had too many elements');
                                i.addrs.push(t.bytes());
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Kc || (Kc = {}));
    var Zp;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.expire != null && t.expire !== 0n && (r.uint32(8), r.uint64(t.expire)), t.addrs != null) for (const i of t.addrs)r.uint32(18), r.bytes(i);
                t.voucher != null && (r.uint32(26), tg.codec().encode(t.voucher, r)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    expire: 0n,
                    addrs: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.expire = t.uint64();
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.addrs != null && i.addrs.length === s.limits.addrs) throw new vt('Decode error - map field "addrs" had too many elements');
                                i.addrs.push(t.bytes());
                                break;
                            }
                        case 3:
                            {
                                i.voucher = tg.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.voucher
                                });
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Zp || (Zp = {}));
    var Gc;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.duration != null && (r.uint32(8), r.uint32(t.duration)), t.data != null && (r.uint32(16), r.uint64(t.data)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {}, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.duration = t.uint32();
                                break;
                            }
                        case 2:
                            {
                                i.data = t.uint64();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Gc || (Gc = {}));
    var tr;
    (function(n) {
        n.UNUSED = "UNUSED", n.OK = "OK", n.RESERVATION_REFUSED = "RESERVATION_REFUSED", n.RESOURCE_LIMIT_EXCEEDED = "RESOURCE_LIMIT_EXCEEDED", n.PERMISSION_DENIED = "PERMISSION_DENIED", n.CONNECTION_FAILED = "CONNECTION_FAILED", n.NO_RESERVATION = "NO_RESERVATION", n.MALFORMED_MESSAGE = "MALFORMED_MESSAGE", n.UNEXPECTED_MESSAGE = "UNEXPECTED_MESSAGE";
    })(tr || (tr = {}));
    var T4;
    (function(n) {
        n[n.UNUSED = 0] = "UNUSED", n[n.OK = 100] = "OK", n[n.RESERVATION_REFUSED = 200] = "RESERVATION_REFUSED", n[n.RESOURCE_LIMIT_EXCEEDED = 201] = "RESOURCE_LIMIT_EXCEEDED", n[n.PERMISSION_DENIED = 202] = "PERMISSION_DENIED", n[n.CONNECTION_FAILED = 203] = "CONNECTION_FAILED", n[n.NO_RESERVATION = 204] = "NO_RESERVATION", n[n.MALFORMED_MESSAGE = 400] = "MALFORMED_MESSAGE", n[n.UNEXPECTED_MESSAGE = 401] = "UNEXPECTED_MESSAGE";
    })(T4 || (T4 = {}));
    (function(n) {
        n.codec = ()=>vr(T4);
    })(tr || (tr = {}));
    var eg;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.relay != null && t.relay.byteLength > 0 && (r.uint32(10), r.bytes(t.relay)), t.peer != null && t.peer.byteLength > 0 && (r.uint32(18), r.bytes(t.peer)), t.expiration != null && t.expiration !== 0n && (r.uint32(24), r.uint64(t.expiration)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    relay: je(0),
                    peer: je(0),
                    expiration: 0n
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.relay = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.peer = t.bytes();
                                break;
                            }
                        case 3:
                            {
                                i.expiration = t.uint64();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(eg || (eg = {}));
    var tg;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.publicKey != null && t.publicKey.byteLength > 0 && (r.uint32(10), r.bytes(t.publicKey)), t.payloadType != null && t.payloadType.byteLength > 0 && (r.uint32(18), r.bytes(t.payloadType)), t.payload != null && (r.uint32(26), eg.codec().encode(t.payload, r)), t.signature != null && t.signature.byteLength > 0 && (r.uint32(42), r.bytes(t.signature)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    publicKey: je(0),
                    payloadType: je(0),
                    signature: je(0)
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.publicKey = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.payloadType = t.bytes();
                                break;
                            }
                        case 3:
                            {
                                i.payload = eg.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.payload
                                });
                                break;
                            }
                        case 5:
                            {
                                i.signature = t.bytes();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(tg || (tg = {}));
    class wA extends Error {
        static name = "HadEnoughRelaysError";
        name = "HadEnoughRelaysError";
    }
    class ohe extends Error {
        static name = "DoubleRelayError";
        name = "DoubleRelayError";
    }
    class ahe extends Error {
        static name = "RelayQueueFullError";
        name = "RelayQueueFullError";
    }
    function bA(n) {
        const e = n * BigInt(1e3), t = new Date().getTime();
        return Number(e - BigInt(t));
    }
    class vA {
        expires;
        bytes;
        constructor(e){
            e?.duration != null && e?.duration !== 0 && (this.expires = Date.now() + e.duration * 1e3), this.bytes = e?.data, this.bytes === 0n && (this.bytes = void 0), this.onData = this.onData.bind(this);
        }
        onData(e) {
            this.bytes != null && (this.bytes -= BigInt(e.byteLength), this.bytes < 0n && (this.bytes = 0n));
        }
        getLimits() {
            if (this.expires == null && this.bytes == null) return;
            const e = {};
            if (this.bytes != null) {
                const t = this;
                Object.defineProperty(e, "bytes", {
                    get () {
                        return t.bytes;
                    }
                });
            }
            if (this.expires != null) {
                const t = this;
                Object.defineProperty(e, "seconds", {
                    get () {
                        return Math.round(((t.expires ?? 0) - Date.now()) / 1e3);
                    }
                });
            }
            return e;
        }
    }
    const HB = Rt(ht(r8.matchers[0], Bt(R8))), QB = Rt(Bt(R8));
    function cy(n, e) {
        const t = {
            [Symbol.iterator]: ()=>t,
            next: ()=>{
                const r = n.next(), s = r.value;
                return r.done === !0 || s == null ? {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: e(s)
                };
            }
        };
        return t;
    }
    let lhe = class {
        map;
        constructor(e){
            if (this.map = new Map, e != null) for (const [t, r] of e.entries())this.map.set(t.toString(), {
                key: t,
                value: r
            });
        }
        [Symbol.iterator]() {
            return this.entries();
        }
        clear() {
            this.map.clear();
        }
        delete(e) {
            return this.map.delete(e.toString());
        }
        entries() {
            return cy(this.map.entries(), (e)=>[
                    e[1].key,
                    e[1].value
                ]);
        }
        forEach(e) {
            this.map.forEach((t, r)=>{
                e(t.value, t.key, this);
            });
        }
        get(e) {
            return this.map.get(e.toString())?.value;
        }
        has(e) {
            return this.map.has(e.toString());
        }
        set(e, t) {
            this.map.set(e.toString(), {
                key: e,
                value: t
            });
        }
        keys() {
            return cy(this.map.values(), (e)=>e.key);
        }
        values() {
            return cy(this.map.values(), (e)=>e.value);
        }
        get size() {
            return this.map.size;
        }
    };
    class che {
        filter;
        constructor(e, t){
            this.filter = Wi(e, t);
        }
        has(e) {
            return this.filter.has(e.toMultihash().bytes);
        }
        add(e) {
            this.filter.add(e.toMultihash().bytes);
        }
        remove(e) {
            this.filter.remove?.(e.toMultihash().bytes);
        }
    }
    function uhe(n, e = .001) {
        return new che(n, e);
    }
    class hhe extends Lt {
        components;
        started;
        running;
        topologyId;
        log;
        discoveryController;
        filter;
        queue;
        constructor(e, t = {}){
            super(), this.log = e.logger.forComponent("libp2p:circuit-relay:discover-relays"), this.components = e, this.started = !1, this.running = !1, this.filter = t.filter, this.discoveryController = new AbortController, this.discoveryController.signal, this.dialPeer = this.dialPeer.bind(this), this.onPeer = this.onPeer.bind(this);
        }
        isStarted() {
            return this.started;
        }
        async start() {
            this.topologyId = await this.components.registrar.register(Jp, {
                filter: this.filter,
                onConnect: (e)=>{
                    this.log.trace("discovered relay %p queue (length: %d, active %d)", e, this.queue?.size, this.queue?.running), this.safeDispatchEvent("relay:discover", {
                        detail: e
                    });
                }
            }), this.started = !0;
        }
        stop() {
            this.topologyId != null && this.components.registrar.unregister(this.topologyId), this.running && this.stopDiscovery(), this.started = !1;
        }
        startDiscovery() {
            this.running || (this.log("start discovery"), this.running = !0, this.discoveryController = new AbortController, this.discoveryController.signal, this.components.events.addEventListener("peer:discovery", this.onPeer), Promise.resolve().then(async ()=>{
                this.log("searching peer store for relays");
                const e = await this.components.peerStore.all({
                    filters: [
                        (r)=>r.protocols.includes(Jp)
                    ],
                    orders: [
                        ()=>Math.random() < .5 ? 1 : -1,
                        (r, s)=>{
                            const i = EA(r), l = EA(s);
                            return i > l ? -1 : l > i ? 1 : 0;
                        }
                    ]
                });
                for (const r of e)this.log.trace("found relay peer %p in peer store", r.id), this.safeDispatchEvent("relay:discover", {
                    detail: r.id
                });
                this.log("found %d relay peers in peer store", e.length);
                const t = this.queue = new Wo({
                    concurrency: 5
                });
                this.log("start random walk");
                for await (const r of this.components.randomWalk.walk({
                    signal: this.discoveryController.signal
                })){
                    if (this.log.trace("found random peer %p", r.id), t.has(r.id)) {
                        this.log.trace("random peer %p was already in queue", r.id);
                        continue;
                    }
                    if (this.components.connectionManager.getConnections(r.id)?.length > 0) {
                        this.log.trace("random peer %p was already connected", r.id);
                        continue;
                    }
                    if (!await this.components.connectionManager.isDialable(r.multiaddrs)) {
                        this.log.trace("random peer %p was not dialable", r.id, r.multiaddrs.map((s)=>s.toString()));
                        continue;
                    }
                    t.queued > 10 && (this.log.trace("wait for space in queue for %p", r.id), await t.onSizeLessThan(10, {
                        signal: this.discoveryController.signal
                    })), this.log("adding random peer %p to dial queue (length: %d, active %d)", r.id, t.size, t.running), t.add(this.dialPeer, {
                        peerId: r.id,
                        signal: this.discoveryController.signal
                    }).catch((s)=>{
                        this.log.error("error opening connection to random peer %p - %e", r.id, s);
                    });
                }
                this.log("stop random walk"), await t.onIdle();
            }).catch((e)=>{
                this.discoveryController.signal.aborted || this.log.error("failed when finding relays on the network - %e", e);
            }));
        }
        stopDiscovery() {
            this.log("stop discovery"), this.running = !1, this.discoveryController?.abort(), this.queue?.clear(), this.components.events.removeEventListener("peer:discovery", this.onPeer);
        }
        onPeer(e) {
            this.log.trace("maybe dialing discovered peer %p", e.detail.id), this.maybeDialPeer(e).catch((t)=>{
                this.log.trace("error dialing discovered peer %p - %e", e.detail.id, t);
            });
        }
        async maybeDialPeer(e) {
            if (this.queue == null) return;
            const t = e.detail.id, r = e.detail.multiaddrs;
            if (this.queue.has(t)) {
                this.log.trace("random peer %p was already in queue", t);
                return;
            }
            if (this.components.connectionManager.getConnections(t)?.length > 0) {
                this.log.trace("random peer %p was already connected", t);
                return;
            }
            if (!await this.components.connectionManager.isDialable(r)) {
                this.log.trace("random peer %p was not dialable", t);
                return;
            }
            this.queue?.add(this.dialPeer, {
                peerId: e.detail.id,
                signal: this.discoveryController.signal
            }).catch((s)=>{
                this.log.error("error opening connection to discovered peer %p - %e", e.detail.id, s);
            });
        }
        async dialPeer({ peerId: e, signal: t }) {
            const r = gt([
                AbortSignal.timeout(5e3),
                t
            ]);
            try {
                await this.components.connectionManager.openConnection(e, {
                    signal: r
                });
            } finally{
                r.clear();
            }
        }
    }
    function EA(n) {
        const e = n.metadata.get("last-dial-success");
        return e == null ? 0 : new Date(L(e)).getTime();
    }
    class dhe extends Lt {
        connectionManager;
        addressManager;
        reservationStore;
        listeningAddrs;
        log;
        listenTimeout;
        reservationId;
        relay;
        constructor(e, t = {}){
            super(), this.log = e.logger.forComponent("libp2p:circuit-relay:transport:listener"), this.connectionManager = e.connectionManager, this.addressManager = e.addressManager, this.reservationStore = e.reservationStore, this.listeningAddrs = [], this.listenTimeout = t.listenTimeout ?? VB, this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer), this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
        }
        _onRemoveRelayPeer = (e)=>{
            this.log("relay removed %p our relay %p", e.detail.relay, this.relay, this.relay?.equals(e.detail.relay)), this.relay?.equals(e.detail.relay) === !0 && (this.log("relay peer removed %p", e.detail.relay), this.listeningAddrs.forEach((t)=>{
                this.addressManager.removeObservedAddr(t);
            }), this.listeningAddrs = [], this.safeDispatchEvent("listening"));
        };
        _onAddRelayPeer = (e)=>{
            const { details: t } = e.detail;
            t.type !== "configured" && t.id === this.reservationId && this.addedRelay(e.detail);
        };
        async listen(e) {
            if (QB.exactMatch(e)) this.log("searching for circuit relay servers"), this.reservationId = this.reservationStore.reserveRelay();
            else if (HB.exactMatch(e)) {
                this.log("listen on specific relay server %a", e);
                const t = AbortSignal.timeout(this.listenTimeout), r = e.decapsulate("/p2p-circuit"), s = await this.connectionManager.openConnection(r, {
                    signal: t
                });
                if (!this.reservationStore.hasReservation(s.remotePeer)) {
                    this.log("making reservation on peer %p", s.remotePeer);
                    const i = await this.reservationStore.addRelay(s.remotePeer, "configured");
                    this.addedRelay(i);
                }
            } else throw new C4(`Could not listen on p2p-circuit address "${e}"`);
        }
        getAddrs() {
            return [
                ...this.listeningAddrs.values()
            ].flat();
        }
        updateAnnounceAddrs() {}
        async close() {
            this.reservationStore.cancelReservations(), this.listeningAddrs = [], this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer), queueMicrotask(()=>{
                this.safeDispatchEvent("close");
            });
        }
        addedRelay(e) {
            this.log("relay peer added %p", e.relay), this.relay = e.relay, this.listeningAddrs = e.details.reservation.addrs.map((t)=>Ho(t).encapsulate("/p2p-circuit")), this.listeningAddrs.forEach((t)=>{
                this.addressManager.confirmObservedAddr(t, {
                    type: "transport"
                });
            }), queueMicrotask(()=>{
                this.safeDispatchEvent("listening");
            });
        }
    }
    function fhe(n) {
        return new dhe(n);
    }
    const phe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    let ghe = (n = 21)=>{
        let e = "", t = crypto.getRandomValues(new Uint8Array(n |= 0));
        for(; n--;)e += phe[t[n] & 63];
        return e;
    };
    const mhe = 60 * 1e3 * 10, yhe = 60 * 1e3 * 5, whe = 30 * 1e3;
    class bhe extends Lt {
        peerId;
        connectionManager;
        peerStore;
        events;
        reserveQueue;
        reservations;
        pendingReservations;
        maxReservationQueueLength;
        reservationCompletionTimeout;
        started;
        log;
        relayFilter;
        constructor(e, t){
            super(), this.log = e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"), this.peerId = e.peerId, this.connectionManager = e.connectionManager, this.peerStore = e.peerStore, this.events = e.events, this.reservations = new lhe, this.pendingReservations = [], this.maxReservationQueueLength = t?.maxReservationQueueLength ?? rhe, this.reservationCompletionTimeout = t?.reservationCompletionTimeout ?? VB, this.started = !1, this.relayFilter = Wi(100), this.reserveQueue = new Wo({
                concurrency: t?.reservationConcurrency ?? nhe,
                metricName: "libp2p_relay_reservation_queue",
                metrics: e.metrics
            }), this.events.addEventListener("connection:close", (r)=>{
                [
                    ...this.reservations.values()
                ].find((i)=>i.connection === r.detail.id) != null && this.#t(r.detail.remotePeer).catch((i)=>{
                    this.log("could not remove relay %p - %e", r.detail, i);
                });
            });
        }
        isStarted() {
            return this.started;
        }
        start() {
            this.started = !0;
        }
        afterStart() {
            Promise.resolve().then(async ()=>{
                const e = await this.peerStore.all({
                    filters: [
                        (t)=>t.tags.has(z0)
                    ]
                });
                this.log("removing tag from %d old relays", e.length), await Promise.all(e.map(async (t)=>{
                    await this.peerStore.merge(t.id, {
                        tags: {
                            [z0]: void 0
                        }
                    });
                })), this.log("redialing %d old relays", e.length), await Promise.all(e.map(async (t)=>this.addRelay(t.id, "discovered"))), this.#n();
            }).catch((e)=>{
                this.log.error("failed to clean up and redial old relays during afterStart - %e", e);
            });
        }
        stop() {
            this.reserveQueue.clear(), this.reservations.forEach(({ timeout: e })=>{
                clearTimeout(e);
            }), this.reservations.clear(), this.started = !1;
        }
        reserveRelay() {
            const e = ghe();
            return this.pendingReservations.push(e), this.#n(), e;
        }
        async addRelay(e, t) {
            if (this.peerId.equals(e)) throw this.log.trace("not trying to use self as relay"), new C4("Cannot use self as relay");
            if (this.reserveQueue.size > this.maxReservationQueueLength) throw new ahe("The reservation queue is full");
            const r = this.reserveQueue.find(e);
            if (r != null) return this.log.trace("potential relay peer %p is already in the reservation queue", e), r.join();
            if (this.relayFilter.has(e.toMultihash().bytes)) throw new C4("The relay was previously invalid");
            return this.log.trace("try to reserve relay slot with %p", e), this.reserveQueue.add(async ()=>{
                const s = Date.now();
                try {
                    const i = this.reservations.get(e);
                    if (i != null) {
                        const S = this.connectionManager.getConnections(e);
                        let _ = !1;
                        if (S.length === 0 && this.log("already have relay reservation with %p but we are no longer connected", e), S.map((I)=>I.id).includes(i.connection) && (this.log("already have relay reservation with %p and the original connection is still open", e), _ = !0), _ && bA(i.reservation.expire) > mhe) return this.log("already have relay reservation with %p but we are still connected and it does not expire soon", e), {
                            relay: e,
                            details: i
                        };
                        await this.#t(e);
                    }
                    if (t === "discovered" && this.pendingReservations.length === 0) throw new wA("Not making reservation on discovered relay because we do not need any more relays");
                    const l = AbortSignal.timeout(this.reservationCompletionTimeout);
                    const u = await this.connectionManager.openConnection(e, {
                        signal: l
                    });
                    if (di.matches(u.remoteAddr)) throw new ohe("not creating reservation over relayed connection");
                    const h = await this.#e(u, {
                        signal: l
                    }), f = bA(h.expire);
                    this.log("created reservation on relay peer %p, expiry date is %s", e, new Date(Date.now() + f).toString());
                    const p = Math.min(Math.max(f - yhe, whe), Math.pow(2, 31) - 1), m = setTimeout(()=>{
                        this.log("refresh reservation to relay %p", e), this.addRelay(e, t).catch(async (S)=>{
                            this.log.error("could not refresh reservation to relay %p - %e", e, S), await this.#t(e);
                        }).catch((S)=>{
                            this.log.error("could not remove expired reservation to relay %p - %e", e, S);
                        });
                    }, p);
                    let w;
                    if (t === "discovered") {
                        const S = this.pendingReservations.pop();
                        if (S == null) throw new wA("Made reservation on relay but did not need any more discovered relays");
                        w = {
                            timeout: m,
                            reservation: h,
                            type: t,
                            connection: u.id,
                            id: S
                        };
                    } else w = {
                        timeout: m,
                        reservation: h,
                        type: t,
                        connection: u.id
                    };
                    this.reservations.set(e, w), await this.peerStore.merge(e, {
                        tags: {
                            [z0]: {
                                value: 1,
                                ttl: f
                            }
                        }
                    }), this.#n();
                    const A = {
                        relay: e,
                        details: w
                    };
                    return this.safeDispatchEvent("relay:created-reservation", {
                        detail: A
                    }), A;
                } catch (i) {
                    throw t === "discovered" && i.name === "HadEnoughRelaysError" || this.log.error("could not reserve slot on %p after %dms - %e", e, Date.now() - s, i), (i.name === "DialError" || i.name === "UnsupportedProtocolError") && this.relayFilter.add(e.toMultihash().bytes), this.#t(e).catch((l)=>{
                        this.log.error("could not remove reservation on %p after reserving slot failed - %e", e, l);
                    }), i;
                }
            }, {
                peerId: e
            });
        }
        hasReservation(e) {
            return this.reservations.has(e);
        }
        getReservation(e) {
            return this.reservations.get(e)?.reservation;
        }
        reservationCount(e) {
            return e == null ? this.reservations.size : [
                ...this.reservations.values()
            ].reduce((t, r)=>(r.type === e && t++, t), 0);
        }
        cancelReservations() {
            [
                ...this.reservations.values()
            ].forEach((e)=>{
                clearTimeout(e.timeout);
            }), this.reservations.clear();
        }
        async #e(e, t) {
            t.signal?.throwIfAborted(), this.log("requesting reservation from %p", e.remotePeer);
            const r = await e.newStream(Jp, t), i = Jn(r).pb(qc);
            this.log.trace("send RESERVE to %p", e.remotePeer), await i.write({
                type: qc.Type.RESERVE
            }, t);
            let l;
            try {
                this.log.trace("reading response from %p", e.remotePeer), l = await i.read(t);
            } catch (h) {
                throw r.abort(h), h;
            } finally{
                r.status !== "closed" && await r.close(t);
            }
            if (this.log.trace("read response %s", l.status), l.status === tr.OK && l.reservation != null) {
                const h = new Set;
                h.add(e.remoteAddr.toString());
                for (const f of l.reservation.addrs){
                    let p = Ho(f);
                    p.getComponents().find((m)=>m.code === Xp) == null && (p = p.encapsulate(`/p2p/${e.remotePeer}`)), p = Ho(p.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`, `/p2p/${e.remotePeer}`)), h.add(p.toString());
                }
                return l.reservation.addrs = [
                    ...h
                ].map((f)=>Ho(f).bytes), l.reservation;
            }
            const u = `reservation failed with status ${l.status ?? "undefined"}`;
            throw this.log.error(u), new Error(u);
        }
        async #t(e) {
            const t = this.reservations.get(e);
            t != null && (this.log("removing relay reservation with %p from local store", e), clearTimeout(t.timeout), this.reservations.delete(e), t.type === "discovered" && this.pendingReservations.push(t.id), await this.peerStore.merge(e, {
                tags: {
                    [z0]: void 0
                }
            }), this.safeDispatchEvent("relay:removed", {
                detail: {
                    relay: e,
                    details: t
                }
            }), this.#n());
        }
        #n() {
            if (this.pendingReservations.length === 0) {
                this.log.trace("have discovered enough relays"), this.reserveQueue.clear(), this.safeDispatchEvent("relay:found-enough-relays");
                return;
            }
            this.relayFilter = Wi(100), this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length), this.safeDispatchEvent("relay:not-enough-relays");
        }
    }
    class vhe extends D6 {
        stream;
        init;
        constructor(e){
            super({
                ...e,
                direction: e.stream.direction
            }), this.init = e, this.stream = e.stream, this.stream.addEventListener("close", (t)=>{
                this.onTransportClosed(t.error);
            }), this.stream.addEventListener("remoteCloseWrite", (t)=>{
                this.onRemoteCloseWrite(), this.close().catch((r)=>{
                    this.abort(r);
                });
            }), this.stream.addEventListener("message", (t)=>{
                e.onDataRead?.(t.data), this.onData(t.data);
            }), this.stream.addEventListener("drain", ()=>{
                this.safeDispatchEvent("drain");
            });
        }
        sendData(e) {
            return this.init.onDataWrite?.(e), {
                sentBytes: e.byteLength,
                canSendMore: this.stream.send(e)
            };
        }
        async sendClose(e) {
            await this.stream.close(e);
        }
        sendReset() {
            this.stream.abort(new Error("An error occurred"));
        }
        sendPause() {
            this.stream.pause();
        }
        sendResume() {
            this.stream.resume();
        }
    }
    function AA(n) {
        return new vhe(n);
    }
    const Ehe = (n)=>{
        if (n.peer == null) return !1;
        try {
            n.peer.addrs.forEach(Ho);
        } catch  {
            return !1;
        }
        return !0;
    }, SA = {
        maxInboundStopStreams: yA,
        maxOutboundStopStreams: yA
    };
    class Ahe {
        components;
        discovery;
        reservationStore;
        maxInboundStopStreams;
        maxOutboundStopStreams;
        started;
        log;
        shutdownController;
        constructor(e, t = {}){
            this.components = e, this.log = e.logger.forComponent("libp2p:circuit-relay:transport"), this.maxInboundStopStreams = t.maxInboundStopStreams ?? SA.maxInboundStopStreams, this.maxOutboundStopStreams = t.maxOutboundStopStreams ?? SA.maxOutboundStopStreams, this.shutdownController = new AbortController, this.discovery = new hhe(e, {
                filter: t.discoveryFilter ?? uhe(she, ihe)
            }), this.discovery.addEventListener("relay:discover", (r)=>{
                this.reservationStore.addRelay(r.detail, "discovered").catch((s)=>{
                    s.name !== "HadEnoughRelaysError" && s.name !== "RelayQueueFullError" && this.log.error("could not add discovered relay %p - %e", r.detail, s);
                });
            }), this.reservationStore = new bhe(e, t), this.reservationStore.addEventListener("relay:not-enough-relays", ()=>{
                this.discovery?.startDiscovery();
            }), this.reservationStore.addEventListener("relay:found-enough-relays", ()=>{
                this.discovery?.stopDiscovery();
            }), this.started = !1, this.onStop = this.onStop.bind(this);
        }
        [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
        [Oce] = [
            "@libp2p/transport",
            "@libp2p/circuit-relay-v2-transport"
        ];
        get [$ce]() {
            return this.discovery != null ? [
                "@libp2p/identify"
            ] : [];
        }
        [Rce] = !0;
        isStarted() {
            return this.started;
        }
        async start() {
            this.shutdownController = new AbortController, this.shutdownController.signal, await this.components.registrar.handle(mA, this.onStop, {
                maxInboundStreams: this.maxInboundStopStreams,
                maxOutboundStreams: this.maxOutboundStopStreams,
                runOnLimitedConnection: !0
            }), await Pce(this.discovery, this.reservationStore), this.started = !0;
        }
        async stop() {
            this.shutdownController.abort(), await kce(this.discovery, this.reservationStore), await this.components.registrar.unhandle(mA), this.started = !1;
        }
        async dial(e, t) {
            const r = e.toString().split("/p2p-circuit"), s = Ho(r[0]), i = Ho(r[r.length - 1]), l = s.getComponents().find((A)=>A.code === Xp)?.value, u = i.getComponents().find((A)=>A.code === Xp)?.value;
            if (l == null || u == null) {
                const A = `ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;
                throw this.log.error(`c${A}`), new Dce(`C${A}`);
            }
            const h = dA(l), f = dA(u);
            let m = this.components.connectionManager.getConnections(h)[0];
            m == null ? (await this.components.peerStore.merge(h, {
                multiaddrs: [
                    s
                ]
            }), t.onProgress?.(new Be("circuit-relay:open-connection")), m = await this.components.connectionManager.openConnection(h, t)) : t.onProgress?.(new Be("circuit-relay:reuse-connection"));
            let w;
            try {
                t.onProgress?.(new Be("circuit-relay:open-hop-stream")), w = await m.newStream(Jp, t);
                const A = Jn(w).pb(qc);
                t.onProgress?.(new Be("circuit-relay:write-connect-message")), await A.write({
                    type: qc.Type.CONNECT,
                    peer: {
                        id: f.toMultihash().bytes,
                        addrs: [
                            Ho(i).bytes
                        ]
                    }
                }, t), t.onProgress?.(new Be("circuit-relay:read-connect-response"));
                const S = await A.read(t);
                if (S.status !== tr.OK) throw new xce(`failed to connect via relay with status ${S?.status?.toString() ?? "undefined"}`);
                const _ = new vA(S.limit), I = AA({
                    stream: A.unwrap().unwrap(),
                    remoteAddr: e,
                    localAddr: s.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),
                    onDataRead: _.onData,
                    onDataWrite: _.onData,
                    log: w.log.newScope("circuit-relay:connection")
                }), k = await this.components.upgrader.upgradeOutbound(I, {
                    ...t,
                    limits: _.getLimits()
                });
                return k.log("outbound relayed connection established to %p with limits %o, over connection %s", k.remotePeer, S.limit ?? "none", m.id), k;
            } catch (A) {
                throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e", f, h, A), w?.abort(A), A;
            }
        }
        createListener(e) {
            return fhe({
                peerId: this.components.peerId,
                connectionManager: this.components.connectionManager,
                addressManager: this.components.addressManager,
                reservationStore: this.reservationStore,
                logger: this.components.logger
            });
        }
        listenFilter(e) {
            return e = Array.isArray(e) ? e : [
                e
            ], e.filter((t)=>HB.exactMatch(t) || QB.exactMatch(t));
        }
        dialFilter(e) {
            return e = Array.isArray(e) ? e : [
                e
            ], e.filter((t)=>di.exactMatch(t));
        }
        async onStop(e, t) {
            const r = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
            try {
                if (!this.reservationStore.hasReservation(t.remotePeer)) try {
                    this.log("dialed via relay we did not have a reservation on, start listening on that relay address"), await this.components.transportManager.listen([
                        t.remoteAddr.encapsulate("/p2p-circuit")
                    ]);
                } catch (m) {
                    this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e", m);
                }
                const s = Jn(e).pb(Vi), i = await s.read({
                    signal: r
                });
                if (this.log("new circuit relay v2 stop stream from %p with type %s", t.remotePeer, i.type), i?.type === void 0) {
                    this.log.error("type was missing from circuit v2 stop protocol request from %s", t.remotePeer), await s.write({
                        type: Vi.Type.STATUS,
                        status: tr.MALFORMED_MESSAGE
                    }, {
                        signal: r
                    }), await e.close({
                        signal: r
                    });
                    return;
                }
                if (i.type !== Vi.Type.CONNECT) {
                    this.log.error("invalid stop connect request via peer %p", t.remotePeer), await s.write({
                        type: Vi.Type.STATUS,
                        status: tr.UNEXPECTED_MESSAGE
                    }, {
                        signal: r
                    }), await e.close({
                        signal: r
                    });
                    return;
                }
                if (!Ehe(i)) {
                    this.log.error("invalid stop connect request via peer %p", t.remotePeer), await s.write({
                        type: Vi.Type.STATUS,
                        status: tr.MALFORMED_MESSAGE
                    }, {
                        signal: r
                    }), await e.close({
                        signal: r
                    });
                    return;
                }
                const l = k8(kt(i.peer.id));
                if (await this.components.connectionGater.denyInboundRelayedConnection?.(t.remotePeer, l) === !0) {
                    this.log.error("connection gater denied inbound relayed connection from %p", t.remotePeer), await s.write({
                        type: Vi.Type.STATUS,
                        status: tr.PERMISSION_DENIED
                    }, {
                        signal: r
                    }), await e.close({
                        signal: r
                    });
                    return;
                }
                this.log.trace("sending success response to %p", t.remotePeer), await s.write({
                    type: Vi.Type.STATUS,
                    status: tr.OK
                }, {
                    signal: r
                });
                const u = new vA(i.limit), h = t.remoteAddr.encapsulate(`/p2p-circuit/p2p/${l.toString()}`), f = this.components.addressManager.getAddresses()[0], p = AA({
                    stream: s.unwrap().unwrap(),
                    remoteAddr: h,
                    localAddr: f,
                    onDataRead: u.onData,
                    onDataWrite: u.onData,
                    log: e.log.newScope("circuit-relay:connection")
                });
                await this.components.upgrader.upgradeInbound(p, {
                    limits: u.getLimits(),
                    signal: r
                }), p.log("inbound relayed connection established to %p with limits %o, over connection %s", l, i.limit ?? "none", t.id);
            } finally{
                r?.clear();
            }
        }
    }
    function qB(n = {}) {
        return (e)=>new Ahe(e, n);
    }
    let Gl = class extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    };
    const She = Symbol.for("@libp2p/service-dependencies");
    let ys = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, pf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, Ihe = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, Che = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const The = 4, _he = 6, xhe = 273, Dhe = 33, Bhe = 41, Phe = 42, khe = 43, Rhe = 53, Ohe = 54, $he = 55, Mhe = 56, Nhe = 132, Lhe = 301, Uhe = 302, zhe = 400, KB = 421, Fhe = 444, Vhe = 445, Hhe = 446, Qhe = 447, qhe = 448, Khe = 449, Ghe = 454, Yhe = 460, Whe = 461, jhe = 465, Xhe = 466, Jhe = 480, Zhe = 481, ede = 443, tde = 477, nde = 478, rde = 479, sde = 277, ide = 275, ode = 276, ade = 280, lde = 281, cde = 290, ude = 777;
    function IA(n) {
        return (e)=>L(e, n);
    }
    function CA(n) {
        return (e)=>re(e, n);
    }
    function rd(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function cc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function hde(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = cc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function dde(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = cc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function TA(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = rd(t);
        return `${r}:${s}`;
    }
    const GB = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new ys("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, fde = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = GB(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new ys("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, pde = function(n) {
        if (n.byteLength !== 4) throw new ys("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, gde = function(n) {
        if (n.byteLength !== 16) throw new ys("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new ys(`Invalid IPv6 address "${t}"`);
        }
    };
    function mde(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new ys(`Invalid IPv6 address "${n}"`);
        }
    }
    const uy = Object.values(un).map((n)=>n.decoder), yde = (function() {
        let n = uy[0].or(uy[1]);
        return uy.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function wde(n) {
        return yde.decode(n);
    }
    function bde(n) {
        return (e)=>n.encoder.encode(e);
    }
    function vde(n) {
        if (parseInt(n).toString() !== n) throw new pf("Value must be an integer");
    }
    function Ede(n) {
        if (n < 0) throw new pf("Value must be a positive integer, or zero");
    }
    function Ade(n) {
        return (e)=>{
            if (e > n) throw new pf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function Sde(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const F0 = Sde(vde, Ede, Ade(65535)), zn = -1;
    let Ide = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new Che(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const wu = new Ide, Cde = [
        {
            code: The,
            name: "ip4",
            size: 32,
            valueToBytes: GB,
            bytesToValue: pde,
            validate: (n)=>{
                if (!Je(n)) throw new pf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: _he,
            name: "tcp",
            size: 16,
            valueToBytes: cc,
            bytesToValue: rd,
            validate: F0
        },
        {
            code: xhe,
            name: "udp",
            size: 16,
            valueToBytes: cc,
            bytesToValue: rd,
            validate: F0
        },
        {
            code: Dhe,
            name: "dccp",
            size: 16,
            valueToBytes: cc,
            bytesToValue: rd,
            validate: F0
        },
        {
            code: Bhe,
            name: "ip6",
            size: 128,
            valueToBytes: fde,
            bytesToValue: gde,
            stringToValue: mde,
            validate: (n)=>{
                if (!xn(n)) throw new pf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: Phe,
            name: "ip6zone",
            size: zn
        },
        {
            code: khe,
            name: "ipcidr",
            size: 8,
            bytesToValue: IA("base10"),
            valueToBytes: CA("base10")
        },
        {
            code: Rhe,
            name: "dns",
            size: zn
        },
        {
            code: Ohe,
            name: "dns4",
            size: zn
        },
        {
            code: $he,
            name: "dns6",
            size: zn
        },
        {
            code: Mhe,
            name: "dnsaddr",
            size: zn
        },
        {
            code: Nhe,
            name: "sctp",
            size: 16,
            valueToBytes: cc,
            bytesToValue: rd,
            validate: F0
        },
        {
            code: Lhe,
            name: "udt"
        },
        {
            code: Uhe,
            name: "utp"
        },
        {
            code: zhe,
            name: "unix",
            size: zn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: KB,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: zn,
            bytesToValue: IA("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? CA("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: Fhe,
            name: "onion",
            size: 96,
            bytesToValue: TA,
            valueToBytes: hde
        },
        {
            code: Vhe,
            name: "onion3",
            size: 296,
            bytesToValue: TA,
            valueToBytes: dde
        },
        {
            code: Hhe,
            name: "garlic64",
            size: zn
        },
        {
            code: Qhe,
            name: "garlic32",
            size: zn
        },
        {
            code: qhe,
            name: "tls"
        },
        {
            code: Khe,
            name: "sni",
            size: zn
        },
        {
            code: Ghe,
            name: "noise"
        },
        {
            code: Yhe,
            name: "quic"
        },
        {
            code: Whe,
            name: "quic-v1"
        },
        {
            code: jhe,
            name: "webtransport"
        },
        {
            code: Xhe,
            name: "certhash",
            size: zn,
            bytesToValue: bde(yn),
            valueToBytes: wde
        },
        {
            code: Jhe,
            name: "http"
        },
        {
            code: Zhe,
            name: "http-path",
            size: zn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: ede,
            name: "https"
        },
        {
            code: tde,
            name: "ws"
        },
        {
            code: nde,
            name: "wss"
        },
        {
            code: rde,
            name: "p2p-websocket-star"
        },
        {
            code: sde,
            name: "p2p-stardust"
        },
        {
            code: ide,
            name: "p2p-webrtc-star"
        },
        {
            code: ode,
            name: "p2p-webrtc-direct"
        },
        {
            code: ade,
            name: "webrtc-direct"
        },
        {
            code: lde,
            name: "webrtc"
        },
        {
            code: cde,
            name: "p2p-circuit"
        },
        {
            code: ude,
            name: "memory",
            size: zn
        }
    ];
    Cde.forEach((n)=>{
        wu.addProtocol(n);
    });
    function Tde(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = wu.getProtocol(r), i = be(r), l = Bde(s, n, t + i);
            let u = 0;
            l > 0 && s.size === zn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function _de(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = wu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === zn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === zn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function xde(n) {
        if (n.charAt(0) !== "/") throw new ys('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = wu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new ys(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new ys(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new ys("Incomplete multiaddr");
        return e;
    }
    function Dde(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = wu.getProtocol(e.code);
            if (t == null) throw new ys(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function Bde(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const Pde = Symbol.for("nodejs.util.inspect.custom"), YB = Symbol.for("@multiformats/multiaddr");
    function kde(n) {
        if (n == null && (n = "/"), $de(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Tde(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), xde(n);
        if (Array.isArray(n)) return n;
        throw new ys("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let Rde = class sd {
        [YB] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = kde(e), t.validate !== !1 && Ode(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = _de(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = Dde(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new sd(e);
            return new sd([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new Ihe(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new sd(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new sd(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [Pde]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function Ode(n) {
        n.getComponents().forEach((e)=>{
            const t = wu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function $de(n) {
        return !!n?.[YB];
    }
    function _A(n) {
        return new Rde(n);
    }
    var Js;
    (function(n) {
        (function(r) {
            r.UNUSED = "UNUSED", r.CONNECT = "CONNECT", r.SYNC = "SYNC";
        })(n.Type || (n.Type = {}));
        let e;
        (function(r) {
            r[r.UNUSED = 0] = "UNUSED", r[r.CONNECT = 100] = "CONNECT", r[r.SYNC = 300] = "SYNC";
        })(e || (e = {})), (function(r) {
            r.codec = ()=>vr(e);
        })(n.Type || (n.Type = {}));
        let t;
        n.codec = ()=>(t == null && (t = Le((r, s, i = {})=>{
                if (i.lengthDelimited !== !1 && s.fork(), r.type != null && (s.uint32(8), n.Type.codec().encode(r.type, s)), r.observedAddresses != null) for (const l of r.observedAddresses)s.uint32(18), s.bytes(l);
                i.lengthDelimited !== !1 && s.ldelim();
            }, (r, s, i = {})=>{
                const l = {
                    observedAddresses: []
                }, u = s == null ? r.len : r.pos + s;
                for(; r.pos < u;){
                    const h = r.uint32();
                    switch(h >>> 3){
                        case 1:
                            {
                                l.type = n.Type.codec().decode(r);
                                break;
                            }
                        case 2:
                            {
                                if (i.limits?.observedAddresses != null && l.observedAddresses.length === i.limits.observedAddresses) throw new vt('Decode error - map field "observedAddresses" had too many elements');
                                l.observedAddresses.push(r.bytes());
                                break;
                            }
                        default:
                            {
                                r.skipType(h & 7);
                                break;
                            }
                    }
                }
                return l;
            })), t), n.encode = (r)=>Ne(r, n.codec()), n.decode = (r, s)=>Me(r, n.codec(), s);
    })(Js || (Js = {}));
    function xA(n, e) {
        return di.matches(n) || e.dialTransportForMultiaddr(n) == null ? !1 : d_.matches(n) ? !0 : EG.matches(n) ? !Is(n) : !1;
    }
    const DA = 1024 * 4, BA = 100, V0 = {
        timeout: 5e3,
        retries: 3,
        maxInboundStreams: 1,
        maxOutboundStreams: 1
    };
    class Mde {
        started;
        timeout;
        retries;
        maxInboundStreams;
        maxOutboundStreams;
        peerStore;
        registrar;
        connectionManager;
        addressManager;
        transportManager;
        topologyId;
        log;
        constructor(e, t){
            this.log = e.logger.forComponent("libp2p:dcutr"), this.started = !1, this.peerStore = e.peerStore, this.registrar = e.registrar, this.addressManager = e.addressManager, this.connectionManager = e.connectionManager, this.transportManager = e.transportManager, this.timeout = t.timeout ?? V0.timeout, this.retries = t.retries ?? V0.retries, this.maxInboundStreams = t.maxInboundStreams ?? V0.maxInboundStreams, this.maxOutboundStreams = t.maxOutboundStreams ?? V0.maxOutboundStreams, this.handleIncomingUpgrade = this.handleIncomingUpgrade.bind(this);
        }
        [Symbol.toStringTag] = "@libp2p/dcutr";
        [She] = [
            "@libp2p/identify"
        ];
        isStarted() {
            return this.started;
        }
        async start() {
            this.started || (this.topologyId = await this.registrar.register(H0, {
                notifyOnLimitedConnection: !0,
                onConnect: (e, t)=>{
                    di.exactMatch(t.remoteAddr) && t.direction === "inbound" && this.upgradeInbound(t).catch((r)=>{
                        this.log.error("error during outgoing DCUtR attempt - %e", r);
                    });
                }
            }), await this.registrar.handle(H0, this.handleIncomingUpgrade, {
                maxInboundStreams: this.maxInboundStreams,
                maxOutboundStreams: this.maxOutboundStreams,
                runOnLimitedConnection: !0
            }), this.started = !0);
        }
        async stop() {
            await this.registrar.unhandle(H0), this.topologyId != null && this.registrar.unregister(this.topologyId), this.started = !1;
        }
        async upgradeInbound(e) {
            if (await this.attemptUnilateralConnectionUpgrade(e)) return;
            let t;
            for(let r = 0; r < this.retries; r++){
                const s = {
                    signal: AbortSignal.timeout(this.timeout)
                };
                try {
                    t = await e.newStream([
                        H0
                    ], {
                        signal: s.signal,
                        runOnLimitedConnection: !0
                    });
                    const i = Jn(t, {
                        maxDataLength: DA
                    }).pb(Js);
                    this.log("B sending connect to %p", e.remotePeer);
                    const l = Date.now();
                    await i.write({
                        type: Js.Type.CONNECT,
                        observedAddresses: this.addressManager.getAddresses().map((m)=>m.bytes)
                    }, s), this.log("B receiving connect from %p", e.remotePeer);
                    const u = await i.read(s);
                    if (u.type !== Js.Type.CONNECT) throw this.log("A sent wrong message type"), new Gl("DCUtR message type was incorrect");
                    const h = this.getDialableMultiaddrs(u.observedAddresses);
                    if (h.length === 0) throw this.log("A did not have any dialable multiaddrs"), new Gl("DCUtR connect message had no multiaddrs");
                    const f = Date.now() - l;
                    this.log("A sending sync, rtt %dms", f), await i.write({
                        type: Js.Type.SYNC,
                        observedAddresses: []
                    }, s), this.log("A waiting for half RTT"), await XV(f / 2), this.log("B dialing", h);
                    const p = await this.connectionManager.openConnection(h, {
                        signal: s.signal,
                        priority: BA,
                        force: !0,
                        initiator: !1
                    });
                    this.log("DCUtR to %p succeeded to address %a, closing relayed connection", e.remotePeer, p.remoteAddr), await e.close(s);
                    break;
                } catch (i) {
                    if (this.log.error("error while attempting DCUtR on attempt %d of %d - %e", r + 1, this.retries, i), t?.abort(i), r === this.retries) throw i;
                } finally{
                    t != null && await t.close(s);
                }
            }
        }
        async attemptUnilateralConnectionUpgrade(e) {
            const r = (await this.peerStore.get(e.remotePeer)).addresses.map((s)=>{
                const i = s.multiaddr;
                return i.getComponents().find((l)=>l.code === KB)?.value == null ? i.encapsulate(`/p2p/${e.remotePeer}`) : i;
            }).filter((s)=>xA(s, this.transportManager));
            if (r.length > 0) {
                const s = AbortSignal.timeout(this.timeout);
                try {
                    this.log("attempting unilateral connection upgrade to %a", r);
                    const i = await this.connectionManager.openConnection(r, {
                        signal: s,
                        force: !0
                    });
                    if (di.exactMatch(i.remoteAddr)) throw new Error("Could not open a new, non-limited, connection");
                    return this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection", e.remotePeer, i.remoteAddr), await e.close({
                        signal: s
                    }), !0;
                } catch (i) {
                    this.log.error("unilateral connection upgrade to %p on addresses %a failed - %e", e.remotePeer, r, i);
                }
            } else this.log("peer %p has no public addresses, not attempting unilateral connection upgrade", e.remotePeer);
            return !1;
        }
        async handleIncomingUpgrade(e, t) {
            const r = {
                signal: AbortSignal.timeout(this.timeout)
            }, s = Jn(e, {
                maxDataLength: DA
            }).pb(Js);
            this.log("A receiving connect");
            const i = await s.read(r);
            if (i.type !== Js.Type.CONNECT) throw this.log("B sent wrong message type"), new Gl("DCUtR message type was incorrect");
            if (i.observedAddresses.length === 0) throw this.log("B sent no multiaddrs"), new Gl("DCUtR connect message had no multiaddrs");
            const l = this.getDialableMultiaddrs(i.observedAddresses);
            if (l.length === 0) throw this.log("B had no dialable multiaddrs in %o", i.observedAddresses.map((f)=>_A(f))), new Gl("DCUtR connect message had no dialable multiaddrs");
            if (this.log("A sending connect"), await s.write({
                type: Js.Type.CONNECT,
                observedAddresses: this.addressManager.getAddresses().map((f)=>f.bytes)
            }), this.log("A receiving sync"), (await s.read(r)).type !== Js.Type.SYNC) throw new Gl("DCUtR message type was incorrect");
            this.log("A dialing", l);
            const h = await this.connectionManager.openConnection(l, {
                signal: r.signal,
                priority: BA,
                force: !0
            });
            this.log("DCUtR to %p succeeded via %a, closing relayed connection", t.remotePeer, h.remoteAddr), await t.close(r), await e.close(r);
        }
        getDialableMultiaddrs(e) {
            const t = [];
            for (const r of e)if (!(r == null || r.length === 0)) try {
                const s = _A(r);
                if (!xA(s, this.transportManager)) continue;
                t.push(s);
            } catch  {}
            return t;
        }
    }
    const H0 = "/libp2p/dcutr";
    function Nde(n = {}) {
        return (e)=>new Mde(e, n);
    }
    function Ce(n) {
        if (n !== void 0 && n !== Ce.REQUEST && n !== Ce.RESPONSE) throw new Error("type must be REQUEST or RESPONSE");
        n === void 0 || this.initialize(n), this.maxHeaderSize = Ce.maxHeaderSize;
    }
    Ce.prototype.initialize = function(n, e) {
        if (n !== Ce.REQUEST && n !== Ce.RESPONSE) throw new Error("type must be REQUEST or RESPONSE");
        this.type = n, this.state = n + "_LINE", this.info = {
            headers: [],
            upgrade: !1
        }, this.trailers = [], this.line = "", this.isChunked = !1, this.connection = "", this.headerSize = 0, this.body_bytes = null, this.isUserCall = !1, this.hadError = !1;
    };
    Ce.encoding = "ascii";
    Ce.maxHeaderSize = 80 * 1024;
    Ce.REQUEST = "REQUEST";
    Ce.RESPONSE = "RESPONSE";
    var WB = Ce.kOnHeaders = 1, _4 = Ce.kOnHeadersComplete = 2, Mg = Ce.kOnBody = 3, O8 = Ce.kOnMessageComplete = 4;
    Ce.prototype[WB] = Ce.prototype[_4] = Ce.prototype[Mg] = Ce.prototype[O8] = function() {};
    var jB = !0;
    Object.defineProperty(Ce, "kOnExecute", {
        get: function() {
            return jB = !1, 99;
        }
    });
    const XB = Ce.methods = [
        "DELETE",
        "GET",
        "HEAD",
        "POST",
        "PUT",
        "CONNECT",
        "OPTIONS",
        "TRACE",
        "COPY",
        "LOCK",
        "MKCOL",
        "MOVE",
        "PROPFIND",
        "PROPPATCH",
        "SEARCH",
        "UNLOCK",
        "BIND",
        "REBIND",
        "UNBIND",
        "ACL",
        "REPORT",
        "MKACTIVITY",
        "CHECKOUT",
        "MERGE",
        "M-SEARCH",
        "NOTIFY",
        "SUBSCRIBE",
        "UNSUBSCRIBE",
        "PATCH",
        "PURGE",
        "MKCALENDAR",
        "LINK",
        "UNLINK",
        "SOURCE"
    ];
    var JB = XB.indexOf("CONNECT");
    Ce.prototype.reinitialize = Ce;
    Ce.prototype.close = Ce.prototype.pause = Ce.prototype.resume = Ce.prototype.remove = Ce.prototype.free = function() {};
    Ce.prototype._compatMode0_11 = !1;
    Ce.prototype.getAsyncId = function() {
        return 0;
    };
    var Lde = {
        REQUEST_LINE: !0,
        RESPONSE_LINE: !0,
        HEADER: !0
    };
    Ce.prototype.execute = function(n, e, t) {
        if (!(this instanceof Ce)) throw new TypeError("not a HTTPParser");
        e = e || 0, t = typeof t == "number" ? t : n.length, this.chunk = n, this.offset = e;
        var r = this.end = e + t;
        try {
            for(; this.offset < r && !this[this.state](););
        } catch (s) {
            if (this.isUserCall) throw s;
            return this.hadError = !0, s;
        }
        return this.chunk = null, t = this.offset - e, Lde[this.state] && (this.headerSize += t, this.headerSize > (this.maxHeaderSize || Ce.maxHeaderSize)) ? new Error("max header size exceeded") : t;
    };
    var Ude = {
        REQUEST_LINE: !0,
        RESPONSE_LINE: !0,
        BODY_RAW: !0
    };
    Ce.prototype.finish = function() {
        if (!this.hadError) {
            if (!Ude[this.state]) return new Error("invalid state for EOF");
            this.state === "BODY_RAW" && this.userCall()(this[O8]());
        }
    };
    Ce.prototype.consume = Ce.prototype.unconsume = Ce.prototype.getCurrentBuffer = function() {};
    Ce.prototype.userCall = function() {
        this.isUserCall = !0;
        var n = this;
        return function(e) {
            return n.isUserCall = !1, e;
        };
    };
    Ce.prototype.nextRequest = function() {
        this.userCall()(this[O8]()), this.reinitialize(this.type);
    };
    Ce.prototype.consumeLine = function() {
        for(var n = this.end, e = this.chunk, t = this.offset; t < n; t++)if (e[t] === 10) {
            var r = this.line + L(e.subarray(this.offset, t), Ce.encoding);
            return r.charAt(r.length - 1) === "\r" && (r = r.substr(0, r.length - 1)), this.line = "", this.offset = t + 1, r;
        }
        this.line += L(e.subarray(this.offset, this.end), Ce.encoding), this.offset = this.end;
    };
    var zde = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/, Fde = /^[ \t]+(.*[^ \t])/;
    Ce.prototype.parseHeader = function(n, e) {
        if (n.indexOf("\r") !== -1) throw Ng("HPE_LF_EXPECTED");
        var t = zde.exec(n), r = t && t[1];
        if (r) e.push(r), e.push(t[2]);
        else {
            var s = Fde.exec(n);
            s && e.length && (e[e.length - 1] && (e[e.length - 1] += " "), e[e.length - 1] += s[1]);
        }
    };
    var Vde = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
    Ce.prototype.REQUEST_LINE = function() {
        var n = this.consumeLine();
        if (n) {
            var e = Vde.exec(n);
            if (e === null) throw Ng("HPE_INVALID_CONSTANT");
            if (this.info.method = this._compatMode0_11 ? e[1] : XB.indexOf(e[1]), this.info.method === -1) throw new Error("invalid request method");
            this.info.url = e[2], this.info.versionMajor = +e[3], this.info.versionMinor = +e[4], this.body_bytes = 0, this.state = "HEADER";
        }
    };
    var Hde = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
    Ce.prototype.RESPONSE_LINE = function() {
        var n = this.consumeLine();
        if (n) {
            var e = Hde.exec(n);
            if (e === null) throw Ng("HPE_INVALID_CONSTANT");
            this.info.versionMajor = +e[1], this.info.versionMinor = +e[2];
            var t = this.info.statusCode = +e[3];
            this.info.statusMessage = e[4], ((t / 100 | 0) === 1 || t === 204 || t === 304) && (this.body_bytes = 0), this.state = "HEADER";
        }
    };
    Ce.prototype.shouldKeepAlive = function() {
        if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
            if (this.connection.indexOf("close") !== -1) return !1;
        } else if (this.connection.indexOf("keep-alive") === -1) return !1;
        return !!(this.body_bytes !== null || this.isChunked);
    };
    Ce.prototype.HEADER = function() {
        var n = this.consumeLine();
        if (n !== void 0) {
            var e = this.info;
            if (n) this.parseHeader(n, e.headers);
            else {
                for(var t = e.headers, r = !1, s, i = !1, l = 0; l < t.length; l += 2)switch(t[l].toLowerCase()){
                    case "transfer-encoding":
                        this.isChunked = t[l + 1].toLowerCase() === "chunked";
                        break;
                    case "content-length":
                        if (s = +t[l + 1], r) {
                            if (s !== this.body_bytes) throw Ng("HPE_UNEXPECTED_CONTENT_LENGTH");
                        } else r = !0, this.body_bytes = s;
                        break;
                    case "connection":
                        this.connection += t[l + 1].toLowerCase();
                        break;
                    case "upgrade":
                        i = !0;
                        break;
                }
                this.isChunked && r && (r = !1, this.body_bytes = null), i && this.connection.indexOf("upgrade") != -1 ? e.upgrade = this.type === Ce.REQUEST || e.statusCode === 101 : e.upgrade = e.method === JB, this.isChunked && e.upgrade && (this.isChunked = !1), e.shouldKeepAlive = this.shouldKeepAlive();
                var u;
                if (jB ? u = this.userCall()(this[_4](e)) : u = this.userCall()(this[_4](e.versionMajor, e.versionMinor, e.headers, e.method, e.url, e.statusCode, e.statusMessage, e.upgrade, e.shouldKeepAlive)), u === 2) return this.nextRequest(), !0;
                if (this.isChunked && !u) this.state = "BODY_CHUNKHEAD";
                else {
                    if (u || this.body_bytes === 0) return this.nextRequest(), e.upgrade;
                    this.body_bytes === null ? this.state = "BODY_RAW" : this.state = "BODY_SIZED";
                }
            }
        }
    };
    Ce.prototype.BODY_CHUNKHEAD = function() {
        var n = this.consumeLine();
        n !== void 0 && (this.body_bytes = parseInt(n, 16), this.body_bytes ? this.state = "BODY_CHUNK" : this.state = "BODY_CHUNKTRAILERS");
    };
    Ce.prototype.BODY_CHUNK = function() {
        var n = Math.min(this.end - this.offset, this.body_bytes);
        this.userCall()(this[Mg](this.chunk.slice(this.offset, this.offset + n), 0, n)), this.offset += n, this.body_bytes -= n, this.body_bytes || (this.state = "BODY_CHUNKEMPTYLINE");
    };
    Ce.prototype.BODY_CHUNKEMPTYLINE = function() {
        var n = this.consumeLine();
        if (n !== void 0) {
            if (n !== "") throw new Error("Expected empty line");
            this.state = "BODY_CHUNKHEAD";
        }
    };
    Ce.prototype.BODY_CHUNKTRAILERS = function() {
        var n = this.consumeLine();
        n !== void 0 && (n ? this.parseHeader(n, this.trailers) : (this.trailers.length && this.userCall()(this[WB](this.trailers, "")), this.nextRequest()));
    };
    Ce.prototype.BODY_RAW = function() {
        this.userCall()(this[Mg](this.chunk.slice(this.offset, this.end), 0, this.end - this.offset)), this.offset = this.end;
    };
    Ce.prototype.BODY_SIZED = function() {
        var n = Math.min(this.end - this.offset, this.body_bytes);
        this.userCall()(this[Mg](this.chunk.slice(this.offset, this.offset + n), 0, n)), this.offset += n, this.body_bytes -= n, this.body_bytes || this.nextRequest();
    };
    [
        "Headers",
        "HeadersComplete",
        "Body",
        "MessageComplete"
    ].forEach(function(n) {
        var e = Ce["kOn" + n];
        Object.defineProperty(Ce.prototype, "on" + n, {
            get: function() {
                return this[e];
            },
            set: function(t) {
                return this._compatMode0_11 = !0, JB = "CONNECT", this[e] = t;
            }
        });
    });
    function Ng(n) {
        var e = new Error("Parse Error");
        return e.code = n, e;
    }
    let $8 = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, Qde = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, qde = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }, PA = class extends Error {
        static name = "ProtocolError";
        constructor(e = "Protocol error"){
            super(e), this.name = "ProtocolError";
        }
    };
    const M8 = Symbol.for("@libp2p/peer-id");
    function Kde(n) {
        return !!n?.[M8];
    }
    const ZB = Symbol.for("nodejs.util.inspect.custom"), Gde = 114;
    let N8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [M8] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Gde, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [ZB]() {
            return `PeerId(${this.toString()})`;
        }
    }, Yde = class extends N8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, Wde = class extends N8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, jde = class extends N8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const Xde = 2336;
    let eP = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [ZB]() {
            return `PeerId(${this.url})`;
        }
        [M8] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Xde, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const Jde = 114, kA = 2336;
    function Zde(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return efe(ge.parse(n));
            throw new $8('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return tP(t);
    }
    function tP(n) {
        if (nfe(n)) return new Yde({
            multihash: n
        });
        if (tfe(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new Wde({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new jde({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new eP(new URL(t));
        }
        throw new qde("Supplied PeerID Multihash is invalid");
    }
    function efe(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== Jde && n.code !== kA) throw new Qde("Supplied PeerID CID is invalid");
        if (n.code === kA) {
            const e = L(n.multihash.digest);
            return new eP(new URL(e));
        }
        return tP(n.multihash);
    }
    function tfe(n) {
        return n.code === nt.code;
    }
    function nfe(n) {
        return n.code === Ut.code;
    }
    let ws = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, gf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, rfe = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, sfe = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const ife = 4, ofe = 6, afe = 273, lfe = 33, cfe = 41, ufe = 42, hfe = 43, dfe = 53, ffe = 54, pfe = 55, gfe = 56, mfe = 132, yfe = 301, wfe = 302, bfe = 400, nP = 421, vfe = 444, Efe = 445, Afe = 446, Sfe = 447, Ife = 448, Cfe = 449, Tfe = 454, _fe = 460, xfe = 461, Dfe = 465, Bfe = 466, Pfe = 480, kfe = 481, Rfe = 443, Ofe = 477, $fe = 478, Mfe = 479, Nfe = 277, Lfe = 275, Ufe = 276, zfe = 280, Ffe = 281, Vfe = 290, Hfe = 777;
    function RA(n) {
        return (e)=>L(e, n);
    }
    function OA(n) {
        return (e)=>re(e, n);
    }
    function id(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function uc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function Qfe(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = uc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function qfe(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = uc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function $A(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = id(t);
        return `${r}:${s}`;
    }
    const rP = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new ws("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, Kfe = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = rP(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new ws("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, Gfe = function(n) {
        if (n.byteLength !== 4) throw new ws("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, Yfe = function(n) {
        if (n.byteLength !== 16) throw new ws("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new ws(`Invalid IPv6 address "${t}"`);
        }
    };
    function Wfe(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new ws(`Invalid IPv6 address "${n}"`);
        }
    }
    const hy = Object.values(un).map((n)=>n.decoder), jfe = (function() {
        let n = hy[0].or(hy[1]);
        return hy.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function Xfe(n) {
        return jfe.decode(n);
    }
    function Jfe(n) {
        return (e)=>n.encoder.encode(e);
    }
    function Zfe(n) {
        if (parseInt(n).toString() !== n) throw new gf("Value must be an integer");
    }
    function e1e(n) {
        if (n < 0) throw new gf("Value must be a positive integer, or zero");
    }
    function t1e(n) {
        return (e)=>{
            if (e > n) throw new gf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function n1e(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const Q0 = n1e(Zfe, e1e, t1e(65535)), Fn = -1;
    let r1e = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new sfe(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const bu = new r1e, s1e = [
        {
            code: ife,
            name: "ip4",
            size: 32,
            valueToBytes: rP,
            bytesToValue: Gfe,
            validate: (n)=>{
                if (!Je(n)) throw new gf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: ofe,
            name: "tcp",
            size: 16,
            valueToBytes: uc,
            bytesToValue: id,
            validate: Q0
        },
        {
            code: afe,
            name: "udp",
            size: 16,
            valueToBytes: uc,
            bytesToValue: id,
            validate: Q0
        },
        {
            code: lfe,
            name: "dccp",
            size: 16,
            valueToBytes: uc,
            bytesToValue: id,
            validate: Q0
        },
        {
            code: cfe,
            name: "ip6",
            size: 128,
            valueToBytes: Kfe,
            bytesToValue: Yfe,
            stringToValue: Wfe,
            validate: (n)=>{
                if (!xn(n)) throw new gf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: ufe,
            name: "ip6zone",
            size: Fn
        },
        {
            code: hfe,
            name: "ipcidr",
            size: 8,
            bytesToValue: RA("base10"),
            valueToBytes: OA("base10")
        },
        {
            code: dfe,
            name: "dns",
            size: Fn
        },
        {
            code: ffe,
            name: "dns4",
            size: Fn
        },
        {
            code: pfe,
            name: "dns6",
            size: Fn
        },
        {
            code: gfe,
            name: "dnsaddr",
            size: Fn
        },
        {
            code: mfe,
            name: "sctp",
            size: 16,
            valueToBytes: uc,
            bytesToValue: id,
            validate: Q0
        },
        {
            code: yfe,
            name: "udt"
        },
        {
            code: wfe,
            name: "utp"
        },
        {
            code: bfe,
            name: "unix",
            size: Fn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: nP,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Fn,
            bytesToValue: RA("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? OA("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: vfe,
            name: "onion",
            size: 96,
            bytesToValue: $A,
            valueToBytes: Qfe
        },
        {
            code: Efe,
            name: "onion3",
            size: 296,
            bytesToValue: $A,
            valueToBytes: qfe
        },
        {
            code: Afe,
            name: "garlic64",
            size: Fn
        },
        {
            code: Sfe,
            name: "garlic32",
            size: Fn
        },
        {
            code: Ife,
            name: "tls"
        },
        {
            code: Cfe,
            name: "sni",
            size: Fn
        },
        {
            code: Tfe,
            name: "noise"
        },
        {
            code: _fe,
            name: "quic"
        },
        {
            code: xfe,
            name: "quic-v1"
        },
        {
            code: Dfe,
            name: "webtransport"
        },
        {
            code: Bfe,
            name: "certhash",
            size: Fn,
            bytesToValue: Jfe(yn),
            valueToBytes: Xfe
        },
        {
            code: Pfe,
            name: "http"
        },
        {
            code: kfe,
            name: "http-path",
            size: Fn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: Rfe,
            name: "https"
        },
        {
            code: Ofe,
            name: "ws"
        },
        {
            code: $fe,
            name: "wss"
        },
        {
            code: Mfe,
            name: "p2p-websocket-star"
        },
        {
            code: Nfe,
            name: "p2p-stardust"
        },
        {
            code: Lfe,
            name: "p2p-webrtc-star"
        },
        {
            code: Ufe,
            name: "p2p-webrtc-direct"
        },
        {
            code: zfe,
            name: "webrtc-direct"
        },
        {
            code: Ffe,
            name: "webrtc"
        },
        {
            code: Vfe,
            name: "p2p-circuit"
        },
        {
            code: Hfe,
            name: "memory",
            size: Fn
        }
    ];
    s1e.forEach((n)=>{
        bu.addProtocol(n);
    });
    function i1e(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = bu.getProtocol(r), i = be(r), l = c1e(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Fn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function o1e(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = bu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Fn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Fn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function a1e(n) {
        if (n.charAt(0) !== "/") throw new ws('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = bu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new ws(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new ws(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new ws("Incomplete multiaddr");
        return e;
    }
    function l1e(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = bu.getProtocol(e.code);
            if (t == null) throw new ws(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function c1e(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const u1e = Symbol.for("nodejs.util.inspect.custom"), sP = Symbol.for("@multiformats/multiaddr");
    function h1e(n) {
        if (n == null && (n = "/"), iP(n)) return n.getComponents();
        if (n instanceof Uint8Array) return i1e(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), a1e(n);
        if (Array.isArray(n)) return n;
        throw new ws("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let d1e = class od {
        [sP] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = h1e(e), t.validate !== !1 && f1e(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = o1e(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = l1e(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new od(e);
            return new od([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new rfe(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new od(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new od(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [u1e]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function f1e(n) {
        n.getComponents().forEach((e)=>{
            const t = bu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function iP(n) {
        return !!n?.[sP];
    }
    function x4(n) {
        return new d1e(n);
    }
    function p1e(n) {
        if (n != null) {
            if (typeof n[Symbol.iterator] == "function") return n[Symbol.iterator]();
            if (typeof n[Symbol.asyncIterator] == "function") return n[Symbol.asyncIterator]();
            if (typeof n.next == "function") return n;
        }
        throw new Error("argument is not an iterator or iterable");
    }
    function g1e(n, e = {}) {
        const t = p1e(n), r = {
            _cancelled: !1,
            async start () {
                this._cancelled = !1;
            },
            async pull (s) {
                try {
                    const { value: i, done: l } = await t.next();
                    if (this._cancelled) return;
                    if (l === !0) {
                        s.close();
                        return;
                    }
                    s.enqueue(i);
                } catch (i) {
                    s.error(i);
                }
            },
            cancel () {
                this._cancelled = !0;
            }
        };
        return new globalThis.ReadableStream(r, e);
    }
    const m1e = (n)=>async (e)=>new Uint8Array(await crypto.subtle.digest(n, e)), y1e = Z4({
        name: "sha-1",
        code: 17,
        encode: m1e("SHA-1")
    });
    class w1e extends globalThis.Request {
        constructor(e, t = {}){
            const r = t.method ?? "GET", s = Bc(t), i = t.body;
            cP(r, s) && (t.method = "UPGRADE"), super(e, t), Object.defineProperties(this, {
                body: {
                    value: i,
                    writable: !1
                },
                method: {
                    value: r,
                    writable: !1
                },
                headers: {
                    value: s,
                    writable: !1
                }
            });
        }
    }
    const b1e = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        103: "Early Hints",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        208: "Already Reported",
        226: "IM Used",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        308: "Permanent Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a Teapot",
        421: "Misdirected Request",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Too Early",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required"
    };
    let Cd = class extends globalThis.Response {
        constructor(e, t = {}){
            const r = Bc(t), s = t.status ?? 200;
            (s < 200 || s > 599) && (t.status = 200), super(e, t), Object.defineProperties(this, {
                status: {
                    value: s,
                    writable: !1
                },
                statusText: {
                    value: b1e[s],
                    writable: !1
                },
                headers: {
                    value: r,
                    writable: !1
                }
            });
        }
    };
    const v1e = [
        "dns",
        "dns4",
        "dns6",
        "dnsaddr"
    ];
    function D4(n, e) {
        if (n instanceof URL) return n;
        const t = P4(n, e), { httpPath: r } = k4(n);
        return new URL(`http://${t}${r}`);
    }
    function B4(n) {
        return n instanceof Uint8Array ? n : n instanceof DataView ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n, 0, n.byteLength);
    }
    function E1e(n, e) {
        const t = {
            method: n.method,
            headers: n.headers
        };
        if ((t.method !== "GET" || n.upgrade) && t.method !== "HEAD") {
            let r = e;
            n.upgrade || (r = I1e(e, n.headers.get("content-length"))), t.body = g1e(r), t.duplex = "half";
        }
        return new w1e(lP(n).toString(), t);
    }
    async function A1e(n, e) {
        if (e.send(re([
            `HTTP/1.1 ${n.status} ${n.statusText}`,
            ...oP(n.headers),
            "",
            ""
        ].join(`\r
`))), n.body == null) {
            await e.close().catch((r)=>{
                e.abort(r);
            });
            return;
        }
        const t = n.body.getReader();
        for(;;){
            const r = await t.read();
            if (r.value != null && (e.send(r.value) || await e.onDrain()), r.done) break;
        }
        await e.close().catch((r)=>{
            e.abort(r);
        });
    }
    const S1e = re([
        "HTTP/1.1 404 Not Found",
        "Connection: close",
        "",
        ""
    ].join(`\r
`));
    re([
        "HTTP/1.1 400 Bad Request",
        "Connection: close",
        "",
        ""
    ].join(`\r
`));
    re([
        "HTTP/1.1 500 Internal Server Error",
        "Connection: close",
        "",
        ""
    ].join(`\r
`));
    re([
        "HTTP/1.1 501 Not Implemented",
        "Connection: close",
        "",
        ""
    ].join(`\r
`));
    function oP(n) {
        const e = [];
        n.get("Connection") == null && n.set("Connection", "close");
        for (const [t, r] of n.entries())e.push(`${t}: ${r}`);
        return e;
    }
    async function* I1e(n, e) {
        if (e = parseInt(`${e ?? ""}`), e == null || isNaN(e)) return n;
        let t = 0;
        for await (const r of n){
            if (t += r.byteLength, t > e) {
                yield r.subarray(0, t - e);
                return;
            }
            if (yield r.subarray(), t === e) return;
        }
    }
    function Ph(n, e) {
        if (typeof n == "string" && (n.startsWith("/") ? n = x4(n) : n = new URL(n)), Kde(n) && (n = x4(`/p2p/${n}`)), n instanceof URL && n.protocol === "multiaddr:" && (n = V_(n.toString())), iP(n) && (n = [
            n
        ]), Array.isArray(n)) {
            for (const t of n)if (t.getComponents().some(({ name: s })=>s === "http")) {
                const s = Sg(t);
                return new URL(`${s}${e ?? ""}`);
            }
        }
        return e == null ? n : n instanceof URL ? new URL(`${n}${e.substring(1)}`) : n.map((t)=>t.encapsulate(`/http-path/${encodeURIComponent(e.substring(1))}`));
    }
    function Bc(n = {}) {
        return n.headers instanceof Headers || (n.headers = new Headers(n.headers)), n.headers;
    }
    function kh(n) {
        return n != null && n !== "";
    }
    function P4(n, e) {
        let t, r = 80, s = "http:";
        if (n instanceof URL && (t = n.hostname, r = parseInt(n.port, 10), s = n.protocol), kh(t) || (t = e.get("host") ?? void 0), !kh(t) && Array.isArray(n)) for (const i of n){
            const u = i.getComponents().filter(({ name: h })=>v1e.includes(h))?.[0]?.value;
            if (u != null) {
                t = u;
                break;
            }
        }
        if (!kh(t) && Array.isArray(n)) for (const i of n){
            const l = i.getComponents().findLast((u)=>u.code === nP)?.value;
            try {
                const u = Xe(i);
                u.port != null && (r = u.port);
            } catch  {}
            if (l != null) {
                t = Zde(l).toCID().toString(No);
                break;
            }
        }
        if (!kh(t) && Array.isArray(n)) for (const i of n)try {
            const l = Xe(i);
            l.host != null && (t = l.host);
            break;
        } catch  {}
        if (kh(t)) return s === "http:" && r !== 80 && (t = `${t}:${r}`), s === "https:" && r !== 443 && (t = `${t}:${r}`), t;
        throw new $8("Could not determine request host name - a request must have a host header, be made to a DNS or IP-based multiaddr or an http(s) URL");
    }
    function k4(n) {
        let e = "/";
        return n = n.map((t)=>x4(t.getComponents().filter((r)=>r.name === "http-path" ? (e = r.value ?? "/", !1) : !0))), {
            httpPath: e,
            addresses: n
        };
    }
    function aP(n, e = [
        "GET"
    ]) {
        return n == null ? e : (typeof n == "string" && (n = [
            n
        ]), n.map((t)=>t.toUpperCase()));
    }
    function lP(n) {
        const e = n.url ?? "/";
        if (e.startsWith("http")) return new URL(e);
        const t = C1e(n);
        return new URL(`http://${t}${e}`);
    }
    function C1e(n) {
        let e = n.headers?.host;
        if (e == null && (e = n.headers?.Host), e == null && typeof n.headers.get == "function" && (e = n.headers.get("host")), e == null) throw new $8("Could not read host");
        return e;
    }
    function cP(n, e) {
        return n === "GET" && e.get("connection")?.toLowerCase() === "upgrade" && e.get("upgrade")?.toLowerCase() === "websocket";
    }
    function MA(n, e) {
        if (n instanceof Headers) return n.get(e) ?? void 0;
        const t = n[e];
        return Array.isArray(t) ? t.join(",") : t;
    }
    async function T1e(n) {
        if (MA(n, "sec-websocket-version") !== "13") throw new PA("Invalid version");
        const e = MA(n, "sec-websocket-key");
        if (e == null) throw new PA("Missing sec-websocket-key");
        const t = `${e}258EAFA5-E914-47DA-95CA-C5AB0DC85B11`, r = await y1e.digest(re(t)), s = X4.encode(r.digest).substring(1);
        return new Headers({
            Upgrade: "websocket",
            Connection: "upgrade",
            "Sec-WebSocket-Accept": s
        });
    }
    async function _1e(n, e) {
        const t = new Ce("REQUEST"), r = new Re;
        let s;
        t[Ce.kOnHeadersComplete] = (i)=>{
            const l = new Headers;
            for(let u = 0; u < i.headers.length; u += 2)l.set(i.headers[u].toLowerCase(), i.headers[u + 1]);
            s = {
                ...i,
                headers: l,
                raw: r,
                method: Ce.methods[i.method]
            };
        };
        try {
            for(;;){
                const { data: i } = await si(n, "message", e?.signal), l = i.subarray(), u = t.execute(l, 0, l.byteLength);
                if (u instanceof Error) throw u;
                if (r.append(l.subarray(0, u)), u < l.byteLength && n.push(l.subarray(u)), s != null) return s;
            }
        } catch (i) {
            n.abort(i);
        } finally{
            t.finish();
        }
        throw new Error("Failed to read header info from request");
    }
    class x1e extends Error {
        static name = "InvalidResponseError";
        name = "InvalidResponseError";
    }
    const D1e = [
        101,
        204,
        205,
        304
    ];
    async function B1e(n, e, t) {
        const r = Promise.withResolvers(), s = new TransformStream, i = s.writable.getWriter();
        let l = !1;
        const u = new Ce("RESPONSE");
        u.maxHeaderSize = t.maxHeaderSize ?? Ce.maxHeaderSize, u[Ce.kOnHeadersComplete] = (f)=>{
            t.log("response headers complete"), l = !0;
            const p = new Headers;
            for(let A = 0; A < f.headers.length; A += 2)p.append(f.headers[A], f.headers[A + 1]);
            let m = s.readable;
            D1e.includes(f.statusCode) && (s.writable.close().catch(()=>{}), s.readable.cancel().catch(()=>{}), m = null);
            const w = new Cd(m, {
                status: f.statusCode,
                statusText: f.statusMessage,
                headers: p
            });
            r.resolve(w);
        }, u[Ce.kOnBody] = (f)=>{
            t.log("response read body %d bytes", f.byteLength), i.write(f).catch((p)=>{
                r.reject(p);
            });
        }, u[Ce.kOnMessageComplete] = ()=>{
            t.log("response message complete"), i.close().catch((f)=>{
                r.reject(f);
            });
        };
        let h = 0;
        return n.addEventListener("message", ({ data: f })=>{
            t.log("response stream read %d bytes", f.byteLength), h += f.byteLength;
            const p = u.execute(f.subarray(), 0, f.byteLength);
            p instanceof Error && (n.abort(p), u.finish());
        }), n.addEventListener("remoteCloseWrite", ()=>{
            l || r.reject(new x1e(`Response ended before headers were received, read ${h} bytes`)), u.finish();
        }), r.promise;
    }
    function P1e(n, e) {
        return e.set("Content-Length", `${n.size}`), e.set("Content-Type", n.type != null && n.type !== "" ? n.type : "application/octet-stream"), n.stream();
    }
    function k1e(n, e) {
        return e.set("Content-Length", `${n.byteLength}`), e.set("Content-Type", "application/octet-stream"), new ReadableStream({
            start (t) {
                t.enqueue(B4(n)), t.close();
            }
        });
    }
    function R1e(n, e, t) {
        const r = [
            `--${t}`
        ];
        let s = 0;
        const i = 2;
        return typeof e == "string" ? (r.push(`Content-Disposition: form-data; name="${n}"`, 'Content-Type: text/plain; charset="UTF-8"', `Content-Length: ${e.length}`, ""), s = e.length + i) : (r.push(`Content-Disposition: form-data; name="${n}"; filename="${encodeURIComponent(e.name)}"`, "Content-Type: application/octet-stream", `Content-Length: ${e.size}`, ""), s = e.size + i), re(r.join(`\r
`)).byteLength + s;
    }
    function O1e(n, e) {
        const t = `-----------------------------${crypto.randomUUID()}`;
        e.set("Content-Type", `multipart/form-data; boundary=${t}`);
        let r = 0;
        for (const [h, f] of n.entries())r += R1e(h, f, t);
        e.set("Content-Length", `${r}`);
        const s = n.entries();
        let i;
        function l(h, f, p, m) {
            const w = [
                `--${m}`
            ];
            typeof p == "string" ? w.push(`Content-Disposition: form-data; name="${f}"`, 'Content-Type: text/plain; charset="UTF-8"', `Content-Length: ${p.length}`, "", p, "") : (w.push(`Content-Disposition: form-data; name="${f}"; filename="${encodeURIComponent(p.name)}"`, "Content-Type: application/octet-stream", `Content-Length: ${p.size}`, ""), i = p.stream().getReader()), h.enqueue(re(w.join(`\r
`)));
        }
        async function u(h, f) {
            if (i != null) {
                const w = await i.read();
                w.value != null && h.enqueue(w.value), w.done && (h.enqueue(re(`\r
`)), i = void 0);
                return;
            }
            const { done: p, value: m } = s.next();
            if (m != null) {
                const [w, A] = m;
                l(h, w, A, f);
            }
            p === !0 && h.close();
        }
        return new ReadableStream({
            async pull (h) {
                await u(h, t);
            }
        });
    }
    function $1e(n, e) {
        e.set("Content-Type", "application/octet-stream"), e.set("Transfer-Encoding", "chunked");
        const t = n.getReader();
        return new ReadableStream({
            async pull (r) {
                const { done: s, value: i } = await t.read();
                i != null && (r.enqueue(re(`${i.byteLength}\r
`)), r.enqueue(i), r.enqueue(re(`\r
`))), s && (r.enqueue(re(`0\r
\r
`)), r.close());
            }
        });
    }
    function NA(n, e) {
        return e.set("Content-Length", `${n.length}`), e.set("Content-Type", 'text/plain; charset="UTF-8"'), new ReadableStream({
            start (t) {
                t.enqueue(re(n)), t.close();
            }
        });
    }
    function M1e(n, e) {
        if (n != null) {
            if (typeof n == "string") return NA(n, e);
            if (n instanceof Blob) return P1e(n, e);
            if (N1e(n)) return k1e(n, e);
            if (n instanceof URLSearchParams) return NA(n.toString(), e);
            if (n instanceof ReadableStream) return $1e(n, e);
            if (n instanceof FormData) return O1e(n, e);
            throw new Error("Unsupported body type");
        }
    }
    function N1e(n) {
        return n == null ? !1 : n.byteLength != null;
    }
    async function L1e(n, e, t) {
        const r = new Headers(t.headers), s = r.get("host") ?? e.hostname;
        r.set("host", s), r.get("user-agent") == null && r.set("user-agent", "libp2p/fetch");
        const i = M1e(t.body, r), l = [
            `${t?.method?.toUpperCase() ?? "GET"} ${e.pathname ?? "/"} HTTP/1.1`,
            ...oP(r),
            "",
            ""
        ];
        n.send(re(l.join(`\r
`))) || await n.onDrain({
            signal: t.signal ?? void 0
        }), i != null && (t.log("request sending body"), await U1e(n, i, t));
    }
    async function U1e(n, e, t) {
        const r = e.getReader();
        for(;;){
            const { done: s, value: i } = await r.read();
            if (i != null && (t.log("request send %d bytes", i.byteLength), n.send(i) || await n.onDrain({
                signal: t.signal ?? void 0
            })), s) {
                t.log("request finished sending body");
                break;
            }
        }
    }
    async function z1e(n, e, t = {}) {
        const r = n.log.newScope("http-fetch");
        e = typeof e == "string" ? new URL(e) : e;
        const [s] = await Promise.all([
            B1e(n, e, {
                ...t,
                log: r
            }),
            L1e(n, e, {
                ...t,
                log: r
            })
        ]);
        return await n.close({
            signal: t.signal ?? void 0
        }), s;
    }
    let uP = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    };
    class F1e extends Event {
        message;
        error;
        filename = "";
        lineno = 0;
        colno = 0;
        constructor(e){
            super("error"), this.error = e, this.message = e.message;
        }
    }
    class LA extends Event {
        code;
        reason;
        wasClean;
        constructor(e, t){
            super(e), this.code = t?.code ?? 0, this.reason = t?.reason ?? "", this.wasClean = t?.wasClean ?? !0;
        }
    }
    const V1e = {
        CONTINUATION: 0,
        TEXT: 1,
        BINARY: 2,
        CONNECTION_CLOSE: 8,
        PING: 9,
        PONG: 10
    }, dy = {
        0: "CONTINUATION",
        1: "TEXT",
        2: "BINARY",
        8: "CONNECTION_CLOSE",
        9: "PING",
        10: "PONG"
    }, hP = {
        NORMAL_CLOSURE: 1e3,
        MESSAGE_TOO_BIG: 1009
    };
    function H1e(n) {
        let e = 0;
        if (n.byteLength < e + 1) return;
        const r = n.get(e) & 15;
        if (e++, dy[r] == null) throw new Error(`Unknown opcode: ${r}`);
        if (n.byteLength < e + 1) return;
        const s = n.get(e), i = (s & 128) === 128;
        let l = s & 127;
        if (e++, l === 126) {
            if (n.byteLength < e + 2) return;
            l = n.getUint16(e), e += 2;
        } else if (l === 127) {
            if (n.byteLength < e + 8) return;
            l = n.getUint32(e), e += 8;
        }
        if (l === 0) return n.consume(e), {
            type: dy[r]
        };
        let u;
        if (i) {
            if (n.byteLength < e + 4) return;
            u = n.subarray(e, e + 4), e += 4;
        }
        if (n.byteLength < e + l) return;
        let h = n.subarray(e, e + l);
        return e += l, u != null && (h = dP(h, u)), n.consume(e), {
            type: dy[r],
            data: h
        };
    }
    function dP(n, e) {
        let t = 0;
        for(let r = 0; r < n.byteLength; r++)n[r] = n[r] ^ e[t], t++, t === e.byteLength && (t = 0);
        return n;
    }
    function Q1e(n, e, t) {
        const r = new Re(Uint8Array.from([
            128 | V1e[n]
        ])), s = e?.byteLength ?? 0;
        if (s < 126) r.append(Uint8Array.from([
            s | (t === !0 ? 128 : 0)
        ]));
        else if (s < 65535) {
            const i = new Re(new Uint8Array(3));
            i.set(0, 126 | (t === !0 ? 128 : 0)), i.setUint16(1, s), r.append(i);
        } else if (s < 18446744073709552e3) {
            const i = new Re(new Uint8Array(9));
            i.set(0, 127 | (t === !0 ? 128 : 0)), i.setUint32(1, s), r.append(i);
        } else throw new Error("Payload too large");
        if (t === !0 && e != null) {
            const i = Uint8Array.from([
                0,
                0,
                0,
                0
            ]);
            r.append(i), e = dP(e, i);
        }
        return e != null && r.append(e), r;
    }
    function q1e(n) {
        if (n instanceof Uint8Array || n instanceof ArrayBuffer || n instanceof DataView) return B4(n);
        if (typeof n == "string") return re(n);
        if (n instanceof Blob) return n.arrayBuffer().then((e)=>B4(e));
        throw new uP("Unsupported data type");
    }
    async function K1e(n, e) {
        return new Promise((t, r)=>{
            let s = !1;
            const i = new Ce("RESPONSE");
            i[Ce.kOnHeadersComplete] = (l)=>{
                s = !0;
                const u = [];
                for(let h = 0; h < l.headers.length; h += 2)u.push([
                    l.headers[h],
                    l.headers[h + 1]
                ]);
                t(new Cd(null, {
                    status: l.statusCode,
                    statusText: l.statusMessage,
                    headers: new Headers(u)
                }));
            }, Promise.resolve().then(async ()=>{
                for(;;){
                    const { data: l } = await si(n, "message", e.signal), u = l.subarray(), h = i.execute(u, 0, u.byteLength);
                    if (h instanceof Error) throw h;
                    if (h < u.byteLength && n.push(u.subarray(h)), s) break;
                }
            }).catch((l)=>{
                r(l);
            });
        });
    }
    async function* G1e(n, e = [], t) {
        const r = X4.encode(crypto.getRandomValues(new Uint8Array(16))).substring(1);
        t.set("host", n.hostname), t.set("connection", "upgrade"), t.set("upgrade", "websocket"), t.set("pragma", "no-cache"), t.set("cache-control", "no-cache"), t.set("sec-websocket-version", "13"), t.set("sec-websocket-key", r), e.length > 0 && t.set("sec-websocket-protocol", e.join(", ")), yield re([
            `GET ${n.pathname ?? "/"} HTTP/1.1`,
            ...[
                ...t.entries()
            ].map(([s, i])=>`${s}: ${i}`),
            "",
            ""
        ].join(`\r
`));
    }
    const Y1e = [
        "BINARY",
        "TEXT",
        "CONTINUATION"
    ], W1e = 10485760, j1e = "/http/1.1";
    class fP extends Lt {
        binaryType = "arraybuffer";
        bufferedAmount = 0;
        extensions = "";
        protocol = "";
        readyState;
        url;
        CONNECTING = 0;
        OPEN = 1;
        CLOSING = 2;
        CLOSED = 3;
        _onclose;
        _onerror;
        _onmessage;
        _onopen;
        sentClose;
        isClient;
        buffer;
        maxMessageSize;
        _url;
        closeController;
        constructor(e, t = {}){
            super(), this.readyState = this.CONNECTING, this.url = e.pathname, this.sentClose = !1, this.isClient = t.isClient ?? !0, this.buffer = new Re, this.closeController = new AbortController, this.maxMessageSize = t.maxMessageSize ?? W1e;
        }
        send(e) {
            if (this.readyState !== this.OPEN) throw new Error("WebSocket was not open");
            const t = q1e(e);
            xC(t) ? t.then((r)=>{
                this._send("BINARY", r);
            }).catch((r)=>{
                this._errored(r);
            }) : this._send("BINARY", t);
        }
        _send(e, t) {
            if (this.readyState !== this.OPEN) return;
            const r = Q1e(e, t, this.isClient), s = r.byteLength;
            this.bufferedAmount += s, this._write(r, (i)=>{
                this.bufferedAmount -= s, i != null && this._errored(i);
            });
        }
        close(e, t) {
            if (this.readyState !== this.OPEN) throw new Error("WebSocket was not open");
            this.readyState = this.CLOSING, this.sentClose = !0, this._send("CONNECTION_CLOSE");
        }
        _errored(e) {
            this.readyState = this.CLOSED, this.dispatchEvent(new F1e(e));
        }
        set onclose(e) {
            this._onclose = e, this.addEventListener("close", e);
        }
        get onclose() {
            return this._onclose ?? null;
        }
        set onerror(e) {
            this._onerror = e, this.addEventListener("error", e);
        }
        get onerror() {
            return this._onerror ?? null;
        }
        set onmessage(e) {
            this._onmessage = e, this.addEventListener("message", e);
        }
        get onmessage() {
            return this._onmessage ?? null;
        }
        set onopen(e) {
            this._onopen = e, this.addEventListener("open", e);
        }
        get onopen() {
            return this._onopen ?? null;
        }
        _push(e) {
            if (this.buffer.append(e), this.buffer.byteLength > this.maxMessageSize) {
                this.close(hP.MESSAGE_TOO_BIG, "Max message size exceeded");
                return;
            }
            for(;;){
                const t = H1e(this.buffer);
                if (t == null) break;
                if (Y1e.includes(t.type) && t.data != null) {
                    let r;
                    this.binaryType === "blob" ? r = new Blob([
                        t.data
                    ]) : t.data.byteOffset === 0 && t.data.byteLength === t.data.buffer.byteLength ? r = t.data.buffer : (r = new ArrayBuffer(t.data.byteLength), new Uint8Array(r, 0, r.byteLength).set(t.data)), this.dispatchEvent(new MessageEvent("message", {
                        data: r,
                        origin: this._url?.hostname
                    }));
                }
                t.type === "PING" && this._send("PONG", t.data), t.type === "CONNECTION_CLOSE" && (this.sentClose || this.close(), this.closeController.abort(), this._close(void 0, ()=>{
                    this.readyState = this.CLOSED, this.dispatchEvent(new LA("close"));
                }));
            }
        }
        _remoteClosed(e) {
            this.readyState = this.CLOSING, this._close(e, ()=>{
                this.readyState = this.CLOSED, this.dispatchEvent(new LA("close"));
            });
        }
    }
    class X1e extends fP {
        writer;
        writable;
        constructor(e, t, r = {}){
            if (super(new URL(e.url), {
                ...r,
                isClient: !1
            }), e.body == null) throw new uP("Request body cannot be null");
            this.readyState = this.OPEN, this.writable = t, this.writer = t.getWriter();
            const s = e.body.getReader();
            Promise.resolve().then(async ()=>{
                for(this.dispatchEvent(new Event("open"));;){
                    const { value: i, done: l } = await s.read();
                    if (i != null && this._push(i), l) {
                        this._remoteClosed();
                        break;
                    }
                }
            }).catch((i)=>{
                this._errored(i);
            });
        }
        _write(e, t) {
            this.writer?.write(e).then(()=>{
                t();
            }, (r)=>{
                t(r);
            });
        }
        _close(e, t) {
            e != null ? this.writable.abort(e).then(()=>{
                t();
            }, ()=>{
                t();
            }) : this.writable.close().then(()=>{
                t();
            }, ()=>{
                t();
            });
        }
    }
    let J1e = class extends fP {
        stream;
        handshakeTimeout;
        drainTimeout;
        constructor(e, t, r, s){
            super(t, {
                ...s,
                isClient: !0
            }), this.handshakeTimeout = s.handshakeTimeout ?? 1e4, this.drainTimeout = s.drainTimeout ?? 1e4, Promise.resolve().then(async ()=>{
                const i = AbortSignal.timeout(this.handshakeTimeout);
                this.stream = await r.openStream(e, j1e, {
                    ...s,
                    signal: i
                });
                for await (const u of G1e(t, s.protocols, Bc(s)))this.stream.send(u) || await this.stream.onDrain({
                    signal: i
                });
                const l = await K1e(this.stream, {
                    signal: i
                });
                if (l.status !== 101) throw new Error("Invalid WebSocket handshake - response status " + l.status);
                await s.onHandshakeResponse?.(l, {
                    signal: i
                }), this.protocol = l.headers.get("Sec-WebSocket-Protocol") ?? "", this.readyState = this.OPEN, this.dispatchEvent(new Event("open"));
                for await (const u of this.stream)this._push(u);
            }).catch((i)=>{
                this._errored(i);
            });
        }
        _write(e, t) {
            if (this.stream == null) {
                t(new Error("WebSocket was not open"));
                return;
            }
            this.stream.send(e) ? t() : this.stream.onDrain({
                signal: AbortSignal.timeout(this.drainTimeout)
            }).then(()=>{
                t();
            }, (r)=>{
                t(r);
            });
        }
        _close(e, t) {
            if (this.stream == null) {
                t();
                return;
            }
            if (e != null) {
                this.stream.abort(e), t();
                return;
            }
            this.stream.close().catch((r)=>{
                this.stream?.abort(r);
            }).finally(()=>{
                t();
            });
        }
    }, pP = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    };
    class UA extends Error {
        static name = "UnsupportedOperationError";
        constructor(e = "Unsupported operation"){
            super(e), this.name = "UnsupportedOperationError";
        }
    }
    function gP(n) {
        return n != null && typeof n.start == "function" && typeof n.stop == "function";
    }
    async function Z1e(...n) {
        const e = [];
        for (const t of n)gP(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStart != null && await t.beforeStart();
        })), await Promise.all(e.map(async (t)=>{
            await t.start();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStart != null && await t.afterStart();
        }));
    }
    async function e0e(...n) {
        const e = [];
        for (const t of n)gP(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStop != null && await t.beforeStop();
        })), await Promise.all(e.map(async (t)=>{
            await t.stop();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStop != null && await t.afterStop();
        }));
    }
    const t0e = Symbol.for("@libp2p/service-capabilities"), R4 = "/http/1.1", mP = Symbol.for("@libp2p/http/websocket-handler");
    var Rs = {}, zA;
    function n0e() {
        if (zA) return Rs;
        zA = 1, Object.defineProperty(Rs, "__esModule", {
            value: !0
        }), Rs.parseCookie = u, Rs.parse = u, Rs.stringifyCookie = h, Rs.stringifySetCookie = f, Rs.serialize = f, Rs.parseSetCookie = p, Rs.stringifySetCookie = f, Rs.serialize = f;
        const n = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, e = /^[\u0021-\u003A\u003C-\u007E]*$/, t = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, r = /^[\u0020-\u003A\u003D-\u007E]*$/, s = /^-?\d+$/, i = Object.prototype.toString, l = (()=>{
            const I = function() {};
            return I.prototype = Object.create(null), I;
        })();
        function u(I, k) {
            const G = new l, P = I.length;
            if (P < 2) return G;
            const J = k?.decode || S;
            let H = 0;
            do {
                const F = w(I, H, P);
                if (F === -1) break;
                const $ = m(I, H, P);
                if (F > $) {
                    H = I.lastIndexOf(";", F - 1) + 1;
                    continue;
                }
                const Y = A(I, H, F);
                G[Y] === void 0 && (G[Y] = J(A(I, F + 1, $))), H = $ + 1;
            }while (H < P);
            return G;
        }
        function h(I, k) {
            const G = k?.encode || encodeURIComponent, P = [];
            for (const J of Object.keys(I)){
                const H = I[J];
                if (H === void 0) continue;
                if (!n.test(J)) throw new TypeError(`cookie name is invalid: ${J}`);
                const F = G(H);
                if (!e.test(F)) throw new TypeError(`cookie val is invalid: ${H}`);
                P.push(`${J}=${F}`);
            }
            return P.join("; ");
        }
        function f(I, k, G) {
            const P = typeof I == "object" ? I : {
                ...G,
                name: I,
                value: String(k)
            }, H = (typeof k == "object" ? k : G)?.encode || encodeURIComponent;
            if (!n.test(P.name)) throw new TypeError(`argument name is invalid: ${P.name}`);
            const F = P.value ? H(P.value) : "";
            if (!e.test(F)) throw new TypeError(`argument val is invalid: ${P.value}`);
            let $ = P.name + "=" + F;
            if (P.maxAge !== void 0) {
                if (!Number.isInteger(P.maxAge)) throw new TypeError(`option maxAge is invalid: ${P.maxAge}`);
                $ += "; Max-Age=" + P.maxAge;
            }
            if (P.domain) {
                if (!t.test(P.domain)) throw new TypeError(`option domain is invalid: ${P.domain}`);
                $ += "; Domain=" + P.domain;
            }
            if (P.path) {
                if (!r.test(P.path)) throw new TypeError(`option path is invalid: ${P.path}`);
                $ += "; Path=" + P.path;
            }
            if (P.expires) {
                if (!_(P.expires) || !Number.isFinite(P.expires.valueOf())) throw new TypeError(`option expires is invalid: ${P.expires}`);
                $ += "; Expires=" + P.expires.toUTCString();
            }
            if (P.httpOnly && ($ += "; HttpOnly"), P.secure && ($ += "; Secure"), P.partitioned && ($ += "; Partitioned"), P.priority) switch(typeof P.priority == "string" ? P.priority.toLowerCase() : void 0){
                case "low":
                    $ += "; Priority=Low";
                    break;
                case "medium":
                    $ += "; Priority=Medium";
                    break;
                case "high":
                    $ += "; Priority=High";
                    break;
                default:
                    throw new TypeError(`option priority is invalid: ${P.priority}`);
            }
            if (P.sameSite) switch(typeof P.sameSite == "string" ? P.sameSite.toLowerCase() : P.sameSite){
                case !0:
                case "strict":
                    $ += "; SameSite=Strict";
                    break;
                case "lax":
                    $ += "; SameSite=Lax";
                    break;
                case "none":
                    $ += "; SameSite=None";
                    break;
                default:
                    throw new TypeError(`option sameSite is invalid: ${P.sameSite}`);
            }
            return $;
        }
        function p(I, k) {
            const G = k?.decode || S, P = I.length, J = m(I, 0, P), H = w(I, 0, J), F = H === -1 ? {
                name: "",
                value: G(A(I, 0, J))
            } : {
                name: A(I, 0, H),
                value: G(A(I, H + 1, J))
            };
            let $ = J + 1;
            for(; $ < P;){
                const Y = m(I, $, P), O = w(I, $, Y), se = O === -1 ? A(I, $, Y) : A(I, $, O), ae = O === -1 ? void 0 : A(I, O + 1, Y);
                switch(se.toLowerCase()){
                    case "httponly":
                        F.httpOnly = !0;
                        break;
                    case "secure":
                        F.secure = !0;
                        break;
                    case "partitioned":
                        F.partitioned = !0;
                        break;
                    case "domain":
                        F.domain = ae;
                        break;
                    case "path":
                        F.path = ae;
                        break;
                    case "max-age":
                        ae && s.test(ae) && (F.maxAge = Number(ae));
                        break;
                    case "expires":
                        if (!ae) break;
                        const oe = new Date(ae);
                        Number.isFinite(oe.valueOf()) && (F.expires = oe);
                        break;
                    case "priority":
                        if (!ae) break;
                        const K = ae.toLowerCase();
                        (K === "low" || K === "medium" || K === "high") && (F.priority = K);
                        break;
                    case "samesite":
                        if (!ae) break;
                        const V = ae.toLowerCase();
                        (V === "lax" || V === "strict" || V === "none") && (F.sameSite = V);
                        break;
                }
                $ = Y + 1;
            }
            return F;
        }
        function m(I, k, G) {
            const P = I.indexOf(";", k);
            return P === -1 ? G : P;
        }
        function w(I, k, G) {
            const P = I.indexOf("=", k);
            return P < G ? P : -1;
        }
        function A(I, k, G) {
            let P = k, J = G;
            do {
                const H = I.charCodeAt(P);
                if (H !== 32 && H !== 9) break;
            }while (++P < J);
            for(; J > P;){
                const H = I.charCodeAt(J - 1);
                if (H !== 32 && H !== 9) break;
                J--;
            }
            return I.slice(P, J);
        }
        function S(I) {
            if (I.indexOf("%") === -1) return I;
            try {
                return decodeURIComponent(I);
            } catch  {
                return I;
            }
        }
        function _(I) {
            return i.call(I) === "[object Date]";
        }
        return Rs;
    }
    var r0e = n0e();
    const s0e = Zc(r0e);
    class i0e {
        log;
        cookies;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:http:cookies"), this.cookies = new Map;
        }
        async prepareRequest(e, t) {
            if ((t.credentials ?? "same-origin") === "omit") return;
            const s = t.headers.get("origin");
            if (s == null || s === "null") return;
            const i = D4(e, t.headers), l = (this.cookies.get(i.hostname) ?? []).filter((u)=>!(u.expires != null && u.expires < Date.now() || u.path != null && !i.pathname.startsWith(u.path))).map((u)=>`${u.name}=${u.value}`).join("; ");
            l.length > 0 && t.headers.set("cookie", l);
        }
        async processResponse(e, t, r) {
            if ((t.credentials ?? "same-origin") === "omit") {
                FA(r);
                return;
            }
            const i = t.headers.get("origin");
            if (i == null || i === "null") return;
            const l = D4(e, t.headers);
            for (const u of r.headers.getSetCookie()){
                const h = [
                    ...this.cookies.get(l.hostname) ?? [],
                    ...o0e(s0e.parse(u))
                ];
                this.cookies.set(l.hostname, h);
            }
            FA(r);
        }
    }
    function FA(n) {
        return n.headers.has("set-cookie") && n.headers.delete("set-cookie"), n;
    }
    function o0e(n) {
        const e = {}, t = [];
        return Object.entries(n).forEach(([r, s])=>{
            r.toLowerCase() === "domain" && s != null && (e.domain = s), r.toLowerCase() === "max-age" && s != null && (e.expires = Date.now() + parseInt(s, 10) * 1e3), !a0e.includes(r.toLowerCase()) && s != null && t.push({
                name: r,
                value: s
            });
        }), t.map((r)=>({
                ...r,
                ...e
            }));
    }
    const a0e = [
        "domain",
        "expires",
        "httponly",
        "max-age",
        "partitioned",
        "path",
        "samesite",
        "secure"
    ];
    class l0e {
        async prepareRequest(e, t) {
            if (t.headers.get("origin") != null || t.mode === "no-cors") return;
            const r = D4(e, t.headers);
            t.headers.set("origin", `${r.protocol}//${r.host}`);
        }
    }
    function c0e(n) {
        return typeof n.init == "function";
    }
    function yP(n, e) {
        if (c0e(n)) {
            const t = n;
            return t.handler = n.init(e), delete t.init, t;
        }
        return n;
    }
    function u0e(n) {
        const e = aP(n.method, [
            "GET"
        ]);
        if (n.fallback == null && e.filter((r)=>r !== "GET").length > 0) throw new pP("WebSocket handlers only support the GET HTTP method");
        const t = {
            ...n,
            init: (r)=>{
                const s = yP(n, r);
                return t[mP] = s.handler, async (i)=>{
                    if (!cP(i.method, i.headers)) return n?.fallback != null ? n.fallback(i) : new Cd(null, {
                        status: 400
                    });
                    const l = new TransformStream;
                    try {
                        const u = new Cd(l.readable, {
                            status: 101,
                            headers: await T1e(i.headers)
                        }), h = new X1e(i, l.writable, n);
                        return s.handler(h), u;
                    } catch  {
                        return new Cd(null, {
                            status: 500
                        });
                    }
                };
            }
        };
        return t;
    }
    const wP = "/.well-known/libp2p/protocols";
    function h0e(n) {
        return u0e({
            path: wP,
            method: [
                "GET"
            ],
            cors: !0,
            handler: (e)=>{
                const t = JSON.stringify(n.getProtocolMap());
                e.send(t), e.close();
            },
            fallback: async (e)=>{
                const t = JSON.stringify(n.getProtocolMap());
                return new Response(t, {
                    headers: {
                        "Content-Type": "application/json",
                        "Content-Length": `${t.length}`
                    }
                });
            }
        });
    }
    class d0e {
        log;
        components;
        protocols;
        endpoint;
        constructor(e, t = {}){
            this.components = e, this.log = e.logger.forComponent("libp2p:http:registrar"), this.protocols = [], this.onStream = this.onStream.bind(this), this.endpoint = t.server, this.handle("", h0e(this));
        }
        async start() {
            await this.components.registrar.handle(R4, this.onStream.bind(this));
        }
        async stop() {
            await this.components.registrar.unhandle(R4);
        }
        async onStream(e, t) {
            const r = await _1e(e);
            if (this.canHandle(r)) {
                this.log("handling incoming request %s %s", r.method, r.url);
                const s = await this.onRequest(E1e(r, e));
                await A1e(s, e), await e.close();
                return;
            }
            if (this.endpoint == null) {
                this.log("cannot handle incoming request %s %s and no endpoint configured", r.method, r.url), e.send(S1e), await e.close();
                return;
            }
            this.log("passing incoming request %s %s to endpoint", r.method, r.url), this.endpoint.inject(r, e, t).catch((s)=>{
                this.log.error("error injecting request to endpoint - %e", s), e.abort(s);
            });
        }
        canHandle(e) {
            const t = lP(e).pathname;
            return this.protocols.find((r)=>r.route.path === t) != null ? (this.log.trace("can handle %s", t), !0) : (this.log.trace("cannot handle %s", t), !1);
        }
        async onRequest(e) {
            this.log("incoming request %s %s", e.method, e.url);
            const t = this.findHandler(e.url);
            if (t == null) return new Response(null, {
                status: 404
            });
            let r;
            return t.route.method.includes(e.method) ? r = await t.route.handler(e) : e.method === "OPTIONS" ? r = new Response(null, {
                status: 204
            }) : r = new Response(null, {
                status: 405
            }), f0e(r, e, t), this.log("%s %s %d %s", e.method, e.url, r.status, r.statusText), r;
        }
        onWebSocket(e) {
            const t = this.findHandler(e.url);
            if (t != null) {
                const r = t.route[mP];
                if (r != null) {
                    r(e);
                    return;
                }
            }
            e.close(hP.NORMAL_CLOSURE);
        }
        findHandler(e) {
            const t = e.startsWith("/") ? e : new URL(e).pathname;
            this.log("search for handler on path %s", t);
            const r = this.protocols.find((s)=>s.route.path === t);
            return r != null && this.log("found handler for HTTP protocol %s on path %s", r.protocol, e), r;
        }
        handle(e, t) {
            if (t.path = t.path ?? e, this.protocols.find((r)=>r.protocol === e) != null) throw new pP(`HTTP protocol handler for ${e} already registered`);
            (t.path === "" || !t.path.startsWith("/")) && (t.path = `/${t.path}`), t.cors = t.cors ?? !0, t.method = aP(t.method), t = yP(t, this.components), this.protocols.push({
                protocol: e,
                route: t
            }), this.protocols.sort(({ route: { path: r } }, { route: { path: s } })=>s.length - r.length);
        }
        unhandle(e) {
            this.protocols = this.protocols.filter((t)=>t.protocol === e);
        }
        getProtocolMap() {
            const e = {};
            for (const t of this.protocols)t.protocol !== "" && (e[t.protocol] = {
                path: t.route.path
            });
            return e;
        }
    }
    function f0e(n, e, t) {
        const r = [
            ...new Set([
                "OPTIONS",
                ...t.route.method
            ])
        ].join(", ");
        t.route.cors && (e.headers.get("Access-Control-Request-Method") != null && n.headers.set("access-control-allow-methods", r), e.headers.get("Access-Control-Request-Headers") != null && n.headers.set("access-control-allow-headers", e.headers.get("Access-Control-Request-Headers") ?? ""), e.headers.get("Origin") != null && (n.headers.set("access-control-allow-origin", e.headers.get("Origin") ?? ""), n.headers.set("vary", "Origin"))), e.method === "OPTIONS" && n.headers.set("allow", r);
    }
    async function p0e(n, e, t) {
        for (const r of e.middleware)await r.prepareRequest?.(n, e);
        return t();
    }
    async function g0e(n, e, t) {
        for (const r of e.middleware)await r.prepareRequest?.(n, e);
        return t();
    }
    async function m0e(n, e, t) {
        for (const r of e.middleware)await r.processResponse?.(n, e, t);
        return t;
    }
    class y0e {
        log;
        components;
        httpRegistrar;
        origin;
        cookies;
        constructor(e, t = {}){
            this.components = e, this.log = e.logger.forComponent("libp2p:http"), this.httpRegistrar = new d0e(e, t), this.origin = new l0e, this.cookies = new i0e(e, t);
        }
        [Symbol.toStringTag] = "@libp2p/http";
        [t0e] = [
            "@libp2p/http"
        ];
        async start() {
            await Z1e(this.httpRegistrar);
        }
        async stop() {
            await e0e(this.httpRegistrar);
        }
        agent(...e) {
            throw new UA("This method is not supported in browsers");
        }
        dispatcher(...e) {
            throw new UA("This method is not supported in browsers");
        }
        async connect(e, t = {}) {
            const r = Ph(e), s = Bc(t), i = {
                ...t,
                headers: s,
                method: "GET",
                middleware: t.middleware?.map((l)=>l(this.components)) ?? []
            };
            return s.set("connection", "upgrade"), s.set("upgrade", "websocket"), g0e(r, i, async ()=>{
                if (r instanceof URL) {
                    const h = new globalThis.WebSocket(r, t.protocols);
                    return h.binaryType = "arraybuffer", h;
                }
                const { addresses: l, httpPath: u } = k4(r);
                return new J1e(l, new URL(`http://${P4(r, i.headers)}${decodeURIComponent(u)}`), this.components.connectionManager, i);
            });
        }
        async fetch(e, t = {}) {
            const r = Ph(e), s = {
                ...t,
                headers: Bc(t),
                method: "GET",
                middleware: [
                    this.origin,
                    this.cookies,
                    ...t.middleware?.map((l)=>l(this.components)) ?? []
                ]
            }, i = await p0e(r, s, async ()=>this.sendRequest(r, t));
            return m0e(r, s, i);
        }
        async connectProtocol(e, t, r) {
            const s = await this.getProtocolPath(e, t, r), i = Ph(e, s);
            return this.connect(i, r);
        }
        async fetchProtocol(e, t, r = {}) {
            const s = await this.getProtocolPath(e, t, r), i = Ph(e, s);
            return this.fetch(i, r);
        }
        async getSupportedProtocols(e, t = {}) {
            const r = Ph(e, wP), s = await this.fetch(r, {
                method: "GET",
                headers: {
                    Accept: "application/json"
                },
                signal: t.signal
            });
            if (s.status !== 200) throw new Error(`Unexpected status code: ${s.status}`);
            return s.json();
        }
        async getProtocolPath(e, t, r = {}) {
            const s = await this.getSupportedProtocols(e, r);
            if (s[t] == null) throw new Error(`Peer does not serve protocol: ${t}`);
            return s[t].path;
        }
        canHandle(e) {
            return this.httpRegistrar.canHandle(e);
        }
        async onRequest(e) {
            return this.httpRegistrar.onRequest(e);
        }
        onWebSocket(e) {
            this.httpRegistrar.onWebSocket(e);
        }
        handle(e, t) {
            this.httpRegistrar.handle(e, t);
        }
        unhandle(e) {
            this.httpRegistrar.unhandle(e);
        }
        getProtocolMap() {
            return this.httpRegistrar.getProtocolMap();
        }
        async sendRequest(e, t) {
            if (e instanceof URL) return this.log("making request to %s with global fetch"), globalThis.fetch(e, t);
            this.log("making request to %s with libp2p fetch", e);
            const r = P4(e, Bc(t)), { addresses: s, httpPath: i } = k4(e), u = await (await this.components.connectionManager.openConnection(s, {
                signal: t.signal ?? void 0
            })).newStream(R4, {
                signal: t.signal ?? void 0
            });
            return z1e(u, new URL(`http://${r}${decodeURIComponent(i)}`), t);
        }
    }
    function w0e(n = {}) {
        return (e)=>new y0e(e, n);
    }
    let b0e = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, v0e = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }, Na = class extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    }, E0e = class extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    };
    const bP = Symbol.for("@libp2p/peer-id"), vP = Symbol.for("@libp2p/service-capabilities");
    let bs = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, mf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, A0e = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, S0e = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const I0e = 4, C0e = 6, T0e = 273, _0e = 33, O4 = 41, EP = 42, x0e = 43, D0e = 53, B0e = 54, P0e = 55, k0e = 56, R0e = 132, O0e = 301, $0e = 302, M0e = 400, L8 = 421, N0e = 444, L0e = 445, U0e = 446, z0e = 447, F0e = 448, V0e = 449, H0e = 454, Q0e = 460, q0e = 461, K0e = 465, G0e = 466, Y0e = 480, W0e = 481, j0e = 443, X0e = 477, J0e = 478, Z0e = 479, epe = 277, tpe = 275, npe = 276, rpe = 280, spe = 281, ipe = 290, ope = 777;
    function VA(n) {
        return (e)=>L(e, n);
    }
    function HA(n) {
        return (e)=>re(e, n);
    }
    function ad(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function hc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function ape(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = hc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function lpe(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = hc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function QA(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = ad(t);
        return `${r}:${s}`;
    }
    const AP = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new bs("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, cpe = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = AP(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new bs("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, upe = function(n) {
        if (n.byteLength !== 4) throw new bs("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, hpe = function(n) {
        if (n.byteLength !== 16) throw new bs("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new bs(`Invalid IPv6 address "${t}"`);
        }
    };
    function dpe(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new bs(`Invalid IPv6 address "${n}"`);
        }
    }
    const fy = Object.values(un).map((n)=>n.decoder), fpe = (function() {
        let n = fy[0].or(fy[1]);
        return fy.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function ppe(n) {
        return fpe.decode(n);
    }
    function gpe(n) {
        return (e)=>n.encoder.encode(e);
    }
    function mpe(n) {
        if (parseInt(n).toString() !== n) throw new mf("Value must be an integer");
    }
    function ype(n) {
        if (n < 0) throw new mf("Value must be a positive integer, or zero");
    }
    function wpe(n) {
        return (e)=>{
            if (e > n) throw new mf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function bpe(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const q0 = bpe(mpe, ype, wpe(65535)), Vn = -1;
    let vpe = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new S0e(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const vu = new vpe, Epe = [
        {
            code: I0e,
            name: "ip4",
            size: 32,
            valueToBytes: AP,
            bytesToValue: upe,
            validate: (n)=>{
                if (!Je(n)) throw new mf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: C0e,
            name: "tcp",
            size: 16,
            valueToBytes: hc,
            bytesToValue: ad,
            validate: q0
        },
        {
            code: T0e,
            name: "udp",
            size: 16,
            valueToBytes: hc,
            bytesToValue: ad,
            validate: q0
        },
        {
            code: _0e,
            name: "dccp",
            size: 16,
            valueToBytes: hc,
            bytesToValue: ad,
            validate: q0
        },
        {
            code: O4,
            name: "ip6",
            size: 128,
            valueToBytes: cpe,
            bytesToValue: hpe,
            stringToValue: dpe,
            validate: (n)=>{
                if (!xn(n)) throw new mf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: EP,
            name: "ip6zone",
            size: Vn
        },
        {
            code: x0e,
            name: "ipcidr",
            size: 8,
            bytesToValue: VA("base10"),
            valueToBytes: HA("base10")
        },
        {
            code: D0e,
            name: "dns",
            size: Vn
        },
        {
            code: B0e,
            name: "dns4",
            size: Vn
        },
        {
            code: P0e,
            name: "dns6",
            size: Vn
        },
        {
            code: k0e,
            name: "dnsaddr",
            size: Vn
        },
        {
            code: R0e,
            name: "sctp",
            size: 16,
            valueToBytes: hc,
            bytesToValue: ad,
            validate: q0
        },
        {
            code: O0e,
            name: "udt"
        },
        {
            code: $0e,
            name: "utp"
        },
        {
            code: M0e,
            name: "unix",
            size: Vn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: L8,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Vn,
            bytesToValue: VA("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? HA("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: N0e,
            name: "onion",
            size: 96,
            bytesToValue: QA,
            valueToBytes: ape
        },
        {
            code: L0e,
            name: "onion3",
            size: 296,
            bytesToValue: QA,
            valueToBytes: lpe
        },
        {
            code: U0e,
            name: "garlic64",
            size: Vn
        },
        {
            code: z0e,
            name: "garlic32",
            size: Vn
        },
        {
            code: F0e,
            name: "tls"
        },
        {
            code: V0e,
            name: "sni",
            size: Vn
        },
        {
            code: H0e,
            name: "noise"
        },
        {
            code: Q0e,
            name: "quic"
        },
        {
            code: q0e,
            name: "quic-v1"
        },
        {
            code: K0e,
            name: "webtransport"
        },
        {
            code: G0e,
            name: "certhash",
            size: Vn,
            bytesToValue: gpe(yn),
            valueToBytes: ppe
        },
        {
            code: Y0e,
            name: "http"
        },
        {
            code: W0e,
            name: "http-path",
            size: Vn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: j0e,
            name: "https"
        },
        {
            code: X0e,
            name: "ws"
        },
        {
            code: J0e,
            name: "wss"
        },
        {
            code: Z0e,
            name: "p2p-websocket-star"
        },
        {
            code: epe,
            name: "p2p-stardust"
        },
        {
            code: tpe,
            name: "p2p-webrtc-star"
        },
        {
            code: npe,
            name: "p2p-webrtc-direct"
        },
        {
            code: rpe,
            name: "webrtc-direct"
        },
        {
            code: spe,
            name: "webrtc"
        },
        {
            code: ipe,
            name: "p2p-circuit"
        },
        {
            code: ope,
            name: "memory",
            size: Vn
        }
    ];
    Epe.forEach((n)=>{
        vu.addProtocol(n);
    });
    function Ape(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = vu.getProtocol(r), i = be(r), l = Tpe(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Vn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function Spe(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = vu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Vn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Vn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function Ipe(n) {
        if (n.charAt(0) !== "/") throw new bs('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = vu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new bs(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new bs(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new bs("Incomplete multiaddr");
        return e;
    }
    function Cpe(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = vu.getProtocol(e.code);
            if (t == null) throw new bs(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function Tpe(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const _pe = Symbol.for("nodejs.util.inspect.custom"), SP = Symbol.for("@multiformats/multiaddr");
    function xpe(n) {
        if (n == null && (n = "/"), Ppe(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Ape(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), Ipe(n);
        if (Array.isArray(n)) return n;
        throw new bs("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let Dpe = class ld {
        [SP] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = xpe(e), t.validate !== !1 && Bpe(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = Spe(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = Cpe(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new ld(e);
            return new ld([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new A0e(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new ld(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new ld(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [_pe]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function Bpe(n) {
        n.getComponents().forEach((e)=>{
            const t = vu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function Ppe(n) {
        return !!n?.[SP];
    }
    function up(n) {
        return new Dpe(n);
    }
    const kpe = "0.1.0", Rpe = "id", Ope = "id/push", $pe = "1.0.0", Mpe = "1.0.0", Npe = 1024 * 8, Lpe = 32, Upe = 1e3;
    var Yc;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.protocolVersion != null && (r.uint32(42), r.string(t.protocolVersion)), t.agentVersion != null && (r.uint32(50), r.string(t.agentVersion)), t.publicKey != null && (r.uint32(10), r.bytes(t.publicKey)), t.listenAddrs != null) for (const i of t.listenAddrs)r.uint32(18), r.bytes(i);
                if (t.observedAddr != null && (r.uint32(34), r.bytes(t.observedAddr)), t.protocols != null) for (const i of t.protocols)r.uint32(26), r.string(i);
                t.signedPeerRecord != null && (r.uint32(66), r.bytes(t.signedPeerRecord)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    listenAddrs: [],
                    protocols: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 5:
                            {
                                i.protocolVersion = t.string();
                                break;
                            }
                        case 6:
                            {
                                i.agentVersion = t.string();
                                break;
                            }
                        case 1:
                            {
                                i.publicKey = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.listenAddrs != null && i.listenAddrs.length === s.limits.listenAddrs) throw new vt('Decode error - map field "listenAddrs" had too many elements');
                                i.listenAddrs.push(t.bytes());
                                break;
                            }
                        case 4:
                            {
                                i.observedAddr = t.bytes();
                                break;
                            }
                        case 3:
                            {
                                if (s.limits?.protocols != null && i.protocols.length === s.limits.protocols) throw new vt('Decode error - map field "protocols" had too many elements');
                                i.protocols.push(t.string());
                                break;
                            }
                        case 8:
                            {
                                i.signedPeerRecord = t.bytes();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Yc || (Yc = {}));
    const IP = Symbol.for("nodejs.util.inspect.custom"), zpe = 114;
    let U8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [bP] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(zpe, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [IP]() {
            return `PeerId(${this.toString()})`;
        }
    }, CP = class extends U8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, TP = class extends U8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, _P = class extends U8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const Fpe = 2336;
    let xP = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [IP]() {
            return `PeerId(${this.url})`;
        }
        [bP] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Fpe, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const Vpe = 114, qA = 2336;
    function Hpe(n) {
        if (n.type === "Ed25519") return new TP({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "secp256k1") return new _P({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "RSA") return new CP({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        throw new E0e;
    }
    function Qpe(n) {
        if (Kpe(n)) return new CP({
            multihash: n
        });
        if (qpe(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new TP({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new _P({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new xP(new URL(t));
        }
        throw new v0e("Supplied PeerID Multihash is invalid");
    }
    function DP(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== Vpe && n.code !== qA) throw new b0e("Supplied PeerID CID is invalid");
        if (n.code === qA) {
            const e = L(n.multihash.digest);
            return new xP(new URL(e));
        }
        return Qpe(n.multihash);
    }
    function qpe(n) {
        return n.code === nt.code;
    }
    function Kpe(n) {
        return n.code === Ut.code;
    }
    const is = {
        protocolPrefix: "ipfs",
        timeout: 5e3,
        maxInboundStreams: 1,
        maxOutboundStreams: 1,
        maxObservedAddresses: 10,
        maxMessageSize: Npe,
        runOnConnectionOpen: !0,
        runOnSelfUpdate: !0,
        runOnLimitedConnection: !0,
        concurrency: Lpe
    };
    function Gpe(n) {
        if (n != null && n.length > 0) try {
            return up(n);
        } catch  {}
    }
    async function BP(n, e, t, r, s) {
        if (t("received identify from %p", r.remotePeer), s == null) throw new Na("message was null or undefined");
        const i = {};
        if (s.listenAddrs.length > 0 && (i.addresses = s.listenAddrs.map((h)=>({
                isCertified: !1,
                multiaddr: up(h)
            }))), s.protocols.length > 0 && (i.protocols = s.protocols), s.publicKey != null) {
            const h = Er(s.publicKey);
            if (!Hpe(h).equals(r.remotePeer)) throw new Na("public key did not match remote PeerId");
            i.publicKey = h;
        }
        let l;
        if (s.signedPeerRecord != null) {
            t.trace("received signedPeerRecord from %p", r.remotePeer);
            let h = s.signedPeerRecord;
            const f = await ci.openAndCertify(h, Ur.DOMAIN);
            let p = Ur.createFromProtobuf(f.payload);
            const m = DP(f.publicKey.toCID());
            if (!p.peerId.equals(m)) throw new Na("signing key does not match PeerId in the PeerRecord");
            if (!r.remotePeer.equals(p.peerId)) throw new Na("signing key does not match remote PeerId");
            let w;
            try {
                w = await n.get(p.peerId);
            } catch (A) {
                if (A.name !== "NotFoundError") throw A;
            }
            if (w != null && (i.metadata = w.metadata, w.peerRecordEnvelope != null)) {
                const A = ci.createFromProtobuf(w.peerRecordEnvelope), S = Ur.createFromProtobuf(A.payload);
                S.seqNumber >= p.seqNumber && (t("sequence number was lower or equal to existing sequence number - stored: %d received: %d", S.seqNumber, p.seqNumber), p = S, h = w.peerRecordEnvelope);
            }
            i.peerRecordEnvelope = h, i.addresses = p.multiaddrs.map((A)=>({
                    isCertified: !0,
                    multiaddr: A
                })), l = {
                seq: p.seqNumber,
                addresses: p.multiaddrs
            };
        } else t("%p did not send a signed peer record", r.remotePeer);
        if (t.trace("patching %p with", r.remotePeer, i), await n.patch(r.remotePeer, i), s.agentVersion != null || s.protocolVersion != null) {
            const h = {};
            s.agentVersion != null && (h.AgentVersion = re(s.agentVersion)), s.protocolVersion != null && (h.ProtocolVersion = re(s.protocolVersion)), t.trace("merging %p metadata", r.remotePeer, h), await n.merge(r.remotePeer, {
                metadata: h
            });
        }
        const u = {
            peerId: r.remotePeer,
            protocolVersion: s.protocolVersion,
            agentVersion: s.agentVersion,
            publicKey: s.publicKey,
            listenAddrs: s.listenAddrs.map((h)=>up(h)),
            observedAddr: s.observedAddr == null ? void 0 : up(s.observedAddr),
            protocols: s.protocols,
            signedPeerRecord: l,
            connection: r
        };
        return e.safeDispatchEvent("peer:identify", {
            detail: u
        }), u;
    }
    class PP {
        host;
        components;
        protocol;
        started;
        timeout;
        maxInboundStreams;
        maxOutboundStreams;
        maxMessageSize;
        maxObservedAddresses;
        runOnLimitedConnection;
        log;
        constructor(e, t){
            this.protocol = t.protocol, this.started = !1, this.components = e, this.log = t.log, this.timeout = t.timeout ?? is.timeout, this.maxInboundStreams = t.maxInboundStreams ?? is.maxInboundStreams, this.maxOutboundStreams = t.maxOutboundStreams ?? is.maxOutboundStreams, this.maxMessageSize = t.maxMessageSize ?? is.maxMessageSize, this.maxObservedAddresses = t.maxObservedAddresses ?? is.maxObservedAddresses, this.runOnLimitedConnection = t.runOnLimitedConnection ?? is.runOnLimitedConnection, this.host = {
                protocolVersion: `${t.protocolPrefix ?? is.protocolPrefix}/${kpe}`,
                agentVersion: e.nodeInfo.userAgent
            }, this.handleProtocol = this.handleProtocol.bind(this);
        }
        isStarted() {
            return this.started;
        }
        async start() {
            this.started || (await this.components.peerStore.merge(this.components.peerId, {
                metadata: {
                    AgentVersion: re(this.host.agentVersion),
                    ProtocolVersion: re(this.host.protocolVersion)
                }
            }), await this.components.registrar.handle(this.protocol, this.handleProtocol, {
                maxInboundStreams: this.maxInboundStreams,
                maxOutboundStreams: this.maxOutboundStreams,
                runOnLimitedConnection: this.runOnLimitedConnection
            }), this.started = !0);
        }
        async stop() {
            await this.components.registrar.unhandle(this.protocol), this.started = !1;
        }
    }
    class Ype extends PP {
        connectionManager;
        concurrency;
        _push;
        constructor(e, t = {}){
            super(e, {
                ...t,
                protocol: `/${t.protocolPrefix ?? is.protocolPrefix}/${Ope}/${Mpe}`,
                log: e.logger.forComponent("libp2p:identify-push")
            }), this.connectionManager = e.connectionManager, this.concurrency = t.concurrency ?? is.concurrency, this._push = zd(this.sendPushMessage.bind(this), t.debounce ?? Upe), (t.runOnSelfUpdate ?? is.runOnSelfUpdate) && e.events.addEventListener("self:peer:update", (r)=>{
                this.push().catch((s)=>{
                    this.log.error("error pushing updates to peers - %e", s);
                });
            });
        }
        [vP] = [
            "@libp2p/identify-push"
        ];
        async push() {
            this._push();
        }
        async sendPushMessage() {
            if (this.isStarted()) try {
                const e = this.components.addressManager.getAddresses().map((p)=>p.decapsulateCode(L8)), t = new Ur({
                    peerId: this.components.peerId,
                    multiaddrs: e
                }), r = await ci.seal(t, this.components.privateKey), s = this.components.registrar.getProtocols(), i = await this.components.peerStore.get(this.components.peerId), l = L(i.metadata.get("AgentVersion") ?? re(this.host.agentVersion)), u = L(i.metadata.get("ProtocolVersion") ?? re(this.host.protocolVersion)), h = this;
                async function* f() {
                    for (const p of h.connectionManager.getConnections())(await h.components.peerStore.get(p.remotePeer)).protocols.includes(h.protocol) && (yield async ()=>{
                        let w;
                        const A = AbortSignal.timeout(h.timeout);
                        try {
                            w = await p.newStream(h.protocol, {
                                signal: A,
                                runOnLimitedConnection: h.runOnLimitedConnection
                            }), await Jn(w, {
                                maxDataLength: h.maxMessageSize
                            }).pb(Yc).write({
                                listenAddrs: e.map((_)=>_.bytes),
                                signedPeerRecord: r.marshal(),
                                protocols: s,
                                agentVersion: l,
                                protocolVersion: u
                            }, {
                                signal: A
                            }), await w.close({
                                signal: A
                            });
                        } catch (S) {
                            w?.log.newScope("identify-push")?.error("could not push identify update to peer", S), w?.abort(S);
                        }
                    });
                }
                await qo(Bg(f(), {
                    concurrency: this.concurrency
                }));
            } catch (e) {
                this.log.error("error pushing updates to peers - %e", e);
            }
        }
        async handleProtocol(e, t) {
            const r = e.log.newScope("identify-push");
            if (this.components.peerId.equals(t.remotePeer)) throw new Error("received push from ourselves?");
            const s = {
                signal: AbortSignal.timeout(this.timeout)
            }, l = await Jn(e, {
                maxDataLength: this.maxMessageSize
            }).pb(Yc).read(s);
            await e.close(s), await BP(this.components.peerStore, this.components.events, r, t, l), r.trace("handled push from %p", t.remotePeer);
        }
    }
    class Wpe extends PP {
        constructor(e, t = {}){
            super(e, {
                ...t,
                protocol: `/${t.protocolPrefix ?? is.protocolPrefix}/${Rpe}/${$pe}`,
                log: e.logger.forComponent("libp2p:identify")
            }), (t.runOnConnectionOpen ?? is.runOnConnectionOpen) && e.events.addEventListener("connection:open", (r)=>{
                const s = r.detail;
                this.identify(s).catch(()=>{});
            });
        }
        [vP] = [
            "@libp2p/identify"
        ];
        async _identify(e, t = {}) {
            let r, s;
            if (t.signal == null) {
                const i = AbortSignal.timeout(this.timeout);
                t = {
                    ...t,
                    signal: i
                };
            }
            this.log("run identify on new connection %a", e.remoteAddr);
            try {
                r = await e.newStream(this.protocol, {
                    ...t,
                    runOnLimitedConnection: this.runOnLimitedConnection
                }), s = r.log.newScope("identify");
                const i = Jn(r, {
                    maxDataLength: this.maxMessageSize
                }).pb(Yc), l = await i.read(t);
                return await i.unwrap().unwrap().close(t), l;
            } catch (i) {
                throw s?.error("identify failed - %e", i), r?.abort(i), i;
            }
        }
        async identify(e, t = {}) {
            const r = await this._identify(e, t), { publicKey: s, protocols: i, observedAddr: l } = r;
            if (s == null) throw new Na("Public key was missing from identify message");
            const u = Er(s), h = DP(u.toCID());
            if (!e.remotePeer.equals(h)) throw new Na("Identified peer does not match the expected peer");
            if (this.components.peerId.equals(h)) throw new Na("Identified peer is our own peer id?");
            return this.maybeAddObservedAddress(l), this.log("completed for peer %p and protocols %o", h, i), BP(this.components.peerStore, this.components.events, this.log, e, r);
        }
        maybeAddObservedAddress(e) {
            const t = Gpe(e);
            if (t == null || (this.log.trace("our observed address was %a", t), Is(t))) return;
            const r = t.getComponents();
            if ((r[0].code === O4 || r[0].code === EP && r[1].code === O4) && !_C(t)) {
                this.log.trace("our observed address was IPv6 but not a global unicast address");
                return;
            }
            Op.exactMatch(t) || (this.log.trace("storing the observed address"), this.components.addressManager.addObservedAddr(t));
        }
        async handleProtocol(e, t) {
            const r = e.log.newScope("identify");
            r("responding to identify");
            const s = AbortSignal.timeout(this.timeout), i = await this.components.peerStore.get(this.components.peerId, {
                signal: s
            }), l = this.components.addressManager.getAddresses().map((p)=>p.decapsulateCode(L8));
            let u = i.peerRecordEnvelope;
            if (l.length > 0 && u == null) {
                const p = new Ur({
                    peerId: this.components.peerId,
                    multiaddrs: l
                });
                u = (await ci.seal(p, this.components.privateKey, {
                    signal: s
                })).marshal().subarray();
            }
            let h = t.remoteAddr.bytes;
            vG.matches(t.remoteAddr) || (h = void 0);
            const f = Jn(e).pb(Yc);
            r("send response"), await f.write({
                protocolVersion: this.host.protocolVersion,
                agentVersion: this.host.agentVersion,
                publicKey: Fr(this.components.privateKey.publicKey),
                listenAddrs: l.map((p)=>p.bytes),
                signedPeerRecord: u,
                observedAddr: h,
                protocols: i.protocols
            }, {
                signal: s
            }), r("close write"), await f.unwrap().unwrap().close({
                signal: s
            });
        }
    }
    function kP(n = {}) {
        return (e)=>new Wpe(e, n);
    }
    function jpe(n = {}) {
        return (e)=>new Ype(e, n);
    }
    const Xpe = Symbol.for("@libp2p/content-routing");
    class Jpe extends Error {
        static name = "AbortError";
        constructor(e = "The operation was aborted"){
            super(e), this.name = "AbortError";
        }
    }
    let ii = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    };
    class KA extends Error {
        static name = "InvalidPublicKeyError";
        constructor(e = "Invalid public key"){
            super(e), this.name = "InvalidPublicKeyError";
        }
    }
    class Mf extends Error {
        static name = "NotFoundError";
        constructor(e = "Not found"){
            super(e), this.name = "NotFoundError";
        }
    }
    let Zpe = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, ege = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }, Ga = class extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    }, tge = class extends Error {
        static name = "TimeoutError";
        constructor(e = "Timed out"){
            super(e), this.name = "TimeoutError";
        }
    };
    class nge extends Error {
        static name = "UnsupportedKeyTypeError";
        constructor(e = "Unsupported key type"){
            super(e), this.name = "UnsupportedKeyTypeError";
        }
    }
    const rge = Symbol.for("@libp2p/peer-discovery"), RP = Symbol.for("@libp2p/peer-id"), sge = Symbol.for("@libp2p/peer-routing"), ige = "keep-alive";
    function OP(n) {
        return n != null && typeof n.start == "function" && typeof n.stop == "function";
    }
    async function $4(...n) {
        const e = [];
        for (const t of n)OP(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStart != null && await t.beforeStart();
        })), await Promise.all(e.map(async (t)=>{
            await t.start();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStart != null && await t.afterStart();
        }));
    }
    async function $P(...n) {
        const e = [];
        for (const t of n)OP(t) && e.push(t);
        await Promise.all(e.map(async (t)=>{
            t.beforeStop != null && await t.beforeStop();
        })), await Promise.all(e.map(async (t)=>{
            await t.stop();
        })), await Promise.all(e.map(async (t)=>{
            t.afterStop != null && await t.afterStop();
        }));
    }
    const oge = Symbol.for("@libp2p/service-capabilities"), age = Symbol.for("@libp2p/service-dependencies"), Eu = 1e3, z8 = 60 * Eu, Lg = 60 * z8, lge = "/ipfs/kad/1.0.0", MP = 48 * Lg, cge = 24 * Lg, uge = 10, hge = 16384, dge = Lg, GA = Lg, fge = 10 * Eu, NP = 20, Ug = 10, pge = 5 * z8, gge = Eu, mge = 5 * Eu, yge = 5 * z8, wge = 30 * Eu, bge = 180 * Eu, YA = `${ige}-kad-dht`;
    var ng;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.key != null && t.key.byteLength > 0 && (r.uint32(10), r.bytes(t.key)), t.value != null && t.value.byteLength > 0 && (r.uint32(18), r.bytes(t.value)), t.timeReceived != null && t.timeReceived !== "" && (r.uint32(42), r.string(t.timeReceived)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    key: je(0),
                    value: je(0),
                    timeReceived: ""
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.key = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.value = t.bytes();
                                break;
                            }
                        case 5:
                            {
                                i.timeReceived = t.string();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(ng || (ng = {}));
    function vge(n) {
        const e = n.getUTCFullYear(), t = String(n.getUTCMonth() + 1).padStart(2, "0"), r = String(n.getUTCDate()).padStart(2, "0"), s = String(n.getUTCHours()).padStart(2, "0"), i = String(n.getUTCMinutes()).padStart(2, "0"), l = String(n.getUTCSeconds()).padStart(2, "0"), u = n.getUTCMilliseconds(), h = String(u * 1e3 * 1e3).padStart(9, "0");
        return `${e}-${t}-${r}T${s}:${i}:${l}.${h}Z`;
    }
    function Ege(n) {
        const e = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"), t = String(n).trim().match(e);
        if (t == null) throw new Error("Invalid format");
        const r = parseInt(t[1], 10), s = parseInt(t[2], 10) - 1, i = parseInt(t[3], 10), l = parseInt(t[4], 10), u = parseInt(t[5], 10), h = parseInt(t[6], 10), f = parseInt(t[7].slice(0, -6), 10);
        return new Date(Date.UTC(r, s, i, l, u, h, f));
    }
    class Ss {
        key;
        value;
        timeReceived;
        constructor(e, t, r){
            if (!(e instanceof Uint8Array)) throw new Error("key must be a Uint8Array");
            if (!(t instanceof Uint8Array)) throw new Error("value must be a Uint8Array");
            this.key = e, this.value = t, this.timeReceived = r;
        }
        serialize() {
            return ng.encode(this.prepareSerialize());
        }
        prepareSerialize() {
            return {
                key: this.key,
                value: this.value,
                timeReceived: vge(this.timeReceived)
            };
        }
        static deserialize(e) {
            const t = ng.decode(e);
            return new Ss(t.key, t.value, new Date(t.timeReceived));
        }
        static fromDeserialized(e) {
            const t = Ege(e.timeReceived);
            if (e.key == null) throw new Error("key missing from deserialized object");
            if (e.value == null) throw new Error("value missing from deserialized object");
            return new Ss(e.key, e.value, t);
        }
    }
    class rg extends Error {
        constructor(e = "Query error"){
            super(e), this.name = "QueryError";
        }
    }
    class Age extends Error {
        constructor(e = "Invalid record"){
            super(e), this.name = "InvalidRecordError";
        }
    }
    class Sge extends Error {
        constructor(e = "No selector function configured for prefix"){
            super(e), this.name = "MissingSelectorError";
        }
    }
    var WA;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                s.lengthDelimited !== !1 && r.fork(), t.key != null && (r.uint32(10), r.bytes(t.key)), t.value != null && (r.uint32(18), r.bytes(t.value)), t.author != null && (r.uint32(26), r.bytes(t.author)), t.signature != null && (r.uint32(34), r.bytes(t.signature)), t.timeReceived != null && (r.uint32(42), r.string(t.timeReceived)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {}, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.key = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                i.value = t.bytes();
                                break;
                            }
                        case 3:
                            {
                                i.author = t.bytes();
                                break;
                            }
                        case 4:
                            {
                                i.signature = t.bytes();
                                break;
                            }
                        case 5:
                            {
                                i.timeReceived = t.string();
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(WA || (WA = {}));
    var Ht;
    (function(n) {
        n.PUT_VALUE = "PUT_VALUE", n.GET_VALUE = "GET_VALUE", n.ADD_PROVIDER = "ADD_PROVIDER", n.GET_PROVIDERS = "GET_PROVIDERS", n.FIND_NODE = "FIND_NODE", n.PING = "PING";
    })(Ht || (Ht = {}));
    var sg;
    (function(n) {
        n[n.PUT_VALUE = 0] = "PUT_VALUE", n[n.GET_VALUE = 1] = "GET_VALUE", n[n.ADD_PROVIDER = 2] = "ADD_PROVIDER", n[n.GET_PROVIDERS = 3] = "GET_PROVIDERS", n[n.FIND_NODE = 4] = "FIND_NODE", n[n.PING = 5] = "PING";
    })(sg || (sg = {}));
    (function(n) {
        n.codec = ()=>vr(sg);
    })(Ht || (Ht = {}));
    var Wc;
    (function(n) {
        n.NOT_CONNECTED = "NOT_CONNECTED", n.CONNECTED = "CONNECTED", n.CAN_CONNECT = "CAN_CONNECT", n.CANNOT_CONNECT = "CANNOT_CONNECT";
    })(Wc || (Wc = {}));
    var M4;
    (function(n) {
        n[n.NOT_CONNECTED = 0] = "NOT_CONNECTED", n[n.CONNECTED = 1] = "CONNECTED", n[n.CAN_CONNECT = 2] = "CAN_CONNECT", n[n.CANNOT_CONNECT = 3] = "CANNOT_CONNECT";
    })(M4 || (M4 = {}));
    (function(n) {
        n.codec = ()=>vr(M4);
    })(Wc || (Wc = {}));
    var dc;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.id != null && t.id.byteLength > 0 && (r.uint32(10), r.bytes(t.id)), t.multiaddrs != null) for (const i of t.multiaddrs)r.uint32(18), r.bytes(i);
                t.connection != null && (r.uint32(24), Wc.codec().encode(t.connection, r)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    id: je(0),
                    multiaddrs: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.id = t.bytes();
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.multiaddrs != null && i.multiaddrs.length === s.limits.multiaddrs) throw new vt('Decode error - map field "multiaddrs" had too many elements');
                                i.multiaddrs.push(t.bytes());
                                break;
                            }
                        case 3:
                            {
                                i.connection = Wc.codec().decode(t);
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(dc || (dc = {}));
    var Pc;
    (function(n) {
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.type != null && sg[t.type] !== 0 && (r.uint32(8), Ht.codec().encode(t.type, r)), t.clusterLevel != null && (r.uint32(80), r.int32(t.clusterLevel)), t.key != null && (r.uint32(18), r.bytes(t.key)), t.record != null && (r.uint32(26), r.bytes(t.record)), t.closer != null) for (const i of t.closer)r.uint32(66), dc.codec().encode(i, r);
                if (t.providers != null) for (const i of t.providers)r.uint32(74), dc.codec().encode(i, r);
                s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    type: Ht.PUT_VALUE,
                    closer: [],
                    providers: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                i.type = Ht.codec().decode(t);
                                break;
                            }
                        case 10:
                            {
                                i.clusterLevel = t.int32();
                                break;
                            }
                        case 2:
                            {
                                i.key = t.bytes();
                                break;
                            }
                        case 3:
                            {
                                i.record = t.bytes();
                                break;
                            }
                        case 8:
                            {
                                if (s.limits?.closer != null && i.closer.length === s.limits.closer) throw new vt('Decode error - map field "closer" had too many elements');
                                i.closer.push(dc.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.closer$
                                }));
                                break;
                            }
                        case 9:
                            {
                                if (s.limits?.providers != null && i.providers.length === s.limits.providers) throw new vt('Decode error - map field "providers" had too many elements');
                                i.providers.push(dc.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.providers$
                                }));
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(Pc || (Pc = {}));
    function jA(n, e = {}) {
        const t = {
            ...n,
            name: "SEND_QUERY",
            type: 0,
            messageName: n.type,
            messageType: n.type
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:send-query", {
            detail: t
        })), t;
    }
    function N4(n, e = {}) {
        const t = {
            ...n,
            name: "PEER_RESPONSE",
            type: 1,
            messageName: n.messageType,
            closer: n.closer ?? [],
            providers: n.providers ?? []
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:peer-response", {
            detail: t
        })), t;
    }
    function py(n, e = {}) {
        const t = {
            ...n,
            name: "FINAL_PEER",
            type: 2
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:final-peer", {
            detail: t
        })), t;
    }
    function jc(n, e = {}) {
        const t = {
            ...n,
            name: "QUERY_ERROR",
            type: 3
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:query-error", {
            detail: t
        })), t;
    }
    function XA(n, e = {}) {
        const t = {
            ...n,
            name: "PROVIDER",
            type: 4
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:provider", {
            detail: t
        })), t;
    }
    function L4(n, e = {}) {
        const t = {
            ...n,
            name: "VALUE",
            type: 5
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:value", {
            detail: t
        })), t;
    }
    function JA(n, e = {}) {
        const t = {
            ...n,
            name: "DIAL_PEER",
            type: 7
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:dial-peer", {
            detail: t
        })), t;
    }
    function Ige(n, e = {}) {
        const t = {
            ...n,
            name: "PATH_ENDED",
            type: 8
        };
        return e.onProgress?.(new CustomEvent("kad-dht:query:path-ended", {
            detail: t
        })), t;
    }
    function Cge(n, e, t) {
        if (t.length === 0) throw new ii("No records given");
        const s = L(e).split("/");
        if (s.length < 3) throw new ii("Record key does not have a selector function");
        const i = n[s[1].toString()];
        if (i == null) throw new Sge(`No selector function configured for key type "${s[1]}"`);
        return t.length === 1 ? 0 : i(e, t);
    }
    function Tge(n, e) {
        return 0;
    }
    const _ge = {
        pk: Tge
    };
    async function F8(n, e, t) {
        const r = e.key, i = L(r).split("/");
        if (i.length < 3) return;
        const l = n[i[1].toString()];
        if (l == null) throw new ii(`No validator available for key type "${i[1]}"`);
        await l(r, e.value, t);
    }
    const xge = async (n, e, t)=>{
        if (!(n instanceof Uint8Array)) throw new ii('"key" must be a Uint8Array');
        if (n.byteLength < 5) throw new ii("Invalid public key record");
        if (L(n.subarray(0, 4)) !== "/pk/") throw new ii("key was not prefixed with /pk/");
        const s = Er(e), i = n.slice(4);
        if (!Ee(i, s.toMultihash().bytes)) throw new ii("public key does not match passed in key");
    }, Dge = {
        pk: xge
    }, LP = Symbol.for("nodejs.util.inspect.custom"), Bge = 114;
    let V8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [RP] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Bge, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [LP]() {
            return `PeerId(${this.toString()})`;
        }
    }, UP = class extends V8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, zP = class extends V8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, FP = class extends V8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const Pge = 2336;
    let VP = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [LP]() {
            return `PeerId(${this.url})`;
        }
        [RP] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(Pge, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const kge = 114, ZA = 2336;
    function Rge(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return $ge(ge.parse(n));
            throw new ii('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return Jo(t);
    }
    function Oge(n) {
        if (n.type === "Ed25519") return new zP({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "secp256k1") return new FP({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        if (n.type === "RSA") return new UP({
            multihash: n.toCID().multihash,
            publicKey: n
        });
        throw new nge;
    }
    function Jo(n) {
        if (Nge(n)) return new UP({
            multihash: n
        });
        if (Mge(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new zP({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new FP({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new VP(new URL(t));
        }
        throw new ege("Supplied PeerID Multihash is invalid");
    }
    function $ge(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== kge && n.code !== ZA) throw new Zpe("Supplied PeerID CID is invalid");
        if (n.code === ZA) {
            const e = L(n.multihash.digest);
            return new VP(new URL(e));
        }
        return Jo(n.multihash);
    }
    function Mge(n) {
        return n.code === nt.code;
    }
    function Nge(n) {
        return n.code === Ut.code;
    }
    const Lge = re("/pk/");
    function Uge(n) {
        return {
            ...n,
            multiaddrs: n.multiaddrs.filter((e)=>!Is(e))
        };
    }
    async function yf(n, e) {
        const t = await Ut.digest(n);
        return e?.signal?.throwIfAborted(), t.digest;
    }
    async function ji(n, e) {
        return yf(n.toMultihash().bytes, e);
    }
    function Td(n, e) {
        return new Nt(`${n}/${L(e, "base32")}`, !1);
    }
    function zge(n) {
        return xe([
            Lge,
            n.toMultihash().bytes
        ]);
    }
    function Fge(n) {
        return L(n.subarray(0, 4)) === "/pk/";
    }
    function Vge(n) {
        const e = kt(n.subarray(4));
        return Jo(e);
    }
    function eS(n, e) {
        const t = new Date;
        return new Ss(n, e, t).serialize();
    }
    function HP(n) {
        const e = n.toString().split("/"), t = e.pop(), r = e.pop();
        if (t == null || r == null) throw new Error(`incorrectly formatted provider entry key in datastore: ${n.toString()}`);
        return {
            cid: ge.createV1(Af, kt(re(r, "base32"))),
            peerId: Rge(t)
        };
    }
    function gy(n, e, t) {
        const r = typeof e == "string" ? e : L(e.multihash.bytes, "base32"), s = [
            n,
            r
        ];
        return t != null && s.push(t.toString()), new Nt(s.join("/"));
    }
    function QP(n) {
        return new Date(et(n));
    }
    function Yl(n, e, t) {
        return async function*(...r) {
            const s = e.queryTime?.timer(t), i = e.errorTime?.timer(t);
            let l = !1;
            try {
                e.queries?.increment({
                    [t]: !0
                }), yield* n(...r);
            } catch (u) {
                throw l = !0, i?.(), e.errors?.increment({
                    [t]: !0
                }), u;
            } finally{
                e.queries?.decrement({
                    [t]: !0
                }), l || s?.();
            }
        };
    }
    function qP(n, e, t) {
        return async function(...r) {
            const s = e?.queryTime?.timer(t), i = e?.errorTime?.timer(t);
            let l = !1;
            try {
                return e.queries?.increment({
                    [t]: !0
                }), await n(...r);
            } catch (u) {
                throw l = !0, i?.(), e.errors?.increment({
                    [t]: !0
                }), u;
            } finally{
                e.queries?.decrement({
                    [t]: !0
                }), l || s?.();
            }
        };
    }
    class Hge {
        log;
        components;
        validators;
        selectors;
        peerRouting;
        queryManager;
        network;
        datastorePrefix;
        constructor(e, t){
            const { validators: r, selectors: s, peerRouting: i, queryManager: l, network: u, logPrefix: h } = t;
            this.components = e, this.log = e.logger.forComponent(`${h}:content-fetching`), this.datastorePrefix = `${t.datastorePrefix}/record`, this.validators = r, this.selectors = s, this.peerRouting = i, this.queryManager = l, this.network = u, this.get = e.metrics?.traceFunction("libp2p.kadDHT.get", this.get.bind(this), {
                optionsIndex: 1
            }) ?? this.get, this.put = e.metrics?.traceFunction("libp2p.kadDHT.put", this.put.bind(this), {
                optionsIndex: 2
            }) ?? this.put;
        }
        async getLocal(e, t) {
            this.log("getLocal %b", e);
            const r = Td(this.datastorePrefix, e);
            this.log("fetching record for key %k", r);
            const s = await this.components.datastore.get(r, t);
            this.log("found %k in local datastore", r);
            const i = Ss.deserialize(s);
            return await F8(this.validators, i, t), i;
        }
        async *sendCorrectionRecord(e, t, r, s) {
            this.log("sendCorrection for %b", e);
            const i = eS(e, r);
            for (const { value: l, from: u } of t){
                if (Ee(l, r)) {
                    this.log("record was ok");
                    continue;
                }
                if (this.components.peerId.equals(u)) {
                    try {
                        const p = Td(this.datastorePrefix, e);
                        this.log(`Storing corrected record for key ${p.toString()}`), await this.components.datastore.put(p, i.subarray(), s);
                    } catch (p) {
                        this.log.error("failed error correcting self - %e", p);
                    }
                    continue;
                }
                let h = !1;
                const f = {
                    type: Ht.PUT_VALUE,
                    key: e,
                    record: i
                };
                for await (const p of this.network.sendRequest(u, f, s))p.name === "PEER_RESPONSE" && p.record != null && Ee(p.record.value, Ss.deserialize(i).value) && (h = !0), yield p;
                if (!h) throw new rg("Could not send correction");
                this.log.error("failed error correcting entry");
            }
        }
        async *put(e, t, r) {
            this.log("put key %b value %b", e, t);
            const s = eS(e, t), i = Td(this.datastorePrefix, e);
            this.log(`storing record for key ${i.toString()}`), await this.components.datastore.put(i, s.subarray(), r), yield* Oc(this.peerRouting.getClosestPeers(e, {
                ...r,
                signal: r.signal
            }), (l)=>kf(l, (u)=>async ()=>{
                        if (u.name !== "FINAL_PEER") return [
                            u
                        ];
                        const h = [], f = {
                            type: Ht.PUT_VALUE,
                            key: e,
                            record: s
                        };
                        this.log("send put to %p", u.peer.id);
                        for await (const p of this.network.sendRequest(u.peer.id, f, {
                            ...r,
                            path: u.path
                        }))h.push(p), p.name === "PEER_RESPONSE" && (p.record != null && Ee(p.record.value, Ss.deserialize(s).value) || h.push(jc({
                            from: u.peer.id,
                            error: new rg("Value not put correctly"),
                            path: p.path
                        }, r)));
                        return h;
                    }), (l)=>Bg(l, {
                    ordered: !1,
                    concurrency: Ug
                }), async function*(l) {
                for await (const u of l)yield* u;
            });
        }
        async *get(e, t) {
            this.log("get %b", e);
            const r = [];
            for await (const u of this.getMany(e, t)){
                if (u.name === "VALUE") {
                    r.push(u);
                    continue;
                }
                yield u;
            }
            if (r.length === 0) return;
            const s = r.map((u)=>u.value);
            let i = 0;
            try {
                i = Cge(this.selectors, e, s);
            } catch (u) {
                if (u.name !== "InvalidParametersError") throw u;
            }
            const l = s[i];
            if (this.log("GetValue %b %b", e, l), l == null) throw new Mf("Best value was not found");
            yield* this.sendCorrectionRecord(e, r, l, {
                ...t,
                path: {
                    index: -1,
                    queued: 0,
                    running: 0,
                    total: 0
                }
            }), yield r[i];
        }
        async *getMany(e, t = {}) {
            this.log("getMany values for %b", e);
            try {
                const i = await this.getLocal(e, t);
                yield L4({
                    value: i.value,
                    from: this.components.peerId,
                    path: {
                        index: -1,
                        running: 0,
                        queued: 0,
                        total: 0
                    }
                }, t);
            } catch (i) {
                this.log("error getting local value for %b", e, i);
            }
            const r = this, s = async function*({ peer: i, signal: l, path: u }) {
                for await (const h of r.peerRouting.getValueOrPeers(i.id, e, {
                    ...t,
                    signal: l,
                    path: u
                }))yield h, h.name === "PEER_RESPONSE" && h.record != null && (yield L4({
                    from: i.id,
                    value: h.record.value,
                    path: u
                }, t));
            };
            yield* this.queryManager.run(e, s, t);
        }
    }
    function _d(n, e) {
        const t = {
            [Symbol.iterator]: ()=>t,
            next: ()=>{
                const r = n.next(), s = r.value;
                return r.done === !0 || s == null ? {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: e(s)
                };
            }
        };
        return t;
    }
    function my(n) {
        const e = kt(He.decode(`z${n}`));
        return Jo(e);
    }
    class H8 {
        map;
        constructor(e){
            if (this.map = new Map, e != null) for (const [t, r] of e.entries())this.map.set(t.toString(), {
                key: t,
                value: r
            });
        }
        [Symbol.iterator]() {
            return this.entries();
        }
        clear() {
            this.map.clear();
        }
        delete(e) {
            return this.map.delete(e.toString());
        }
        entries() {
            return _d(this.map.entries(), (e)=>[
                    e[1].key,
                    e[1].value
                ]);
        }
        forEach(e) {
            this.map.forEach((t, r)=>{
                e(t.value, t.key, this);
            });
        }
        get(e) {
            return this.map.get(e.toString())?.value;
        }
        has(e) {
            return this.map.has(e.toString());
        }
        set(e, t) {
            this.map.set(e.toString(), {
                key: e,
                value: t
            });
        }
        keys() {
            return _d(this.map.values(), (e)=>e.key);
        }
        values() {
            return _d(this.map.values(), (e)=>e.value);
        }
        get size() {
            return this.map.size;
        }
    }
    class Ua {
        set;
        constructor(e){
            if (this.set = new Set, e != null) for (const t of e)this.set.add(t.toString());
        }
        get size() {
            return this.set.size;
        }
        [Symbol.iterator]() {
            return this.values();
        }
        add(e) {
            this.set.add(e.toString());
        }
        clear() {
            this.set.clear();
        }
        delete(e) {
            this.set.delete(e.toString());
        }
        entries() {
            return _d(this.set.entries(), (e)=>{
                const t = my(e[0]);
                return [
                    t,
                    t
                ];
            });
        }
        forEach(e) {
            this.set.forEach((t)=>{
                const r = my(t);
                e(r, r, this);
            });
        }
        has(e) {
            return this.set.has(e.toString());
        }
        values() {
            return _d(this.set.values(), (e)=>my(e));
        }
        intersection(e) {
            const t = new Ua;
            for (const r of e)this.has(r) && t.add(r);
            return t;
        }
        difference(e) {
            const t = new Ua;
            for (const r of this)e.has(r) || t.add(r);
            return t;
        }
        union(e) {
            const t = new Ua;
            for (const r of e)t.add(r);
            for (const r of this)t.add(r);
            return t;
        }
    }
    class Qge extends H8 {
        metric;
        constructor(e){
            super();
            const { name: t, metrics: r } = e;
            this.metric = r.registerMetric(t), this.updateComponentMetric();
        }
        set(e, t) {
            return super.set(e, t), this.updateComponentMetric(), this;
        }
        delete(e) {
            const t = super.delete(e);
            return this.updateComponentMetric(), t;
        }
        clear() {
            super.clear(), this.updateComponentMetric();
        }
        updateComponentMetric() {
            this.metric.update(this.size);
        }
    }
    function qge(n) {
        const { name: e, metrics: t } = n;
        let r;
        return t != null ? r = new Qge({
            name: e,
            metrics: t
        }) : r = new H8, r;
    }
    let vs = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, wf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, Kge = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, Gge = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const Yge = 4, Wge = 6, jge = 273, Xge = 33, Jge = 41, Zge = 42, e2e = 43, t2e = 53, n2e = 54, r2e = 55, s2e = 56, i2e = 132, o2e = 301, a2e = 302, l2e = 400, KP = 421, c2e = 444, u2e = 445, h2e = 446, d2e = 447, f2e = 448, p2e = 449, g2e = 454, m2e = 460, y2e = 461, w2e = 465, b2e = 466, v2e = 480, E2e = 481, A2e = 443, S2e = 477, I2e = 478, C2e = 479, T2e = 277, _2e = 275, x2e = 276, D2e = 280, B2e = 281, P2e = 290, k2e = 777;
    function tS(n) {
        return (e)=>L(e, n);
    }
    function nS(n) {
        return (e)=>re(e, n);
    }
    function cd(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function fc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function R2e(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = fc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function O2e(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = fc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function rS(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = cd(t);
        return `${r}:${s}`;
    }
    const GP = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new vs("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, $2e = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = GP(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new vs("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, M2e = function(n) {
        if (n.byteLength !== 4) throw new vs("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, N2e = function(n) {
        if (n.byteLength !== 16) throw new vs("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new vs(`Invalid IPv6 address "${t}"`);
        }
    };
    function L2e(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new vs(`Invalid IPv6 address "${n}"`);
        }
    }
    const yy = Object.values(un).map((n)=>n.decoder), U2e = (function() {
        let n = yy[0].or(yy[1]);
        return yy.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function z2e(n) {
        return U2e.decode(n);
    }
    function F2e(n) {
        return (e)=>n.encoder.encode(e);
    }
    function V2e(n) {
        if (parseInt(n).toString() !== n) throw new wf("Value must be an integer");
    }
    function H2e(n) {
        if (n < 0) throw new wf("Value must be a positive integer, or zero");
    }
    function Q2e(n) {
        return (e)=>{
            if (e > n) throw new wf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function q2e(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const K0 = q2e(V2e, H2e, Q2e(65535)), Hn = -1;
    let K2e = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new Gge(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const Au = new K2e, G2e = [
        {
            code: Yge,
            name: "ip4",
            size: 32,
            valueToBytes: GP,
            bytesToValue: M2e,
            validate: (n)=>{
                if (!Je(n)) throw new wf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: Wge,
            name: "tcp",
            size: 16,
            valueToBytes: fc,
            bytesToValue: cd,
            validate: K0
        },
        {
            code: jge,
            name: "udp",
            size: 16,
            valueToBytes: fc,
            bytesToValue: cd,
            validate: K0
        },
        {
            code: Xge,
            name: "dccp",
            size: 16,
            valueToBytes: fc,
            bytesToValue: cd,
            validate: K0
        },
        {
            code: Jge,
            name: "ip6",
            size: 128,
            valueToBytes: $2e,
            bytesToValue: N2e,
            stringToValue: L2e,
            validate: (n)=>{
                if (!xn(n)) throw new wf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: Zge,
            name: "ip6zone",
            size: Hn
        },
        {
            code: e2e,
            name: "ipcidr",
            size: 8,
            bytesToValue: tS("base10"),
            valueToBytes: nS("base10")
        },
        {
            code: t2e,
            name: "dns",
            size: Hn
        },
        {
            code: n2e,
            name: "dns4",
            size: Hn
        },
        {
            code: r2e,
            name: "dns6",
            size: Hn
        },
        {
            code: s2e,
            name: "dnsaddr",
            size: Hn
        },
        {
            code: i2e,
            name: "sctp",
            size: 16,
            valueToBytes: fc,
            bytesToValue: cd,
            validate: K0
        },
        {
            code: o2e,
            name: "udt"
        },
        {
            code: a2e,
            name: "utp"
        },
        {
            code: l2e,
            name: "unix",
            size: Hn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: KP,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Hn,
            bytesToValue: tS("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? nS("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: c2e,
            name: "onion",
            size: 96,
            bytesToValue: rS,
            valueToBytes: R2e
        },
        {
            code: u2e,
            name: "onion3",
            size: 296,
            bytesToValue: rS,
            valueToBytes: O2e
        },
        {
            code: h2e,
            name: "garlic64",
            size: Hn
        },
        {
            code: d2e,
            name: "garlic32",
            size: Hn
        },
        {
            code: f2e,
            name: "tls"
        },
        {
            code: p2e,
            name: "sni",
            size: Hn
        },
        {
            code: g2e,
            name: "noise"
        },
        {
            code: m2e,
            name: "quic"
        },
        {
            code: y2e,
            name: "quic-v1"
        },
        {
            code: w2e,
            name: "webtransport"
        },
        {
            code: b2e,
            name: "certhash",
            size: Hn,
            bytesToValue: F2e(yn),
            valueToBytes: z2e
        },
        {
            code: v2e,
            name: "http"
        },
        {
            code: E2e,
            name: "http-path",
            size: Hn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: A2e,
            name: "https"
        },
        {
            code: S2e,
            name: "ws"
        },
        {
            code: I2e,
            name: "wss"
        },
        {
            code: C2e,
            name: "p2p-websocket-star"
        },
        {
            code: T2e,
            name: "p2p-stardust"
        },
        {
            code: _2e,
            name: "p2p-webrtc-star"
        },
        {
            code: x2e,
            name: "p2p-webrtc-direct"
        },
        {
            code: D2e,
            name: "webrtc-direct"
        },
        {
            code: B2e,
            name: "webrtc"
        },
        {
            code: P2e,
            name: "p2p-circuit"
        },
        {
            code: k2e,
            name: "memory",
            size: Hn
        }
    ];
    G2e.forEach((n)=>{
        Au.addProtocol(n);
    });
    function Y2e(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = Au.getProtocol(r), i = be(r), l = J2e(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Hn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function W2e(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = Au.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Hn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Hn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function j2e(n) {
        if (n.charAt(0) !== "/") throw new vs('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = Au.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new vs(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new vs(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new vs("Incomplete multiaddr");
        return e;
    }
    function X2e(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = Au.getProtocol(e.code);
            if (t == null) throw new vs(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function J2e(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const Z2e = Symbol.for("nodejs.util.inspect.custom"), YP = Symbol.for("@multiformats/multiaddr");
    function eme(n) {
        if (n == null && (n = "/"), rme(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Y2e(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), j2e(n);
        if (Array.isArray(n)) return n;
        throw new vs("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    let tme = class ud {
        [YP] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = eme(e), t.validate !== !1 && nme(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = W2e(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = X2e(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new ud(e);
            return new ud([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new Kge(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new ud(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new ud(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [Z2e]() {
            return `Multiaddr(${this.toString()})`;
        }
    };
    function nme(n) {
        n.getComponents().forEach((e)=>{
            const t = Au.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function rme(n) {
        return !!n?.[YP];
    }
    function WP(n) {
        return new tme(n);
    }
    function sme(n, e) {
        return {
            id: n.id.toMultihash().bytes,
            multiaddrs: (n.multiaddrs ?? []).map((r)=>r.bytes),
            connection: e
        };
    }
    function G0(n) {
        if (n.id == null) throw new Error("Invalid peer in message");
        const e = kt(n.id);
        return {
            id: Jo(e),
            multiaddrs: (n.multiaddrs ?? []).map((t)=>WP(t))
        };
    }
    class ime {
        log;
        components;
        network;
        peerRouting;
        queryManager;
        routingTable;
        providers;
        constructor(e, t){
            const { network: r, peerRouting: s, queryManager: i, routingTable: l, providers: u, logPrefix: h } = t;
            this.components = e, this.log = e.logger.forComponent(`${h}:content-routing`), this.network = r, this.peerRouting = s, this.queryManager = i, this.routingTable = l, this.providers = u, this.findProviders = e.metrics?.traceFunction("libp2p.kadDHT.findProviders", this.findProviders.bind(this), {
                optionsIndex: 1,
                getAttributesFromYieldedValue: (f, p)=>(f.name === "PROVIDER" && (p.providers ??= [], p.providers.push(...f.providers.map((m)=>m.id.toString()))), p)
            }) ?? this.findProviders, this.provide = e.metrics?.traceFunction("libp2p.kadDHT.provide", this.provide.bind(this), {
                optionsIndex: 1,
                getAttributesFromYieldedValue: (f, p)=>(f.name === "PEER_RESPONSE" && f.messageName === "ADD_PROVIDER" && (p.providers ??= [], p.providers.push(f.from.toString())), p)
            }) ?? this.provide;
        }
        async *provide(e, t, r = {}) {
            this.log("provide %s", e);
            const s = e.multihash.bytes;
            await this.providers.addProvider(e, this.components.peerId, r);
            const i = {
                type: Ht.ADD_PROVIDER,
                key: s,
                providers: [
                    sme({
                        id: this.components.peerId,
                        multiaddrs: t
                    })
                ]
            };
            let l = 0;
            const u = this;
            async function* h(m) {
                try {
                    u.log("sending provider record for %s to %p", e, m.peer.id);
                    for await (const w of u.network.sendMessage(m.peer.id, i, {
                        ...r,
                        path: m.path
                    }))w.name === "PEER_RESPONSE" && (u.log("sent provider record for %s to %p", e, m.peer.id), l++), yield w;
                } catch (w) {
                    u.log.error("error sending provide record to peer %p - %e", m.peer.id, w), yield jc({
                        from: m.peer.id,
                        error: w,
                        path: m.path
                    }, r);
                }
            }
            const f = Hs({
                objectMode: !0
            }), p = new Yo({
                concurrency: Ug
            });
            p.addEventListener("idle", ()=>{
                f.end();
            }), p.addEventListener("failure", (m)=>{
                this.log.error("error publishing provider record to peer - %e", m.detail.error);
            }), p.add(async ()=>{
                const m = [];
                for await (const w of this.peerRouting.getClosestPeers(s, r))f.push(w), w.name === "FINAL_PEER" && m.push(w);
                m.forEach((w)=>{
                    p.add(async ()=>{
                        for await (const A of h(w))f.push(A);
                    }).catch((A)=>{
                        this.log.error("error publishing provider record to peer - %e", A);
                    });
                });
            }).catch((m)=>{
                f.end(m);
            }), yield* f, this.log("sent provider records to %d peers", l);
        }
        async *findProviders(e, t) {
            const r = this.routingTable.kBucketSize;
            let s = 0;
            const i = e.multihash.bytes, l = this;
            this.log("findProviders %c", e);
            const u = await this.providers.getProviders(e, t);
            if (u.length > 0) {
                const p = [];
                for (const m of u.slice(0, r))try {
                    const w = await this.components.peerStore.get(m, t);
                    p.push({
                        id: m,
                        multiaddrs: w.addresses.map(({ multiaddr: A })=>A)
                    });
                } catch (w) {
                    if (w.name !== "NotFoundError") throw w;
                    this.log("no peer store entry for %p", m);
                }
                if (yield N4({
                    from: this.components.peerId,
                    messageType: Ht.GET_PROVIDERS,
                    providers: p,
                    path: {
                        index: -1,
                        queued: 0,
                        running: 0,
                        total: 0
                    }
                }, t), yield XA({
                    from: this.components.peerId,
                    providers: p,
                    path: {
                        index: -1,
                        queued: 0,
                        running: 0,
                        total: 0
                    }
                }, t), s += p.length, s >= r) return;
            }
            const h = async function*({ peer: p, signal: m, path: w }) {
                const A = {
                    type: Ht.GET_PROVIDERS,
                    key: i
                };
                yield* l.network.sendRequest(p.id, A, {
                    ...t,
                    signal: m,
                    path: w
                });
            }, f = new Ua(u);
            for await (const p of this.queryManager.run(i, h, t))if (yield p, p.name === "PEER_RESPONSE") {
                this.log("Found %d provider entries for %c and %d closer peers", p.providers.length, e, p.closer.length);
                const m = [];
                for (const w of p.providers)f.has(w.id) || (f.add(w.id), m.push(w));
                if (m.length > 0 && (yield XA({
                    from: p.from,
                    providers: m,
                    path: p.path
                }, t), s += m.length, s >= r)) return;
            }
        }
    }
    class ome extends Lt {
        log;
        protocol;
        running;
        components;
        timeout;
        metrics;
        constructor(e, t){
            super(), this.components = e, this.log = e.logger.forComponent(`${t.logPrefix}:network`), this.running = !1, this.protocol = t.protocol, this.timeout = new Fd({
                ...t.timeout ?? {},
                metrics: e.metrics,
                metricName: `${t.metricsPrefix}_network_message_send_times_milliseconds`
            }), this.metrics = {
                operations: e.metrics?.registerCounterGroup(`${t.metricsPrefix}_outbound_rpc_requests_total`),
                errors: e.metrics?.registerCounterGroup(`${t.metricsPrefix}_outbound_rpc_errors_total`)
            }, this.sendRequest = e.metrics?.traceFunction("libp2p.kadDHT.sendRequest", this.sendRequest.bind(this), {
                optionsIndex: 2,
                getAttributesFromArgs ([r, s], i) {
                    return {
                        ...i,
                        to: r.toString(),
                        "message type": `${s.type}`
                    };
                },
                getAttributesFromYieldedValue: (r, s)=>(r.name === "PEER_RESPONSE" && (r.providers.length > 0 && r.providers.forEach((i, l)=>{
                        s[`providers-${l}`] = i.id.toString();
                    }), r.closer.length > 0 && r.closer.forEach((i, l)=>{
                        s[`closer-${l}`] = i.id.toString();
                    })), s)
            }) ?? this.sendRequest, this.sendMessage = e.metrics?.traceFunction("libp2p.kadDHT.sendMessage", this.sendMessage.bind(this), {
                optionsIndex: 2,
                getAttributesFromArgs ([r, s], i) {
                    return {
                        ...i,
                        to: r.toString(),
                        "message type": `${s.type}`
                    };
                },
                getAttributesFromYieldedValue: (r, s)=>(r.name === "PEER_RESPONSE" && (r.providers.length > 0 && r.providers.forEach((i, l)=>{
                        s[`providers-${l}`] = i.id.toString();
                    }), r.closer.length > 0 && r.closer.forEach((i, l)=>{
                        s[`closer-${l}`] = i.id.toString();
                    })), s)
            }) ?? this.sendMessage;
        }
        async start() {
            this.running || (this.running = !0);
        }
        async stop() {
            this.running = !1;
        }
        isStarted() {
            return this.running;
        }
        async *sendRequest(e, t, r) {
            if (!this.running) return;
            const s = t.type;
            if (s == null) throw new ii("Message type was missing");
            let i;
            const l = this.timeout.getTimeoutSignal(r);
            r = {
                ...r,
                signal: l
            };
            try {
                this.metrics.operations?.increment({
                    [s]: !0
                }), this.log("dialling %p", e), yield JA({
                    peer: e,
                    path: r.path
                }, r), i = await this.components.connectionManager.openStream(e, this.protocol, r), this.log("sending %s to %p", t.type, e), yield jA({
                    to: e,
                    type: s,
                    path: r.path
                }, r);
                const u = await this._writeReadMessage(i, t, r);
                i.close(r).catch((h)=>{
                    this.log.error("error closing stream to %p - %e", e, h), i?.abort(h);
                }), yield N4({
                    from: e,
                    messageType: u.type,
                    closer: u.closer.map(G0),
                    providers: u.providers.map(G0),
                    record: u.record == null ? void 0 : Ss.deserialize(u.record),
                    path: r.path
                }, r);
            } catch (u) {
                this.metrics.errors?.increment({
                    [s]: !0
                }), i?.abort(u), r.signal?.aborted !== !0 && this.log.error("could not send %s to %p - %e", t.type, e, u), yield jc({
                    from: e,
                    error: u,
                    path: r.path
                }, r);
            } finally{
                this.timeout.cleanUp(l);
            }
        }
        async *sendMessage(e, t, r) {
            if (!this.running) return;
            const s = t.type;
            if (s == null) throw new ii("Message type was missing");
            let i;
            const l = this.timeout.getTimeoutSignal(r);
            r = {
                ...r,
                signal: l
            };
            try {
                this.metrics.operations?.increment({
                    [s]: !0
                }), this.log("dialling %p", e), yield JA({
                    peer: e,
                    path: r.path
                }, r), i = await this.components.connectionManager.openStream(e, this.protocol, r), this.log("sending %s to %p", t.type, e), yield jA({
                    to: e,
                    type: s,
                    path: r.path
                }, r), await this._writeMessage(i, t, r), i.close(r).catch((u)=>{
                    this.log.error("error closing stream to %p - %e", e, u), i?.abort(u);
                }), yield N4({
                    from: e,
                    messageType: s,
                    path: r.path
                }, r);
            } catch (u) {
                this.metrics.errors?.increment({
                    [s]: !0
                }), i?.abort(u), yield jc({
                    from: e,
                    error: u,
                    path: r.path
                }, r);
            } finally{
                this.timeout.cleanUp(l);
            }
        }
        async _writeMessage(e, t, r) {
            await Jn(e).write(t, Pc, r);
        }
        async _writeReadMessage(e, t, r) {
            const s = Jn(e);
            await s.write(t, Pc, r);
            const i = await s.read(Pc, r);
            return i.closer.forEach((l)=>{
                this.safeDispatchEvent("peer", {
                    detail: G0(l)
                });
            }), i.providers.forEach((l)=>{
                this.safeDispatchEvent("peer", {
                    detail: G0(l)
                });
            }), i;
        }
    }
    function xd(n, e) {
        if (n.byteLength !== e.byteLength) throw new Error("Inputs should have the same length");
        for(let t = 0; t < n.byteLength; t++)if (n[t] !== e[t]) return n[t] < e[t] ? -1 : 1;
        return 0;
    }
    class Q8 {
        originDhtKey;
        capacity;
        peerDistances;
        constructor(e, t){
            this.originDhtKey = e, this.capacity = t, this.peerDistances = [];
        }
        get length() {
            return this.peerDistances.length;
        }
        get peers() {
            return [
                ...this.peerDistances
            ];
        }
        async add(e, t = {
            index: -1,
            queued: 0,
            running: 0,
            total: 0
        }, r) {
            const s = await ji(e.id, r);
            this.addWithKadId(e, s, t);
        }
        addWithKadId(e, t, r = {
            index: -1,
            queued: 0,
            running: 0,
            total: 0
        }) {
            if (this.peerDistances.find((l)=>l.peer.id.equals(e.id)) != null) return;
            const s = {
                peer: e,
                distance: Qc(this.originDhtKey, t),
                path: r
            };
            if (this.peerDistances.length === this.capacity) {
                const l = this.peerDistances[this.peerDistances.length - 1];
                if (l != null && xd(s.distance, l.distance) !== -1) return;
            }
            let i = !1;
            for(let l = 0; l < this.peerDistances.length; l++){
                const u = xd(this.peerDistances[l].distance, s.distance);
                if (u === 0 || u === 1) {
                    i = !0, this.peerDistances.splice(l, 0, s);
                    break;
                }
            }
            i || this.peerDistances.push(s), this.peerDistances = this.peerDistances.slice(0, this.capacity);
        }
        async isCloser(e, t) {
            if (this.length === 0) return !0;
            const r = await ji(e, t), s = Qc(r, this.originDhtKey), i = this.peerDistances[this.peerDistances.length - 1].distance;
            return xd(s, i) === -1;
        }
        async anyCloser(e, t) {
            return e.length === 0 ? !1 : Promise.any(e.map(async (r)=>this.isCloser(r, t)));
        }
    }
    class ame {
        log;
        routingTable;
        network;
        validators;
        queryManager;
        components;
        constructor(e, t){
            this.routingTable = t.routingTable, this.network = t.network, this.validators = t.validators, this.queryManager = t.queryManager, this.components = e, this.log = e.logger.forComponent(`${t.logPrefix}:peer-routing`), this.findPeer = e.metrics?.traceFunction("libp2p.kadDHT.findPeer", this.findPeer.bind(this), {
                optionsIndex: 1
            }) ?? this.findPeer, this.getClosestPeers = e.metrics?.traceFunction("libp2p.kadDHT.getClosestPeers", this.getClosestPeers.bind(this), {
                optionsIndex: 1
            }) ?? this.getClosestPeers;
        }
        async findPeerLocal(e, t) {
            let r;
            const s = await this.routingTable.find(e, t);
            if (s != null) {
                this.log("findPeerLocal found %p in routing table", e);
                try {
                    r = await this.components.peerStore.get(s, t);
                } catch (i) {
                    if (i.name !== "NotFoundError") throw i;
                }
            }
            if (r == null) try {
                r = await this.components.peerStore.get(e, t);
            } catch (i) {
                if (i.name !== "NotFoundError") throw i;
            }
            if (r != null) return this.log("findPeerLocal found %p in peer store", e), {
                id: r.id,
                multiaddrs: r.addresses.map((i)=>i.multiaddr)
            };
        }
        async *_getValueSingle(e, t, r) {
            const s = {
                type: Ht.GET_VALUE,
                key: t
            };
            yield* this.network.sendRequest(e, s, r);
        }
        async *getPublicKeyFromNode(e, t = {}) {
            const r = zge(e), s = {
                index: -1,
                queued: 0,
                running: 0,
                total: 0
            };
            for await (const i of this._getValueSingle(e, r, {
                ...t,
                path: s
            }))if (yield i, i.name === "PEER_RESPONSE" && i.record != null) {
                const l = Er(i.record.value), u = Oge(l);
                if (!u.equals(e)) throw new KA("public key does not match id");
                if (u.publicKey == null) throw new KA("public key missing");
                yield L4({
                    from: e,
                    value: i.record.value,
                    path: s
                }, t);
            }
            throw new rg(`Node not responding with its public key: ${e.toString()}`);
        }
        async *findPeer(e, t = {}) {
            if (this.log("findPeer %p", e), t.useCache !== !1) {
                const s = await this.findPeerLocal(e, t);
                if (s != null) {
                    this.log("found local"), yield py({
                        from: this.components.peerId,
                        peer: s,
                        path: {
                            index: -1,
                            queued: 0,
                            running: 0,
                            total: 0
                        }
                    }, t);
                    return;
                }
            }
            let r = !1;
            if (t.useNetwork !== !1) {
                const s = this, i = async function*({ peer: l, signal: u, path: h }) {
                    const f = {
                        type: Ht.FIND_NODE,
                        key: e.toMultihash().bytes
                    };
                    for await (const p of s.network.sendRequest(l.id, f, {
                        ...t,
                        signal: u,
                        path: h
                    }))if (yield p, p.name === "PEER_RESPONSE") {
                        const m = p.closer.find((w)=>w.id.equals(e));
                        m != null && (yield py({
                            from: p.from,
                            peer: m,
                            path: p.path
                        }, t));
                    }
                };
                for await (const l of this.queryManager.run(e.toMultihash().bytes, i, t))l.name === "FINAL_PEER" && (r = !0), yield l;
            }
            if (!r) throw new Mf("Not found");
        }
        async *getClosestPeers(e, t = {}) {
            this.log("getClosestPeers to %b", e);
            const r = await yf(e, t), s = new Q8(r, this.routingTable.kBucketSize), i = this, l = async function*({ peer: u, path: h, peerKadId: f, signal: p }) {
                i.log("getClosestPeers asking %p", u.id);
                const m = {
                    type: Ht.FIND_NODE,
                    key: e
                };
                yield* i.network.sendRequest(u.id, m, {
                    ...t,
                    signal: p,
                    path: h
                }), s.addWithKadId(u, f, h);
            };
            yield* this.queryManager.run(e, l, t), this.log("found %d peers close to %b", s.length, e);
            for (let { peer: u, path: h } of s.peers)try {
                if (u.multiaddrs.length === 0 && (u = await i.components.peerStore.getInfo(u.id, t)), u.multiaddrs.length === 0) continue;
                yield py({
                    from: this.components.peerId,
                    peer: await i.components.peerStore.getInfo(u.id, t),
                    path: {
                        index: h.index,
                        queued: 0,
                        running: 0,
                        total: 0
                    }
                }, t);
            } catch  {
                continue;
            }
        }
        async *getValueOrPeers(e, t, r) {
            for await (const s of this._getValueSingle(e, t, r)){
                if (s.name === "PEER_RESPONSE" && s.record != null) try {
                    await this._verifyRecordOnline(s.record, r);
                } catch  {
                    const l = "invalid record received, discarded";
                    this.log(l), yield jc({
                        from: s.from,
                        error: new rg(l),
                        path: r.path
                    }, r);
                    continue;
                }
                yield s;
            }
        }
        async _verifyRecordOnline(e, t) {
            if (e.timeReceived == null) throw new Age("invalid record received");
            await F8(this.validators, new Ss(e.key, e.value, e.timeReceived), t);
        }
        async getClosestPeersOffline(e, t) {
            const r = [];
            try {
                const l = kt(e), u = Jo(l), h = await this.components.peerStore.get(u, t);
                r.push({
                    id: h.id,
                    multiaddrs: h.addresses.map(({ multiaddr: f })=>f)
                });
            } catch  {}
            const s = await yf(e, t), i = this.routingTable.closestPeers(s, t);
            for (const l of i)try {
                r.push(await this.components.peerStore.getInfo(l, t));
            } catch (u) {
                if (u.name !== "NotFoundError") throw u;
            }
            return r.length > 0 ? this.log("getClosestPeersOffline returning the %d closest peer(s) we know to %b", r.length, e) : this.log("getClosestPeersOffline could not any peers close to %b with %d peers in the routing table", e, this.routingTable.size), r;
        }
    }
    class lme {
        log;
        datastore;
        datastorePrefix;
        constructor(e, t){
            this.log = e.logger.forComponent(`${t.logPrefix}:providers`), this.datastorePrefix = `${t.datastorePrefix}/provider`, this.datastore = e.datastore;
        }
        async addProvider(e, t, r) {
            this.log.trace("%p provides %s", t, e), await this.writeProviderEntry(e, t, r);
        }
        async removeProvider(e, t, r) {
            const s = gy(this.datastorePrefix, e, t);
            this.log.trace("%p no longer provides %s", t, e), await this.datastore.delete(s, r);
        }
        async getProviders(e, t) {
            this.log.trace("get providers for %c", e);
            const r = await this.loadProviders(e, t);
            return this.log.trace("got %d providers for %c", r.size, e), [
                ...r.keys()
            ];
        }
        async writeProviderEntry(e, t, r) {
            const s = gy(this.datastorePrefix, e, t), i = zr(r?.time?.getTime() ?? Date.now());
            await this.datastore.put(s, i, r);
        }
        async loadProviders(e, t) {
            const r = new H8, s = gy(this.datastorePrefix, e);
            for await (const i of this.datastore.query({
                prefix: s.toString()
            }, t)){
                const { peerId: l } = HP(i.key);
                r.set(l, QP(i.value));
            }
            return r;
        }
    }
    async function* cme(n) {
        const { key: e, startingPeers: t, ourPeerId: r, query: s, alpha: i, path: l, numPaths: u, log: h, peersSeen: f, connectionManager: p, signal: m } = n, w = Hs({
            objectMode: !0
        }), A = new Yo({
            concurrency: i,
            sort: (_, I)=>xd(_.options.distance, I.options.distance)
        });
        A.addEventListener("idle", ()=>{
            w.push(Ige({
                path: {
                    index: l,
                    queued: A.queued,
                    running: A.running,
                    total: A.size
                }
            }, n)), w.end();
        }), A.addEventListener("failure", (_)=>{
            h.error("error during query - %e", _.detail.error);
        });
        const S = ()=>{
            A.abort(), w.end(new Jpe);
        };
        m.addEventListener("abort", S);
        try {
            let I = function(k, G) {
                if (k == null) return;
                f.add(k.id.toMultihash().bytes);
                const P = Qc(G, _);
                A.add(async ()=>{
                    try {
                        for await (const J of s({
                            ...n,
                            key: e,
                            peer: k,
                            path: {
                                index: l,
                                queued: A.queued,
                                running: A.running,
                                total: A.size
                            },
                            numPaths: u,
                            peerKadId: G,
                            signal: m
                        })){
                            if (J.name === "PEER_RESPONSE") for (const H of J.closer){
                                if (f.has(H.id.toMultihash().bytes)) {
                                    h("already seen %p in query", H.id);
                                    continue;
                                }
                                if (r.equals(H.id)) {
                                    h("not querying ourselves");
                                    continue;
                                }
                                if (!await p.isDialable(H.multiaddrs)) {
                                    h("not querying undialable peer");
                                    continue;
                                }
                                const F = await ji(H.id, {
                                    signal: m
                                }), $ = Qc(F, _);
                                if (xd($, P) !== -1) {
                                    h("skipping %p as they are not closer to %b than %p", H.id, e, k.id);
                                    continue;
                                }
                                h("querying closer peer %p", H.id), I(H, F);
                            }
                            w.push({
                                ...J,
                                path: {
                                    index: l,
                                    queued: A.queued,
                                    running: A.running,
                                    total: A.size
                                }
                            });
                        }
                    } catch (J) {
                        w.push(jc({
                            from: k.id,
                            error: J,
                            path: {
                                index: l,
                                queued: A.queued,
                                running: A.running - 1,
                                total: A.size - 1
                            }
                        }, n));
                    }
                }, {
                    distance: P
                }).catch((J)=>{
                    h.error("error during query - %e", J);
                });
            };
            const _ = await yf(e, {
                signal: m
            });
            await Promise.all(t.map(async (k)=>{
                I({
                    id: k,
                    multiaddrs: []
                }, await ji(k, {
                    signal: m
                }));
            })), yield* w;
        } finally{
            m.removeEventListener("abort", S);
        }
    }
    class ume {
        disjointPaths;
        alpha;
        shutDownController;
        running;
        logger;
        peerId;
        connectionManager;
        routingTable;
        initialQuerySelfHasRun;
        logPrefix;
        allowQueryWithZeroPeers;
        constructor(e, t){
            this.logPrefix = t.logPrefix, this.disjointPaths = t.disjointPaths ?? NP, this.alpha = t.alpha ?? Ug, this.initialQuerySelfHasRun = t.initialQuerySelfHasRun, this.routingTable = t.routingTable, this.logger = e.logger, this.peerId = e.peerId, this.connectionManager = e.connectionManager, this.allowQueryWithZeroPeers = t.allowQueryWithZeroPeers ?? !1, this.shutDownController = new AbortController, this.shutDownController.signal, this.running = !1;
        }
        isStarted() {
            return this.running;
        }
        async start() {
            this.running || (this.running = !0, this.shutDownController = new AbortController, this.shutDownController.signal, void 0);
        }
        async stop() {
            this.running = !1, this.shutDownController.abort();
        }
        async *run(e, t, r = {}) {
            if (!this.running) throw new Error("QueryManager not started");
            if (r.signal == null) {
                const h = AbortSignal.timeout(bge);
                r = {
                    ...r,
                    signal: h
                };
            }
            const s = new AbortController, i = gt([
                this.shutDownController.signal,
                s.signal,
                r.signal
            ]);
            s.signal;
            const l = this.logger.forComponent(`${this.logPrefix}:query:` + L(e, "base58btc"));
            let u = !1;
            try {
                this.routingTable.size === 0 && !this.allowQueryWithZeroPeers && (l("routing table was empty, waiting for some peers before running%s query", r.isSelfQuery === !0 ? " self" : ""), await an(this.routingTable, "peer:add", {
                    signal: i,
                    filter: (A)=>!this.peerId.equals(A.detail)
                }), l("routing table has peers, continuing with%s query", r.isSelfQuery === !0 ? " self" : "")), r.isSelfQuery !== !0 && this.initialQuerySelfHasRun != null && (l("waiting for initial self query before continuing"), await Xn(this.initialQuerySelfHasRun.promise, i), this.initialQuerySelfHasRun = void 0), l("query:start");
                const h = await yf(e, {
                    signal: i
                }), f = this.routingTable.closestPeers(h, {
                    count: this.routingTable.kBucketSize
                }), p = f.sort(()=>Math.random() > .5 ? 1 : -1).reduce((A, S, _)=>(A[_ % this.disjointPaths].push(S), A), new Array(this.disjointPaths).fill(0).map(()=>[])).filter((A)=>A.length > 0);
                if (f.length === 0) {
                    l.error("running query with no peers");
                    return;
                }
                const m = Wi(1024), w = p.map((A, S)=>cme({
                        ...r,
                        key: e,
                        startingPeers: A,
                        ourPeerId: this.peerId,
                        signal: i,
                        query: t,
                        path: S,
                        numPaths: p.length,
                        alpha: this.alpha,
                        log: l,
                        peersSeen: m,
                        onProgress: r.onProgress,
                        connectionManager: this.connectionManager
                    }));
                for await (const A of Uo(...w)){
                    if (A.name === "QUERY_ERROR" && l.error("query error - %e", A.error), A.name === "PEER_RESPONSE") for (const S of [
                        ...A.closer,
                        ...A.providers
                    ])await this.connectionManager.isDialable(S.multiaddrs, {
                        signal: i
                    }) && await this.routingTable.add(S.id, {
                        signal: i
                    });
                    i.throwIfAborted(), yield A;
                }
                u = !0;
            } catch (h) {
                if (this.running) throw h;
            } finally{
                u || (l("query exited early"), s.abort()), i.clear(), l("query finished");
            }
        }
    }
    function hme(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function jP(n) {
        if (hme(n)) return (async ()=>{
            let e = 0;
            for await (const t of n)e++;
            return e;
        })();
        {
            let e = 0;
            for (const t of n)e++;
            return e;
        }
    }
    class dme {
        log;
        peerId;
        peerRouting;
        events;
        count;
        interval;
        initialInterval;
        queryTimeout;
        running;
        timeoutId;
        controller;
        initialQuerySelfHasRun;
        querySelfPromise;
        constructor(e, t){
            this.peerId = e.peerId, this.log = e.logger.forComponent(`${t.logPrefix}:query-self`), this.events = e.events, this.running = !1, this.peerRouting = t.peerRouting, this.count = t.count ?? NP, this.interval = t.interval ?? pge, this.initialInterval = t.initialInterval ?? gge, this.queryTimeout = t.queryTimeout ?? mge, this.initialQuerySelfHasRun = t.initialQuerySelfHasRun, this.querySelf = qP(this.querySelf.bind(this), t.operationMetrics, "SELF_QUERY");
        }
        isStarted() {
            return this.running;
        }
        start() {
            this.running || (this.running = !0, clearTimeout(this.timeoutId), this.timeoutId = setTimeout(()=>{
                this.querySelf().catch((e)=>{
                    this.log.error("error running self-query - %e", e);
                });
            }, this.initialInterval));
        }
        stop() {
            this.running = !1, this.timeoutId != null && clearTimeout(this.timeoutId), this.controller != null && this.controller.abort();
        }
        async querySelf() {
            if (!this.running) {
                this.log("skip self-query because we are not started");
                return;
            }
            if (this.querySelfPromise != null) return this.log("joining existing self query"), this.querySelfPromise.promise;
            if (this.querySelfPromise = xt(), this.running) {
                this.controller = new AbortController;
                const e = [
                    this.controller.signal
                ];
                if (this.initialQuerySelfHasRun == null) {
                    const r = AbortSignal.timeout(this.queryTimeout);
                    e.push(r);
                }
                const t = gt(e);
                this.controller.signal;
                try {
                    this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
                    const r = Date.now(), s = await Oc(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes, {
                        signal: t,
                        isSelfQuery: !0
                    }), (l)=>Pp(l, this.count), async (l)=>jP(l));
                    t?.throwIfAborted();
                    const i = Date.now() - r;
                    this.log("self-query found %d peers in %dms", s, i), this.events.dispatchEvent(new CustomEvent("kad-dht:query:self", {
                        detail: {
                            peers: s,
                            duration: i
                        }
                    }));
                } catch (r) {
                    this.log.error("self-query error - %e", r);
                } finally{
                    t.clear(), this.initialQuerySelfHasRun != null && (this.initialQuerySelfHasRun.resolve(), this.initialQuerySelfHasRun = void 0);
                }
            }
            this.querySelfPromise.resolve(), this.querySelfPromise = void 0, this.running && (this.timeoutId = setTimeout(()=>{
                this.querySelf().catch((e)=>{
                    this.log.error("error running self-query - %e", e);
                });
            }, this.interval));
        }
    }
    class fme extends Lt {
        log;
        reprovideQueue;
        maxQueueSize;
        datastore;
        timeout;
        reprovideTimeout;
        running;
        shutdownController;
        reprovideThreshold;
        contentRouting;
        datastorePrefix;
        addressManager;
        validity;
        interval;
        peerId;
        constructor(e, t){
            super(), this.log = e.logger.forComponent(`${t.logPrefix}:reprovider`), this.peerId = e.peerId, this.reprovideQueue = new Yo({
                concurrency: t.concurrency ?? uge,
                metrics: e.metrics,
                metricName: `${t.metricsPrefix}_reprovide_queue`
            }), this.reprovideTimeout = new Fd({
                ...t.timeout ?? {},
                metrics: e.metrics,
                metricName: `${t.metricsPrefix}_reprovide_timeout_milliseconds`
            }), this.datastore = e.datastore, this.addressManager = e.addressManager, this.datastorePrefix = `${t.datastorePrefix}/provider`, this.reprovideThreshold = t.threshold ?? cge, this.maxQueueSize = t.maxQueueSize ?? hge, this.validity = t.validity ?? MP, this.interval = t.interval ?? dge, this.contentRouting = t.contentRouting, this.running = !1, this.reprovide = qP(this.reprovide.bind(this), t.operationMetrics, "PROVIDE");
        }
        start() {
            this.running || (this.running = !0, this.shutdownController = new AbortController, this.shutdownController.signal, this.timeout = setTimeout(()=>{
                this.processRecords({
                    signal: AbortSignal.timeout(GA)
                }).catch((e)=>{
                    this.log.error("error running process to reprovide/cleanup - %e", e);
                });
            }, this.interval));
        }
        stop() {
            this.running = !1, this.reprovideQueue.clear(), clearTimeout(this.timeout), this.shutdownController?.abort();
        }
        async processRecords(e) {
            try {
                this.safeDispatchEvent("reprovide:start"), this.log("starting reprovide/cleanup");
                for await (const t of this.datastore.query({
                    prefix: this.datastorePrefix
                }, e))try {
                    const { cid: r, peerId: s } = HP(t.key), l = QP(t.value).getTime() + this.validity, u = Date.now(), h = u > l, f = this.peerId.equals(s);
                    this.log.trace("comparing: %d (now) < %d (expires) = %s %s", u, l, h, h ? "(expired)" : "(valid)"), h && !f && await this.datastore.delete(t.key, e), this.shouldReprovide(f, l) && (this.log("reproviding %c as it is within the reprovide threshold (%d)", r, this.reprovideThreshold), this.queueReprovide(r).catch((p)=>{
                        this.log.error("could not reprovide %c - %e", r, p);
                    }));
                } catch (r) {
                    this.log.error("error processing datastore key %s - %s", t.key, r.message);
                }
                this.log("reprovide/cleanup successful");
            } finally{
                this.safeDispatchEvent("reprovide:end"), this.running && (this.log("queuing next re-provide/cleanup run in %d ms", this.interval), this.timeout = setTimeout(()=>{
                    this.processRecords({
                        signal: AbortSignal.timeout(GA)
                    }).catch((t)=>{
                        this.log.error("error running re-provide - %e", t);
                    });
                }, this.interval));
            }
        }
        shouldReprovide(e, t) {
            if (!e) return !1;
            const r = Date.now();
            return t < r ? !0 : t - r < this.reprovideThreshold;
        }
        async queueReprovide(e, t) {
            if (!this.running) return;
            this.log.trace("waiting for queue capacity before adding %c to re-provide queue", e), await this.reprovideQueue.onSizeLessThan(this.maxQueueSize, t);
            const r = this.reprovideQueue.queue.find((s)=>s.options.cid.equals(e));
            if (r != null) return this.log.trace("not adding %c to re-provide queue - already in queue", e), r.join();
            this.log.trace("adding %c to re-provide queue", e), this.reprovideQueue.add(async (s)=>{
                if (s.signal?.throwIfAborted(), !this.running) return;
                this.log.trace("re-providing %c", e);
                const i = this.reprovideTimeout.getTimeoutSignal(s);
                try {
                    await this.reprovide(s.cid, s);
                } finally{
                    this.reprovideTimeout.cleanUp(i);
                }
                this.log.trace("re-provided %c", e);
            }, {
                signal: this.shutdownController?.signal,
                cid: e
            }).catch((s)=>{
                this.log.error("could not re-provide key %c - %e", e, s);
            });
        }
        async reprovide(e, t) {
            await qo(this.contentRouting.provide(e, this.addressManager.getAddresses(), t));
        }
    }
    const pme = 20, gme = 5e3, mme = "kad-close", yme = 50;
    class wme {
        routingTable;
        components;
        closestPeers;
        newPeers;
        refreshInterval;
        peerSetSize;
        timeout;
        closeTagName;
        closeTagValue;
        log;
        running;
        constructor(e, t){
            this.components = e, this.log = e.logger.forComponent(`${t.logPrefix}:routing-table`), this.routingTable = t.routingTable, this.refreshInterval = t.refreshInterval ?? gme, this.peerSetSize = t.peerSetSize ?? pme, this.closeTagName = t.closeTagName ?? mme, this.closeTagValue = t.closeTagValue ?? yme, this.closestPeers = new Ua, this.onPeerPing = this.onPeerPing.bind(this), this.running = !1;
        }
        async start() {
            if (this.running) return;
            this.running = !0;
            const e = await ji(this.components.peerId);
            this.newPeers = new Q8(e, this.peerSetSize), this.routingTable.addEventListener("peer:ping", this.onPeerPing), this.timeout = setInterval(()=>{
                this.updatePeerTags().catch((t)=>{
                    this.log.error("error updating peer tags - %e", t);
                });
            }, this.refreshInterval);
        }
        stop() {
            this.running = !1, this.routingTable.removeEventListener("peer:ping", this.onPeerPing), clearTimeout(this.timeout);
        }
        onPeerPing(e) {
            this.newPeers?.add({
                id: e.detail,
                multiaddrs: []
            }).catch((t)=>{
                this.log.error("error adding peer to distance list - %e", t);
            });
        }
        async updatePeerTags() {
            const e = new Ua(this.newPeers?.peers.map(({ peer: s })=>s.id)), t = e.difference(this.closestPeers), r = this.closestPeers.difference(e);
            this.closestPeers = e, await Promise.all([
                ...[
                    ...t
                ].map(async (s)=>{
                    await this.components.peerStore.merge(s, {
                        tags: {
                            [this.closeTagName]: {
                                value: this.closeTagValue
                            },
                            [YA]: {
                                value: 1
                            }
                        }
                    });
                }),
                ...[
                    ...r
                ].map(async (s)=>{
                    await this.components.peerStore.merge(s, {
                        tags: {
                            [this.closeTagName]: void 0,
                            [YA]: void 0
                        }
                    });
                })
            ]);
        }
    }
    function hp(n) {
        return Array.isArray(n?.peers);
    }
    class bme {
        peerId;
        root;
        localPeer;
        prefixLength;
        splitThreshold;
        kBucketSize;
        numberOfNodesToPing;
        lastPingThreshold;
        ping;
        verify;
        onAdd;
        onRemove;
        onMove;
        addingPeerMap;
        constructor(e, t){
            this.peerId = e.peerId, this.prefixLength = t.prefixLength ?? Ame, this.kBucketSize = t.kBucketSize ?? q8, this.splitThreshold = t.splitThreshold ?? this.kBucketSize, this.numberOfNodesToPing = t.numberOfOldContactsToPing ?? Cme, this.lastPingThreshold = t.lastPingThreshold ?? Dme, this.ping = t.ping, this.verify = t.verify, this.onAdd = t.onAdd, this.onRemove = t.onRemove, this.addingPeerMap = qge({
                name: `${t.metricsPrefix}_adding_peer_map`,
                metrics: e.metrics
            }), this.root = {
                prefix: "",
                depth: 0,
                peers: []
            };
        }
        async start() {
            await this.addSelfPeer(this.peerId);
        }
        stop() {
            this.addingPeerMap.clear(), this.root = {
                prefix: "",
                depth: 0,
                peers: []
            };
        }
        async addSelfPeer(e, t) {
            this.localPeer = {
                peerId: e,
                kadId: await ji(e, t),
                lastPing: Date.now()
            };
        }
        async add(e, t) {
            const r = {
                peerId: e,
                kadId: await ji(e, t),
                lastPing: 0
            }, s = this.addingPeerMap.get(e);
            if (s != null) return s;
            try {
                const i = this._add(r, t);
                this.addingPeerMap.set(e, i), await i;
            } finally{
                this.addingPeerMap.delete(e);
            }
        }
        async _add(e, t) {
            const r = this._determineBucket(e.kadId);
            if (this._indexOf(r, e.kadId) > -1) return;
            if (r.peers.length === this.splitThreshold && r.depth < this.prefixLength) {
                await this._split(r, t), await this._add(e, t);
                return;
            }
            if (r.peers.length < this.kBucketSize) {
                if (!Eme(e, this.lastPingThreshold)) {
                    r.peers.push(e), await this.onAdd?.(e, r, t);
                    return;
                }
                await this.verify(e, t) && (e.lastPing = Date.now(), await this._add(e, t));
                return;
            }
            const s = r.peers.filter((l)=>!(l.peerId.equals(this.localPeer?.peerId) || l.lastPing > Date.now() - this.lastPingThreshold)).sort((l, u)=>l.lastPing < u.lastPing ? -1 : l.lastPing > u.lastPing ? 1 : 0).slice(0, this.numberOfNodesToPing);
            let i = !1;
            for await (const l of this.ping(s, t))i = !0, await this.remove(l.kadId, t);
            i && await this._add(e, t);
        }
        *closest(e, t) {
            const r = new Q8(e, t?.count ?? this.kBucketSize);
            for (const s of this.toIterable())t?.exclude?.some((i)=>i.equals(s.peerId)) !== !0 && r.addWithKadId({
                id: s.peerId,
                multiaddrs: []
            }, s.kadId);
            yield* kf(r.peers, ({ peer: s })=>s.id);
        }
        count() {
            function e(t) {
                if (hp(t)) return t.peers.length;
                let r = 0;
                return t.left != null && (r += e(t.left)), t.right != null && (r += e(t.right)), r;
            }
            return e(this.root);
        }
        get(e) {
            const t = this._determineBucket(e), r = this._indexOf(t, e);
            return t.peers[r];
        }
        async remove(e, t) {
            const r = this._determineBucket(e), s = this._indexOf(r, e);
            if (s > -1) {
                const i = r.peers.splice(s, 1)[0];
                await this.onRemove?.(i, r, t);
            }
        }
        *toIterable() {
            function* e(t) {
                if (hp(t)) {
                    yield* t.peers;
                    return;
                }
                yield* e(t.left), yield* e(t.right);
            }
            yield* e(this.root);
        }
        distance(e, t) {
            return BigInt("0x" + L(Qc(e, t), "base16"));
        }
        _determineBucket(e) {
            const t = L(e, "base2");
            function r(s, i = 0) {
                return hp(s) ? s : t[i] === "0" ? r(s.left, i + 1) : r(s.right, i + 1);
            }
            return r(this.root);
        }
        _indexOf(e, t) {
            return e.peers.findIndex((r)=>Ee(r.kadId, t));
        }
        async _split(e, t) {
            const r = {
                prefix: "0",
                depth: e.depth + 1,
                peers: []
            }, s = {
                prefix: "1",
                depth: e.depth + 1,
                peers: []
            };
            for (const i of e.peers)L(i.kadId, "base2")[e.depth] === "0" ? (r.peers.push(i), await this.onMove?.(i, e, r, t)) : (s.peers.push(i), await this.onMove?.(i, e, s, t));
            vme(e, r, s);
        }
    }
    function vme(n, e, t) {
        return delete n.peers, n.left = e, n.right = t, n.prefix === "" && (delete n.depth, delete n.prefix), !0;
    }
    function Eme(n, e) {
        return n.lastPing < Date.now() - e;
    }
    const q8 = 20, Ame = 6, Sme = 20, Ime = 100, Cme = 3, Tme = 20, _me = 100, sS = "kad-peer", xme = 1, Dme = 6e5, Bme = !0, Pme = 1e3;
    class kme extends Lt {
        kBucketSize;
        kb;
        network;
        closestPeerTagger;
        log;
        components;
        running;
        pingNewContactTimeout;
        pingNewContactQueue;
        pingOldContactTimeout;
        pingOldContactQueue;
        populateFromDatastoreOnStart;
        populateFromDatastoreLimit;
        protocol;
        peerTagName;
        peerTagValue;
        metrics;
        shutdownController;
        constructor(e, t){
            super(), this.components = e, this.log = e.logger.forComponent(`${t.logPrefix}:routing-table`), this.kBucketSize = t.kBucketSize ?? q8, this.running = !1, this.protocol = t.protocol, this.network = t.network, this.peerTagName = t.peerTagName ?? sS, this.peerTagValue = t.peerTagValue ?? xme, this.pingOldContacts = this.pingOldContacts.bind(this), this.verifyNewContact = this.verifyNewContact.bind(this), this.peerAdded = this.peerAdded.bind(this), this.peerRemoved = this.peerRemoved.bind(this), this.populateFromDatastoreOnStart = t.populateFromDatastoreOnStart ?? Bme, this.populateFromDatastoreLimit = t.populateFromDatastoreLimit ?? Pme, this.shutdownController = new AbortController, this.shutdownController.signal, this.pingOldContactQueue = new Wo({
                concurrency: t.pingOldContactConcurrency ?? Tme,
                metricName: `${t.metricsPrefix}_ping_old_contact_queue`,
                metrics: this.components.metrics,
                maxSize: t.pingOldContactMaxQueueSize ?? _me
            }), this.pingOldContactTimeout = new Fd({
                ...t.pingOldContactTimeout ?? {},
                metrics: this.components.metrics,
                metricName: `${t.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`
            }), this.pingNewContactQueue = new Wo({
                concurrency: t.pingNewContactConcurrency ?? Sme,
                metricName: `${t.metricsPrefix}_ping_new_contact_queue`,
                metrics: this.components.metrics,
                maxSize: t.pingNewContactMaxQueueSize ?? Ime
            }), this.pingNewContactTimeout = new Fd({
                ...t.pingNewContactTimeout ?? {},
                metrics: this.components.metrics,
                metricName: `${t.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`
            }), this.kb = new bme(e, {
                kBucketSize: t.kBucketSize,
                prefixLength: t.prefixLength,
                splitThreshold: t.splitThreshold,
                numberOfOldContactsToPing: t.numberOfOldContactsToPing,
                lastPingThreshold: t.lastPingThreshold,
                ping: this.pingOldContacts,
                verify: this.verifyNewContact,
                onAdd: this.peerAdded,
                onRemove: this.peerRemoved,
                metricsPrefix: t.metricsPrefix
            }), this.closestPeerTagger = new wme(this.components, {
                logPrefix: t.logPrefix,
                routingTable: this,
                peerSetSize: t.closestPeerSetSize,
                refreshInterval: t.closestPeerSetRefreshInterval,
                closeTagName: t.closeTagName,
                closeTagValue: t.closeTagValue
            }), this.components.metrics != null && (this.metrics = {
                routingTableSize: this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_size`),
                routingTableKadBucketTotal: this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_total`),
                routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),
                routingTableKadBucketMinOccupancy: this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),
                routingTableKadBucketMaxOccupancy: this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),
                routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_max_depth`),
                kadBucketEvents: this.components.metrics.registerCounterGroup(`${t.metricsPrefix}_kad_bucket_events_total`)
            });
        }
        isStarted() {
            return this.running;
        }
        async start() {
            this.running || (this.running = !0, this.shutdownController = new AbortController, this.shutdownController.signal, await $4(this.closestPeerTagger, this.kb));
        }
        async afterStart() {
            let e = 0;
            Promise.resolve().then(async ()=>{
                if (!this.populateFromDatastoreOnStart) return;
                const t = gt([
                    this.shutdownController.signal,
                    AbortSignal.timeout(2e4)
                ]);
                try {
                    for (const r of await this.components.peerStore.all({
                        filters: [
                            (s)=>s.protocols.includes(this.protocol) && s.tags.has(sS)
                        ],
                        limit: this.populateFromDatastoreLimit,
                        signal: t
                    })){
                        if (!this.running) return;
                        try {
                            await this.add(r.id, {
                                signal: t
                            }), e++;
                        } catch  {
                            this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e"), await this.components.peerStore.merge(r.id, {
                                tags: {
                                    [this.peerTagName]: void 0
                                }
                            });
                        }
                    }
                } finally{
                    t.clear();
                }
                this.log("added %d peer store peers to the routing table", e);
            }).catch((t)=>{
                this.log.error("error adding %d, peer store peers to the routing table - %e", e, t);
            });
        }
        async stop() {
            this.running = !1, await $P(this.closestPeerTagger, this.kb), this.pingOldContactQueue.abort(), this.pingNewContactQueue.abort(), this.shutdownController.abort();
        }
        async peerAdded(e, t, r) {
            this.components.peerId.equals(e.peerId) || await this.components.peerStore.merge(e.peerId, {
                tags: {
                    [this.peerTagName]: {
                        value: this.peerTagValue
                    }
                }
            }, r), this.updateMetrics(), this.metrics?.kadBucketEvents.increment({
                peer_added: !0
            }), this.safeDispatchEvent("peer:add", {
                detail: e.peerId
            });
        }
        async peerRemoved(e, t, r) {
            this.components.peerId.equals(e.peerId) || await this.components.peerStore.merge(e.peerId, {
                tags: {
                    [this.peerTagName]: void 0
                }
            }, r), this.updateMetrics(), this.metrics?.kadBucketEvents.increment({
                peer_removed: !0
            }), this.safeDispatchEvent("peer:remove", {
                detail: e.peerId
            });
        }
        async *pingOldContacts(e, t) {
            if (!this.running) return;
            const r = [];
            for (const s of e){
                if (this.kb.get(s.kadId) == null) {
                    this.log("asked to ping contact %p that was not in routing table", s.peerId);
                    continue;
                }
                this.metrics?.kadBucketEvents.increment({
                    ping_old_contact: !0
                }), r.push(async ()=>{
                    const i = this.pingOldContactQueue.find(s.peerId);
                    if (i != null) return this.log("asked to ping contact %p was already being pinged", s.peerId), await i.join(t) ? void 0 : s;
                    if (!await this.pingOldContactQueue.add(async (u)=>{
                        const h = this.pingOldContactTimeout.getTimeoutSignal(), f = gt([
                            h,
                            this.shutdownController.signal,
                            u?.signal
                        ]);
                        try {
                            return await this.pingContact(s, u);
                        } catch  {
                            return this.metrics?.kadBucketEvents.increment({
                                ping_old_contact_error: !0
                            }), !0;
                        } finally{
                            this.pingOldContactTimeout.cleanUp(h), f.clear();
                        }
                    }, {
                        peerId: s.peerId,
                        signal: t?.signal
                    })) return s;
                });
            }
            for await (const s of Bg(r))s != null && (yield s);
        }
        async verifyNewContact(e, t) {
            const r = this.pingNewContactTimeout.getTimeoutSignal(), s = gt([
                r,
                this.shutdownController.signal,
                t?.signal
            ]);
            try {
                const i = this.pingNewContactQueue.find(e.peerId);
                return i != null ? (this.log("joining existing ping to add new peer %p to routing table", e.peerId), await i.join({
                    signal: s
                })) : await this.pingNewContactQueue.add(async (l)=>(this.metrics?.kadBucketEvents.increment({
                        ping_new_contact: !0
                    }), this.log("pinging new peer %p before adding to routing table", e.peerId), this.pingContact(e, l)), {
                    peerId: e.peerId,
                    signal: s
                });
            } catch  {
                return this.log.trace("tried to add peer %p but they were not online", e.peerId), this.metrics?.kadBucketEvents.increment({
                    ping_new_contact_error: !0
                }), !1;
            } finally{
                this.pingNewContactTimeout.cleanUp(r), s.clear();
            }
        }
        async pingContact(e, t) {
            try {
                return this.log("pinging contact %p", e.peerId), await this.components.ping.ping(e.peerId, t), this.log("contact %p ping ok", e.peerId), this.safeDispatchEvent("peer:ping", {
                    detail: e.peerId
                }), !0;
            } catch (r) {
                return this.log("error pinging old contact %p - %e", e.peerId, r), !1;
            }
        }
        get size() {
            return this.kb == null ? 0 : this.kb.count();
        }
        async find(e, t) {
            const r = await ji(e, t);
            return this.kb.get(r)?.peerId;
        }
        closestPeer(e) {
            const t = this.closestPeers(e, {
                count: 1
            });
            if (t.length > 0) return t[0];
        }
        closestPeers(e, t) {
            return this.kb == null ? [] : [
                ...this.kb.closest(e, t)
            ];
        }
        async add(e, t) {
            if (this.kb == null) throw new Error("RoutingTable is not started");
            await this.kb.add(e, t);
        }
        async remove(e, t) {
            if (this.kb == null) throw new Error("RoutingTable is not started");
            const r = await ji(e, t);
            await this.kb.remove(r, t);
        }
        updateMetrics() {
            if (this.metrics == null || this.kb == null) return;
            let e = 0, t = 0, r = 0, s = 20, i = 0;
            function l(u) {
                if (hp(u)) {
                    u.depth > r && (r = u.depth), t++, e += u.peers.length, u.peers.length < s && (s = u.peers.length), u.peers.length > i && (i = u.peers.length);
                    return;
                }
                l(u.left), l(u.right);
            }
            l(this.kb.root), this.metrics.routingTableSize.update(e), this.metrics.routingTableKadBucketTotal.update(t), this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(e / t)), this.metrics.routingTableKadBucketMinOccupancy.update(s), this.metrics.routingTableKadBucketMaxOccupancy.update(i), this.metrics.routingTableKadBucketMaxDepth.update(r);
        }
    }
    const Rme = [
        77591,
        22417,
        43971,
        28421,
        740,
        29829,
        71467,
        228973,
        196661,
        78537,
        27689,
        36431,
        44415,
        14362,
        19456,
        106025,
        96308,
        2882,
        49509,
        21149,
        87173,
        131409,
        75844,
        23676,
        121838,
        30291,
        17492,
        2953,
        7564,
        110620,
        129477,
        127283,
        53113,
        72417,
        165166,
        109690,
        21200,
        102125,
        24049,
        71504,
        90342,
        25307,
        72039,
        26812,
        26715,
        32264,
        133800,
        71161,
        88956,
        171987,
        51779,
        24425,
        16671,
        30251,
        186294,
        247761,
        14202,
        2121,
        8465,
        35024,
        4876,
        85917,
        169730,
        3638,
        256836,
        96184,
        943,
        18678,
        6583,
        52907,
        35807,
        112254,
        214097,
        18796,
        11595,
        9243,
        23554,
        887,
        268203,
        382004,
        24590,
        111335,
        11625,
        16619,
        29039,
        102425,
        69006,
        97976,
        92362,
        32552,
        63717,
        41433,
        128974,
        137630,
        59943,
        10019,
        13986,
        35430,
        33665,
        108037,
        43799,
        43280,
        38195,
        29078,
        58629,
        18265,
        14425,
        46832,
        235538,
        40830,
        77881,
        110717,
        58937,
        3463,
        325358,
        51300,
        47623,
        117252,
        19007,
        10170,
        20540,
        91237,
        294813,
        4951,
        79841,
        56232,
        36270,
        128547,
        69209,
        66275,
        100156,
        32063,
        73531,
        34439,
        80937,
        28892,
        44466,
        88595,
        216307,
        32583,
        49620,
        16605,
        82127,
        45807,
        21630,
        78726,
        20235,
        40163,
        111007,
        96926,
        5567,
        72083,
        21665,
        58844,
        39419,
        179767,
        48328,
        42662,
        51550,
        5251,
        37811,
        49608,
        81056,
        50854,
        55513,
        20922,
        18891,
        197409,
        164656,
        32593,
        71449,
        220474,
        58919,
        85682,
        67854,
        13758,
        35066,
        3565,
        61905,
        214793,
        119572,
        141419,
        21504,
        10302,
        27354,
        67003,
        46131,
        32668,
        15165,
        64871,
        34450,
        17821,
        2757,
        11452,
        34189,
        5160,
        12257,
        85523,
        560,
        53385,
        65887,
        119549,
        135620,
        312353,
        115979,
        122356,
        10867,
        193231,
        124537,
        54783,
        90675,
        120791,
        4715,
        142253,
        50943,
        17271,
        43358,
        25331,
        4917,
        120566,
        34580,
        12878,
        33786,
        160528,
        32523,
        4869,
        301307,
        104817,
        81491,
        23276,
        8832,
        97911,
        31265,
        52065,
        7998,
        49622,
        9715,
        43998,
        34091,
        84587,
        20664,
        69041,
        29419,
        53205,
        10838,
        58288,
        116145,
        6185,
        5154,
        141795,
        35924,
        21307,
        144738,
        43730,
        12085,
        8279,
        10002,
        119,
        133779,
        199668,
        72938,
        31768,
        39176,
        67875,
        38453,
        9700,
        44144,
        4121,
        116048,
        41733,
        12868,
        82669,
        92308,
        128,
        34262,
        11332,
        7712,
        90764,
        36141,
        13553,
        71312,
        77470,
        117314,
        96549,
        49135,
        23602,
        54468,
        28605,
        6327,
        62308,
        17171,
        67531,
        21319,
        14105,
        894,
        107722,
        46157,
        8503,
        51069,
        100472,
        45138,
        15246,
        14577,
        35609,
        191464,
        1757,
        13364,
        161349,
        32067,
        91705,
        81144,
        52339,
        5408,
        91066,
        21983,
        14157,
        100545,
        4372,
        26630,
        129112,
        1423,
        29676,
        213626,
        4397,
        88436,
        99190,
        6877,
        49958,
        26122,
        114348,
        60661,
        29818,
        293118,
        50042,
        179738,
        16400,
        163423,
        89627,
        31040,
        43973,
        36638,
        45952,
        5153,
        1894,
        109322,
        1898,
        134021,
        12402,
        112077,
        68309,
        190269,
        69866,
        31938,
        107383,
        11522,
        105232,
        11248,
        14868,
        39852,
        71707,
        186525,
        16530,
        38162,
        106212,
        11700,
        5130,
        16608,
        26998,
        59586,
        108399,
        230033,
        43683,
        48135,
        82179,
        2073,
        5015,
        196684,
        189293,
        16378,
        23452,
        8301,
        35640,
        11632,
        214551,
        29240,
        57644,
        33137,
        91949,
        55157,
        52384,
        117313,
        5090,
        17717,
        89668,
        49363,
        82238,
        241035,
        66216,
        29066,
        184088,
        97206,
        62820,
        26595,
        4241,
        135635,
        173672,
        8202,
        459,
        71355,
        146294,
        29587,
        3008,
        135385,
        141203,
        14803,
        6634,
        45094,
        69362,
        50925,
        546,
        51884,
        62011,
        83296,
        234584,
        44515,
        56050,
        89476,
        87751,
        19373,
        12691,
        149923,
        19794,
        13833,
        35846,
        87557,
        58339,
        2884,
        19145,
        25647,
        12224,
        11024,
        77338,
        64608,
        122297,
        53025,
        7205,
        36189,
        36294,
        170779,
        21750,
        7739,
        173883,
        75192,
        35664,
        224240,
        113121,
        30181,
        26267,
        27036,
        117827,
        92015,
        106516,
        55628,
        203549,
        67949,
        60462,
        60844,
        35911,
        20457,
        1820,
        920,
        19773,
        8738,
        73173,
        181993,
        38521,
        98254,
        76257,
        46008,
        92796,
        5384,
        26868,
        151566,
        22124,
        2411,
        15919,
        186872,
        180021,
        28099,
        152961,
        78811,
        80237,
        62352,
        102653,
        74259,
        184890,
        16792,
        123702,
        224945,
        29940,
        19512,
        75283,
        14059,
        112691,
        92811,
        233329,
        20411,
        138569,
        53341,
        109802,
        50600,
        134528,
        66747,
        5529,
        166531,
        31578,
        64732,
        67189,
        1596,
        126357,
        967,
        167999,
        206598,
        109752,
        119431,
        207825,
        78791,
        91938,
        10301,
        27311,
        24233,
        252343,
        28831,
        32812,
        66002,
        112267,
        90895,
        8786,
        8095,
        16824,
        22866,
        21813,
        60507,
        174833,
        19549,
        130985,
        117051,
        52110,
        6938,
        81923,
        123864,
        38061,
        919,
        18680,
        53534,
        46739,
        112893,
        161529,
        85429,
        26761,
        11900,
        81121,
        91968,
        15390,
        217947,
        56524,
        1713,
        6654,
        37089,
        85630,
        138866,
        61850,
        16491,
        75577,
        16884,
        98296,
        73523,
        6140,
        44645,
        6062,
        36366,
        29844,
        57946,
        37932,
        42472,
        5266,
        20834,
        19309,
        33753,
        127182,
        134259,
        35810,
        41805,
        45878,
        312001,
        14881,
        47757,
        49251,
        120050,
        44252,
        3708,
        25856,
        107864,
        120347,
        1228,
        36550,
        41682,
        34496,
        47025,
        8393,
        173365,
        246526,
        12894,
        161607,
        35670,
        90785,
        126572,
        2095,
        124731,
        157033,
        58694,
        554,
        12786,
        9642,
        4817,
        16136,
        47864,
        174698,
        66992,
        4639,
        69284,
        10625,
        40710,
        27763,
        51738,
        30404,
        264105,
        137904,
        109882,
        52487,
        42824,
        57514,
        2740,
        10479,
        146799,
        107390,
        16586,
        88038,
        174951,
        9410,
        16185,
        44158,
        5568,
        40658,
        46108,
        12763,
        97385,
        26175,
        108859,
        664,
        230732,
        67470,
        46663,
        14395,
        50750,
        141320,
        93140,
        15361,
        47997,
        55784,
        6791,
        307840,
        118569,
        107326,
        18056,
        58281,
        260415,
        54691,
        8790,
        73332,
        45633,
        7511,
        45674,
        143373,
        14031,
        11799,
        94491,
        35646,
        96544,
        14560,
        26049,
        32983,
        25791,
        83814,
        42094,
        231370,
        63955,
        139212,
        2359,
        169908,
        3108,
        183486,
        105867,
        28197,
        32941,
        124968,
        26402,
        88267,
        149768,
        23053,
        3078,
        19091,
        52924,
        25383,
        19209,
        111548,
        97361,
        3959,
        24880,
        235061,
        9099,
        24921,
        161254,
        151405,
        20508,
        7159,
        34381,
        20133,
        11434,
        74036,
        19974,
        34769,
        36585,
        1076,
        22454,
        17354,
        38727,
        235160,
        111547,
        96454,
        117448,
        156940,
        91330,
        37299,
        7310,
        26915,
        117060,
        51369,
        22620,
        61861,
        322264,
        106850,
        111694,
        15091,
        2624,
        40345,
        300446,
        177064,
        1707,
        27389,
        54792,
        327783,
        132669,
        183543,
        59003,
        17744,
        20603,
        151134,
        106923,
        53084,
        71803,
        279424,
        319816,
        11579,
        21946,
        16728,
        38274,
        72711,
        5085,
        83391,
        88646,
        40159,
        25027,
        34680,
        10752,
        12988,
        54126,
        30365,
        18338,
        100445,
        230674,
        44874,
        84974,
        143877,
        123253,
        139372,
        28082,
        91477,
        144002,
        13096,
        219729,
        46016,
        50029,
        42377,
        14601,
        6660,
        58244,
        58978,
        23918,
        88206,
        113611,
        64452,
        17541,
        41032,
        10942,
        12021,
        49189,
        10978,
        40175,
        37156,
        10947,
        71709,
        106894,
        112538,
        57007,
        137486,
        150608,
        152719,
        40615,
        7746,
        279716,
        13101,
        19524,
        28708,
        40578,
        72320,
        1096,
        182051,
        94527,
        51275,
        22833,
        45164,
        81917,
        77519,
        48508,
        5421,
        140302,
        37845,
        149830,
        5587,
        27579,
        5357,
        428725,
        248187,
        6326,
        206760,
        39814,
        32585,
        89923,
        44341,
        288753,
        284443,
        96368,
        31201,
        94189,
        119504,
        20359,
        52073,
        103216,
        179,
        27934,
        32801,
        96035,
        34111,
        34309,
        101326,
        18198,
        20704,
        210266,
        37643,
        27880,
        141873,
        106e3,
        19414,
        56614,
        167714,
        66483,
        107885,
        86602,
        4379,
        20796,
        75467,
        4987,
        5017,
        118857,
        26003,
        34308,
        114428,
        29198,
        6686,
        29697,
        73632,
        3739,
        69795,
        16798,
        41504,
        7207,
        30722,
        21436,
        36735,
        28067,
        28545,
        3239,
        11221,
        36031,
        41889,
        100010,
        19247,
        317673,
        29495,
        174554,
        6424,
        129725,
        53845,
        94986,
        7955,
        59676,
        2604,
        191497,
        19735,
        102214,
        62954,
        23844,
        11872,
        179525,
        261436,
        34492,
        428,
        78404,
        142035,
        16747,
        17246,
        27578,
        37021,
        33672,
        57944,
        26056,
        135760,
        2369,
        61674,
        122066,
        31327,
        19374,
        157065,
        40553,
        130982,
        69619,
        71290,
        38855,
        72100,
        92903,
        95940,
        51422,
        165999,
        65713,
        57873,
        50726,
        7288,
        20272,
        2081,
        42326,
        22624,
        81120,
        57914,
        79352,
        19447,
        1684,
        72302,
        11774,
        302559,
        161481,
        96396,
        13692,
        414988,
        3721,
        79066,
        56627,
        46883,
        21150,
        11747,
        12184,
        5856,
        113458,
        176117,
        84416,
        52079,
        27933,
        3354,
        59765,
        141359,
        2212,
        216309,
        2555,
        23458,
        196722,
        142463,
        45701,
        44548,
        28798,
        19418,
        215,
        29916,
        9396,
        10574,
        114226,
        84475,
        13520,
        18694,
        34056,
        4524,
        90302,
        62930,
        13539,
        19407,
        77209,
        7728,
        38088,
        9535,
        2263,
        23875,
        183945,
        17750,
        26274,
        67172,
        10585,
        28042,
        22199,
        7478,
        51331,
        66030,
        26774,
        192929,
        31434,
        25850,
        50197,
        52926,
        178158,
        4679,
        181256,
        70184,
        229600,
        9959,
        105594,
        72158,
        73974,
        2726,
        35085,
        78087,
        23284,
        35568,
        51713,
        155676,
        5401,
        27254,
        11966,
        17569,
        223253,
        71993,
        103357,
        111477,
        55722,
        30504,
        26034,
        46774,
        35392,
        36285,
        214814,
        41143,
        163465,
        1051,
        16094,
        81044,
        6636,
        76489,
        179102,
        20712,
        39178,
        35683,
        125177,
        54219,
        30617,
        52994,
        25324,
        50123,
        2543,
        87529,
        58995,
        10688,
        125199,
        12388,
        60158,
        125481,
        131646,
        7642,
        133350,
        65874,
        3438,
        97277,
        101450,
        10075,
        56344,
        116821,
        50778,
        60547,
        98016,
        106135,
        13859,
        14255,
        16300,
        77373,
        173521,
        8285,
        45932,
        37426,
        4054,
        114295,
        55947,
        7703,
        39114,
        52,
        51119,
        128135,
        19714,
        60715,
        9554,
        50492,
        88180,
        2823,
        118271,
        52993,
        122625,
        97919,
        23859,
        37895,
        25040,
        33614,
        32102,
        20431,
        3577,
        9275,
        15686,
        43031,
        157741,
        110358,
        1884,
        40291,
        125391,
        13736,
        5008,
        64881,
        87336,
        77381,
        70711,
        43032,
        49155,
        118587,
        70494,
        4318,
        10168,
        30126,
        12580,
        10524,
        280104,
        104001,
        145413,
        2862,
        84140,
        6603,
        106005,
        13566,
        12780,
        11251,
        42830,
        571,
        179910,
        82443,
        13146,
        469,
        42714,
        32591,
        265217,
        424024,
        92553,
        54721,
        134100,
        6007,
        15242,
        114681,
        59030,
        16718,
        85465,
        200214,
        85982,
        55174,
        165013,
        23493,
        56964,
        82529,
        109150,
        32706,
        27568,
        82442,
        5350,
        14976,
        13165,
        44890,
        60021,
        21343,
        33978,
        17264,
        4655,
        22328,
        27819,
        75730,
        16567,
        55483,
        14510,
        17926,
        45827,
        150609,
        3704,
        7385,
        272531,
        161543,
        76904,
        122163,
        52405,
        2039,
        19165,
        41623,
        14423,
        228354,
        3369,
        176360,
        85491,
        7122,
        35789,
        303724,
        4465,
        13628,
        2233,
        55311,
        118771,
        20713,
        10006,
        221519,
        45115,
        71021,
        35650,
        29775,
        7337,
        10864,
        20665,
        21142,
        1746,
        15080,
        1624,
        32449,
        10905,
        105743,
        229797,
        7701,
        3940,
        22997,
        178467,
        57208,
        389057,
        39683,
        59403,
        63344,
        63125,
        54847,
        69691,
        18336,
        56448,
        3362,
        37202,
        18282,
        29648,
        138224,
        35867,
        10495,
        5911,
        28814,
        26653,
        31514,
        176702,
        26550,
        45621,
        11734,
        4525,
        40543,
        73944,
        121080,
        27858,
        155561,
        14887,
        44670,
        30742,
        8796,
        107455,
        113472,
        56369,
        75581,
        183777,
        240095,
        133699,
        153299,
        8768,
        160464,
        26058,
        49078,
        103971,
        21875,
        71486,
        44888,
        17156,
        9678,
        89541,
        123019,
        102337,
        3972,
        83930,
        21245,
        87852,
        109660,
        287918,
        183019,
        686,
        10100,
        39177,
        283941,
        11274,
        24736,
        26793,
        26214,
        25995,
        77011,
        141580,
        4070,
        23742,
        46285,
        46632,
        30700,
        26669,
        19056,
        35951,
        115575,
        174034,
        56097,
        35463,
        87425,
        24575,
        44245,
        38701,
        82317,
        85922,
        281616,
        100333,
        147697,
        61503,
        7730,
        84330,
        8530,
        59917,
        61597,
        17173,
        9092,
        32658,
        90288,
        193136,
        39023,
        20381,
        56654,
        31132,
        7779,
        1919,
        1375,
        117128,
        30819,
        11169,
        40938,
        23935,
        115201,
        101155,
        151034,
        4835,
        11231,
        74550,
        89388,
        59951,
        91704,
        107312,
        167882,
        115062,
        12732,
        72738,
        88703,
        464019,
        158267,
        57995,
        60496,
        737,
        14371,
        123867,
        4174,
        243339,
        159946,
        7568,
        16025,
        134556,
        110916,
        38103,
        191,
        80226,
        88794,
        29688,
        27230,
        10454,
        76308,
        57647,
        77409,
        113483,
        66864,
        14745,
        19808,
        12023,
        46583,
        84805,
        16015,
        17102,
        2231,
        20611,
        3547,
        95740,
        250131,
        34559,
        108894,
        8498,
        15853,
        159169,
        148920,
        20942,
        2813,
        93160,
        45188,
        210613,
        45531,
        52587,
        149062,
        39782,
        28194,
        57849,
        60965,
        84954,
        89766,
        84453,
        100927,
        16501,
        27658,
        165311,
        103841,
        54192,
        207341,
        19558,
        20084,
        319622,
        5672,
        205467,
        98462,
        61849,
        36279,
        13609,
        147177,
        24726,
        165015,
        209489,
        59591,
        31157,
        6551,
        117580,
        75060,
        141146,
        277310,
        21072,
        22023,
        106474,
        63041,
        137443,
        122965,
        68371,
        5383,
        42146,
        98961,
        113467,
        30863,
        23794,
        4843,
        99630,
        30392,
        82679,
        13699,
        241612,
        33601,
        93146,
        24319,
        18643,
        32155,
        95669,
        40440,
        15333,
        34089,
        67799,
        142144,
        58245,
        38633,
        114531,
        117400,
        77861,
        188726,
        5507,
        2568,
        8853,
        10987,
        107222,
        2663,
        2421,
        11530,
        13345,
        30075,
        41785,
        118661,
        104786,
        17459,
        12490,
        16281,
        71936,
        193555,
        17431,
        5944,
        71758,
        26485,
        77317,
        20803,
        367167,
        158,
        7362,
        93430,
        11735,
        172445,
        46002,
        11532,
        54482,
        930,
        62911,
        2235,
        23004,
        179236,
        4764,
        101859,
        208113,
        22477,
        55163,
        95579,
        14098,
        67320,
        162556,
        90709,
        156949,
        3826,
        57492,
        4025,
        34092,
        87442,
        104565,
        6718,
        186015,
        28214,
        14209,
        10039,
        107186,
        233912,
        58877,
        81637,
        55265,
        39828,
        6194,
        145813,
        50831,
        105849,
        4974,
        88319,
        122296,
        10272,
        197216,
        95714,
        51540,
        72418,
        23324,
        91555,
        8743,
        140452,
        250249,
        51666,
        34124,
        7229,
        38592,
        129641,
        78169,
        174242,
        22464,
        149964,
        51450,
        14034,
        10026,
        95376,
        26190,
        120062,
        14401,
        8700,
        265,
        31386,
        143573,
        7203,
        229889,
        61567,
        4227,
        140981,
        2466,
        72052,
        10787,
        10062,
        30958,
        6099,
        38471,
        30103,
        23202,
        208101,
        70847,
        467,
        58934,
        32271,
        32984,
        36637,
        24107,
        30771,
        17109,
        73353,
        13650,
        2098,
        157040,
        67366,
        66904,
        106018,
        265380,
        107238,
        18535,
        44025,
        32681,
        144983,
        62505,
        91295,
        56120,
        3082,
        77508,
        10322,
        63023,
        36700,
        81885,
        224127,
        16721,
        45023,
        239261,
        111272,
        13852,
        7866,
        149243,
        204199,
        32309,
        22084,
        42029,
        38316,
        126644,
        104973,
        14406,
        43454,
        67322,
        61310,
        15789,
        40285,
        24026,
        181047,
        6301,
        70927,
        23319,
        115823,
        27248,
        66693,
        115875,
        278566,
        63007,
        146844,
        56841,
        59007,
        87368,
        180001,
        22370,
        42114,
        80605,
        12022,
        10374,
        308,
        25079,
        14689,
        12618,
        63368,
        7936,
        264973,
        212291,
        136713,
        95999,
        105801,
        18965,
        32075,
        48700,
        52230,
        35119,
        96912,
        32992,
        8586,
        16606,
        101333,
        101812,
        14969,
        39930,
        759,
        193090,
        27387,
        42914,
        12937,
        5058,
        62646,
        64528,
        38624,
        25743,
        37502,
        3716,
        4435,
        30352,
        178687,
        26461,
        132611,
        42002,
        138442,
        35833,
        59582,
        16345,
        8048,
        60319,
        49349,
        309,
        47800,
        49739,
        90482,
        26405,
        34470,
        63786,
        32479,
        85028,
        39866,
        47846,
        11649,
        23934,
        29466,
        2816,
        42864,
        31828,
        7410,
        74885,
        49632,
        47629,
        111801,
        90749,
        19536,
        18767,
        105764,
        59606,
        21223,
        10746,
        76298,
        22220,
        39408,
        7190,
        79654,
        64856,
        11602,
        82156,
        272765,
        17079,
        70089,
        245473,
        51813,
        184407,
        384678,
        1576,
        122249,
        5064,
        27481,
        6188,
        25790,
        74361,
        27541,
        318284,
        45430,
        31488,
        620,
        93579,
        45723,
        192118,
        22670,
        51913,
        4162,
        70244,
        35966,
        26397,
        16199,
        50899,
        209613,
        121702,
        287507,
        2993,
        36101,
        132229,
        67345,
        33062,
        76295,
        118628,
        78705,
        52316,
        34375,
        107083,
        107454,
        44863,
        127561,
        33964,
        3073,
        154010,
        190914,
        55967,
        39074,
        6272,
        31047,
        5550,
        41123,
        26154,
        98638,
        47110,
        19998,
        148091,
        50229,
        31329,
        59900,
        195442,
        19106,
        61347,
        73497,
        70015,
        682,
        45850,
        25776,
        38022,
        148951,
        6288,
        37411,
        232526,
        109277,
        27286,
        32342,
        9262,
        5220,
        16651,
        23175,
        46740,
        129438,
        78614,
        121925,
        66914,
        88710,
        127952,
        5563,
        21500,
        34521,
        10739,
        14863,
        191006,
        62956,
        17359,
        16749,
        67027,
        56284,
        69134,
        43301,
        35039,
        58883,
        54466,
        60823,
        404451,
        75743,
        59856,
        86979,
        7923,
        34273,
        83785,
        32142,
        7693,
        268986,
        197428,
        282681,
        17049,
        22346,
        22990,
        92245,
        107180,
        3357,
        37104,
        96724,
        49153,
        7683,
        31197,
        43267,
        82231,
        164276,
        23696,
        20848,
        188364,
        22309,
        24821,
        158707,
        1018,
        22514,
        70922,
        27792,
        45589,
        59709,
        10765,
        736,
        35218,
        63479,
        51987,
        24275,
        63588,
        55361,
        92929,
        81964,
        4658,
        20122,
        12330,
        44058,
        13065,
        311456,
        72224,
        8337,
        211229,
        38979,
        22590,
        138478,
        52757,
        32595,
        133600,
        8838,
        31549,
        94412,
        43391,
        90056,
        1585,
        94802,
        127271,
        6223,
        31889,
        137038,
        132910,
        2165,
        57616,
        230152,
        6080,
        10748,
        36737,
        74579,
        134062,
        50525,
        180532,
        119270,
        34556,
        76155,
        82394,
        52595,
        29258,
        31435,
        87820,
        67996,
        26943,
        183878,
        38007,
        2410,
        13526,
        180297,
        69856,
        3503,
        187396,
        167700,
        7838,
        16701,
        9199,
        56267,
        3661,
        37407,
        65994,
        23767,
        5708,
        62508,
        221700,
        67088,
        86978,
        46776,
        84434,
        32088,
        5612,
        9149,
        88244,
        21685,
        95151,
        46750,
        189612,
        2979,
        506311,
        2594,
        3628,
        40074,
        105039,
        78243,
        28523,
        6651,
        38058,
        71999,
        30992,
        12764,
        68261,
        108991,
        6165,
        26450,
        61961,
        13400,
        22426,
        7490,
        60890,
        109623,
        2070,
        12958,
        50355,
        67979,
        257096,
        7213,
        42578,
        52121,
        35716,
        65461,
        7516,
        124758,
        39268,
        302,
        64712,
        14977,
        1467,
        219452,
        2840,
        34229,
        11121,
        21602,
        19270,
        63574,
        8024,
        1532,
        17331,
        79839,
        78885,
        52029,
        180767,
        57957,
        6069,
        91265,
        61380,
        55767,
        8927,
        32881,
        287603,
        22149,
        35029,
        68876,
        6428,
        199567,
        46926,
        13412,
        104132,
        21434,
        366616,
        45060,
        110046,
        81924,
        128910,
        45886,
        52821,
        130416,
        29416,
        77342,
        21762,
        67329,
        121432,
        79924,
        11724,
        38625,
        81006,
        102033,
        28338,
        13326,
        3250,
        82056,
        82526,
        38212,
        21112,
        12382,
        111495,
        3263,
        7414,
        86274,
        93490,
        40844,
        30224,
        45212,
        24019,
        48411,
        71367,
        24941,
        76729,
        57776,
        3769,
        38114,
        202019,
        197745,
        31953,
        237533,
        33270,
        201580,
        255648,
        100798,
        44741,
        32241,
        98468,
        106931,
        10085,
        15090,
        170358,
        33154,
        66787,
        18819,
        69760,
        25061,
        234005,
        82660,
        6295,
        131975,
        16874,
        9076,
        4094,
        25005,
        17740,
        40908,
        19533,
        220019,
        44330,
        99792,
        50040,
        19619,
        13950,
        55228,
        24423,
        31253,
        95308,
        103177,
        184795,
        28590,
        82285,
        5059,
        3210,
        75525,
        49894,
        70007,
        56178,
        10580,
        36051,
        139681,
        21617,
        98736,
        3555,
        106306,
        164189,
        37352,
        63915,
        47824,
        24883,
        145530,
        61904,
        28444,
        11483,
        19837,
        145446,
        30420,
        112972,
        85939,
        11835,
        191233,
        2262,
        20705,
        58630,
        1753,
        148334,
        1197,
        144714,
        6887,
        11223,
        107667,
        60879,
        77914,
        4151,
        57417,
        81594,
        96681,
        169430,
        1784,
        20444,
        95138,
        254041,
        27038,
        596,
        7117,
        72808,
        13759,
        3353,
        126776,
        21074,
        55322,
        27081,
        36942,
        39547,
        139830,
        179275,
        4453,
        713,
        8722,
        71399,
        19204,
        25785,
        22794,
        23923,
        104114,
        11291,
        25458,
        102309,
        88396,
        75288,
        230440,
        206396,
        104551,
        58447,
        130857,
        37247,
        94734,
        31548,
        176529,
        226077,
        65159,
        20104,
        10096,
        66881,
        94191,
        237909,
        27109,
        37404,
        1520,
        27421,
        25220,
        113003,
        23423,
        24884,
        50585,
        6286,
        231877,
        150800,
        11789,
        3226,
        90004,
        60642,
        5053,
        202400,
        61442,
        132531,
        175329,
        57138,
        30116,
        103847,
        9973,
        75367,
        16452,
        32360,
        59119,
        21246,
        10191,
        164804,
        23305,
        61051,
        37348,
        154530,
        13214,
        5468,
        50403,
        66754,
        130976,
        50559,
        80515,
        14436,
        155492,
        84017,
        5472,
        43107,
        41240,
        2890,
        90431,
        70188,
        382,
        76234,
        48040,
        50211,
        281038,
        237007,
        32115,
        142178,
        1536,
        22761,
        96429,
        1811,
        31243,
        1679,
        49143,
        55209,
        17402,
        235054,
        61494,
        7462,
        77030,
        34925,
        87609,
        78002,
        9499,
        9027,
        73289,
        201078,
        101379,
        63544,
        27666,
        5469,
        10642,
        30029,
        49816,
        132979,
        95620,
        58086,
        351930,
        116300,
        2110,
        2043,
        30845,
        6154,
        11279,
        16727,
        4122,
        2277,
        27281,
        4971,
        3650,
        39060,
        61970,
        65951,
        39674,
        75686,
        38151,
        11370,
        130809,
        177895,
        32665,
        63725,
        122267,
        7857,
        39618,
        118483,
        44792,
        157755,
        178624,
        136994,
        24260,
        41308,
        22471,
        12404,
        21707,
        12486,
        30473,
        52781,
        50246,
        20247,
        39065,
        909,
        56825,
        103158,
        128603,
        31542,
        1089,
        41935,
        32744,
        12428,
        37963,
        84420,
        33134,
        72921,
        208449,
        42622,
        168151,
        127335,
        147107,
        46699,
        38216,
        12591,
        94342,
        85814,
        31423,
        24944,
        2605,
        87542,
        67473,
        192551,
        4496,
        56321,
        91819,
        17630,
        6300,
        256183,
        114569,
        202090,
        33209,
        35289,
        34897,
        24967,
        40520,
        43470,
        5344,
        10199,
        34810,
        14283,
        10381,
        10017,
        62923,
        49924,
        23233,
        64539,
        13051,
        35686,
        19698,
        11570,
        135555,
        120868,
        44924,
        87065,
        52318,
        52335,
        47586,
        140906,
        245885,
        109834,
        78668,
        9065,
        46990,
        25258,
        72022,
        61243,
        40838,
        4545,
        146387,
        10537,
        11557,
        17470,
        36930,
        68104,
        46711,
        24264,
        79401,
        81043,
        18225,
        120488,
        24746,
        84338,
        81652,
        28266,
        13776,
        21878,
        46973,
        1047,
        230465,
        73357,
        95777,
        24973,
        210160,
        62210,
        58404,
        110633,
        169651,
        6937,
        41870,
        9909,
        26822,
        191062,
        76553,
        27519,
        96256,
        239070,
        2478,
        205678,
        67955,
        58532,
        20601,
        50120,
        19148,
        78501,
        195724,
        110740,
        8249,
        109665,
        27446,
        30568,
        57631,
        31425,
        49752,
        32820,
        65504,
        50079,
        3663,
        102256,
        219898,
        23849,
        211315,
        14645,
        4359,
        91767,
        9528,
        12449,
        49366,
        7941,
        49763,
        107848,
        8930,
        27086,
        50686,
        9744,
        10447,
        81935,
        39513,
        46514,
        1670,
        29229,
        6172,
        22312,
        137280,
        97759,
        9806,
        14445,
        22976,
        56458,
        73391,
        34983,
        93760,
        174219,
        52573,
        33149,
        59747,
        2429,
        136277,
        75123,
        165263,
        91040,
        7446,
        57632,
        48633,
        97140,
        246081,
        84766,
        151684,
        79918,
        93268,
        120346,
        54059,
        54875,
        77858,
        32996,
        103590,
        45276,
        11968,
        19600,
        25849,
        17159,
        132907,
        42828,
        16817,
        4913,
        99462,
        103303,
        27395,
        5737,
        74184,
        20749,
        21160,
        14377,
        77062,
        131403,
        158735,
        10999,
        27799,
        77785,
        9320,
        34366,
        51593,
        61070,
        33746,
        47048,
        29268,
        36675,
        30262,
        53297,
        9832,
        82e3,
        20188,
        122292,
        39917,
        7331,
        18160,
        68301,
        185935,
        134830,
        15031,
        4935,
        10004,
        165845,
        185534,
        46923,
        30109,
        44134,
        122631,
        18874,
        22903,
        112790,
        26561,
        18549,
        348902,
        82871,
        140345,
        255565,
        135390,
        63556,
        103747,
        145055,
        179600,
        145662,
        296111,
        61661,
        211987,
        23952,
        52342,
        126343,
        48450,
        32919,
        44277,
        82185,
        9591,
        62139,
        205363,
        376969,
        394874,
        108461,
        18040,
        120885,
        14798,
        39863,
        16571,
        16794,
        58271,
        81025,
        55206,
        14640,
        118656,
        6361,
        44092,
        85970,
        6262,
        153863,
        108244,
        180200,
        72264,
        79947,
        38044,
        10050,
        5735,
        61221,
        80712,
        5471,
        115689,
        11391,
        11661,
        184257,
        20010,
        60116,
        30320,
        19327,
        134598,
        45455,
        27542,
        18004,
        125092,
        452272,
        1549,
        91523,
        46567,
        180063,
        156026,
        2608,
        11174,
        58848,
        37788,
        65907,
        80194,
        30490,
        5786,
        40775,
        119519,
        106241,
        11323,
        156297,
        8425,
        61495,
        2617,
        29675,
        2425,
        59886,
        112582,
        49142,
        59618,
        4863,
        50597,
        86710,
        50650,
        168632,
        27693,
        85641,
        83643,
        18993,
        25768,
        84284,
        28090,
        93592,
        36627,
        312804,
        43381,
        9887,
        9402,
        100931,
        97165,
        3311,
        173330,
        66805,
        28935,
        4963,
        184460,
        3201,
        78102,
        19126,
        21607,
        37496,
        24938,
        22615,
        16153,
        32862,
        134792,
        153318,
        61120,
        6067,
        2812,
        12826,
        12792,
        23825,
        37559,
        64662,
        202250,
        102694,
        155488,
        85881,
        149193,
        46233,
        65383,
        15521,
        106982,
        11358,
        176786,
        25752,
        39717,
        34208,
        24510,
        32464,
        77742,
        39371,
        72028,
        138229,
        60688,
        71386,
        102834,
        132477,
        2208,
        11548,
        63670,
        271279,
        28351,
        30338,
        38620,
        32491,
        99845,
        143885,
        152266,
        13252,
        2825,
        178663,
        108097,
        1775,
        78201,
        14897,
        113573,
        163346,
        62292,
        171129,
        22183,
        96598,
        38733,
        64971,
        166776,
        117445,
        9968,
        146393,
        44677,
        74867,
        20908,
        97328,
        12761,
        25656,
        26785,
        9148,
        112344,
        26115,
        99176,
        110121,
        22437,
        49547,
        6180,
        79320,
        5835,
        31392,
        43328,
        33377,
        75870,
        119860,
        69497,
        80273,
        7325,
        155219,
        43167,
        111173,
        28347,
        20222,
        3763,
        71752,
        55041,
        47252,
        14618,
        28088,
        15012,
        97805,
        194698,
        54636,
        2036,
        41349,
        6173,
        96604,
        61530,
        51859,
        43782,
        13361,
        24334,
        22668,
        24792,
        7070,
        23441,
        16789,
        3209,
        36211,
        208475,
        26242,
        32880,
        122181,
        182407,
        21444,
        31060,
        88459,
        29929,
        77907,
        12716,
        10934,
        97005,
        20599,
        31690,
        8403,
        58445,
        30303,
        22700,
        10336,
        86731,
        103115,
        337709,
        72556,
        46788,
        112566,
        47684,
        67089,
        53548,
        36874,
        56487,
        41387,
        125985,
        26893,
        40071,
        106683,
        73712,
        18787,
        40105,
        72992,
        67246,
        137276,
        50802,
        36790,
        70328,
        138827,
        22466,
        39263,
        183295,
        29858,
        50975,
        9322,
        57397,
        10654,
        24364,
        30383,
        55799,
        41600,
        23584,
        127295,
        296610,
        129078,
        143558,
        244131,
        86397,
        36049,
        1085,
        80677,
        3820,
        108139,
        5476,
        34767,
        24683,
        7758,
        13060,
        7239,
        131671,
        250593,
        59556,
        103392,
        29810,
        4188,
        252323,
        39404,
        116877,
        7651,
        43600,
        40338,
        13554,
        157253,
        39196,
        25978,
        144387,
        61211,
        234,
        50104,
        6129,
        10449,
        93777,
        9240,
        356378,
        274148,
        4439,
        72970,
        3724,
        147770,
        78680,
        62570,
        115877,
        40027,
        40547,
        36817,
        224392,
        64609,
        34795,
        165027,
        67440,
        2477,
        37206,
        23431,
        50754,
        164797,
        46018,
        94995,
        170982,
        27051,
        7957,
        22767,
        3674,
        27900,
        56419,
        18930,
        60701,
        41302,
        2692,
        84749,
        339721,
        61996,
        111094,
        80221,
        50129,
        1045,
        8153,
        62945,
        19202,
        8250,
        37208,
        37418,
        32560,
        79477,
        41106,
        88569,
        33963,
        36693,
        5892,
        30570,
        1581,
        66471,
        49647,
        11922,
        160717,
        29442,
        5643,
        114865,
        82962,
        95982,
        132098,
        22633,
        22838,
        94726,
        54556,
        28566,
        205039,
        162340,
        33216,
        16849,
        35847,
        221339,
        94851,
        26533,
        71469,
        1805,
        3804,
        12935,
        45483,
        71020,
        36310,
        65381,
        192960,
        34240,
        35165,
        59773,
        1248,
        46954,
        155332,
        96864,
        4246,
        388800,
        16129,
        57133,
        74592,
        44807,
        442014,
        38203,
        42574,
        80818,
        91592,
        26377,
        36424,
        65760,
        977,
        77387,
        22628,
        147610,
        28018,
        30561,
        98454,
        6969,
        119628,
        63648,
        18170,
        36854,
        26601,
        64018,
        22027,
        37279,
        51395,
        152934,
        21153,
        9430,
        58760,
        194742,
        5330,
        55115,
        34158,
        28917,
        174111,
        13171,
        122326,
        1526,
        43896,
        66094,
        25325,
        4234,
        148354,
        11450,
        275,
        18999,
        112191,
        44365,
        22723,
        68409,
        8733,
        57746,
        96565,
        75007,
        14196,
        108844,
        29475,
        88599,
        177563,
        100792,
        106156,
        86323,
        93726,
        14248,
        135341,
        194131,
        40126,
        47099,
        14779,
        8272,
        39597,
        95983,
        171398,
        65882,
        28052,
        10393,
        47213,
        40689,
        22120,
        72212,
        106829,
        34964,
        109146,
        753,
        648,
        21660,
        30047,
        17527,
        181025,
        5619,
        145357,
        4085,
        216883,
        9359,
        186951,
        24779,
        53931,
        24545,
        36197,
        223296,
        62628,
        168101,
        4243,
        107313,
        30321,
        26642,
        13049,
        51059,
        31027,
        107912,
        807,
        73550,
        26551,
        84369,
        122422,
        165872,
        49754,
        74213,
        234264,
        33151,
        52014,
        33100,
        87183,
        22365,
        52500,
        40013,
        23302,
        5652,
        72723,
        21404,
        26107,
        48434,
        587,
        94049,
        168493,
        96418,
        32871,
        70860,
        31709,
        25128,
        443,
        71597,
        166253,
        15670,
        70994,
        26341,
        133675,
        28280,
        75491,
        54756,
        47955,
        56028,
        26182,
        11952,
        113272,
        472197,
        64640,
        110753,
        17919,
        337,
        50642,
        22576,
        142,
        87371,
        53391,
        93210,
        126694,
        15285,
        19642,
        85667,
        14148,
        1506,
        42092,
        52962,
        33243,
        11970,
        20734,
        135843,
        57044,
        58880,
        13002,
        219134,
        22876,
        64754,
        232519,
        4257,
        43120,
        321573,
        24799,
        64526,
        124728,
        52579,
        81472,
        70831,
        276848,
        17403,
        74359,
        23021,
        182101,
        74597,
        23744,
        148267,
        12055,
        7976,
        5349,
        11772,
        67540,
        167347,
        65318,
        18720,
        127832,
        108238,
        22828,
        90233,
        9987,
        259080,
        118185,
        73209,
        79270,
        13775,
        90100,
        137742,
        90799,
        70569,
        15699,
        19961,
        9087,
        67475,
        57872,
        39731,
        8810,
        134897,
        131868,
        146849,
        19898,
        3334,
        2281,
        167061,
        91073,
        60356,
        467742,
        74712,
        188,
        53179,
        137679,
        92769,
        29241,
        9537,
        132595,
        80119,
        1041,
        88962,
        5976,
        40171,
        44911,
        102859,
        139059,
        104558,
        98987,
        47761,
        19272,
        71472,
        113864,
        175377,
        73338,
        10857,
        23402,
        23758,
        1591,
        139864,
        5644,
        4076,
        118760,
        16427,
        134198,
        18853,
        20291,
        100849,
        37423,
        22038,
        36677,
        19071,
        195521,
        57445,
        11069,
        31869,
        55718,
        66882,
        148490,
        44,
        41296,
        75242,
        49704,
        166810,
        9906,
        20943,
        122258,
        49112,
        105667,
        15969,
        10344,
        6408,
        187694,
        21399,
        72742,
        58970,
        14867,
        14376,
        81889,
        41856,
        23225,
        15042,
        56993,
        16074,
        131389,
        74276,
        72407,
        53875,
        383108,
        53597,
        37363,
        68993,
        44854,
        122548,
        430927,
        198279,
        38430,
        80409,
        12245,
        2981,
        628,
        2818,
        17760,
        37437,
        238229,
        7968,
        46892,
        2200,
        3730,
        34190,
        65983,
        37959,
        112291,
        87850,
        70827,
        6522,
        20750,
        73913,
        111621,
        41652,
        19587,
        2780,
        58668,
        25916,
        85259,
        18200,
        168962,
        95781,
        42445,
        102050,
        7776,
        57662,
        103313,
        47742,
        96358,
        41964,
        66174,
        100396,
        29069,
        204735,
        19679,
        27978,
        7479,
        40264,
        22534,
        61183,
        36081,
        107436,
        58223,
        14680,
        23002,
        101311,
        24716,
        124108,
        12908,
        5646,
        31750,
        40380,
        14215,
        232799,
        102772,
        14122,
        96775,
        61398,
        50917,
        12096,
        149880,
        67833,
        598749,
        124194,
        155871,
        49216,
        790,
        14677,
        65319,
        56917,
        7440,
        145744,
        95701,
        12206,
        49405,
        129269,
        76199,
        45732,
        9767,
        11058,
        9047,
        210885,
        11051,
        7392,
        26307,
        2130,
        8132,
        147526,
        20802,
        232698,
        115660,
        50060,
        59789,
        57344,
        107623,
        80343,
        112676,
        23291,
        9866,
        160971,
        34032,
        118291,
        15719,
        59730,
        164911,
        28975,
        2659,
        58046,
        78480,
        21854,
        66209,
        53863,
        109085,
        116045,
        29021,
        46481,
        107552,
        22130,
        18764,
        70254,
        31272,
        11300,
        52460,
        43933,
        84738,
        20721,
        53869,
        190840,
        79673,
        105300,
        7561,
        321817,
        66924,
        13940,
        33281,
        101046,
        183181,
        32176,
        71878,
        5678,
        62924,
        79535,
        56646,
        40303,
        19559,
        27703,
        93042,
        73368,
        42187,
        3670,
        37376,
        46440,
        7023,
        36816,
        109628,
        20680,
        5940,
        276440,
        275233,
        170848,
        112093,
        136996,
        14984,
        20226,
        111441,
        77693,
        112960,
        48577,
        39370,
        55707,
        50314,
        123404,
        26570,
        54281,
        61372,
        123391,
        4857,
        35928,
        246740,
        132507,
        106646,
        44241,
        7196,
        92258,
        9825,
        37688,
        51197,
        303141,
        5590,
        15476,
        132986,
        10955,
        85782,
        34486,
        26696,
        7991,
        28813,
        18858,
        39546,
        11703,
        11365,
        38185,
        5716,
        93555,
        11925,
        40121,
        60002,
        6985,
        10976,
        171384,
        3887,
        43394,
        13337,
        56346,
        6381,
        252336,
        39573,
        75042,
        53711,
        1028,
        31781,
        44295,
        95925,
        131713,
        7214,
        68125,
        43571,
        70954,
        213234,
        1628,
        8760,
        13391,
        65485,
        17320,
        56038,
        1710,
        25248,
        60803,
        57399,
        19839,
        3870,
        326,
        281556,
        50945,
        72400,
        21460,
        316244,
        75619,
        56246,
        98775,
        481,
        13513,
        55765,
        50427,
        7388,
        123519,
        32929,
        57908,
        27124,
        61316,
        101097,
        57467,
        30228,
        48792,
        10788,
        20402,
        37318,
        50526,
        155730,
        34456,
        158065,
        145305,
        17832,
        43733,
        64052,
        4506,
        35072,
        205355,
        177028,
        184004,
        187081,
        68616,
        35938,
        83703,
        10367,
        36892,
        93186,
        260137,
        51934,
        89970,
        4985,
        23445,
        26755,
        21558,
        7948,
        78741,
        23376,
        124405,
        85594,
        68596,
        57536,
        49351,
        12619,
        56593,
        132668,
        99924,
        109728,
        71844,
        71935,
        196018,
        65464,
        17617,
        14987,
        89701,
        143773,
        33997,
        8687,
        22701,
        33258,
        2914,
        4436,
        72108,
        85610,
        9671,
        49067,
        2327,
        82988,
        1361,
        1672,
        44033,
        35777,
        30269,
        24057,
        10605,
        82236,
        616,
        15793,
        13919,
        47249,
        112086,
        116698,
        9484,
        80207,
        90574,
        33304,
        68624,
        93127,
        56101,
        42210,
        160929,
        4827,
        38995,
        38095,
        4701,
        125119,
        5027,
        33680,
        9236,
        231236,
        14135,
        87837,
        23318,
        70261,
        78893,
        30151,
        81482,
        14332,
        1084,
        74256,
        27532,
        46644,
        79185,
        3148,
        62615,
        6981,
        55672,
        31668,
        36825,
        1849,
        14536,
        37446,
        14738,
        23779,
        43058,
        162749,
        72199,
        1168,
        21346,
        5592,
        85932,
        85302,
        9668,
        18351,
        57135,
        150360,
        2080,
        228015,
        77953,
        34670,
        119302,
        151751,
        31009,
        106725,
        84265,
        45214,
        59289,
        74178,
        113071,
        263206,
        111009,
        4021,
        44449,
        188119,
        192629,
        123592,
        392506,
        292847,
        114487,
        12831,
        205858,
        9852,
        20780,
        79648,
        75767,
        357014,
        97721,
        18166,
        21005,
        67950,
        33226,
        204009,
        16536,
        2987,
        11335,
        66717,
        144910,
        47950,
        17262,
        55060,
        15063,
        2934,
        51038,
        26775,
        178497,
        66008,
        3427,
        49433,
        128592,
        20036,
        157553,
        63861,
        3089,
        23015,
        51210,
        28696,
        35933,
        49942,
        71135,
        231518,
        99620,
        17248,
        21835,
        176536,
        20676,
        16944,
        38700,
        165831,
        233253,
        295625,
        36723,
        13023,
        52745,
        10907,
        19423,
        67972,
        125868,
        95473,
        82875,
        1183,
        108455,
        52685,
        33417,
        64095,
        21433,
        52438,
        33191,
        127809,
        44505,
        211823,
        7810,
        2752,
        95548,
        162031,
        7185,
        91196,
        47563,
        61721,
        33359,
        17897,
        23682,
        42806,
        178101,
        22874,
        49707,
        199897,
        75419,
        82456,
        8618,
        11171,
        79712,
        116847,
        18783,
        44190,
        46564,
        5346,
        59046,
        95032,
        7893,
        14916,
        3214,
        26800,
        24172,
        121453,
        34362,
        10250,
        17408,
        18888,
        4840,
        68696,
        22831,
        13162,
        36005,
        32512,
        14800,
        62357,
        41723,
        45046,
        27247,
        37486,
        5372,
        2564,
        34261,
        298500,
        66509,
        133920,
        89138,
        31305,
        117697,
        19097,
        108304,
        81386,
        84106,
        23802,
        46411,
        63304,
        946,
        51417,
        41777,
        41041,
        19501,
        115864,
        60743,
        294354,
        37955,
        94165,
        18116,
        1156,
        17937,
        20645,
        57114,
        90804,
        58042,
        48643,
        92288,
        9861,
        2557,
        88546,
        61333,
        101008,
        12853,
        5148,
        87856,
        4152,
        144503,
        73841,
        18718,
        9789,
        147565,
        10846,
        42085,
        12789,
        30223,
        8993,
        56352,
        67203,
        2448,
        28215,
        6052,
        23540,
        126319,
        75933,
        36689,
        80235,
        23231,
        23561,
        21383,
        38800,
        77548,
        102798,
        21234,
        31468,
        158608,
        46188,
        63960,
        191679,
        8051,
        67014,
        11185,
        170078,
        42186,
        28827,
        34777,
        41930,
        212079,
        12421,
        34750,
        24111,
        110344,
        73918,
        45171,
        70826,
        141949,
        40063,
        23979,
        24254,
        37309,
        26724,
        27179,
        24718,
        83648,
        54938,
        14591,
        17425,
        29525,
        102675,
        48975,
        48654,
        12316,
        8929,
        60640,
        41709,
        50168,
        63264,
        89812,
        50716,
        48632,
        38755,
        138583,
        160123,
        55579,
        71829,
        24230,
        233277,
        46322,
        39650,
        166388,
        34718,
        24108,
        98252,
        7031,
        106695,
        62498,
        18258,
        35062,
        217827,
        78731,
        34824,
        33354,
        19520,
        60852,
        2432,
        60224,
        8587,
        2836,
        62955,
        702,
        20227,
        42285,
        40560,
        95592,
        62486,
        11094,
        53035,
        143291,
        18842,
        46177,
        77994,
        1770,
        9657,
        107422,
        172915,
        32655,
        128716,
        25886,
        25164,
        156740,
        119928,
        165875,
        85817,
        11007,
        89110,
        33956,
        12652,
        65156,
        180266,
        8494,
        36889,
        19958,
        20955,
        96,
        1264,
        118288,
        135769,
        44754,
        86671,
        5632,
        19026,
        168220,
        289120,
        33569,
        93821,
        66144,
        70635,
        7687,
        5642,
        2714,
        55445,
        56636,
        71545,
        184182,
        93133,
        7332,
        37389,
        12643,
        52315,
        22729,
        11014,
        158742,
        17050,
        152889,
        50178,
        34601,
        41945,
        52136,
        9948,
        26914,
        63548,
        95721,
        115951,
        40759,
        8960,
        158258,
        38938,
        49232,
        48325,
        42234,
        81523,
        253019,
        66128,
        40978,
        20048,
        238048,
        38760,
        62928,
        122560,
        118532,
        43687,
        137472,
        163689,
        26680,
        9878,
        17448,
        51035,
        16211,
        60834,
        36749,
        29178,
        14241,
        59868,
        150086,
        2305,
        26477,
        42422,
        34342,
        165341,
        83279,
        33894,
        14257,
        29928,
        12743,
        13957,
        125571,
        89134,
        66712,
        10952,
        16507,
        147839,
        30146,
        7249,
        16565,
        45399,
        39874,
        114565,
        215780,
        31990,
        230881,
        171477,
        102,
        196546,
        44538,
        10880,
        84948,
        281705,
        86651,
        10617,
        31395,
        2342,
        453658,
        43569,
        60561,
        132901,
        21845,
        17727,
        58556,
        258242,
        22262,
        58728,
        4008,
        77997,
        11806,
        37431,
        30599,
        81375,
        109137,
        185787,
        114085,
        217292,
        97453,
        169085,
        30593,
        60212,
        11544,
        102056,
        65580,
        2384,
        91655,
        4855,
        95725,
        7295,
        157994,
        16228,
        20669,
        53276,
        141590,
        105246,
        17334,
        25440,
        76067,
        17967,
        39321,
        38911,
        11362,
        28559,
        63807,
        21627,
        26468,
        85816,
        40120,
        1025,
        15234,
        58319,
        69516,
        66512,
        124548,
        75845,
        78873,
        22137,
        46681,
        51242,
        85683,
        32909,
        76747,
        35555,
        43396,
        101465,
        1765,
        73094,
        1077,
        2962,
        39028,
        66777,
        57831,
        42048,
        15828,
        13962,
        36041,
        63657,
        52412,
        5242,
        58846,
        2141,
        5506,
        219012,
        134451,
        3936,
        182230,
        17558,
        17153,
        152237,
        22621,
        49377,
        170216,
        35257,
        68233,
        65374,
        6510,
        11126,
        212151,
        7184,
        2480,
        22517,
        3437,
        33073,
        30156,
        16557,
        3768,
        55067,
        86829,
        91e3,
        12350,
        148650,
        66017,
        79424,
        70885,
        49066,
        28250,
        21369,
        51213,
        34533,
        11510,
        3258,
        18176,
        18465,
        84413,
        6315,
        36411,
        163765,
        4346,
        356,
        107618,
        598,
        13727,
        285026,
        162695,
        8749,
        14583,
        7132,
        63521,
        184253,
        32378,
        25991,
        5604,
        30961,
        53675,
        4874,
        84693,
        5086,
        34811,
        26978,
        56564,
        7904,
        33519,
        51221,
        113942,
        69253,
        6664,
        125563,
        22055,
        220680,
        102008,
        742,
        51930,
        19494,
        176108,
        44424,
        35123,
        13025,
        75685,
        11759,
        74335,
        22250,
        181453,
        131147,
        16984,
        132115,
        154311,
        11991,
        76452,
        52609,
        85351,
        196,
        30969,
        9198,
        74919,
        2529,
        56838,
        71779,
        29187,
        116304,
        3504,
        62330,
        41190,
        86153,
        28393,
        254926,
        104228,
        105189,
        13264,
        84359,
        3574,
        12415,
        8534,
        57147,
        10175,
        188174,
        59504,
        60932,
        66318,
        16407,
        107921,
        17638,
        99103,
        49278,
        28403,
        39786,
        145865,
        8462,
        3558,
        43406,
        142271,
        29139,
        21989,
        36552,
        93955,
        72365,
        7176,
        13556,
        106185,
        37957,
        321774,
        17782,
        129017,
        51154,
        27938,
        24952,
        1935,
        39366,
        2791,
        33489,
        41582,
        56078,
        24558,
        9311,
        5449,
        218786,
        27808,
        190429,
        68013,
        36020,
        86003,
        29735,
        3404,
        87348,
        119357,
        115714,
        2324,
        86796,
        81973,
        40992,
        43376,
        93621,
        28784,
        16808,
        36367,
        2517,
        2909,
        191926,
        24978,
        55303,
        53308,
        205724,
        60068,
        3098,
        21375,
        64784,
        23949,
        26579,
        63121,
        12319,
        80145,
        39967,
        97861,
        6757,
        70143,
        67642,
        37082,
        34698,
        69140,
        122883,
        46151,
        62187,
        80934,
        429,
        19437,
        135071,
        137885,
        222647,
        13331,
        154065,
        327,
        61778,
        74257,
        40116,
        37493,
        14855,
        85079,
        237641,
        42342,
        102164,
        199965,
        71204,
        4662,
        29368,
        5042,
        113914,
        122214,
        8955,
        13149,
        102503,
        43173,
        5659,
        163787,
        69003,
        307084,
        63392,
        171080,
        21390,
        81918,
        86666,
        36622,
        24126,
        28887,
        5736,
        28054,
        207170,
        163428,
        79891,
        346467,
        95363,
        38980,
        111806,
        80828,
        9200,
        19288,
        294896,
        114468,
        87405,
        111715,
        141705,
        7015,
        72754,
        68463,
        48738,
        243147,
        33397,
        101210,
        37051,
        98801,
        82847,
        20397,
        4940,
        185559,
        18716,
        54718,
        83491,
        11725,
        40803,
        1128,
        12128,
        23060,
        5174,
        7745,
        67007,
        46701,
        1571,
        27807,
        180186,
        256996,
        18975,
        16837,
        7877,
        212758,
        250379,
        15440,
        87954,
        57755,
        24719,
        124057,
        83461,
        258,
        50864,
        8874,
        29038,
        71289,
        31627,
        15429,
        9005,
        4061,
        113851,
        107716,
        82819,
        13651,
        79656,
        117851,
        17539,
        111446,
        12938,
        39724,
        190787,
        4352,
        15402,
        21070,
        62708,
        8539,
        23777,
        73853,
        13552,
        38810,
        86117,
        16285,
        56400,
        1718,
        75342,
        142863,
        29033,
        378,
        110113,
        180321,
        32586,
        23606,
        26393,
        160984,
        207987,
        23783,
        8406,
        16904,
        24596,
        47274,
        11693,
        46539,
        60524,
        78595,
        48423,
        31718,
        20170,
        9009,
        146268,
        15183,
        191060,
        172765,
        1349,
        138436,
        37365,
        10970,
        40509,
        225817,
        20021,
        70394,
        152138,
        21541,
        66559,
        66544,
        89352,
        2725,
        17258,
        91345,
        7313,
        3815,
        115868,
        8660,
        40362,
        4071,
        103524,
        39388,
        118275,
        21950,
        6549,
        38226,
        32754,
        209574,
        29201,
        43495,
        18028,
        20296,
        40597,
        18370,
        47520,
        202450,
        24134,
        2219,
        8195,
        69545,
        38041,
        136934,
        46374,
        19041,
        159811,
        84865,
        58620,
        846,
        98749,
        13569,
        30714,
        97246,
        32186,
        4479,
        27355,
        92973,
        35214,
        151491,
        75963,
        37631,
        1561,
        27200,
        238083,
        23182,
        60756,
        12291,
        25766,
        39355,
        102333,
        87362,
        65741,
        59906,
        19538,
        201575,
        48772,
        102938,
        24438,
        292580,
        39964,
        66366,
        9004,
        61379,
        50548,
        37622,
        38732,
        28379,
        68180,
        76622,
        17488,
        69849,
        5963,
        7219,
        48143,
        43413,
        55358,
        540,
        58691,
        29506,
        19245,
        52193,
        48621,
        5518,
        13048,
        118625,
        44755,
        191081,
        42061,
        89197,
        2259,
        60665,
        66994,
        71210,
        51232,
        3585,
        142096,
        55024,
        7892,
        8345,
        58653,
        463307,
        65658,
        64319,
        137941,
        136323,
        53499,
        12746,
        43492,
        6978,
        95163,
        29925,
        60175,
        5128,
        7352,
        41463,
        184756,
        121146,
        20473,
        18426,
        4598,
        5309,
        54580,
        14277,
        121151,
        10691,
        56711,
        43880,
        63409,
        76682,
        11830,
        172218,
        264898,
        32632,
        66536,
        81062,
        31649,
        25788,
        92774,
        60222,
        11100,
        63159,
        9432,
        224657,
        25240,
        53613,
        152,
        138620,
        163829,
        2397,
        85345,
        12501,
        37507,
        64932,
        38575,
        43522,
        65789,
        80198,
        78796,
        35226,
        3851,
        108891,
        73311,
        3060,
        28391,
        93671,
        39663,
        46142,
        30982,
        66041,
        37281,
        68157,
        26553,
        71872,
        81142,
        211527,
        39747,
        118119,
        22695,
        2859,
        11066,
        20232,
        168911,
        7933,
        197005,
        17066,
        111071,
        44434,
        133994,
        120798,
        12766,
        227798,
        45756,
        132852,
        29917,
        36076,
        55352,
        65281,
        129800,
        41958,
        18944,
        84678,
        18580,
        168093,
        132621,
        39997,
        54092,
        27740,
        32354,
        3770,
        114118,
        103242,
        43918,
        15899,
        18574,
        145944,
        3190,
        123469,
        219903,
        24169,
        100571,
        62403,
        16776,
        92779,
        14535,
        17168,
        16475,
        14304,
        37231,
        1712,
        28218,
        242754,
        61688,
        28980,
        1318,
        51359,
        222657,
        99200,
        67989,
        31772,
        23932,
        35351,
        201251,
        49041,
        27306,
        19128,
        40135,
        3986,
        77333,
        19649,
        120683,
        151927,
        21081,
        7076,
        78375,
        77501,
        101599,
        8011,
        89585,
        96715,
        58179,
        5378,
        102138,
        106793,
        26051,
        217276,
        4197,
        16297,
        27014,
        46721,
        13322,
        22806,
        5278,
        29629,
        70632,
        9647,
        71519,
        58818,
        40603,
        128530,
        8903,
        36770,
        56900,
        31483,
        26935,
        43845,
        34265,
        34920,
        87658,
        6114,
        84767,
        64250,
        47318,
        50720,
        19264,
        162514,
        33357,
        13117,
        6705,
        46696,
        75032,
        71054,
        87004,
        42035,
        69138,
        11903,
        99854,
        102328,
        19611,
        34525,
        69312,
        6431,
        49842,
        101600,
        133178,
        108751,
        41829,
        89939,
        225664,
        48916,
        99556,
        9195,
        130387,
        5960,
        36857,
        116724,
        53518,
        94002,
        39077,
        53996,
        6945,
        22261,
        64291,
        8314,
        152785,
        57588,
        16522,
        9091,
        5048,
        87671,
        35441,
        39509,
        1945,
        12423,
        158923,
        178413,
        37549,
        14095,
        1475,
        73188,
        62878,
        4819,
        24012,
        68534,
        42606,
        4010,
        120809,
        57497,
        59564,
        101758,
        103718,
        32701,
        80116,
        12345,
        95834,
        46918,
        21468,
        53213,
        15665,
        31200,
        3867,
        5140,
        96013,
        250744,
        21016,
        10069,
        13968,
        35449,
        180829,
        27683,
        39704,
        59956,
        22893,
        3115,
        26293,
        32785,
        75934,
        62445,
        141162,
        62720,
        2018,
        83638,
        19949,
        114012,
        95006,
        3330,
        99829,
        130935,
        309272,
        9565,
        55874,
        121727,
        37017,
        23586,
        319858,
        40970,
        27602,
        8625,
        112329,
        61060,
        100088,
        118525,
        25922,
        16232,
        1907,
        60671,
        51583,
        44553,
        80993,
        5262,
        94679,
        8676,
        940,
        20736,
        11823,
        3020,
        16476,
        12340,
        152600,
        97416,
        3703,
        25744,
        66826,
        16245,
        16876,
        46446,
        84798,
        74227,
        176020,
        45192,
        61955,
        75496,
        23946,
        23626,
        40372,
        26036,
        6149,
        11822,
        30582,
        16541,
        41914,
        82385,
        232823,
        40921,
        80773,
        14930,
        3631,
        7517,
        39619,
        4348,
        36180,
        126106,
        138939,
        62611,
        1477,
        113512,
        47321,
        25052,
        14546,
        118881,
        29060,
        23589,
        128322,
        36795,
        18401,
        137921,
        104699,
        267929,
        36194,
        172791,
        18113,
        4766,
        188215,
        30083,
        332586,
        94089,
        5805,
        77909,
        22194,
        68234,
        154976,
        43220,
        40660,
        70001,
        184893,
        138095,
        11128,
        103010,
        22663,
        5108,
        212615,
        8485,
        5565,
        49222,
        54614,
        26530,
        42639,
        16319,
        55062,
        152662,
        105595,
        21114,
        22216,
        10294,
        68158,
        10436,
        86950,
        7206,
        62115,
        3977,
        3657,
        59874,
        456,
        118617,
        18156,
        106663,
        112229,
        80992,
        17442,
        8217,
        55551,
        5133,
        34344,
        251927,
        51153,
        39364,
        201321,
        7816,
        66803,
        23057,
        156724,
        145664,
        14276,
        95705,
        979,
        2796,
        6875,
        13429,
        212525,
        50602,
        26276,
        28284,
        3424,
        19465,
        52397,
        46963,
        31420,
        51399,
        206476,
        92317,
        48851,
        637,
        100820,
        83349,
        10317,
        60227,
        21972,
        6908,
        282439,
        32857,
        224767,
        95629,
        83882,
        42106,
        87338,
        69757,
        29840,
        68709,
        37665,
        45244,
        114577,
        49188,
        175943,
        54009,
        186746,
        106158,
        70168,
        3358,
        234002,
        50555,
        9221,
        129338,
        9562,
        20118,
        32923,
        78479,
        118280,
        65752,
        4977,
        10474,
        102174,
        60947,
        129006,
        10570,
        83451,
        8598,
        8078,
        159367,
        123785,
        80438,
        16742,
        5905,
        5281,
        181513,
        42402,
        6977,
        163136,
        93179,
        42191,
        14968,
        50421,
        112401,
        105440,
        33456,
        57347,
        121611,
        4221,
        94954,
        36517,
        24046,
        27796,
        6255,
        33394,
        72990,
        135408,
        116627,
        1233,
        57874,
        25654,
        95419,
        68156,
        401399,
        313338,
        55208,
        45573,
        93124,
        119251,
        47200,
        38196,
        11909,
        130667,
        45391,
        73904,
        64964,
        167846,
        4137,
        115606,
        52036,
        62214,
        7969,
        160925,
        7187,
        1132,
        134835,
        40309,
        73195,
        64494,
        80472,
        444841,
        61111,
        26500,
        45323,
        40743,
        53625,
        52797,
        22659,
        15631,
        29739,
        36706,
        28841,
        39147,
        102836,
        26794,
        10536,
        14845,
        87305,
        45874,
        12241,
        127587,
        83833,
        57183,
        79722,
        30844,
        41304,
        84655,
        20825,
        92500,
        3722,
        25655,
        27811,
        10157,
        81634,
        31362,
        34088,
        92487,
        70123,
        22190,
        185100,
        72658,
        139035,
        192523,
        88241,
        2078,
        230490,
        44528,
        85638,
        100198,
        22088,
        29982,
        291233,
        241062,
        13865,
        4445,
        137791,
        37835,
        107218,
        31726,
        19718,
        38234,
        72528,
        23046,
        19177,
        66695,
        5109,
        17251,
        28077,
        5617,
        21554,
        47839,
        72425,
        133825,
        1486,
        73065,
        181275,
        141508,
        21768,
        62971,
        63082,
        2512,
        34200,
        9904,
        120309,
        6392,
        91243,
        68416,
        268253,
        41199,
        116757,
        138551,
        185526,
        41246,
        28986,
        4093,
        19057,
        17295,
        4148,
        245766,
        122360,
        35356,
        112075,
        20301,
        75441,
        10998,
        7977,
        19769,
        62922,
        937,
        63547,
        100196,
        26427,
        157820,
        20983,
        236696,
        22935,
        8140,
        90315,
        156004,
        47204,
        140973,
        7726,
        45097,
        52725,
        22636,
        23436,
        257282,
        105247,
        522,
        88389,
        216031,
        202204,
        46812,
        211666,
        19693,
        68828,
        81691,
        45925,
        11256,
        30292,
        372,
        5236,
        167826,
        88328,
        232776,
        151611,
        5360,
        82104,
        18841,
        80393,
        25465,
        18285,
        20320,
        72377,
        31730,
        33160,
        45803,
        38715,
        27705,
        37379,
        24163,
        18360,
        103586,
        4015,
        32305,
        269494,
        91252,
        20080,
        36567,
        54650,
        7797,
        57073,
        12650,
        31164,
        42209,
        6375,
        261663,
        105528,
        81661,
        106002,
        2800,
        5375,
        17247,
        43151,
        4442,
        15727,
        194619,
        100855,
        144898,
        62320,
        78465,
        39929,
        16454,
        1967,
        28311,
        61363,
        17219,
        9395,
        8745,
        121445,
        76939,
        80385,
        162380,
        22009,
        54191,
        44248,
        16299,
        122830,
        48151,
        74429,
        78291,
        64755,
        14238,
        44966,
        2511,
        17712,
        67954,
        93583,
        829,
        105899,
        49935,
        84750,
        11591,
        33185,
        85447,
        42717,
        27409,
        208542,
        28965,
        62052,
        52525,
        5597,
        25694,
        65594,
        16343,
        63224,
        276188,
        12475,
        9331,
        127507,
        38522,
        57287,
        24128,
        133161,
        79723,
        105548,
        133695,
        48917,
        27558,
        43278,
        46520,
        13778,
        141954,
        110785,
        83366,
        17715,
        46317,
        105763,
        66298,
        147013,
        41086,
        94180,
        16478,
        220447,
        44611,
        730,
        19722,
        78975,
        117889,
        125643,
        26254,
        16574,
        18480,
        65006,
        15806,
        38549,
        246418,
        46052,
        36056,
        8440,
        34984,
        30170,
        3163,
        59800,
        4458,
        115442,
        4283,
        41970,
        33507,
        104078,
        1653,
        22,
        121158,
        276486,
        3655,
        6338,
        24048,
        133421,
        23641,
        2161,
        24422,
        36006,
        8086,
        10675,
        181474,
        12307,
        29514,
        59143,
        14729,
        52509,
        87128,
        122470,
        19446,
        80852,
        33314,
        24573,
        119864,
        14237,
        9652,
        57779,
        6612,
        51851,
        15284,
        98871,
        90581,
        124466,
        156831,
        21190,
        22015,
        71380,
        161906,
        87247,
        69201,
        18392,
        17908,
        108470,
        72962,
        40719,
        14338,
        17911,
        95260,
        43339,
        20610,
        78916,
        20710,
        72451,
        11315,
        31448,
        17263,
        58853,
        178878,
        48111,
        116002,
        45497,
        80506,
        82605,
        85880,
        36300,
        121755,
        25215,
        36118,
        301929,
        88728,
        405223,
        276136,
        553,
        34704,
        212438,
        49970,
        78329,
        922,
        20711,
        25036,
        257130,
        38295,
        145369,
        18128,
        15385,
        30829,
        55656,
        48345,
        8012,
        3561,
        28004,
        122041,
        192900,
        58338,
        112508,
        41085,
        29976,
        87040,
        47117,
        23905,
        4336,
        92061,
        138880,
        97407,
        42083,
        172121,
        6256,
        25192,
        172671,
        5,
        93568,
        1420,
        12677,
        31605,
        56743,
        40620,
        6015,
        78415,
        231077,
        31298,
        80026,
        13902,
        19048,
        24924,
        170586,
        32955,
        176119,
        87859,
        36731,
        6773,
        27711,
        24658,
        26475,
        115216,
        133207,
        93250,
        95820,
        88522,
        8317,
        5714,
        124047,
        55219,
        86860,
        19677,
        23961,
        22928,
        162209,
        8904,
        225992,
        359835,
        56084,
        96201,
        29392,
        96558,
        86071,
        93643,
        55114,
        13347,
        8183,
        95129,
        82012,
        2017,
        123336,
        34219,
        115554,
        157159,
        47747,
        101684,
        41008,
        18735,
        193781,
        104151,
        226906,
        7552,
        179874,
        124113,
        31159,
        21162,
        44010,
        14771,
        51268,
        166128,
        31382,
        73124,
        77438,
        92830,
        205709,
        12113,
        1292,
        38937,
        13114,
        1334,
        2118,
        15597,
        69581,
        14449,
        21934,
        76618,
        48728,
        67038,
        14967,
        51495,
        24243,
        87736,
        147249,
        26720,
        11119,
        46063,
        43749,
        5843,
        44147,
        152629,
        133428,
        65703,
        14269,
        45604,
        57982,
        28672,
        55616,
        45957,
        8438,
        95433,
        37698,
        220862,
        132034,
        39456,
        61870,
        4161,
        26501,
        73560,
        56418,
        9845,
        4654,
        20916,
        10456,
        88920,
        119358,
        9015,
        65931,
        96507,
        48029,
        38534,
        21676,
        109081,
        43078,
        34943,
        25089,
        6131,
        28766,
        23665,
        5477,
        10255,
        16695,
        67,
        45778,
        42443,
        42770,
        29534,
        23733,
        100513,
        62617,
        42630,
        48746,
        14191,
        43753,
        50295,
        26007,
        8792,
        57243,
        43119,
        54725,
        164253,
        58250,
        112304,
        131796,
        25165,
        4651,
        3188,
        24831,
        47748,
        3705,
        19540,
        13211,
        102095,
        5593,
        18699,
        23666,
        32005,
        117571,
        33541,
        60584,
        74573,
        86311,
        99443,
        25172,
        27222,
        168938,
        7143,
        11853,
        53560,
        18834,
        19960,
        86522,
        28217,
        53266,
        117700,
        72989,
        34323,
        18721,
        66450,
        34346,
        74056,
        47217,
        202002,
        46269,
        9429,
        68582,
        75458,
        37823,
        82843,
        96652,
        32549,
        145144,
        27958,
        19820,
        158086,
        31955,
        201406,
        135379,
        31207,
        192545,
        12950,
        51704,
        9094,
        248263,
        76147,
        64028,
        110009,
        79407,
        89345,
        99284,
        223492,
        47966,
        26848,
        15359,
        201137,
        2861,
        110507,
        71231,
        72297,
        31851,
        118777,
        71039,
        151051,
        240855,
        16333,
        50766,
        14727,
        7939,
        4149,
        80908,
        418780,
        88378,
        59276,
        1327,
        7284,
        38576,
        79814,
        65820,
        42199,
        84860,
        49574,
        62596,
        12396,
        70598,
        40117,
        8648,
        7994,
        16836,
        7630,
        14047,
        359699,
        106878,
        525,
        29037,
        28064,
        13380,
        11675,
        50669,
        74216,
        103539,
        180314,
        27449,
        56299,
        172344,
        19274,
        7301,
        246099,
        32043,
        19422,
        36506,
        129317,
        6806,
        30140,
        4614,
        46639,
        66926,
        932,
        86600,
        6322,
        27847,
        233103,
        10541,
        39025,
        34887,
        3517,
        12972,
        26220,
        2031,
        66561,
        115015,
        48658,
        47596,
        12714,
        33845,
        3893,
        16165,
        35237,
        89983,
        14769,
        11962,
        147224,
        47018,
        29977,
        27979,
        5552,
        82338,
        86023,
        131368,
        1218,
        24853,
        237840,
        132193,
        15455,
        40873,
        3668,
        65351,
        53388,
        15229,
        59889,
        272245,
        47934,
        11858,
        34347,
        18038,
        90853,
        86981,
        300602,
        19343,
        114181,
        29362,
        84921,
        6095,
        106059,
        79472,
        38015,
        1206,
        48741,
        6208,
        8e4,
        21916,
        17423,
        6002,
        108083,
        24479,
        34931,
        56661,
        9511,
        26995,
        100694,
        163853,
        35997,
        81254,
        58321,
        18919,
        171890,
        86877,
        91341,
        74503,
        70477,
        53412,
        7027,
        59281,
        39892,
        131302,
        5864,
        15947,
        61301,
        67466,
        162369,
        47956,
        27874,
        35624,
        282324,
        21270,
        111847,
        102548,
        41482,
        30955,
        116737,
        28264,
        8592,
        55458,
        22301,
        75090,
        29821,
        30697,
        51709,
        3041,
        19208,
        8038,
        24634,
        30467,
        87509,
        126428,
        19389,
        18814,
        152686,
        20701,
        83474,
        45832,
        80891,
        105808,
        11378,
        153223,
        120770,
        98186,
        150633,
        49838,
        9141,
        12755,
        30962,
        5260,
        74490,
        21256,
        31678,
        65062,
        33326,
        289838,
        187831,
        20595,
        89768,
        2805,
        58535,
        10844,
        70085,
        12090,
        2451,
        138068,
        98544,
        24461,
        4511,
        6754,
        41684,
        28203,
        3383,
        65355,
        82833,
        30161,
        83924,
        234361,
        128424,
        28921,
        222594,
        33975,
        125491,
        34069,
        11508,
        67464,
        144226,
        41850,
        98703,
        34371,
        7901,
        21254,
        38398,
        65651,
        23549,
        53883,
        213340,
        123269,
        12028,
        71764,
        177701,
        28758,
        2623,
        68395,
        11549,
        15232,
        68603,
        9660,
        63116,
        36079,
        57093,
        31198,
        20475,
        48467,
        89984,
        35619,
        186847,
        107469,
        31389,
        43631,
        73867,
        41949,
        68841,
        114250,
        1605,
        30564,
        63403,
        17588,
        27680,
        99533,
        12641,
        70325,
        50428,
        73426,
        78379,
        11855,
        91651,
        72081,
        91720,
        60198,
        15743,
        12065,
        83398,
        140046,
        6761,
        46598,
        45900,
        5068,
        886,
        62448,
        148968,
        37347,
        19405,
        9680,
        15819,
        43496,
        63370,
        75667,
        163700,
        37639,
        3633,
        22774,
        34341,
        183131,
        134335,
        37200,
        23915,
        7054,
        14194,
        12970,
        26438,
        13350,
        285521,
        25594,
        8219,
        104410,
        91039,
        168804,
        138480,
        149734,
        15907,
        33818,
        61132,
        60082,
        4622,
        110187,
        56736,
        13551,
        73571,
        3945,
        73463,
        65498,
        17758,
        263266,
        17593,
        2710,
        27585,
        54469,
        38200,
        45367,
        63754,
        28881,
        3473,
        12791,
        98287,
        31895,
        65787,
        4463,
        94536,
        24951,
        36332,
        59901,
        28803,
        52130,
        86403,
        7668,
        181822,
        74831,
        18977,
        9850,
        177206,
        145485,
        109798,
        7292,
        31421,
        26280,
        77211,
        58511,
        12507,
        127004,
        11113,
        147,
        8729,
        56208,
        43066,
        79926,
        129937,
        31345,
        83947,
        39915,
        46146,
        98763,
        42566,
        1337,
        13192,
        18323,
        105163,
        80570,
        117753,
        16555,
        72883,
        11077,
        159438,
        40764,
        70933,
        83329,
        26066,
        12276,
        72059,
        21655,
        173836,
        126713,
        69454,
        153482,
        91585,
        70644,
        102558,
        110483,
        6764,
        127864,
        190133,
        3961,
        101798,
        20945,
        71138,
        82402,
        90884,
        69669,
        44753,
        923,
        16939,
        59700,
        164258,
        25969,
        27082,
        31399,
        43846,
        6306,
        246093,
        51342,
        6153,
        151581,
        202801,
        182731,
        56475,
        162188,
        89426,
        141356,
        14355,
        121815,
        27536,
        28023,
        65257,
        77523,
        106668,
        127314,
        24947,
        12790,
        38796,
        169698,
        23555,
        10725,
        44573,
        183083,
        42088,
        62716,
        43265,
        105958,
        32050,
        44067,
        50118,
        1668,
        3874,
        6243,
        318411,
        16599,
        1691,
        94999,
        52378,
        28671,
        216728,
        123258,
        2059,
        34969,
        69225,
        5913,
        136280,
        171443,
        141515,
        91662,
        22175,
        135282,
        80020,
        92270,
        1663,
        4808,
        4482,
        3495,
        34691,
        5226,
        109830,
        108512,
        17342,
        107488,
        11606,
        123190,
        100247,
        29666,
        146527,
        113014,
        15794,
        30894,
        13224,
        39585,
        243192,
        22351,
        9903,
        7836,
        47699,
        11078,
        25468,
        122291,
        48821,
        26780,
        122679,
        75521,
        81450,
        630,
        4895,
        92900,
        55074,
        74293,
        17441,
        3563,
        111657,
        103102,
        51613,
        12318,
        52370,
        36191,
        68245,
        34269,
        40445,
        41354,
        122901,
        168604,
        182500,
        62012,
        42557,
        11259,
        24428,
        115113,
        86345,
        12362,
        3909,
        78430,
        86852,
        134602,
        20459,
        47853,
        93879,
        22577,
        7659,
        3688,
        38555,
        13349,
        17381,
        56715,
        91639,
        12493,
        10895,
        92438,
        3142,
        37057,
        28928,
        2004,
        36427,
        32268,
        34222,
        209974,
        10432,
        67436,
        41989,
        173518,
        107930,
        27079,
        62729,
        30908,
        55558,
        5828,
        45031,
        14902,
        53546,
        8204,
        144263,
        60255,
        14520,
        88212,
        86582,
        109589,
        69356,
        8064,
        47449,
        8505,
        66558,
        16886,
        4844,
        52817,
        111260,
        215129,
        12941,
        91118,
        650,
        20770,
        6273,
        73089,
        40618,
        62790,
        2873,
        35002,
        14023,
        97208,
        19386,
        102646,
        36993,
        143736,
        135457,
        35385,
        113601,
        17893,
        32627,
        84439,
        100619,
        56016,
        6581,
        57264,
        172160,
        45452,
        111710,
        203627,
        70131,
        24100,
        322787,
        1996,
        35665,
        70078,
        22358,
        90922,
        83658,
        4097,
        63200,
        58499,
        14542,
        99153,
        52159,
        6615,
        12414,
        63415,
        31986,
        16823,
        1579,
        65405,
        137809,
        8841,
        16898,
        48082,
        259,
        33014,
        42375,
        12260,
        179850,
        73667,
        91389,
        98882,
        29532,
        17311,
        326251,
        41092,
        5928,
        20742,
        44964,
        48019,
        43505,
        9317,
        49265,
        6643,
        192712,
        48424,
        163487,
        19861,
        20113,
        70848,
        31928,
        105333,
        23685,
        78563,
        14638,
        54755,
        7158,
        24142,
        44018,
        20774,
        125255,
        20331,
        24280,
        10163,
        1285,
        2336,
        39851,
        4299,
        117269,
        46714,
        63816,
        87779,
        159624,
        11731,
        9971,
        990,
        137317,
        108831,
        50994,
        74554,
        162680,
        23640,
        131597,
        146962,
        170620,
        34829,
        91205,
        21184,
        1913,
        63616,
        18427,
        93136,
        156592,
        17519,
        67565,
        115882,
        138220,
        78622,
        88535,
        18115,
        2711,
        33554,
        109492,
        54298,
        971,
        24914,
        25863,
        36363,
        45715,
        27099,
        194995,
        14299,
        178181,
        111488,
        72395,
        322385,
        157719,
        130787,
        11897,
        81843,
        83999,
        11369,
        49280,
        118604,
        40922,
        61332,
        110343,
        53407,
        75639,
        40582,
        300440,
        54722,
        25637,
        13694,
        48248,
        48278,
        194521,
        56203,
        52779,
        48783,
        72627,
        10953,
        376,
        16733,
        280238,
        26351,
        230789,
        15132,
        25168,
        137270,
        3588,
        63704,
        73376,
        94031,
        74284,
        19443,
        159557,
        9697,
        39901,
        13351,
        119050,
        15406,
        146455,
        3460,
        29556,
        75195,
        37673,
        102524,
        92329,
        47289,
        98413,
        15311,
        100684,
        56345,
        7116,
        95480,
        11590,
        7200,
        167,
        23610,
        58426,
        17730,
        136656,
        27944,
        53151,
        2701,
        8824,
        103124,
        3017,
        90744,
        113588,
        53216,
        79736,
        65940,
        26931,
        498,
        29568,
        80540,
        143543,
        21292,
        1740,
        59268,
        16561,
        180816,
        42323,
        50174,
        40890,
        52866,
        10703,
        57169,
        4700,
        17191,
        4424,
        93511,
        49698,
        166650,
        26972,
        48631,
        165169,
        82879,
        69326,
        202970,
        4007,
        2376,
        231325,
        139592,
        22119,
        62851,
        37504,
        68816,
        58345,
        67398,
        186643,
        43331,
        277416,
        53749,
        15746,
        23102,
        17432,
        4793,
        151138,
        48822,
        54265,
        48203,
        198688,
        14305,
        54287,
        2291,
        18018,
        113378,
        123260,
        7180,
        97549,
        87027,
        120085,
        2920,
        76080,
        8190,
        102005,
        5641,
        64580,
        14955,
        59802,
        54028,
        58884,
        19367,
        81779,
        412567,
        85957,
        97053,
        103637,
        78871,
        29364,
        27637,
        141728,
        4767,
        30686,
        112738,
        130146,
        42745,
        12730,
        105040,
        14844,
        232,
        210944,
        36581,
        152317,
        135543,
        29744,
        3129,
        55647,
        58149,
        46319,
        27265,
        17499,
        28005,
        59948,
        7170,
        34138,
        5702,
        293047,
        110892,
        408,
        91760,
        218674,
        18469,
        46095,
        81403,
        14389,
        4610,
        35672,
        73060,
        11006,
        74848,
        104820,
        118143,
        190357,
        20043,
        105358,
        141735,
        5115,
        27093,
        45924,
        123073,
        52599,
        29433,
        9616,
        238350,
        78610,
        24851,
        58858,
        26769,
        31969,
        24613,
        18294,
        4982,
        32735,
        39639,
        143563,
        112073,
        202205,
        12567,
        4873,
        88601,
        44897,
        81503,
        101648,
        81362,
        34662,
        85277,
        17574,
        48173,
        21435,
        221188,
        40215,
        39576,
        80786,
        26544,
        64668,
        81841,
        10731,
        37733,
        247986,
        149188,
        127703,
        495,
        18382,
        54388,
        72446,
        43071,
        30974,
        198723,
        89608,
        41360,
        190,
        33045,
        8386,
        31658,
        19992,
        237838,
        119015,
        137622,
        50890,
        100913,
        6460,
        116233,
        267230,
        26621,
        104129,
        65114,
        14190,
        41542,
        14888,
        85962,
        23342,
        23041,
        26453,
        43725,
        71809,
        45186,
        4770,
        46452,
        53894,
        56616,
        221286,
        18973,
        9038,
        109299,
        55365,
        19366,
        26863,
        18808,
        60909,
        69353,
        41738,
        83463,
        12100,
        68561,
        72860,
        3980,
        13796,
        49340,
        12332,
        31311,
        27418,
        4255,
        53430,
        18976,
        45523,
        510,
        14224,
        30477,
        26581,
        4530,
        3651,
        101663,
        139840,
        22709,
        150861,
        31996,
        63923,
        120623,
        262522,
        3076,
        10528,
        2929,
        14672,
        130238,
        18087,
        9816,
        121894,
        100308,
        25085,
        55111,
        14565,
        18952,
        53293,
        2042,
        369988,
        23674,
        61789,
        133529,
        28783,
        108293,
        35477,
        47119,
        36448,
        71049,
        40015,
        33055,
        78598,
        198442,
        1833,
        159937,
        40654,
        77444,
        189245,
        113153,
        8621,
        18599,
        38553,
        35223,
        166072,
        2375,
        11659,
        21786,
        89523,
        6032,
        12116,
        63046,
        159398,
        18454,
        3678,
        32521,
        47626,
        11411,
        103527,
        38896,
        42946,
        15696,
        26370,
        10185,
        8413,
        37080,
        165583,
        4331,
        63555,
        14907,
        72220,
        50056,
        6623,
        62236,
        36565,
        49783,
        10049,
        17503,
        100581,
        55951,
        146244,
        24724,
        9626,
        17969,
        25524,
        109300,
        173965,
        99994,
        101056,
        46459,
        43647,
        53737,
        277968,
        8347,
        123521,
        74858,
        33829,
        44762,
        77574,
        877,
        81377,
        222525,
        123532,
        30602,
        43881,
        53145,
        2973,
        16284,
        81940,
        61281,
        127044,
        63620,
        9875,
        14756,
        114829,
        19032,
        9202,
        52759,
        119141,
        23928,
        120551,
        19607,
        3599,
        33401,
        76821,
        73233,
        117430,
        39968,
        36539,
        7071,
        5446,
        121735,
        194059,
        15206,
        45283,
        6706,
        15603,
        65615,
        1207,
        165723,
        92275,
        34773,
        104447,
        8396,
        32353,
        205240,
        164323,
        13600,
        60555,
        79205,
        25532,
        22907,
        33410,
        57480,
        107111,
        69630,
        32137,
        47832,
        70913,
        33161,
        20321,
        2371,
        117348,
        10714,
        86246,
        1625,
        11763,
        17900,
        268,
        78457,
        99175,
        97940,
        101092,
        86660,
        32221,
        14041,
        128504,
        125080,
        53744,
        124263,
        31017,
        13897,
        403,
        31859,
        21964,
        5633,
        111630,
        5547,
        77329,
        17961,
        18241,
        84995,
        25984,
        12983,
        67491,
        62168,
        47262,
        5241,
        297,
        51191,
        7351,
        8967,
        147212,
        82060,
        16821,
        782,
        11033,
        82431,
        62957,
        5026,
        43459,
        77963,
        203477,
        53528,
        6247,
        191852,
        87774,
        74164,
        215654,
        13467,
        1522,
        219964,
        28589,
        244104,
        16242,
        117821,
        67725,
        72570,
        156792,
        17186,
        15979,
        26990,
        44128,
        193014,
        35276,
        57125,
        16212,
        166451,
        68017,
        6905,
        77608,
        16364,
        53777,
        75921,
        76426,
        37975,
        26203,
        269296,
        64099,
        84122,
        12077,
        38533,
        830,
        4407,
        20139,
        963,
        43028,
        38902,
        42911,
        37503,
        83343,
        85045,
        16979,
        1165,
        60835,
        137387,
        58380,
        86990,
        110066,
        134540,
        56331,
        193845,
        81238,
        17922,
        163093,
        38744,
        110641,
        12502,
        56404,
        34862,
        26865,
        125964,
        12965,
        111648,
        25547,
        7771,
        27196,
        136980,
        9555,
        29551,
        107158,
        57885,
        18831,
        37705,
        35505,
        101742,
        13970,
        102109,
        62548,
        124657,
        23328,
        11124,
        89592,
        146376,
        248050,
        6241,
        22033,
        18337,
        80685,
        29898,
        11908,
        216623,
        67721,
        106162,
        146610,
        21377,
        15085,
        91552,
        42041,
        62560,
        122532,
        125336,
        102365,
        121537,
        142559,
        29693,
        223919,
        11515,
        110495,
        18776,
        22494,
        5895,
        185059,
        103592,
        229351,
        51220,
        100102,
        37027,
        257855,
        29359,
        54123,
        36066,
        106493,
        12244,
        79258,
        32002,
        432,
        56205,
        94836,
        90182,
        6726,
        14762,
        29391,
        48938,
        26864,
        38083,
        60364,
        3310,
        60192,
        14766,
        205567,
        57504,
        110760,
        22649,
        24666,
        46333,
        21517,
        3430,
        13135,
        28873,
        27052,
        158809,
        11597,
        20529,
        6695,
        23138,
        22960,
        37137,
        45574,
        6545,
        305877,
        43423,
        26153,
        24769,
        59844,
        14501,
        10430,
        134352,
        56169,
        13213,
        103432,
        49523,
        35181,
        13435,
        12408,
        129475,
        64620,
        230854,
        77390,
        51990,
        15653,
        83248,
        33466,
        44571,
        117828,
        51481,
        2187,
        10559,
        68019,
        18021,
        54895,
        48247,
        18354,
        33737,
        4554,
        108595,
        37288,
        39767,
        116707,
        9175,
        3726,
        108877,
        21616,
        83684,
        49862,
        1938,
        8543,
        276466,
        20134,
        108498,
        48770,
        102254,
        31914,
        131520,
        185291,
        100559,
        51890,
        209,
        19526,
        76471,
        50544,
        71814,
        99351,
        8172,
        198526,
        28816,
        20419,
        9109,
        98389,
        136777,
        76479,
        75596,
        30635,
        165417,
        48216,
        120220,
        25955,
        211071,
        39314,
        24308,
        32164,
        2559,
        146280,
        43403,
        9233,
        17947,
        90585,
        1786,
        86920,
        125662,
        2457,
        64741,
        32152,
        32918,
        122882,
        78538,
        44001,
        31723,
        56426,
        23375,
        103172,
        88177,
        145697,
        52506,
        49319,
        68016,
        31664,
        41488,
        18486,
        110400,
        7030,
        28241,
        986,
        109199,
        19900,
        42147,
        56864,
        65287,
        49183,
        7858,
        24e3,
        30453,
        840,
        16673,
        25907,
        68916,
        89927,
        6309,
        158335,
        36407,
        199737,
        130464,
        13137,
        59603,
        201778,
        195292,
        21015,
        42466,
        179062,
        172561,
        89492,
        11075,
        180407,
        31868,
        72493,
        20998,
        60217,
        9865,
        19530,
        39274,
        130266,
        54539,
        21623,
        12535,
        13505,
        40641,
        73375,
        4087,
        85633,
        2153,
        3117,
        70680,
        55788,
        92096,
        47509,
        98493,
        37490,
        271936,
        151475,
        3032,
        16171,
        96642,
        34106,
        78425,
        125761,
        19591,
        3366,
        19316,
        54508,
        24183,
        50786,
        194248,
        91528,
        33253,
        34622,
        108355,
        41741,
        705,
        3814,
        3883,
        108929,
        13203,
        67831,
        10142,
        59754,
        68208,
        29128,
        84820,
        56880,
        38794,
        24972,
        48571,
        40821,
        40476,
        18137,
        164254,
        24064,
        236309,
        79181,
        11282,
        395,
        39169,
        2013,
        51587,
        28551,
        9645,
        701,
        109513,
        115899,
        113566,
        12762,
        62045,
        58322,
        103726,
        41343,
        40866,
        244102,
        143816,
        2490,
        70346,
        40973,
        52618,
        15412,
        30720,
        104315,
        38917,
        42027,
        93676,
        17513,
        107418,
        20706,
        123890,
        13399,
        97727,
        24044,
        87962,
        65606,
        44250,
        98044,
        65276,
        74790,
        101473,
        19350,
        91570,
        1326,
        87790,
        172042,
        7577,
        100813,
        86896,
        85891,
        41512,
        108130,
        27794,
        14875,
        71431,
        12835,
        156250,
        58135,
        3759,
        22476,
        42176,
        115873,
        34686,
        56523,
        73643,
        108505,
        51491,
        20838,
        12721,
        32863,
        45700,
        29496,
        13700,
        34294,
        55360,
        29206,
        155942,
        123812,
        7706,
        163234,
        203,
        132720,
        49358,
        144431,
        8130,
        175788,
        35818,
        3270,
        76832,
        25710,
        54095,
        97274,
        28779,
        94621,
        74396,
        19092,
        128242,
        58067,
        20885,
        14670,
        93255,
        15107,
        63291,
        23654,
        126900,
        129421,
        59294,
        262659,
        9798,
        3251,
        67344,
        28600,
        44629,
        50672,
        29072,
        26999,
        31526,
        23183,
        49175,
        165843,
        175455,
        17282,
        175411,
        32022,
        45989,
        30298,
        90690,
        78118,
        83156,
        23749,
        35636,
        31317,
        7069,
        80381,
        94561,
        133756,
        14960,
        97404,
        6138,
        41065,
        78041,
        32843,
        16601,
        34123,
        9559,
        146529,
        123377,
        96395,
        54441,
        42012,
        84257,
        123541,
        10745,
        22139,
        106459,
        11720,
        150883,
        172651,
        154996,
        110538,
        4728,
        53447,
        25704,
        2009,
        71152,
        119354,
        21166,
        66604,
        1429,
        216162,
        8637,
        122250,
        63520,
        27180,
        29172,
        36124,
        276428,
        107787,
        77184,
        4680,
        14952,
        104903,
        24418,
        14793,
        51561,
        52931,
        8371,
        26342,
        48526,
        7118,
        92066,
        67280,
        40653,
        8847,
        34597,
        105438,
        14198,
        50163,
        61188,
        146286,
        50315,
        41205,
        170829,
        161496,
        585,
        197359,
        95056,
        1687,
        365794,
        91349,
        48507,
        5804,
        49263,
        5146,
        104902,
        96365,
        117343,
        132222,
        46084,
        96919,
        16875,
        8073,
        262381,
        79982,
        52663,
        13928,
        16056,
        153908,
        15145,
        109256,
        132308,
        18763,
        24904,
        167644,
        13618,
        40750,
        18686,
        147124,
        114709,
        150038,
        52849,
        2938,
        12568,
        48617,
        8778,
        5459,
        44202,
        44591,
        74914,
        17183,
        248689,
        13878,
        7822,
        80060,
        23116,
        194037,
        18487,
        2067,
        7798,
        43077,
        33678,
        244028,
        31320,
        74273,
        2794,
        19466,
        8218,
        36280,
        183997,
        48124,
        19416,
        29656,
        19280,
        98734,
        7715,
        18311,
        30701,
        133602,
        150307,
        126956,
        7378,
        2933,
        79903,
        13178,
        12593,
        86571,
        26604,
        92446,
        13574,
        44205,
        65699,
        427599,
        21118,
        8245,
        14407,
        27877,
        47936,
        33542,
        7916,
        26460,
        117762,
        21596,
        37818,
        2249,
        127359,
        209394,
        60044,
        47677,
        308089,
        36791,
        154971,
        31417,
        6998,
        150042,
        174360,
        12255,
        43009,
        29335,
        48739,
        3912,
        101398,
        53340,
        2580,
        146939,
        151295,
        45360,
        125275,
        15273,
        45383,
        27456,
        48761,
        23314,
        8750,
        60801,
        85823,
        104759,
        27894,
        123685,
        66968,
        39480,
        26917,
        55290,
        83305,
        2696,
        98390,
        57569,
        145853,
        340733,
        4919,
        20024,
        52268,
        30884,
        7413,
        203685,
        70989,
        112855,
        4129,
        50536,
        349518,
        68205,
        332641,
        159581,
        135361,
        236026,
        37563,
        176404,
        64899,
        6578,
        122033,
        63871,
        1850,
        85234,
        82089,
        66124,
        74145,
        121098,
        107351,
        12687,
        36881,
        117334,
        13136,
        14698,
        85933,
        93866,
        18047,
        32620,
        310,
        15094,
        46e3,
        88451,
        23632,
        36645,
        27940,
        87618,
        80520,
        58892,
        20976,
        27702,
        140090,
        96075,
        67841,
        103292,
        238964,
        87778,
        107338,
        17019,
        83427,
        67522,
        7302,
        8261,
        47570,
        116787,
        8730,
        80484,
        61772,
        174422,
        56005,
        131193,
        52875,
        14588,
        28471,
        59817,
        9586,
        15720,
        158155,
        51307,
        109734,
        15196,
        11025,
        59331,
        3884,
        52626,
        102602,
        84797,
        25158,
        27314,
        4437,
        20488,
        76214,
        189248,
        35023,
        114952,
        157376,
        2827,
        62439,
        102878,
        129749,
        36405,
        10329,
        109339,
        108633,
        36662,
        1254,
        13267,
        5470,
        87105,
        58004,
        15397,
        10434,
        159667,
        21864,
        52022,
        179464,
        3013,
        32147,
        31496,
        116832,
        18494,
        105502,
        129227,
        107267,
        50033,
        13481,
        9954,
        24267,
        22141,
        16257,
        116154,
        36185,
        950,
        115685,
        11305,
        176708,
        2048,
        178671,
        112573,
        287867,
        162328,
        497663,
        95170,
        50979,
        193861,
        50987,
        30368,
        136257,
        31830,
        46549,
        15119,
        169876,
        23788,
        17462,
        249887,
        57377,
        1949,
        35448,
        14791,
        43769,
        210091,
        3783,
        34612,
        282103,
        88380,
        245190,
        5457,
        20491,
        98908,
        11402,
        86899,
        117916,
        16028,
        162584,
        60644,
        320177,
        156096,
        31065,
        55876,
        22e3,
        77655,
        9992,
        23397,
        13757,
        317623,
        63978,
        215255,
        2443,
        17648,
        93231,
        27388,
        104529,
        93807,
        55505,
        140477,
        12046,
        112040,
        70887,
        40152,
        94365,
        112353,
        25063,
        114679,
        266061,
        71248,
        119555,
        15589,
        2244,
        617,
        14129,
        211431,
        70110,
        100652,
        7777,
        4383,
        85911,
        89221,
        21010,
        120615,
        58357,
        86405,
        37554,
        41647,
        18,
        15143,
        69662,
        60491,
        14714,
        186134,
        148344,
        42347,
        5410,
        168175,
        44535,
        42449,
        343894,
        129417,
        99682,
        20659,
        27272,
        140483,
        63455,
        222159,
        17536,
        13722,
        42637,
        62324,
        11976,
        114691,
        148109,
        2283,
        32057,
        182393,
        4295,
        147364,
        33705,
        2075,
        44303,
        30274,
        28331,
        63740,
        69740,
        29148,
        10346,
        44862,
        33716,
        73937,
        153333,
        12930,
        38784,
        247159,
        2515,
        41053,
        20256,
        83368,
        256189,
        54639,
        115240,
        5096,
        24661,
        175419,
        153552,
        26516,
        141,
        138176,
        63885,
        34115,
        47222,
        55709,
        2765,
        28479,
        38875,
        236608,
        12229,
        22921,
        77291,
        54426,
        45388,
        2860,
        57787,
        114579,
        295139,
        105782,
        17826,
        71066,
        19119,
        54364,
        69385,
        16568,
        12323,
        28057,
        33346,
        34919,
        124763,
        155533,
        101386,
        31644,
        8627,
        49001,
        303600,
        29868,
        63213,
        9103,
        77280,
        71333,
        9696,
        138789,
        37059,
        24823,
        5057,
        21352,
        32368,
        114208,
        56803,
        19424,
        10445,
        58514,
        8661,
        209508,
        26187,
        171838,
        10460,
        63454,
        14016,
        122504,
        41328,
        21329,
        46618,
        32493,
        38225,
        7855,
        31763,
        7945,
        29876,
        8734,
        6438,
        24205,
        97490,
        139977,
        130740,
        47323,
        33195,
        85390,
        57194,
        13813,
        60600,
        21313,
        96251,
        7699,
        27584,
        170521,
        139271,
        1363,
        4402,
        336738,
        129223,
        84983,
        69150,
        13147,
        3590,
        163929,
        207225,
        155260,
        55916,
        20288,
        4503,
        8398,
        98490,
        11773,
        27512,
        37113,
        84976,
        86558,
        28365,
        11756,
        116005,
        182148,
        13733,
        115313,
        47644,
        67208,
        85069,
        9347,
        14995,
        226141,
        14704,
        101835,
        41159,
        35314,
        13113,
        63526,
        214039,
        29978,
        50446,
        83339,
        17440,
        129441,
        72522,
        118641,
        97816,
        24907,
        73844,
        15717,
        118884,
        167255,
        96509,
        162793,
        30847,
        36849,
        51297,
        78974,
        77793,
        10427,
        1873,
        2972,
        9999,
        35074,
        28190,
        64297,
        146836,
        46298,
        60038,
        163007,
        108919,
        61219,
        2403,
        75022,
        127339,
        4233,
        110389,
        69022,
        9833,
        128097,
        88016,
        79390,
        222936,
        22570,
        94657,
        28462,
        56956,
        38803,
        81536,
        30474,
        152794,
        19566,
        16481,
        147408,
        74574,
        81895,
        20731,
        1918,
        1366,
        76367,
        187321,
        54494,
        24366,
        21690,
        61696,
        33283,
        107477,
        77499,
        31112,
        414383,
        74362,
        18463,
        218441,
        120929,
        59848,
        258629,
        201924,
        69269,
        454,
        19989,
        13054,
        59894,
        3623,
        58908,
        20681,
        35723,
        78523,
        102680,
        38988,
        184112,
        108087,
        50944,
        132704,
        52966,
        21699,
        18860,
        96349,
        201411,
        82697,
        85395,
        95658,
        5093,
        6427,
        177894,
        44191,
        32755,
        26961,
        155739,
        6249,
        31310,
        81030,
        26574,
        84311,
        120155,
        86730,
        113535,
        7424,
        48888,
        13516,
        45747,
        98098,
        20077,
        183995,
        81945,
        43210,
        26704,
        40420,
        75831,
        45648,
        11180,
        6855,
        57927,
        65528,
        124096,
        34851,
        2598,
        156633,
        107572,
        127352,
        38169,
        123845,
        60142,
        62722,
        105584,
        232364,
        23211,
        68120,
        1601,
        22169,
        89299,
        747,
        258039,
        80572,
        7258,
        152249,
        11862,
        101204,
        8834,
        121434,
        33761,
        19175,
        133142,
        46343,
        40178,
        48723,
        3589,
        41977,
        30210,
        38868,
        62257,
        10087,
        82658,
        87827,
        90646,
        16415,
        47552,
        351723,
        28298,
        72225,
        91146,
        272760,
        1701,
        11295,
        1652,
        109651,
        300747,
        51863,
        198800,
        29446,
        11794,
        32345,
        37538,
        22356,
        33102,
        37590,
        113544,
        37970,
        11478,
        179743,
        25454,
        103417,
        59905,
        221970,
        105196,
        145604,
        7817,
        164809,
        102360,
        16974,
        75840,
        255333,
        56902,
        6659,
        1954,
        645,
        59400,
        67769,
        7689,
        18675,
        5215,
        13793,
        20536,
        27852,
        3387,
        29523,
        259718,
        16860,
        94625,
        43143,
        29245,
        15848,
        233581,
        22685,
        63631,
        78557,
        22836,
        133302,
        84513,
        1348,
        51826,
        47129,
        98836,
        58284,
        1830,
        1749,
        94642,
        10933,
        6145,
        12506,
        10975,
        13879,
        103781,
        144434,
        10268,
        28409,
        32346,
        52968,
        121567,
        107374,
        77268,
        23686,
        35097,
        10501,
        155275,
        15303,
        47136,
        21102,
        168741,
        55332,
        90385,
        15996,
        84817,
        681,
        137803,
        25054,
        142275,
        6163,
        38175,
        8056,
        124296,
        240642,
        65621,
        4934,
        178205,
        16101,
        62803,
        60964,
        18230,
        100622,
        76465,
        44689,
        14545,
        9543,
        47514,
        16852,
        93380,
        28048,
        12047,
        107106,
        37575,
        101485,
        77047,
        57326,
        34819,
        96137,
        76916,
        6469,
        46264,
        115983,
        75768,
        87668,
        69942,
        13027,
        165,
        8373,
        114231,
        26434,
        52844,
        42799,
        182044,
        23580,
        146254,
        38081,
        43236,
        33883,
        146220,
        382894,
        14606,
        46035,
        36481,
        166621,
        35417,
        95382,
        2957,
        59384,
        60428,
        36358,
        66343,
        75378,
        22267,
        22950,
        83528,
        17577,
        56474,
        25285,
        4619,
        179691,
        75355,
        95836,
        53295,
        34588,
        171410,
        4487,
        14679,
        84208,
        44015,
        18562,
        109133,
        54101,
        11531,
        86052,
        174479,
        303157,
        28095,
        9953,
        35642,
        14564,
        39802,
        16145,
        77606,
        117406,
        53038,
        121117,
        53624,
        22062,
        1212,
        7632,
        127157,
        237292,
        189087,
        10478,
        127345,
        102515,
        181997,
        86752,
        87623,
        10966,
        121602,
        68783,
        68681,
        83042,
        114380,
        138349,
        191305,
        67176,
        50085,
        39016,
        1427,
        42384,
        1412,
        67118,
        122616,
        72389,
        25260,
        2237,
        13576,
        137346,
        19938,
        20304,
        2191,
        68759,
        5373,
        61364,
        238507,
        75814,
        23931,
        69565,
        38993,
        131741,
        38364,
        12528,
        87762,
        5679,
        129853,
        5310,
        186831,
        32653,
        90338,
        260176,
        389531,
        108118,
        26843,
        43985,
        50175,
        30563,
        25106,
        56965,
        18130,
        140428,
        4542,
        165503,
        117991,
        24219,
        229605,
        1819,
        129663,
        1240,
        3797,
        76093,
        18398,
        71339,
        51919,
        93043,
        27175,
        47060,
        216257,
        6483,
        35051,
        1217,
        16512,
        80798,
        129064,
        13225,
        69339,
        8548,
        237079,
        72298,
        2575,
        34280,
        51379,
        117910,
        55671,
        53345,
        247552,
        29486,
        39328,
        140821,
        34681,
        57045,
        60177,
        5004,
        90269,
        78522,
        2479,
        322607,
        48474,
        61296,
        13057,
        31558,
        4678,
        59271,
        6699,
        27044,
        31988,
        35944,
        12503,
        83480,
        4389,
        136508,
        3781,
        114121,
        70279,
        4488,
        155829,
        42214,
        2898,
        68191,
        75695,
        305850,
        45041,
        74344,
        106509,
        30087,
        17429,
        93292,
        12477,
        290,
        23080,
        114802,
        35714,
        18751,
        26554,
        105424,
        17775,
        2144,
        2412,
        100610,
        65192,
        113975,
        52975,
        180272,
        135050,
        129815,
        76238,
        106483,
        21440,
        63186,
        4260,
        46189,
        9711,
        28249,
        4169,
        23429,
        23390,
        8324,
        141585,
        63809,
        67668,
        38457,
        38063,
        39226,
        59972,
        1189,
        203916,
        62368,
        14403,
        16949,
        61767,
        85801,
        1739,
        40147,
        35049,
        76757,
        33124,
        62102,
        15780,
        103593,
        103009,
        53484,
        22952,
        67973,
        114645,
        6566,
        5245,
        50462,
        7601,
        8288,
        3513,
        194571,
        80276,
        1908,
        54592,
        5124,
        58571,
        2513,
        6800,
        273997,
        193904,
        1119,
        17991,
        117245,
        2508,
        129156,
        82366,
        26278,
        71465,
        63341,
        56943,
        39662,
        106116,
        94966,
        156875,
        9736,
        2204,
        122308,
        94418,
        27134,
        1280,
        24539,
        49022,
        45314,
        3764,
        50904,
        46424,
        30699,
        28087,
        293839,
        9400,
        33646,
        40165,
        822,
        147499,
        50263,
        116179,
        29085,
        11863,
        31314,
        5578,
        17797,
        5104,
        12454,
        1604,
        15342,
        219206,
        10232,
        67800,
        94261,
        25872,
        13565,
        90339,
        78971,
        75377,
        26649,
        41184,
        47695,
        11514,
        35369,
        20767,
        14227,
        41953,
        309396,
        148270,
        147938,
        33074,
        14453,
        27499,
        109019,
        39018,
        25738,
        240196,
        158931,
        52820,
        8612,
        95853,
        21524,
        137010,
        84901,
        70869,
        70021,
        116794,
        48404,
        38771,
        6732,
        1070,
        70990,
        187297,
        49140,
        5238,
        576,
        3564,
        253975,
        16027,
        16483,
        2811,
        37775,
        19034,
        25259,
        4053,
        2e3,
        70083,
        95774,
        19713,
        33431,
        92703,
        91314,
        42381,
        288770,
        48194,
        95985,
        3991,
        77418,
        13406,
        241328,
        245086,
        56533,
        35275,
        62725,
        9246,
        51924,
        70181,
        95331,
        16163,
        31410,
        79016,
        39312,
        120878,
        119371,
        275987,
        80124,
        27712,
        9186,
        220,
        23598,
        146167,
        85209,
        68238,
        282190,
        57048,
        31273,
        30555,
        80913,
        17594,
        75779,
        59160,
        135002,
        101219,
        189377,
        29225,
        96735,
        60126,
        62522,
        104e3,
        27620,
        86814,
        17240,
        147533,
        11001,
        5425,
        43682,
        410,
        49460,
        87270,
        69480,
        46315,
        59448,
        1816,
        76201,
        9431,
        11788,
        87960,
        29063,
        65539,
        47347,
        11678,
        33846,
        7008,
        196704,
        9895,
        6753,
        8633,
        120892,
        59970,
        572824,
        115934,
        6646,
        202559,
        892,
        48351,
        37611,
        251282,
        57823,
        67263,
        57750,
        26527,
        34485,
        90747,
        7685,
        88370,
        6144,
        64182,
        1709,
        41969,
        21458,
        62327,
        181657,
        49247,
        225330,
        122600,
        114574,
        107124,
        85361,
        111833,
        63243,
        71420,
        15655,
        191178,
        72430,
        18063,
        51425,
        54002,
        12364,
        53225,
        86557,
        18193,
        97580,
        41232,
        138398,
        67821,
        128724,
        8944,
        233212,
        101353,
        52099,
        42127,
        14006,
        120107,
        32789,
        32132,
        3498,
        18123,
        33758,
        56058,
        5779,
        128760,
        59888,
        98869,
        18445,
        84702,
        51911,
        13234,
        218379,
        20093,
        39031,
        8074,
        70195,
        20708,
        23462,
        24355,
        131384,
        60189,
        26390,
        10403,
        41060,
        7140,
        10781,
        49410,
        42261,
        87202,
        82566,
        41663,
        43105,
        60276,
        2768,
        5733,
        74176,
        28329,
        2297,
        145430,
        131632,
        83615,
        122915,
        105441,
        655,
        224102,
        5284,
        136426,
        67763,
        16294,
        188511,
        32538,
        61049,
        27893,
        3394,
        13951,
        159099,
        28542,
        17930,
        145360,
        9492,
        190122,
        32285,
        78855,
        26440,
        13570,
        58648,
        73908,
        4239,
        124561,
        2444,
        74172,
        53131,
        11468,
        10794,
        73566,
        11623,
        35343,
        64710,
        30481,
        4163,
        10328,
        38309,
        29901,
        10538,
        154377,
        76132,
        92405,
        24839,
        11679,
        3465,
        13449,
        11637,
        7824,
        2337,
        57754,
        1260,
        14458,
        41118,
        19878,
        38661,
        13416,
        159180,
        37074,
        163164,
        54137,
        28627,
        52134,
        184900,
        8520,
        40385,
        29546,
        30502,
        22386,
        66527,
        107458,
        6850,
        24022,
        47983,
        30603,
        35083,
        8934,
        304066,
        39500,
        9,
        28261,
        33026,
        77251,
        9374,
        44833,
        116312,
        34990,
        29236,
        63563,
        125639,
        135405,
        165398,
        159055,
        55690,
        88141,
        69643,
        236964,
        31983,
        25572,
        20436,
        36746,
        60896,
        31850,
        16179,
        11828,
        5888,
        3043,
        66368,
        9750,
        31167,
        7915,
        53111,
        36430,
        1333,
        64344,
        93659,
        20061,
        60596,
        180191,
        51630,
        6792,
        30244,
        43509,
        101058,
        22409,
        420,
        44210,
        109783,
        43223,
        27030,
        72477,
        72831,
        32679,
        29235,
        7675,
        47556,
        12258,
        39907,
        149412,
        84926,
        118247,
        24692,
        71717,
        105038,
        86009,
        45941,
        41189,
        89453,
        29856,
        52543,
        30627,
        226798,
        67303,
        59230,
        67415,
        34408,
        1367,
        99685,
        16867,
        128419,
        52147,
        4111,
        125381,
        117881,
        16173,
        44093,
        102224,
        31575,
        23234,
        24870,
        83790,
        127407,
        239098,
        3200,
        994,
        1255,
        100903,
        242275,
        117266,
        55116,
        38205,
        16140,
        29662,
        11307,
        40414,
        208793,
        123355,
        56470,
        4862,
        75600,
        30119,
        58218,
        70828,
        24075,
        26974,
        7802,
        192353,
        4851,
        5475,
        78720,
        66596,
        3409,
        28573,
        64396,
        30381,
        30690,
        59859,
        88256,
        5406,
        99945,
        103064,
        34463,
        37727,
        24238,
        86643,
        60088,
        4057,
        23741,
        5967,
        162904,
        38240,
        28356,
        93858,
        25510,
        122879,
        6897,
        3278,
        7057,
        11971,
        4400,
        35461,
        211413,
        21395,
        59615,
        39471,
        87233,
        55795,
        128426,
        3051,
        22470,
        41950,
        14705,
        3974,
        180108,
        80476,
        78442,
        204996,
        91987,
        15634,
        67610,
        139015,
        142373,
        35611,
        51134,
        10387,
        4353,
        153456,
        57749,
        181039,
        14183,
        68447,
        151532,
        21107,
        36452,
        20551,
        3186,
        46247,
        46383,
        129666,
        88736,
        140662,
        146243,
        2066,
        8360,
        7978,
        64818,
        106963,
        17896,
        47801,
        10723,
        114821,
        223295,
        74192,
        3293,
        3393,
        16987,
        74064,
        11277,
        91622,
        4270,
        29828,
        27951,
        387869,
        103235,
        1374,
        61988,
        120083,
        477,
        145892,
        128378,
        11779,
        211263,
        61354,
        18221,
        17869,
        46530,
        83061,
        108538,
        157981,
        90608,
        67199,
        95080,
        49064,
        195814,
        12302,
        66307,
        10348,
        231346,
        160732,
        112859,
        63633,
        146558,
        21271,
        31037,
        198802,
        47622,
        12862,
        95710,
        3910,
        77850,
        73961,
        85585,
        34752,
        61e3,
        4082,
        24595,
        103679,
        71107,
        8208,
        79568,
        150019,
        16615,
        24961,
        139857,
        32664,
        197366,
        4559,
        54735,
        32696,
        4126,
        162019,
        75698,
        13916,
        70108,
        159638,
        19834,
        9349,
        24675,
        175560,
        49643,
        18206,
        52459,
        27992,
        10809,
        88865,
        401975,
        133172,
        29e3,
        34558,
        30915,
        3658,
        25834,
        42430,
        36562,
        125265,
        18182,
        10155,
        40149,
        97082,
        208980,
        19575,
        60853,
        90529,
        66545,
        9600,
        789,
        46420,
        2317,
        88593,
        55595,
        98980,
        115302,
        5742,
        169155,
        1073,
        177901,
        3472,
        11189,
        63711,
        78643,
        65472,
        50459,
        127979,
        93,
        42202,
        67053,
        21720,
        157650,
        11145,
        141378,
        42033,
        22824,
        85705,
        79114,
        35584,
        15974,
        1510,
        54172,
        28562,
        12451,
        104226,
        19190,
        97151,
        73024,
        20948,
        5151,
        81741,
        21499,
        29006,
        84183,
        198074,
        54003,
        45120,
        170125,
        26240,
        35177,
        28389,
        64863,
        79974,
        60778,
        176915,
        232183,
        45342,
        2038,
        80253,
        41564,
        40703,
        32689,
        5430,
        100689,
        5366,
        23007,
        134279,
        14266,
        26712,
        73993,
        24934,
        64242,
        52113,
        102887,
        61801,
        46415,
        201049,
        54251,
        62133,
        122757,
        164883,
        30815,
        139966,
        2319,
        30842,
        766,
        13362,
        10287,
        134518,
        86111,
        81665,
        82440,
        28333,
        43019,
        18963,
        8804,
        161944,
        23439,
        102144,
        101145,
        80029,
        39052,
        248708,
        30350,
        117340,
        11878,
        128467,
        974,
        138625,
        63961,
        5237,
        74778,
        61834,
        67040,
        43814,
        13690,
        65947,
        33809,
        232476,
        115258,
        181745,
        28824,
        94013,
        9510,
        10246,
        93722,
        81976,
        7217,
        114383,
        3493,
        16014,
        69045,
        72692,
        12145,
        80981,
        9507,
        6692,
        1620,
        60820,
        330444,
        35474,
        33962,
        4797,
        7053,
        295463,
        46445,
        27026,
        12491,
        77988,
        49524,
        35675,
        90947,
        29114,
        166705,
        101385,
        133782,
        32704,
        6186,
        84595,
        176031,
        185623,
        45966,
        151302,
        63069,
        1699,
        107491,
        947,
        15458,
        74452,
        196212,
        6046,
        10498,
        12163,
        10239,
        35191,
        243951,
        9277,
        9090,
        29539,
        54460,
        22820,
        26514,
        112549,
        60372,
        51753,
        48756,
        21812,
        70861,
        260326,
        41,
        44222,
        10441,
        16961,
        48148,
        138771,
        216194,
        5914,
        52153,
        53400,
        212036,
        56519,
        26245,
        10117,
        45888,
        15294,
        138019,
        90913,
        26368,
        43842,
        42111,
        23348,
        6082,
        194845,
        161089,
        156206,
        51546,
        11647,
        30759,
        302912,
        262094,
        8635,
        78876,
        26535,
        35283,
        54183,
        31183,
        85484,
        147873,
        12989,
        5197,
        6356,
        72894,
        65347,
        20150,
        27370,
        73787,
        1493,
        45918,
        12366,
        190217,
        20724,
        13858,
        10981,
        67449,
        81213,
        7553,
        14115,
        72242,
        271517,
        11842,
        48310,
        88743,
        143726,
        22177,
        3290,
        243231,
        58452,
        62937,
        12592,
        1654,
        40066,
        33477,
        13751,
        9921,
        128442,
        15868,
        7106,
        75236,
        83773,
        10775,
        36938,
        10482,
        170465,
        17368,
        17469,
        161508,
        32752,
        98340,
        800,
        19824,
        264456,
        3901,
        87319,
        2867,
        26782,
        9630,
        113102,
        185815,
        24197,
        44584,
        86366,
        40224,
        3636,
        140916,
        31731,
        267731,
        9567,
        53678,
        72984,
        29389,
        27963,
        17106,
        50282,
        284911,
        60170,
        8322,
        12608,
        23374,
        89652,
        5268,
        39044,
        229766,
        8869,
        151350,
        31436,
        177342,
        12269,
        183212,
        120418,
        116270,
        2843,
        78888,
        69192,
        7865,
        184099,
        1086,
        129897,
        18383,
        70508,
        20242,
        18508,
        229924,
        124569,
        35749,
        50589,
        55626,
        9884,
        83115,
        40971,
        30671,
        18135,
        14452,
        38861,
        17844,
        201826,
        5549,
        26413,
        17189,
        13561,
        38539,
        10679,
        143331,
        3314,
        36785,
        171194,
        49685,
        187713,
        67506,
        4618,
        104039,
        17060,
        195080,
        50648,
        33159,
        19238,
        67559,
        134840,
        28599,
        157523,
        17130,
        38064,
        117398,
        94355,
        31918,
        13575,
        34538,
        40326,
        13997,
        3494,
        348283,
        62481,
        26862,
        3603,
        104426,
        244363,
        153709,
        112487,
        304612,
        199674,
        41239,
        35545,
        54869,
        293005,
        28223,
        26277,
        26899,
        4533,
        18518,
        15492,
        38587,
        80488,
        70485,
        160395,
        263,
        60162,
        11382,
        222152,
        4696,
        250751,
        51921,
        182609,
        10707,
        48463,
        46243,
        1227,
        49111,
        111564,
        46502,
        33342,
        56846,
        68541,
        63559,
        858,
        139927,
        16654,
        229375,
        76759,
        26478,
        33205,
        95828,
        23399,
        92945,
        2637,
        35630,
        28470,
        143992,
        50214,
        14174,
        21456,
        166191,
        65665,
        1711,
        21594,
        78019,
        97599,
        111701,
        36,
        147151,
        110246,
        189022,
        43021,
        30397,
        40757,
        131935,
        42065,
        73335,
        48039,
        26596,
        28984,
        15102,
        2361,
        7421,
        202167,
        69744,
        43766,
        52826,
        3642,
        83304,
        33873,
        75140,
        63169,
        192389,
        36551,
        92748,
        13039,
        123959,
        233220,
        21738,
        84447,
        77230,
        20228,
        187852,
        19095,
        25799,
        92136,
        108774,
        29237,
        53947,
        2299,
        118106,
        2687,
        8830,
        42331,
        202924,
        33667,
        2023,
        73763,
        30704,
        19363,
        19779,
        16737,
        35629,
        48081,
        24068,
        101013,
        162338,
        291912,
        13749,
        24745,
        328289,
        167679,
        70086,
        48299,
        23306,
        16732,
        17801,
        43322,
        54589,
        3586,
        63653,
        43624,
        53474,
        925,
        109177,
        251316,
        43805,
        13082,
        19511,
        86565,
        142182,
        92461,
        17117,
        101033,
        103319,
        64589,
        4022,
        4351,
        235897,
        5352,
        82705,
        107142,
        46391,
        156084,
        5860,
        61365,
        10558,
        13045,
        7717,
        18357,
        33922,
        12590,
        33065,
        6928,
        46993,
        783,
        46937,
        67846,
        8952,
        26295,
        6107,
        119656,
        18799,
        17458,
        50747,
        4229,
        179559,
        112727,
        118080,
        20683,
        41464,
        125468,
        51560,
        49749,
        44231,
        7359,
        35339,
        62988,
        136487,
        67015,
        5208,
        29150,
        24956,
        105186,
        48858,
        6143,
        18097,
        6972,
        16404,
        73489,
        58742,
        97196,
        36357,
        164616,
        5834,
        32267,
        13746,
        147733,
        15113,
        132091,
        34127,
        106298,
        39729,
        106426,
        22294,
        9780,
        15602,
        36213,
        71502,
        42808,
        66802,
        599,
        60755,
        5851,
        39120,
        67363,
        108623,
        126368,
        72770,
        91263,
        32486,
        30596,
        151717,
        7951,
        52002,
        43103,
        11768,
        68942,
        40901,
        39344,
        24037,
        127500,
        116890,
        48403,
        16926,
        86750,
        17745,
        48648,
        159545,
        34460,
        58419,
        5634,
        114317,
        67865,
        31462,
        23352,
        24010,
        98185,
        125708,
        69686,
        68337,
        13610,
        26271,
        70691,
        2980,
        4768,
        27225,
        102402,
        75453,
        28106,
        8104,
        6931,
        1176,
        6274,
        6475,
        112635,
        22498,
        6176,
        238686,
        26832,
        28893,
        90319,
        14441,
        15682,
        15087,
        39517,
        45270,
        109134,
        104440,
        45965,
        47645,
        81772,
        7876,
        52683,
        87720,
        12898,
        4505,
        185665,
        2769,
        113401,
        15664,
        57592,
        105229,
        137381,
        97059,
        119268,
        6876,
        43309,
        33886,
        128363,
        35476,
        144249,
        67013,
        143587,
        83367,
        25703,
        91436,
        59347,
        53236,
        2289,
        16519,
        19844,
        46309,
        58558,
        99834,
        23313,
        218816,
        231303,
        36388,
        51333,
        183535,
        109792,
        139277,
        54306,
        90139,
        18235,
        8275,
        32710,
        37677,
        82464,
        86025,
        92204,
        88842,
        117723,
        37570,
        128723,
        234242,
        76350,
        73795,
        34896,
        148247,
        58424,
        11105,
        11744,
        45746,
        63372,
        17118,
        49772,
        199520,
        81902,
        38004,
        22911,
        33752,
        3125,
        1995,
        53792,
        4689,
        26909,
        108150,
        146062,
        69674,
        41811,
        161444,
        84855,
        8999,
        28561,
        16731,
        93937,
        3189,
        21967,
        24890,
        22943,
        1356,
        145300,
        51569,
        28802,
        517,
        118679,
        31703,
        40607,
        48098,
        108854,
        25003,
        10233,
        73969,
        177495,
        5248,
        24516,
        215347,
        146192,
        48712,
        60626,
        69188,
        40735,
        5866,
        586,
        101541,
        6509,
        47590,
        52129,
        5969,
        222045,
        110933,
        25733,
        24223,
        65339,
        62812,
        2414,
        155418,
        35819,
        16022,
        78423,
        43138,
        20995,
        128255,
        240673,
        46745,
        236093,
        72176,
        57085,
        97841,
        61248,
        107,
        36068,
        193177,
        105427,
        55726,
        215229,
        20446,
        47228,
        100420,
        87091,
        14429,
        121708,
        23605,
        21157,
        187721,
        21880,
        2997,
        203976,
        99166,
        95068,
        25877,
        7724,
        98925,
        83401,
        4829,
        13182,
        18229,
        13718,
        239662,
        38653,
        116505,
        153497,
        30589,
        89029,
        38962,
        181302,
        43853,
        78872,
        180301,
        4786,
        248240,
        7401,
        106136,
        112590,
        77745,
        19731,
        60880,
        77789,
        125748,
        135487,
        5975,
        48627,
        34084,
        12419,
        215770,
        47557,
        254582,
        10364,
        106495,
        21856,
        67539,
        88981,
        38805,
        21428,
        48732,
        42316,
        12149,
        16078,
        52808,
        25327,
        51322,
        33850,
        51147,
        12253,
        122354,
        46077,
        56483,
        254553,
        115417,
        81834,
        150991,
        94662,
        86668,
        7381,
        12841,
        100650,
        18218,
        15741,
        22372,
        68294,
        50705,
        15535,
        84660,
        61887,
        22553,
        72299,
        31361,
        24824,
        17743,
        46820,
        64288,
        31582,
        77006,
        111674,
        116384,
        30760,
        80920,
        86149,
        77192,
        51979,
        79691,
        60342,
        122805,
        103800,
        240873,
        160744,
        233114,
        78962,
        54920,
        8608,
        3484,
        316104,
        72548,
        24337,
        5088,
        230040,
        21926,
        10172,
        36838,
        26,
        86221,
        83458,
        102176,
        12062,
        17571,
        41929,
        41170,
        28428,
        68239,
        41750,
        103930,
        2634,
        18313,
        53019,
        34825,
        97837,
        63115,
        24606,
        73157,
        152474,
        14715,
        91439,
        37033,
        109806,
        140259,
        30668,
        174760,
        380,
        135597,
        95673,
        136073,
        65073,
        134249,
        13829,
        17279,
        122305,
        4420,
        46444,
        10237,
        64848,
        203623,
        70728,
        10349,
        182885,
        65075,
        24519,
        25783,
        40318,
        34139,
        22222,
        63394,
        55266,
        102764,
        41422,
        20126,
        65100,
        90408,
        53640,
        35128,
        48932,
        11192,
        38935,
        96839,
        34782,
        39492,
        19396,
        41332,
        6250,
        5511,
        19492,
        51304,
        25936,
        104466,
        54099,
        73771,
        86115,
        5080,
        7669,
        30891,
        111700,
        13931,
        25276,
        72289,
        135447,
        14820,
        258641,
        25265,
        31005,
        281179,
        75286,
        393,
        95359,
        14623,
        13584,
        6680,
        101227,
        80173,
        44933,
        76666,
        54542,
        13244,
        39348,
        458,
        25379,
        109451,
        134348,
        81143,
        6959,
        65554,
        12027,
        51311,
        8716,
        57589,
        140731,
        28467,
        23316,
        17272,
        30458,
        25980,
        55229,
        77197,
        83798,
        28302,
        114784,
        7428,
        34548,
        26241,
        14712,
        39336,
        103304,
        18928,
        54080,
        12870,
        334,
        87722,
        15208,
        16895,
        142098,
        114262,
        39820,
        83913,
        57817,
        28682,
        7721,
        14900,
        108672,
        11250,
        62246,
        42849,
        415188,
        1724,
        26555,
        24549,
        25505,
        26443,
        107450,
        145899,
        61035,
        43528,
        6901,
        60726,
        65906,
        267741,
        21338,
        147590,
        42079,
        18924,
        73017,
        135236,
        15393,
        5206,
        4026,
        84185,
        1531,
        5988,
        113890,
        82647,
        303391,
        7386,
        69844,
        71611,
        189865,
        76523,
        31877,
        13315,
        19314,
        198575,
        32821,
        1928,
        67641,
        25913,
        104475,
        103489,
        3297,
        70391,
        18406,
        15446,
        113347,
        19295,
        93790,
        27856,
        1792,
        167471,
        116449,
        8541,
        4408,
        41757,
        63233,
        25765,
        86680,
        64501,
        27034,
        24816,
        34975,
        6079,
        4486,
        49693,
        36229,
        16917,
        21581,
        62426,
        27862,
        11612,
        54284,
        35702,
        194034,
        355,
        24277,
        48262,
        87411,
        70504,
        310164,
        118018,
        12516,
        47559,
        43502,
        57433,
        107139,
        9290,
        66533,
        80863,
        14634,
        34312,
        91725,
        28606,
        21342,
        67241,
        72355,
        43244,
        375789,
        37402,
        174015,
        105070,
        8342,
        44167,
        67494,
        1890,
        16365,
        11723,
        271002,
        1865,
        47918,
        8350,
        45564,
        27742,
        25110,
        125803,
        8553,
        49504,
        81925,
        62211,
        4534,
        15491,
        19011,
        80373,
        206920,
        667,
        102405,
        128623,
        245524,
        5553,
        113309,
        192739,
        65766,
        19567,
        22832,
        261958,
        29679,
        21293,
        71134,
        20962,
        105123,
        24721,
        860,
        21752,
        33448,
        18372,
        157167,
        94822,
        35770,
        173224,
        232737,
        75729,
        28937,
        46828,
        28062,
        25453,
        5207,
        140366,
        36665,
        30652,
        6169,
        67920,
        150458,
        92040,
        23186,
        184604,
        92330,
        20891,
        176492,
        49427,
        27828,
        38305,
        42495,
        143982,
        49560,
        25503,
        90043,
        29747,
        65328,
        47830,
        12932,
        11068,
        77721,
        9003,
        25213,
        94205,
        140426,
        46090,
        89945,
        138173,
        192691,
        33329,
        112232,
        129905,
        35709,
        27514,
        1841,
        19957,
        31411,
        127476,
        53572,
        17497,
        173549,
        55063,
        175135,
        19841,
        69314,
        5192,
        237921,
        117660,
        150697,
        4060,
        273045,
        50414,
        98940,
        65348,
        153665,
        164423,
        58804,
        156695,
        48994,
        213928,
        86036,
        28608,
        8355,
        39574,
        34540,
        16927,
        135680,
        18374,
        151587,
        10830,
        53805,
        16878,
        16623,
        4282,
        48030,
        8537,
        14986,
        46102,
        13062,
        72897,
        72,
        33050,
        108227,
        39451,
        45935,
        651,
        113320,
        40535,
        95176,
        57450,
        48843,
        5003,
        19019,
        10407,
        211163,
        3848,
        1068,
        4988,
        32091,
        30095,
        41692,
        15099,
        43602,
        107434,
        50744,
        7627,
        171349,
        16313,
        150832,
        352665,
        207750,
        33937,
        38256,
        51091,
        156e3,
        87889,
        90663,
        84175,
        24908,
        114900,
        50365,
        31494,
        83829,
        5398,
        169342,
        47521,
        54818,
        18935,
        8356,
        43094,
        41212,
        174536,
        10082,
        92550,
        6678,
        60614,
        23355,
        69721,
        14796,
        34149,
        128830,
        58187,
        3179,
        208,
        40325,
        28399,
        225029,
        401412,
        51150,
        31580,
        207268,
        6657,
        10993,
        69818,
        64282,
        289845,
        23308,
        12961,
        38447,
        6681,
        52944,
        31855,
        2572,
        47646,
        120728,
        179148,
        37240,
        45196,
        218274,
        4816,
        3695,
        21961,
        50084,
        35209,
        18073,
        51452,
        27004,
        6100,
        33941,
        1377,
        84831,
        171214,
        85,
        141510,
        9078,
        99227,
        32610,
        6417,
        11718,
        49868,
        65579,
        87902,
        73018,
        49062,
        46280,
        61742,
        21512,
        40862,
        107733,
        15941,
        29168,
        157765,
        144919,
        14487,
        5767,
        158014,
        140070,
        7241,
        573,
        71584,
        16921,
        223566,
        40331,
        179473,
        35081,
        47926,
        140885,
        41508,
        52104,
        59180,
        42310,
        32811,
        29048,
        123517,
        102413,
        80208,
        10104,
        14746,
        12649,
        153641,
        126022,
        37965,
        113017,
        4171,
        83,
        142592,
        2809,
        6362,
        50416,
        71323,
        116894,
        260776,
        16204,
        1524,
        5760,
        30351,
        12658,
        20703,
        54403,
        36083,
        45408,
        74772,
        4946,
        14485,
        50759,
        111222,
        10890,
        2195,
        167147,
        92962,
        130534,
        16283,
        177256,
        35016,
        15472,
        210156,
        151187,
        73922,
        117691,
        43250,
        52051,
        37392,
        24811,
        24358,
        30830,
        5775,
        818,
        21969,
        1476,
        127322,
        151783,
        58392,
        31021,
        106913,
        65215,
        89407,
        90802,
        28531,
        11690,
        20234,
        95249,
        44602,
        37256,
        18707,
        11928,
        5161,
        4410,
        26571,
        51903,
        49768,
        22008,
        25252,
        65780,
        209499,
        68769,
        203726,
        13249,
        137363,
        48845,
        86823,
        6658,
        5674,
        31881,
        1083,
        1823,
        108676,
        34518,
        166752,
        13791,
        14287,
        91576,
        91429,
        8665,
        11529,
        26401,
        16191,
        91972,
        30964,
        5254,
        28486,
        54697,
        79613,
        66520,
        18447,
        22870,
        45203,
        194466,
        22822,
        51703,
        12278,
        76716,
        44595,
        73455,
        33546,
        12235,
        144843,
        36154,
        51247,
        11116,
        33040,
        3180,
        225753,
        60864,
        1972,
        28469,
        12891,
        28879,
        10338,
        144157,
        56294,
        353058,
        38302,
        41447,
        87532,
        110616,
        27065,
        168438,
        6557,
        1213,
        50804,
        144643,
        24817,
        2390,
        136531,
        38174,
        247513,
        16190,
        4059,
        122791,
        131994,
        137430,
        39506,
        57650,
        16305,
        5188,
        54309,
        106128,
        20628,
        88071,
        67394,
        395446,
        250285,
        66176,
        91254,
        1399,
        114196,
        43915,
        60230,
        44853,
        27206,
        106353,
        43013,
        18733,
        345105,
        226453,
        51202,
        16607,
        57106,
        117175,
        35492,
        10476,
        89598,
        127439,
        15187,
        39624,
        13688,
        61570,
        10615,
        31111,
        59370,
        6238,
        175252,
        32143,
        224492,
        41388,
        95408,
        34384,
        148238,
        78307,
        38959,
        9340,
        160091,
        61443,
        15737,
        11216,
        41244,
        170,
        38299,
        102443,
        113097,
        26382,
        14027,
        33707,
        3957,
        76300,
        66160,
        19431,
        18900,
        6952,
        1717,
        108656,
        82206,
        188021,
        257335,
        27295,
        43999,
        41210,
        31777,
        46956,
        57457,
        12657,
        11489,
        15697,
        48060,
        204748,
        53583,
        82422,
        284790,
        30503,
        137341,
        8120,
        19615,
        220311,
        15991,
        10217,
        63424,
        9808,
        67431,
        70976,
        98221,
        4491,
        15177,
        28535,
        144789,
        751,
        13230,
        2394,
        1504,
        33977,
        132104,
        30316,
        22230,
        931,
        97193,
        185240,
        24826,
        22687,
        174322,
        15307,
        22988,
        1390,
        188745,
        180325,
        29580,
        59068,
        74903,
        18994,
        29195,
        79,
        15436,
        7622,
        38462,
        11566,
        138710,
        44828,
        45774,
        37768,
        99236,
        68137,
        84083,
        19282,
        22698,
        17134,
        74807,
        126662,
        173497,
        46248,
        16938,
        119735,
        3212,
        28292,
        213652,
        49013,
        9975,
        32180,
        45660,
        86250,
        4801,
        68788,
        95490,
        77482,
        113751,
        11994,
        44624,
        94452,
        46839,
        128497,
        100316,
        5798,
        58588,
        73184,
        202987,
        65417,
        37790,
        88524,
        1606,
        43156,
        97964,
        105717,
        34947,
        11203,
        100060,
        37742,
        130074,
        93653,
        107799,
        94311,
        196106,
        41347,
        8035,
        10780,
        16390,
        27883,
        118236,
        167395,
        1979,
        25006,
        19375,
        31628,
        18916,
        144723,
        78502,
        114047,
        103107,
        86492,
        107686,
        5844,
        20934,
        206963,
        23556,
        22591,
        16562,
        146333,
        20167,
        10471,
        117434,
        33085,
        2863,
        9740,
        36669,
        41849,
        37271,
        22790,
        18209,
        28979,
        8231,
        12952,
        54408,
        21731,
        25130,
        45208,
        55748,
        138120,
        75826,
        414,
        29593,
        9925,
        292865,
        25999,
        683,
        123149,
        7036,
        92159,
        86055,
        61827,
        103680,
        23176,
        54918,
        58466,
        57578,
        13305,
        5709,
        86479,
        16697,
        31064,
        17660,
        200919,
        10770,
        49793,
        33423,
        32370,
        52047,
        16488,
        62555,
        6459,
        8426,
        83493,
        7763,
        59725,
        82812,
        18628,
        67760,
        79405,
        68557,
        9612,
        7673,
        28102,
        56517,
        69620,
        171797,
        32458,
        29541,
        15870,
        81109,
        32080,
        207644,
        71495,
        21202,
        11039,
        91036,
        61230,
        2810,
        130800,
        32260,
        4613,
        60590,
        37112,
        75214,
        33979,
        126402,
        155062,
        30642,
        63875,
        12810,
        194463,
        82799,
        47664,
        16725,
        36685,
        43367,
        61099,
        449,
        172150,
        102867,
        21691,
        301838,
        36745,
        7130,
        18671,
        57316,
        34852,
        38034,
        54182,
        35578,
        65900,
        99486,
        19771,
        3456,
        2658,
        16914,
        99866,
        28390,
        28109,
        8262,
        21147,
        34353,
        20006,
        4228,
        137085,
        1675,
        203023,
        283196,
        198286,
        214375,
        163329,
        290603,
        152574,
        40471,
        83506,
        30068,
        14730,
        23177,
        131539,
        34759,
        27668,
        32178,
        71896,
        104799,
        116305,
        85430,
        119262,
        42860,
        25160,
        8911,
        23428,
        49437,
        105322,
        6519,
        16203,
        6349,
        74711,
        1230,
        38045,
        8540,
        75165,
        44736,
        25909,
        51026,
        317034,
        4984,
        32281,
        91312,
        27060,
        44431,
        17817,
        45363,
        155937,
        239085,
        35697,
        59784,
        91993,
        29531,
        126740,
        213757,
        76560,
        167776,
        285273,
        24262,
        8237,
        65030,
        41160,
        74437,
        48804,
        118916,
        13159,
        37842,
        1031,
        75349,
        1478,
        11655,
        108777,
        23435,
        277425,
        101734,
        67469,
        70231,
        124711,
        43532,
        28514,
        65526,
        54956,
        1e3,
        21882,
        17728,
        25302,
        40952,
        52214,
        149632,
        1999,
        2111,
        3259,
        63362,
        89961,
        220561,
        39777,
        26335,
        9063,
        10572,
        12416,
        34551,
        34623,
        38604,
        24723,
        5947,
        15588,
        69927,
        66252,
        119177,
        69173,
        46629,
        28714,
        70715,
        212408,
        20521,
        406913,
        74380,
        11716,
        50659,
        50862,
        37009,
        88460,
        130101,
        7210,
        53853,
        538,
        65120,
        151950,
        55806,
        163748,
        52837,
        13153,
        21100,
        16674,
        64536,
        6091,
        138201,
        44837,
        58547,
        3723,
        163,
        2177,
        32288,
        85454,
        34033,
        8497,
        14282,
        25742,
        10535,
        10741,
        79559,
        117493,
        243787,
        49337,
        100718,
        79495,
        40139,
        42956,
        7551,
        55433,
        15421,
        31509,
        23034,
        45081,
        547,
        61176,
        53434,
        328001,
        8470,
        36263,
        30145,
        4519,
        74173,
        53935,
        11845,
        73774,
        60211,
        78025,
        3,
        4102,
        73782,
        109293,
        315332,
        48412,
        26683,
        13714,
        6865,
        20128,
        18490,
        104141,
        325,
        39470,
        171970,
        115860,
        15707,
        7268,
        73301,
        74336,
        31370,
        2368,
        111827,
        107757,
        136231,
        142844,
        97138,
        96638,
        84053,
        38691,
        23801,
        1588,
        10573,
        122098,
        77039,
        240,
        186135,
        146101,
        11996,
        18143,
        112963,
        46171,
        155836,
        348769,
        47795,
        121213,
        116266,
        132515,
        3344,
        144804,
        31286,
        99187,
        255838,
        129694,
        35894,
        48779,
        55235,
        148582,
        71967,
        65282,
        15174,
        13920,
        47080,
        6147,
        108242,
        157593,
        125025,
        7136,
        1286,
        28957,
        127956,
        28402,
        98813,
        20805,
        7532,
        109417,
        40610,
        5041,
        32958,
        15142,
        18408,
        108596,
        33543,
        50517,
        27748,
        80114,
        233434,
        91447,
        487,
        37094,
        100048,
        30541,
        43477,
        10639,
        89862,
        155868,
        37667,
        8726,
        60684,
        237903,
        73408,
        99589,
        12190,
        38739,
        97348,
        3914,
        13594,
        2680,
        149016,
        13907,
        30171,
        28343,
        23530,
        115225,
        61104,
        35821,
        147679,
        14337,
        4297,
        244282,
        24085,
        326976,
        56428,
        7851,
        21303,
        131620,
        71446,
        83253,
        68692,
        111870,
        5224,
        15813,
        38197,
        49026,
        45057,
        13660,
        3306,
        76345,
        40671,
        27905,
        91072,
        996,
        68527,
        62085,
        91351,
        122634,
        55109,
        168209,
        2024,
        27560,
        112707,
        17352,
        8306,
        167115,
        169921,
        166958,
        5031,
        46020,
        11844,
        67284,
        19130,
        76185,
        6920,
        32849,
        5450,
        14610,
        22451,
        21002,
        17392,
        31872,
        66682,
        84796,
        13709,
        40210,
        59898,
        12029,
        8719,
        53564,
        21462,
        91884,
        21647,
        88379,
        194428,
        12754,
        37797,
        132826,
        160016,
        22567,
        54383,
        53186,
        77611,
        31107,
        8339,
        4694,
        19185,
        90355,
        23597,
        17222,
        140675,
        28442,
        23668,
        55977,
        9128,
        61555,
        28774,
        155229,
        17658,
        9390,
        24379,
        69357,
        15752,
        127381,
        239631,
        62460,
        93181,
        55913,
        45133,
        140155,
        18676,
        25249,
        33164,
        29581,
        82837,
        67223,
        22362,
        29975,
        7317,
        52813,
        1943,
        29613,
        20012,
        207130,
        49617,
        49651,
        5636,
        15334,
        36313,
        29226,
        28084,
        95247,
        72072,
        19e3,
        224932,
        15811,
        114,
        32127,
        38097,
        37508,
        88507,
        37225,
        27359,
        91626,
        12193,
        69279,
        20608,
        11055,
        88156,
        92808,
        2152,
        57259,
        55275,
        72789,
        24475,
        104414,
        1708,
        9882,
        3818,
        48661,
        66897,
        1631,
        34806,
        227930,
        85815,
        87753,
        18321,
        250664,
        72733,
        25107,
        206797,
        50891,
        8082,
        196411,
        92596,
        96764,
        152823,
        65514,
        22819,
        387277,
        62176,
        51225,
        40329,
        15563,
        189,
        3659,
        73670,
        64357,
        51793,
        275136,
        33482,
        86653,
        74615,
        67058,
        11318,
        125720,
        15388,
        22388,
        8267,
        1730,
        102663,
        170910,
        40784,
        7144,
        85373,
        13040,
        7088,
        94309,
        583,
        44224,
        140424,
        77439,
        18496,
        164026,
        36578,
        4722,
        9151,
        5824,
        63365,
        26510,
        35199,
        40500,
        79277,
        32495,
        44614,
        35233,
        9566,
        203293,
        152144,
        7097,
        2330,
        183480,
        98629,
        13423,
        330887,
        44130,
        68600,
        30939,
        97829,
        31012,
        345465,
        56747,
        94879,
        4939,
        160027,
        149761,
        99423,
        46099,
        32251,
        15332,
        8761,
        96094,
        128555,
        5763,
        235318,
        222223,
        55729,
        30241,
        55420,
        201746,
        3987,
        81382,
        8259,
        49325,
        23287,
        7719,
        24633,
        251100,
        92311,
        18591,
        110533,
        64759,
        170260,
        393860,
        7175,
        21144,
        132887,
        3593,
        75346,
        101277,
        91109,
        16387,
        259187,
        11627,
        57459,
        173829,
        44694,
        55780,
        49797,
        89192,
        120443,
        62622,
        3904,
        14814,
        23887,
        1027,
        112258,
        64955,
        99800,
        11132,
        66353,
        36202,
        48624,
        18158,
        88481,
        96882,
        43059,
        11040,
        2455,
        7077,
        21651,
        181159,
        99126,
        100434,
        61388,
        68186,
        19161,
        110468,
        120052,
        8819,
        55324,
        41494,
        7014,
        37689,
        3618,
        87729,
        92615,
        207943,
        9823,
        128657,
        12587,
        15857,
        6379,
        67628,
        51216,
        71775,
        157617,
        63244,
        1503,
        3864,
        218754,
        110864,
        5769,
        21492,
        7243,
        1192,
        87921,
        85529,
        31512,
        18537,
        42698,
        35350,
        73510,
        84474,
        34301,
        8991,
        21013,
        35034,
        566,
        38832,
        19838,
        35586,
        37216,
        39413,
        55006,
        12178,
        59742,
        856,
        84563,
        6900,
        25632,
        17437,
        49786,
        30723,
        13847,
        70845,
        4044,
        7843,
        23944,
        235976,
        55530,
        48942,
        6518,
        20939,
        73769,
        192653,
        52936,
        95207,
        23895,
        132542,
        142982,
        22632,
        87452,
        48042,
        54018,
        178468,
        10728,
        26230,
        23559,
        363,
        81269,
        142012,
        5718,
        346258,
        31456,
        84333,
        246476,
        51018,
        66692,
        101804,
        120570,
        39962,
        30373,
        70593,
        2864,
        60541,
        19425,
        54209,
        104092,
        7201,
        31545,
        48018,
        25865,
        15442,
        46257,
        40443,
        8328,
        6451,
        111782,
        47527,
        97754,
        33046,
        470,
        245116,
        31095,
        39,
        91934,
        87208,
        73470,
        36708,
        36521,
        12801,
        70624,
        36272,
        8892,
        79768,
        12427,
        55454,
        103756,
        5908,
        52390,
        62962,
        22720,
        141138,
        94634,
        41689,
        128402,
        126390,
        6628,
        106394,
        35527,
        134394,
        82727,
        254651,
        194502,
        148064,
        89549,
        3202,
        28359,
        957,
        21954,
        27906,
        49840,
        142747,
        8307,
        24206,
        48978,
        1186,
        71728,
        133038,
        71474,
        91306,
        6333,
        110959,
        74600,
        70387,
        18983,
        62609,
        56057,
        22970,
        1147,
        135850,
        1321,
        28834,
        3578,
        59715,
        102227,
        32827,
        81415,
        99952,
        55636,
        257598,
        390,
        22702,
        35701,
        85872,
        402916,
        39216,
        189795,
        14929,
        19467,
        10112,
        144422,
        61514,
        5279,
        63421,
        134686,
        41436,
        8424,
        51925,
        10598,
        132295,
        124416,
        4604,
        194739,
        210929,
        57866,
        31829,
        51626,
        50007,
        9976,
        91878,
        61906,
        56168,
        81906,
        60918,
        61859,
        40017,
        23059,
        16887,
        40927,
        62064,
        12785,
        32893,
        32913,
        21782,
        93965,
        20169,
        44387,
        79084,
        38463,
        11457,
        93950,
        27127,
        157050,
        2697,
        337088,
        5116,
        54128,
        48255,
        33279,
        8821,
        27352,
        25515,
        124022,
        65710,
        28906,
        38557,
        33390,
        1722,
        104435,
        72215,
        38551,
        12094,
        30978,
        25113,
        6671,
        37355,
        175109,
        42862,
        98024,
        65406,
        221276,
        59624,
        118012,
        64637,
        78760,
        86697,
        21426,
        1639,
        40350,
        12584,
        67193,
        84144,
        31396,
        7863,
        143011,
        69629,
        63112,
        9454,
        28666,
        65798,
        46372,
        134721,
        6314,
        51402,
        30837,
        151922,
        2847,
        38676,
        38008,
        92823,
        136245,
        17540,
        5504,
        109295,
        205242,
        37606,
        5211,
        214892,
        1586,
        20670,
        208711,
        137743,
        19328,
        40652,
        16995,
        20023,
        14657,
        154919,
        34422,
        12996,
        13918,
        38221,
        47690,
        16398,
        2959,
        37680,
        89122,
        6721,
        198469,
        91876,
        172043,
        83898,
        101992,
        26084,
        94570,
        3635,
        76958,
        22853,
        76497,
        38266,
        176590,
        168403,
        44464,
        142840,
        79180,
        184594,
        1984,
        41806,
        83147,
        11985,
        6546,
        366068,
        59732,
        24533,
        271505,
        8736,
        39084,
        222992,
        93429,
        28962,
        58985,
        86665,
        8432,
        30028,
        14548,
        32439,
        54424,
        165029,
        55175,
        27458,
        69046,
        121277,
        46168,
        33732,
        20661,
        24581,
        135574,
        123110,
        37556,
        79260,
        72611,
        16957,
        12939,
        46162,
        58238,
        44907,
        72936,
        253758,
        41324,
        32518,
        96480,
        11949,
        124438,
        65280,
        43256,
        34107,
        53533,
        43531,
        37037,
        28366,
        45970,
        32741,
        173438,
        6121,
        194202,
        62969,
        26355,
        30314,
        58370,
        28455,
        1848,
        50519,
        82830,
        90393,
        21761,
        295490,
        10936,
        256940,
        133568,
        44050,
        20269,
        4089,
        27457,
        21610,
        219460,
        36743,
        14821,
        101388,
        52005,
        13124,
        30979,
        140816,
        167362,
        26054,
        18458,
        60789,
        34917,
        40447,
        26606,
        33422,
        9066,
        3452,
        83614,
        5761,
        20263,
        137238,
        25038,
        91310,
        101,
        52322,
        74548,
        42572,
        38084,
        214054,
        186568,
        31802,
        17665,
        30620,
        141936,
        37730,
        14420,
        4265,
        187218,
        49640,
        188208,
        51441,
        55388,
        96452,
        66659,
        40869,
        42039,
        60967,
        221027,
        19234,
        178581,
        29105,
        96050,
        9165,
        196118,
        157335,
        3738,
        40354,
        117436,
        2965,
        34136,
        59659,
        15570,
        50843,
        230035,
        31444,
        71260,
        43886,
        18316,
        5387,
        38500,
        168508,
        17406,
        32174,
        8828,
        103373,
        143806,
        90367,
        3560,
        18719,
        122310,
        16508,
        26719,
        2541,
        105429,
        6645,
        37998,
        73190,
        10591,
        235916,
        49737,
        87112,
        233941,
        53188,
        32193,
        79154,
        4544,
        52905,
        126477,
        7580,
        63501,
        57314,
        3216,
        31337,
        6541,
        103083,
        60846,
        49,
        9756,
        15481,
        1355,
        43840,
        14319,
        13743,
        27486,
        10222,
        73114,
        230718,
        418644,
        16706,
        6674,
        279748,
        23058,
        45273,
        295831,
        86306,
        2743,
        5535,
        88773,
        21829,
        35253,
        120938,
        31153,
        3169,
        16839,
        42847,
        8751,
        80974,
        33942,
        36867,
        35514,
        16485,
        26474,
        77775,
        56877,
        5391,
        48346,
        3882,
        108713,
        31403,
        27804,
        55248,
        26235,
        43821,
        136104,
        40118,
        175507,
        28034,
        203908,
        18732,
        1788,
        34030,
        106427,
        36958,
        54359,
        7251,
        44936,
        15356,
        69139,
        455,
        157915,
        22173,
        140291,
        50348,
        43275,
        82066,
        49621,
        54952,
        15216,
        36226,
        96695,
        66855,
        6936,
        1987,
        8227,
        196087,
        4631,
        68827,
        99004,
        47541,
        110265,
        17953,
        147605,
        110242,
        58520,
        31312,
        38724,
        329975,
        642,
        3155,
        34497,
        75937,
        6207,
        73843,
        6120,
        17249,
        51429,
        117746,
        3218,
        910,
        68961,
        319671,
        14938,
        29555,
        34700,
        1649,
        66673,
        72268,
        9655,
        76800,
        153087,
        6941,
        210168,
        27130,
        35398,
        1780,
        73242,
        3135,
        56689,
        19556,
        165307,
        8765,
        35967,
        121458,
        13333,
        70453,
        17350,
        117253,
        22265,
        13340,
        44265,
        39869,
        441,
        3742,
        135025,
        23581,
        33309,
        16543,
        17731,
        13291,
        157637,
        283005,
        21408,
        101360,
        63887,
        52312,
        83873,
        5338,
        233779,
        23759,
        186949,
        34531,
        177320,
        38069,
        156465,
        91004,
        19353,
        59852,
        68160,
        14891,
        1338,
        1072,
        29823,
        1950,
        28901,
        81407,
        313445,
        73038,
        84807,
        162348,
        240257,
        37162,
        138934,
        16111,
        58013,
        41253,
        102951,
        16457,
        96056,
        19541,
        56402,
        67217,
        41638,
        94381,
        89674,
        29481,
        37456,
        80815,
        151579,
        13937,
        13683,
        132537,
        19699,
        134545,
        67020,
        29816,
        222341,
        141235,
        427578,
        48868,
        129557,
        233342,
        23077,
        87871,
        16213,
        18728,
        16184,
        9469,
        37913,
        19680,
        2798,
        171356,
        178328,
        13216,
        50049,
        72690,
        71904,
        124644,
        55455,
        7504,
        29052,
        41036,
        266546,
        19899,
        30391,
        188755,
        8659,
        59469,
        16,
        104298,
        112943,
        53865,
        76203,
        138226,
        68857,
        139953,
        14125,
        107625,
        119795,
        173133,
        4398,
        50273,
        48808,
        54390,
        16466,
        122086,
        31835,
        67035,
        50971,
        48859,
        7508,
        46427,
        66477,
        73021,
        84615,
        39985,
        83076,
        46779,
        201569,
        53336,
        36443,
        60865,
        168164,
        143810,
        51393,
        25548,
        169307,
        32896,
        24485,
        38424,
        21837,
        29087,
        275813,
        51674,
        6714,
        64883,
        46169,
        187369,
        55186,
        76192,
        12852,
        12018,
        62134,
        31067,
        118303,
        16542,
        12125,
        10579,
        4928,
        26291,
        43854,
        7091,
        10946,
        253716,
        109062,
        39283,
        17261,
        113012,
        258512,
        47764,
        125126,
        32646,
        55892,
        80279,
        201623,
        149872,
        3192,
        385,
        1208,
        48750,
        5376,
        58738,
        22335,
        5427,
        82416,
        47811,
        32435,
        143086,
        38930,
        94128,
        59975,
        156037,
        37977,
        38224,
        62485,
        7698,
        50405,
        71027,
        16462,
        21559,
        136153,
        34131,
        107506,
        162069,
        63703,
        3101,
        215029,
        40407,
        4178,
        3774,
        9187,
        80019,
        17880,
        97926,
        67579,
        2600,
        18405,
        8351,
        47924,
        86638,
        70820,
        92206,
        86453,
        29610,
        42241,
        119200,
        3198,
        15466,
        67813,
        57863,
        35454,
        4779,
        99518,
        4649,
        104641,
        144269,
        33730,
        38073,
        65864,
        6838,
        109456,
        193298,
        154007,
        5623,
        45741,
        30846,
        182578,
        25573,
        157224,
        1543,
        58575,
        138703,
        146140,
        44971,
        49356,
        18275,
        59064,
        20300,
        13122,
        11848,
        24453,
        11973,
        9797,
        86843,
        2919,
        25530,
        49210,
        1130,
        161220,
        76788,
        75373,
        85604,
        34926,
        36014,
        17777,
        17255,
        51533,
        11676,
        92226,
        51845,
        119859,
        21525,
        5936,
        18507,
        28050,
        1140,
        31418,
        14857,
        34207,
        47859,
        10750,
        36382,
        32079,
        106909,
        59426,
        87757,
        38393,
        110042,
        15965,
        97104,
        33757,
        35344,
        97993,
        53979,
        33651,
        45407,
        41884,
        82515,
        173089,
        7177,
        58371,
        35365,
        47543,
        51927,
        35587,
        10670,
        23544,
        29306,
        84233,
        39976,
        76076,
        62097,
        9007,
        8668,
        28119,
        78281,
        120790,
        19835,
        143020,
        54968,
        18670,
        64959,
        20649,
        34469,
        42570,
        33001,
        136570,
        87796,
        120044,
        1106,
        58700,
        63951,
        127623,
        12805,
        83057,
        40212,
        31773,
        49850,
        7361,
        54336,
        347524,
        101314,
        23751,
        19569,
        48791,
        29174,
        49369,
        20467,
        7465,
        75842,
        38281,
        623,
        112457,
        60210,
        28849,
        51003,
        94720,
        6426,
        90047,
        85560,
        43761,
        3579,
        85105,
        34607,
        90410,
        118528,
        7224,
        42907,
        111163,
        18168,
        6960,
        161135,
        191298,
        5247,
        100584,
        127552,
        171568,
        20121,
        91173,
        12636,
        54615,
        20199,
        63730,
        98105,
        2396,
        40387,
        14438,
        125012,
        4765,
        33235,
        12865,
        45299,
        37728,
        82098,
        77872,
        114037,
        59253,
        19675,
        24838,
        398016,
        102561,
        11446,
        17069,
        57508,
        178277,
        65836,
        99941,
        26114,
        2585,
        271882,
        136866,
        50126,
        11027,
        155648,
        118367,
        14585,
        8910,
        123015,
        335383,
        40434,
        41016,
        53021,
        14439,
        87098,
        176860,
        201543,
        121888,
        2358,
        9286,
        5739,
        22666,
        54270,
        37884,
        169381,
        33984,
        93859,
        16124,
        89364,
        72207,
        51639,
        76366,
        99029,
        65812,
        2198,
        12147,
        174891,
        194289,
        6986,
        30252,
        88822,
        21284,
        11445,
        288337,
        160821,
        33034,
        100869,
        43852,
        25761,
        52882,
        1144,
        103809,
        1924,
        84458,
        86079,
        43411,
        13542,
        139276,
        18141,
        34978,
        41298,
        7276,
        26481,
        173800,
        33210,
        17951,
        142652,
        33616,
        33677,
        2210,
        19941,
        98568,
        2486,
        192414,
        80136,
        12058,
        235883,
        50963,
        249638,
        29572,
        27221,
        47034,
        6124,
        72107,
        63346,
        97620,
        158513,
        299699,
        40388,
        23235,
        37176,
        224244,
        198386,
        121323,
        67992,
        23827,
        63170,
        17838,
        106622,
        158590,
        26807,
        5345,
        23489,
        91891,
        55474,
        74834,
        37981,
        13058,
        5977,
        72552,
        34706,
        26828,
        145172,
        19904,
        21367,
        34043,
        960,
        77092,
        91381,
        4733,
        47446,
        7680,
        41697,
        5170,
        16960,
        14741,
        46101,
        13656,
        473,
        51842,
        37433,
        11103,
        11551,
        121951,
        13191,
        97536,
        165932,
        50397,
        51628,
        129028,
        9069,
        44885,
        6590,
        59195,
        47045,
        32940,
        225472,
        90345,
        21833,
        13303,
        29407,
        96615,
        141951,
        5198,
        6028,
        18395,
        7181,
        3861,
        14966,
        156358,
        167182,
        36529,
        55253,
        25942,
        173153,
        30959,
        27261,
        50691,
        150176,
        162201,
        38467,
        48462,
        80602,
        42163,
        118482,
        168,
        108756,
        26011,
        17166,
        54149,
        456538,
        22512,
        91374,
        13816,
        90358,
        131615,
        18132,
        226707,
        1824,
        28139,
        26860,
        42253,
        93877,
        77351,
        65575,
        8980,
        80574,
        22020,
        27948,
        40422,
        91324,
        76376,
        13528,
        39281,
        91685,
        82215,
        122541,
        144066,
        1983,
        193851,
        17283,
        26320,
        2739,
        194978,
        4790,
        26845,
        42627,
        61300,
        65815,
        174612,
        55133,
        4200,
        191130,
        79771,
        158321,
        52280,
        166796,
        221620,
        62461,
        11278,
        4067,
        88152,
        83409,
        31717,
        121367,
        13522,
        47325,
        37945,
        10406,
        174348,
        249321,
        154101,
        64912,
        29938,
        51775,
        17220,
        15776,
        166138,
        78890,
        84425,
        54121,
        42861,
        16368,
        24572,
        291647,
        10197,
        32073,
        22651,
        11677,
        97509,
        26952,
        35787,
        18424,
        41910,
        71614,
        94977,
        72318,
        41594,
        70024,
        275419,
        37702,
        60199,
        7335,
        39107,
        61315,
        18271,
        18394,
        33768,
        87884,
        104277,
        123724,
        7277,
        56288,
        71981,
        189803,
        49320,
        3352,
        6798,
        14240,
        8954,
        69220,
        94433,
        57372,
        28620,
        68863,
        193727,
        85575,
        42309,
        41667,
        67689,
        42081,
        22543,
        44824,
        12719,
        28540,
        114236,
        101553,
        27638,
        27296,
        4300,
        5353,
        4663,
        19379,
        94098,
        3758,
        95888,
        95144,
        80344,
        87320,
        28447,
        259518,
        12718,
        71391,
        152731,
        37063,
        24132,
        31911,
        104896,
        15672,
        103782,
        1521,
        4945,
        72541,
        23717,
        122632,
        15619,
        87175,
        206120,
        29428,
        189780,
        61416,
        28350,
        44457,
        972,
        1175,
        47233,
        198738,
        95789,
        41907,
        21953,
        97034,
        59341,
        22864,
        53713,
        16873,
        32971,
        20693,
        20954,
        31336,
        21477,
        16169,
        38370,
        16412,
        9019,
        3841,
        24599,
        21938,
        17085,
        6484,
        81198,
        76413,
        5849,
        72514,
        12320,
        65247,
        276175,
        37234,
        59796,
        52642,
        16312,
        57349,
        198507,
        94148,
        46134,
        18958,
        125552,
        1747,
        18725,
        151873,
        14901,
        5490,
        68287,
        29470,
        3689,
        64794,
        40814,
        26018,
        25692,
        54450,
        2703,
        88278,
        124886,
        173087,
        174e3,
        24159,
        179477,
        24276,
        46004,
        201876,
        209202,
        445,
        52876,
        31948,
        30206,
        157610,
        39180,
        18439,
        44124,
        50469,
        5774,
        96278,
        222758,
        200216,
        50290,
        45486,
        20435,
        46986,
        46276,
        140133,
        142326,
        15569,
        13363,
        47522,
        92583,
        2182,
        7135,
        16853,
        22998,
        30272,
        4952,
        63263,
        35623,
        39096,
        53789,
        44864,
        20053,
        110392,
        124213,
        4630,
        16087,
        28221,
        127787,
        25839,
        77481,
        44693,
        13464,
        113146,
        6983,
        27069,
        55717,
        50102,
        4760,
        7107,
        26186,
        66507,
        59145,
        36032,
        104182,
        71328,
        29425,
        64317,
        50781,
        47465,
        94298,
        69706,
        74899,
        22754,
        120756,
        25108,
        93077,
        56834,
        73286,
        39928,
        16218,
        41699,
        176763,
        7555,
        70819,
        50083,
        26895,
        23315,
        26014,
        16773,
        123079,
        41712,
        5719,
        31516,
        90427,
        158540,
        85051,
        183128,
        40864,
        27505,
        55392,
        9058,
        45224,
        96857,
        30901,
        136622,
        96557,
        56304,
        120061,
        11501,
        151448,
        5773,
        89743,
        7769,
        86069,
        2935,
        18471,
        41628,
        10114,
        33660,
        110170,
        49479,
        26745,
        92846,
        33221,
        26731,
        18795,
        87076,
        8550,
        2100,
        29972,
        120289,
        3077,
        72490,
        33784,
        2630,
        208722,
        50861,
        63483,
        79029,
        6419,
        39467,
        14302,
        45286,
        64207,
        9686,
        67513,
        44170,
        1050,
        77246,
        59266,
        17055,
        53801,
        7150,
        11111,
        42432,
        4278,
        94579,
        362117,
        36175,
        42902,
        41933,
        39002,
        98489,
        22913,
        74161,
        84773,
        57036,
        17556,
        162288,
        74485,
        178760,
        93867,
        73635,
        128860,
        50362,
        261,
        67455,
        80001,
        46080,
        35662,
        4368,
        25247,
        19230,
        74393,
        22588,
        1822,
        27682,
        235324,
        13798,
        85998,
        13194,
        235067,
        23514,
        71669,
        147632,
        23191,
        134748,
        214683,
        105101,
        1518,
        25489,
        247114,
        7380,
        54842,
        26922,
        3971,
        26361,
        20844,
        68642,
        170517,
        77339,
        123255,
        8963,
        77818,
        150998,
        48466,
        36806,
        2732,
        23261,
        11741,
        236162,
        18243,
        126216,
        28690,
        50546,
        16385,
        92760,
        197383,
        246558,
        201295,
        88255,
        67588,
        71687,
        176076,
        172653,
        169058,
        33906,
        63747,
        24835,
        157621,
        43338,
        30050,
        46152,
        132741,
        2770,
        51371,
        94835,
        6614,
        15112,
        11749,
        56936,
        1250,
        19027,
        399017,
        58036,
        100215,
        23388,
        55815,
        308768,
        124152,
        94803,
        9521,
        64186,
        8971,
        28,
        30427,
        62163,
        7616,
        103838,
        35079,
        29203,
        131235,
        7743,
        17389,
        10882,
        37420,
        61460,
        228512,
        85363,
        41581,
        131077,
        62822,
        119647,
        10130,
        54445,
        26925,
        19968,
        29016,
        24446,
        74028,
        24176,
        61448,
        67185,
        9254,
        8563,
        119129,
        9771,
        99184,
        37716,
        39514,
        10532,
        221512,
        258753,
        218630,
        55980,
        23394,
        32141,
        61924,
        66749,
        32411,
        3741,
        36475,
        26678,
        77010,
        44946,
        91203,
        128749,
        116953,
        20476,
        49625,
        53116,
        13735,
        102335,
        29376,
        51946,
        83407,
        67892,
        59212,
        34685,
        21083,
        1546,
        112982,
        32972,
        74397,
        1078,
        190545,
        16082,
        86140,
        58591,
        89611,
        101531,
        10061,
        105104,
        76319,
        20035,
        17551,
        52611,
        169061,
        190842,
        100780,
        23907,
        90413,
        115619,
        9675,
        34710,
        193435,
        49443,
        129734,
        11183,
        258877,
        16318,
        136182,
        126808,
        44635,
        27304,
        192375,
        2599,
        125648,
        47051,
        12091,
        23814,
        721,
        58800,
        40137,
        66726,
        97930,
        60877,
        74487,
        7942,
        54326,
        9841,
        41428,
        13762,
        8211,
        85383,
        6950,
        99177,
        79806,
        201786,
        296464,
        124087,
        13144,
        29741,
        41721,
        47634,
        55088,
        254286,
        106408,
        17041,
        99064,
        12942,
        64086,
        45233,
        14005,
        2612,
        55827,
        255,
        7984,
        13980,
        38574,
        12776,
        46654,
        73499,
        249951,
        2101,
        26676,
        25996,
        132326,
        116415,
        119062,
        50449,
        31033,
        23038,
        11589,
        179252,
        20007,
        14860,
        129270,
        21143,
        17796,
        144715,
        60106,
        70758,
        69842,
        34674,
        282133,
        44014,
        16774,
        57268,
        38528,
        24053,
        46373,
        201667,
        28327,
        471023,
        51889,
        102667,
        21193,
        114909,
        84132,
        69317,
        96723,
        67969,
        16134,
        68145,
        15058,
        28765,
        32035,
        2524,
        101089,
        98664,
        25045,
        76571,
        14957,
        86040,
        118506,
        262428,
        154764,
        81573,
        39681,
        283900,
        73287,
        127825,
        544,
        80448,
        52347,
        38512,
        175971,
        15180,
        45467,
        33086,
        46552,
        48894,
        81107,
        43213,
        36672,
        54025,
        76703,
        8053,
        7608,
        13299,
        56619,
        20752,
        238099,
        54164,
        105133,
        1444,
        32942,
        953,
        37564,
        8e3,
        66316,
        119463,
        106817,
        404,
        13667,
        149108,
        128597,
        31267,
        10269,
        49836,
        106150,
        1484,
        52330,
        76965,
        160486,
        171648,
        38456,
        31263,
        22424,
        37738,
        66245,
        67467,
        143369,
        60471,
        75610,
        20895,
        115528,
        86070,
        60854,
        40796,
        49347,
        18989,
        15030,
        11371,
        37578,
        15779,
        79867,
        10187,
        86462,
        46402,
        155626,
        93200,
        40229,
        7090,
        57547,
        108053,
        99598,
        11088,
        47505,
        41218,
        206017,
        2173,
        20988,
        30219,
        22919,
        80563,
        57566,
        42369,
        93141,
        41675,
        2407,
        182519,
        120495,
        27154,
        16702,
        29456,
        14349,
        7958,
        16688,
        117177,
        140375,
        42467,
        261919,
        74916,
        153569,
        10836,
        34742,
        49526,
        7621,
        105997,
        12212,
        2270,
        392377,
        7755,
        17959,
        25086,
        232152,
        138791,
        33847,
        13860,
        35316,
        5811,
        1344,
        71259,
        50452,
        207539,
        92635,
        50359,
        5821,
        33674,
        30255,
        2086,
        2587,
        96264,
        17543,
        42,
        6029,
        9580,
        43007,
        139248,
        82831,
        12917,
        29607,
        25786,
        51467,
        42137,
        85161,
        100698,
        31561,
        88989,
        121990,
        278500,
        3602,
        109344,
        37982,
        15279,
        116442,
        28936,
        30880,
        87894,
        58079,
        128661,
        126731,
        67392,
        28051,
        146885,
        4861,
        16216,
        97344,
        42827,
        147561,
        153948,
        22684,
        21335,
        47685,
        1853,
        43349,
        15185,
        59642,
        10229,
        25520,
        187921,
        108972,
        5579,
        98037,
        24945,
        6697,
        19193,
        63734,
        137934,
        75056,
        89740,
        19767,
        224268,
        56138,
        63643,
        151661,
        39313,
        70618,
        84031,
        89723,
        84074,
        13703,
        85626,
        35460,
        8867,
        64845,
        3439,
        57906,
        99776,
        63968,
        49270,
        81130,
        34356,
        16210,
        23547,
        36446,
        34090,
        140028,
        72439,
        2221,
        22163,
        57058,
        363492,
        113754,
        18913,
        95451,
        48663,
        54464,
        54037,
        176097,
        68425,
        3023,
        34906,
        29482,
        117389,
        341780,
        80431,
        58330,
        16753,
        92616,
        60907,
        94846,
        147486,
        4498,
        48646,
        7773,
        46801,
        7778,
        18946,
        464978,
        47558,
        33223,
        177444,
        7328,
        15626,
        63337,
        94700,
        11743,
        9351,
        255024,
        39098,
        16447,
        42647,
        96230,
        39769,
        58840,
        10068,
        63439,
        35800,
        65843,
        58823,
        413844,
        9156,
        51258,
        7434,
        61791,
        85018,
        6872,
        3692,
        28096,
        7121,
        33024,
        6009,
        75532,
        31997,
        192535,
        9661,
        3304,
        9547,
        14753,
        31987,
        25314,
        55689,
        15896,
        20430,
        39472,
        31340,
        99744,
        25398,
        115569,
        54883,
        28719,
        205423,
        23071,
        57855,
        64638,
        149867,
        25671,
        82403,
        37616,
        20668,
        39989,
        77996,
        74948,
        140555,
        175248,
        64810,
        36515,
        46595,
        4958,
        248773,
        24045,
        28728,
        136673,
        168704,
        20804,
        114833,
        100325,
        27135,
        21205,
        96151,
        153134,
        45992,
        7093,
        13992,
        76047,
        1980,
        19432,
        145001,
        75159,
        87462,
        17710,
        1013,
        45556,
        34297,
        144882,
        20648,
        26061,
        11319,
        129567,
        108555,
        18872,
        464580,
        33386,
        22717,
        65948,
        167189,
        5603,
        135042,
        79542,
        8801,
        202632,
        18114,
        91882,
        5973,
        5239,
        67315,
        4431,
        60916,
        47819,
        71693,
        32597,
        32606,
        18183,
        45072,
        80329,
        76385,
        24749,
        51305,
        40314,
        156514,
        14693,
        130345,
        13168,
        66214,
        18029,
        12858,
        34801,
        27628,
        14544,
        10823,
        40522,
        40185,
        33739,
        148694,
        23548,
        9923,
        61012,
        28859,
        17933,
        19442,
        34364,
        99849,
        164107,
        141167,
        30629,
        21054,
        6744,
        36491,
        8096,
        42474,
        41706,
        155060,
        30650,
        10600,
        163442,
        1143,
        96655,
        61390,
        52359,
        7559,
        51568,
        64256,
        203854,
        4467,
        22453,
        14504,
        436398,
        7878,
        6980,
        8293,
        63610,
        293747,
        16167,
        35763,
        19627,
        147603,
        15419,
        18032,
        110744,
        51346,
        33681,
        54571,
        40472,
        48615,
        39073,
        21604,
        13754,
        173027,
        92560,
        11083,
        47299,
        63062,
        11813,
        52007,
        29883,
        9734,
        139722,
        15953,
        1550,
        20651,
        13616,
        49306,
        16113,
        90089,
        92326,
        7584,
        30712,
        72424,
        164858,
        6831,
        152871,
        55746,
        197721,
        34167,
        196442,
        6022,
        112107,
        55215,
        7538,
        123381,
        4920,
        43539,
        77165,
        8939,
        50392,
        34192,
        20225,
        79762,
        22505,
        58667,
        40770,
        29788,
        97180,
        82835,
        4568,
        8579,
        13273,
        363569,
        35898,
        49983,
        436,
        36598,
        3237,
        131691,
        62418,
        35591,
        8101,
        4073,
        379438,
        65218,
        76072,
        33887,
        2968,
        27573,
        212619,
        288680,
        68278,
        72851,
        150504,
        217896,
        6913,
        121339,
        22017,
        35340,
        51072,
        43616,
        75043,
        31437,
        10833,
        81487,
        4364,
        22968,
        41454,
        106687,
        85446,
        19863,
        109625,
        149241,
        524,
        141850,
        214404,
        54376,
        657,
        237023,
        9401,
        108137,
        53800,
        32474,
        49712,
        53334,
        126876,
        27337,
        45552,
        177696,
        8269,
        15036,
        12097,
        42240,
        2328,
        125374,
        119295,
        99715,
        2500,
        19624,
        39441,
        27220,
        102691,
        60957,
        94543,
        39101,
        18566,
        67362,
        13975,
        78230,
        25017,
        34017,
        239007,
        90027,
        39351,
        41681,
        35354,
        43822,
        1043,
        916,
        58587,
        141983,
        94818,
        38799,
        75459,
        41114,
        67432,
        16195,
        36606,
        59568,
        22272,
        126769,
        31424,
        68659,
        12287,
        134302,
        257977,
        5756,
        207285,
        95637,
        47248,
        117689,
        19583,
        77451,
        22373,
        12200,
        54993,
        117118,
        34244,
        29386,
        34562,
        53819,
        71267,
        64172,
        77665,
        49368,
        7716,
        59301,
        25749,
        45426,
        194789,
        17297,
        2650,
        1766,
        32501,
        45198,
        20403,
        20984,
        6600,
        14171,
        94604,
        19037,
        5402,
        29896,
        9938,
        59935,
        109708,
        88081,
        145182,
        44844,
        39167,
        352626,
        164173,
        35374,
        45982,
        6122,
        154,
        73419,
        220487,
        53834,
        53601,
        17992,
        8609,
        229321,
        5610,
        68098,
        66815,
        71012,
        95069,
        140968,
        27396,
        8957,
        134489,
        24656,
        86659,
        56598,
        134852,
        17316,
        123838,
        255436,
        6613,
        41610,
        138033,
        81452,
        32023,
        32396,
        123687,
        63398,
        8693,
        29712,
        30407,
        19296,
        121188,
        3551,
        36099,
        20032,
        111948,
        56624,
        16547,
        27453,
        35916,
        15378,
        52039,
        56849,
        13489,
        22214,
        73177,
        53097,
        277349,
        2157,
        14029,
        187886,
        10260,
        141743,
        246460,
        91880,
        50869,
        3788,
        49486,
        133566,
        54950,
        33120,
        129337,
        53768,
        18333,
        9525,
        26902,
        312251,
        10297,
        9020,
        70759,
        16647,
        112432,
        59260,
        84609,
        9818,
        82766,
        73569,
        468,
        46001,
        75780,
        55028,
        52106,
        11498,
        43645,
        108069,
        17150,
        17753,
        29417,
        16705,
        31799,
        9606,
        289,
        122254,
        115975,
        8620,
        6133,
        255357,
        56908,
        14456,
        133464,
        43554,
        79224,
        11247,
        29630,
        160,
        12756,
        25464,
        65960,
        350428,
        62521,
        321796,
        100359,
        67358,
        35169,
        46172,
        113128,
        48988,
        88868,
        31094,
        33266,
        6847,
        60887,
        98188,
        49659,
        69117,
        92977,
        220228,
        13947,
        80181,
        35103,
        62170,
        97351,
        13475,
        2440,
        199768,
        19498,
        36597,
        46971,
        25234,
        67806,
        62881,
        84717,
        73648,
        181966,
        10488,
        94149,
        21550,
        26655,
        63436,
        48375,
        14405,
        165650,
        9621,
        24439,
        28043,
        42735,
        4490,
        29963,
        56674,
        45373,
        1934,
        262446,
        50855,
        67098,
        26898,
        5261,
        52696,
        40644,
        33900,
        9440,
        180286,
        87162,
        22940,
        19704,
        26936,
        69769,
        10254,
        101759,
        27406,
        12243,
        48e3,
        73926,
        113215,
        54935,
        5726,
        192787,
        4312,
        106216,
        9366,
        11550,
        52949,
        23457,
        212271,
        277152,
        133895,
        108374,
        6191,
        96477,
        29980,
        218916,
        58024,
        54696,
        40853,
        91124,
        65894,
        91170,
        65908,
        252552,
        6793,
        29212,
        15389,
        44516,
        122515,
        52617,
        35058,
        9017,
        103536,
        39510,
        49136,
        19242,
        130652,
        662077,
        74699,
        47024,
        31422,
        8517,
        73351,
        24399,
        13867,
        128360,
        4810,
        4434,
        61779,
        111983,
        61036,
        17798,
        110240,
        59722,
        102960,
        39688,
        10001,
        23803,
        23039,
        176498,
        56659,
        44814,
        134295,
        17188,
        77577,
        74466,
        226175,
        102472,
        154333,
        63900,
        111747,
        18062,
        41171,
        79669,
        32773,
        408933,
        42562,
        28931,
        30907,
        107388,
        43487,
        2946,
        240310,
        23938,
        24354,
        319,
        184983,
        7927,
        6488,
        1422,
        10790,
        68809,
        68209,
        64775,
        4361,
        202,
        17123,
        59634,
        51200,
        44391,
        18188,
        17843,
        2619,
        74278,
        3230,
        9540,
        47187,
        21702,
        36274,
        56894,
        43907,
        16310,
        34790,
        16866,
        6150,
        5561,
        13587,
        107545,
        108873,
        126867,
        86986,
        28640,
        33427,
        19017,
        5762,
        80637,
        17430,
        46903,
        2047,
        131055,
        25958,
        13558,
        5444,
        47152,
        13900,
        44563,
        122857,
        45348,
        70863,
        39593,
        54332,
        38068,
        33637,
        318,
        40310,
        143467,
        18502,
        24520,
        11377,
        62013,
        28942,
        27246,
        28269,
        83545,
        17999,
        59015,
        90707,
        30065,
        15161,
        34720,
        1263,
        37008,
        2012,
        6060,
        98575,
        92933,
        5721,
        299,
        199555,
        24578,
        29223,
        2985,
        743,
        115825,
        109523,
        136657,
        47454,
        26378,
        53586,
        3733,
        174945,
        93340,
        244456,
        5693,
        37386,
        28782,
        89767,
        27545,
        23573,
        18798,
        136425,
        34320,
        84778,
        20041,
        48453,
        38215,
        7477,
        71958,
        40621,
        8773,
        5874,
        187927,
        105965,
        51100,
        43533,
        18083,
        8443,
        10180,
        43597,
        2003,
        183999,
        69689,
        12216,
        129696,
        146188,
        62389,
        34044,
        68410,
        12765,
        43273,
        26949,
        266807,
        3345,
        34477,
        79197,
        5688,
        47539,
        213110,
        21634,
        22257,
        50092,
        32222,
        42346,
        39530,
        63668,
        98,
        134978,
        74022,
        5152,
        59088,
        174145,
        37220,
        9934,
        9545,
        118937,
        5724,
        87240,
        19875,
        15784,
        40143,
        23263,
        87513,
        181654,
        285152,
        37881,
        263241,
        4966,
        43934,
        10433,
        186657,
        6470,
        74416,
        225854,
        25908,
        142677,
        246262,
        32280,
        6192,
        75890,
        45546,
        143264,
        135305,
        29742,
        47013,
        77787,
        11732,
        126658,
        8763,
        37950,
        21806,
        57557,
        113464,
        89465,
        108995,
        164574,
        23894,
        22996,
        23169,
        15369,
        23117,
        17642,
        130607,
        40503,
        36239,
        280990,
        44666,
        9981,
        40427,
        147487,
        26869,
        168452,
        32886,
        32991,
        46798,
        240839,
        15111,
        70502,
        65697,
        88548,
        44145,
        28701,
        48767,
        31139,
        206777,
        35659,
        181164,
        166262,
        14554,
        171445,
        31786,
        66523,
        76607,
        17956,
        6507,
        31279,
        90476,
        116611,
        167918,
        6560,
        1243,
        115324,
        80128,
        41867,
        55897,
        187323,
        37069,
        32596,
        189444,
        145931,
        13390,
        105530,
        65709,
        26805,
        6999,
        55714,
        41300,
        22915,
        68951,
        22138,
        21120,
        22264,
        10058,
        19945,
        33635,
        56123,
        99085,
        10032,
        5818,
        6016,
        46649,
        57476,
        35264,
        94413,
        112522,
        262288,
        93686,
        83038,
        14341,
        23204,
        28807,
        66084,
        77987,
        6101,
        126673,
        7133,
        38126,
        5923,
        122091,
        170240,
        97772,
        46874,
        215746,
        43948,
        41622,
        3272,
        55596,
        8332,
        146411,
        251315,
        13533,
        8561,
        81521,
        115449,
        48616,
        175175,
        2063,
        186556,
        3036,
        134537,
        75772,
        29728,
        82360,
        22973,
        186559,
        86348,
        89100,
        38388,
        82297,
        45610,
        2613,
        87082,
        9986,
        177812,
        57884,
        23591,
        47485,
        42543,
        33582,
        44713,
        74439,
        257444,
        252451,
        31825,
        35631,
        38540,
        33066,
        5147,
        13973,
        4343,
        51830,
        70378,
        22827,
        26448,
        95560,
        36896,
        241741,
        48067,
        203953,
        298860,
        61620,
        20450,
        3220,
        67272,
        6586,
        107662,
        100160,
        108684,
        6929,
        57226,
        4762,
        7457,
        1320,
        40404,
        77204,
        99309,
        62750,
        208653,
        59977,
        44e3,
        74315,
        34332,
        5819,
        172217,
        64904,
        114077,
        18147,
        84012,
        1791,
        98456,
        90930,
        21446,
        116669,
        103938,
        7422,
        85140,
        59713,
        5768,
        326211,
        16239,
        75411,
        13229,
        29398,
        10758,
        236107,
        1539,
        112472,
        95979,
        152154,
        151294,
        306,
        21196,
        38146,
        10700,
        6891,
        84282,
        109646,
        56492,
        40539,
        6589,
        119491,
        51354,
        30685,
        140209,
        136906,
        29622,
        73617,
        49553,
        70525,
        51671,
        166869,
        139616,
        74395,
        37439,
        49595,
        45678,
        11959,
        33211,
        86560,
        52434,
        9282,
        62690,
        112155,
        130810,
        5243,
        108261,
        99970,
        265613,
        72551,
        80049,
        6391,
        33365,
        90721,
        66737,
        69872,
        87011,
        1860,
        9032,
        112544,
        60905,
        37371,
        89015,
        140351,
        19076,
        850,
        373531,
        2802,
        36725,
        218795,
        72062,
        28990,
        16550,
        24614,
        7815,
        6187,
        26336,
        33373,
        32162,
        42791,
        73555,
        32062,
        23386,
        10244,
        56392,
        49442,
        27076,
        136262,
        12412,
        14883,
        1134,
        33675,
        97153,
        199281,
        15608,
        100152,
        74072,
        47942,
        254301,
        36451,
        16026,
        10687,
        65067,
        56708,
        254030,
        30290,
        50490,
        13864,
        57941,
        259331,
        35588,
        23485,
        43486,
        24869,
        21620,
        92971,
        22072,
        88645,
        1048,
        182050,
        13343,
        32452,
        14825,
        19509,
        3325,
        216938,
        45740,
        99716,
        189082,
        53740,
        78245,
        25609,
        24311,
        176777,
        47340,
        308354,
        40669,
        66085,
        14102,
        125339,
        9225,
        128709,
        97207,
        1271,
        200933,
        78439,
        113451,
        88975,
        18324,
        46521,
        11819,
        18570,
        141756,
        72512,
        170020,
        52754,
        63550,
        118515,
        103073,
        93330,
        32736,
        50499,
        14722,
        31600,
        68452,
        398867,
        29316,
        172786,
        18417,
        104924,
        2606,
        5670,
        84818,
        16288,
        67106,
        59580,
        82929,
        607401,
        291,
        85829,
        359,
        15897,
        35830,
        50696,
        65630,
        52672,
        22115,
        356968,
        29895,
        40837,
        231192,
        34024,
        38957,
        26722,
        406,
        23335,
        124952,
        72068,
        68804,
        13268,
        147101,
        164740,
        276569,
        162596,
        66943,
        11569,
        26654,
        66358,
        4777,
        23229,
        102127,
        5848,
        978,
        2921,
        59666,
        5371,
        28212,
        90108,
        42938,
        39320,
        2499,
        4271,
        108792,
        33510,
        125072,
        71653,
        65239,
        38250,
        66357,
        38577,
        13964,
        86251,
        35708,
        50755,
        36010,
        29448,
        12209,
        3844,
        38222,
        206337,
        100876,
        67827,
        137088,
        14167,
        252225,
        84163,
        195270,
        1306,
        5703,
        54198,
        779,
        46802,
        22028,
        51124,
        86759,
        70560,
        113164,
        35685,
        162145,
        45471,
        34561,
        422,
        2611,
        6464,
        47486,
        19223,
        38246,
        9191,
        18331,
        89942,
        243642,
        212364,
        15893,
        17518,
        22617,
        6409,
        30046,
        126182,
        59716,
        36560,
        104428,
        18846,
        26592,
        19458,
        50793,
        147333,
        30826,
        1388,
        27647,
        10922,
        14495,
        33545,
        19269,
        135828,
        39727,
        41601,
        46931,
        233379,
        49169,
        131130,
        182112,
        16276,
        82381,
        118209,
        142445,
        128310,
        19672,
        28740,
        82907,
        33436,
        3118,
        102206,
        28723,
        24819,
        41937,
        38854,
        5157,
        3881,
        111491,
        1142,
        9776,
        421673,
        152241,
        29309,
        14961,
        87854,
        6054,
        15424,
        3796,
        82656,
        54996,
        2108,
        55367,
        239450,
        154525,
        9643,
        118103,
        106041,
        64601,
        68549,
        48707,
        30266,
        25772,
        18740,
        9462,
        229669,
        91798,
        112152,
        191327,
        14493,
        72828,
        8175,
        66636,
        236474,
        25817,
        87351,
        129027,
        76653,
        20422,
        22983,
        71240,
        27846,
        44661,
        12399,
        46158,
        77704,
        53101,
        35032,
        11072,
        17300,
        109294,
        33638,
        24408,
        1895,
        11241,
        760,
        17584,
        82479,
        125877,
        63150,
        141075,
        34259,
        23274,
        81698,
        15732,
        43577,
        48340,
        91584,
        14688,
        16379,
        24481,
        150280,
        96420,
        262050,
        48635,
        43727,
        61819,
        56268,
        72003,
        88178,
        17281,
        79912,
        13218,
        122519,
        125295,
        166396,
        11811,
        2171,
        118930,
        67746,
        17636,
        178278,
        174656,
        95661,
        173039,
        83845,
        79689,
        17473,
        98555,
        127696,
        203415,
        54730,
        22925,
        232239,
        9309,
        12136,
        175026,
        20740,
        180188,
        10747,
        39816,
        314017,
        266131,
        10040,
        175732,
        112550,
        220651,
        31974,
        37393,
        888,
        23008,
        86799,
        4303,
        64905,
        148467,
        75337,
        251,
        3284,
        370102,
        50264,
        9835,
        5438,
        23655,
        4481,
        29851,
        329,
        12855,
        7162,
        64931,
        78141,
        12804,
        42372,
        296771,
        83547,
        18624,
        34874,
        86271,
        3360,
        48665,
        77735,
        88767,
        11463,
        63527,
        28889,
        22258,
        29140,
        194315,
        113924,
        25499,
        6406,
        31334,
        1845,
        4802,
        49184,
        43455,
        35469,
        127594,
        92970,
        61038,
        115005,
        38840,
        87761,
        106838,
        8811,
        20572,
        55637,
        11162,
        96721,
        132425,
        108925,
        2948,
        125457,
        36356,
        3502,
        75270,
        27622,
        127192,
        2561,
        123095,
        49394,
        61155,
        16897,
        110064,
        9699,
        89448,
        53356,
        19628,
        220310,
        21622,
        83036,
        9885,
        112214,
        6087,
        26713,
        17901,
        161912,
        91492,
        3440,
        68594,
        9266,
        92238,
        8087,
        6866,
        150194,
        72175,
        80701,
        13459,
        31836,
        43243,
        239700,
        95846,
        44749,
        50647,
        21945,
        230538,
        120612,
        132371,
        244604,
        5193,
        105637,
        34661,
        41341,
        68775,
        85393,
        1874,
        8771,
        33718,
        49672,
        77403,
        595452,
        99507,
        6490,
        58895,
        128742,
        7704,
        39239,
        73217,
        43816,
        62824,
        37804,
        199976,
        22361,
        80005,
        87514,
        94832,
        14089,
        4574,
        139975,
        59142,
        75523,
        100268,
        43906,
        53442,
        15152,
        2547,
        186002,
        17011,
        19513,
        204282,
        3343,
        60568,
        128318,
        119250,
        4298,
        51871,
        41336,
        71759,
        21921,
        45074,
        98169,
        145889,
        99427,
        11350,
        1237,
        5520,
        28799,
        7803,
        53702,
        21026,
        136352,
        38293,
        128690,
        12158,
        90132,
        44600,
        10184,
        26957,
        39459,
        126025,
        78904,
        82999,
        59373,
        39301,
        150198,
        120529,
        153042,
        20177,
        50089,
        14764,
        271571,
        30530,
        123161,
        38975,
        101562,
        22941,
        5648,
        124654,
        109243,
        69817,
        71675,
        49162,
        106884,
        21241,
        107795,
        30258,
        16572,
        188262,
        141456,
        7688,
        60718,
        8271,
        11044,
        32440,
        104608,
        103419,
        236109,
        93156,
        43293,
        128929,
        42107,
        67180,
        25201,
        115254,
        185488,
        130954,
        72813,
        167547,
        20537,
        39969,
        38432,
        22582,
        184022,
        1139,
        27199,
        5655,
        17767,
        97412,
        122606,
        209377,
        27070,
        35871,
        326617,
        188954,
        42680,
        73512,
        80911,
        22629,
        3011,
        95021,
        315242,
        157737,
        383,
        41821,
        41808,
        19335,
        27950,
        15674,
        25677,
        110950,
        35375,
        76835,
        59108,
        57370,
        35262,
        16569,
        160415,
        37706,
        78086,
        32041,
        49691,
        137143,
        9782,
        172080,
        50148,
        77917,
        6323,
        10110,
        69172,
        17711,
        21795,
        59511,
        76184,
        135114,
        31046,
        132319,
        59105,
        157578,
        20549,
        80778,
        57649,
        158421,
        65143,
        4575,
        72235,
        21899,
        10797,
        92745,
        34035,
        106079,
        80159,
        4508,
        78304,
        25350,
        75457,
        46458,
        32937,
        25623,
        47,
        8531,
        104751,
        84953,
        8138,
        36508,
        187199,
        66310,
        115274,
        13253,
        32461,
        38536,
        1916,
        42007,
        187160,
        35055,
        26325,
        84394,
        35963,
        94216,
        45590,
        97782
    ], Y0 = 15;
    class Ome {
        log;
        peerRouting;
        routingTable;
        refreshInterval;
        refreshQueryTimeout;
        commonPrefixLengthRefreshedAt;
        refreshTimeoutId;
        constructor(e, t){
            const { peerRouting: r, routingTable: s, refreshInterval: i, refreshQueryTimeout: l, logPrefix: u } = t;
            this.log = e.logger.forComponent(`${u}:routing-table:refresh`), this.peerRouting = r, this.routingTable = s, this.refreshInterval = i ?? yge, this.refreshQueryTimeout = l ?? wge, this.commonPrefixLengthRefreshedAt = [], this.refreshTable = this.refreshTable.bind(this);
        }
        async afterStart() {
            this.log(`refreshing routing table every ${this.refreshInterval}ms`), this.refreshTable(!0);
        }
        async stop() {
            this.refreshTimeoutId != null && clearTimeout(this.refreshTimeoutId);
        }
        refreshTable(e = !1, t) {
            this.log("refreshing routing table");
            const r = this._maxCommonPrefix(), s = this._getTrackedCommonPrefixLengthsForRefresh(r);
            this.log(`max common prefix length ${r}`), this.log(`tracked CPLs [ ${s.map((i)=>i.toISOString()).join(", ")} ]`), Promise.all(s.map(async (i, l)=>{
                try {
                    if (await this._refreshCommonPrefixLength(l, i, e, t), this._numPeersForCpl(r) === 0) {
                        const u = Math.min(2 * (l + 1), s.length - 1);
                        for(let h = l + 1; h < u + 1; h++)try {
                            await this._refreshCommonPrefixLength(h, i, e, t);
                        } catch (f) {
                            this.log.error("failed to refresh entries with common prefix length %d - %e", h, f);
                        }
                    }
                } catch (u) {
                    this.log.error("failed to refresh entries with common prefix length - %e", u);
                }
            })).catch((i)=>{
                this.log.error("failed to refresh table - %e", i);
            }).then(()=>{
                this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval), this.refreshTimeoutId.unref != null && this.refreshTimeoutId.unref();
            }).catch((i)=>{
                this.log.error("failed to set refresh timeout - %e", i);
            });
        }
        async _refreshCommonPrefixLength(e, t, r, s) {
            if (!r && t.getTime() > Date.now() - this.refreshInterval) {
                this.log("not running refresh for cpl %s as time since last refresh not above interval", e);
                return;
            }
            const i = this._generateRandomPeerId(e);
            this.log("starting refreshing cpl %s with key %p (routing table size was %s)", e, i, this.routingTable.size);
            const l = gt([
                s?.signal,
                AbortSignal.timeout(this.refreshQueryTimeout)
            ]);
            try {
                const u = await jP(this.peerRouting.getClosestPeers(i.toMultihash().bytes, {
                    signal: l
                }));
                this.log(`found ${u} peers that were close to imaginary peer %p`, i), this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", e, i, this.routingTable.size);
            } finally{
                l.clear();
            }
        }
        _getTrackedCommonPrefixLengthsForRefresh(e) {
            e > Y0 && (e = Y0);
            const t = [];
            for(let r = 0; r <= e; r++)t[r] = this.commonPrefixLengthRefreshedAt[r] ?? new Date;
            return t;
        }
        _generateRandomPeerId(e) {
            if (this.routingTable.kb == null) throw new Error("Routing table not started");
            if (this.routingTable.kb.localPeer == null) throw new Error("Local peer not set");
            const t = Go(2), r = (t[1] << 8) + t[0], s = this._makePeerId(this.routingTable.kb.localPeer.kadId, r, e), i = kt(s);
            return Jo(i);
        }
        _makePeerId(e, t, r) {
            if (r > Y0) throw new Error(`Cannot generate peer ID for common prefix length greater than ${Y0}`);
            const l = new DataView(e.buffer, e.byteOffset, e.byteLength).getUint16(0, !1) ^ 32768 >> r, u = 65535 << 16 - (r + 1), h = l & u | t & ~u, f = Rme[h], p = new ArrayBuffer(34), m = new DataView(p, 0, p.byteLength);
            return m.setUint8(0, Ut.code), m.setUint8(1, 32), m.setUint32(2, f, !1), new Uint8Array(m.buffer, m.byteOffset, m.byteLength);
        }
        _maxCommonPrefix() {
            let e = 0;
            for (const t of this._prefixLengths())t > e && (e = t);
            return e;
        }
        _numPeersForCpl(e) {
            let t = 0;
            for (const r of this._prefixLengths())r === e && t++;
            return t;
        }
        *_prefixLengths() {
            if (this.routingTable.kb?.localPeer != null) for (const { kadId: e } of this.routingTable.kb.toIterable()){
                const t = Qc(this.routingTable.kb.localPeer.kadId, e);
                let r = 0;
                for (const s of t)if (s === 0) r++;
                else break;
                yield r;
            }
        }
    }
    class $me {
        peerId;
        providers;
        peerStore;
        log;
        constructor(e, t){
            this.log = e.logger.forComponent(`${t.logPrefix}:rpc:handlers:add-provider`), this.peerId = e.peerId, this.providers = t.providers, this.peerStore = e.peerStore;
        }
        async handle(e, t) {
            if (t.key == null || t.key.length === 0) throw new Ga("Missing key");
            let r;
            try {
                r = ge.decode(t.key);
            } catch  {
                throw new Ga("Invalid CID");
            }
            (t.providers == null || t.providers.length === 0) && this.log.error("no providers found in message"), this.log("%p asked us, %p to store provider record for for %c", e, this.peerId, r), await Promise.all(t.providers.map(async (s)=>{
                const i = kt(s.id), l = Jo(i), u = s.multiaddrs.map((h)=>WP(h));
                if (!e.equals(l)) {
                    this.log("invalid provider peer %p from %p", s.id, e);
                    return;
                }
                if (s.multiaddrs.length < 1) {
                    this.log("no valid addresses for provider %p. Ignore", e);
                    return;
                }
                this.log.trace("received provider %p for %s (addrs %s)", e, r, u), await this.providers.addProvider(r, l), await this.peerStore.merge(l, {
                    multiaddrs: u
                });
            }));
        }
    }
    class Mme {
        peerRouting;
        peerInfoMapper;
        peerId;
        addressManager;
        log;
        constructor(e, t){
            const { peerRouting: r, logPrefix: s } = t;
            this.log = e.logger.forComponent(`${s}:rpc:handlers:find-node`), this.peerId = e.peerId, this.addressManager = e.addressManager, this.peerRouting = r, this.peerInfoMapper = t.peerInfoMapper;
        }
        async handle(e, t) {
            this.log("incoming request from %p for peers close to %b", e, t.key);
            try {
                if (t.key == null) throw new Ga("Invalid FIND_NODE message received - key was missing");
                const r = await this.peerRouting.getClosestPeersOffline(t.key, {
                    exclude: [
                        e,
                        this.peerId
                    ]
                });
                Ee(this.peerId.toMultihash().bytes, t.key) && r.push({
                    id: this.peerId,
                    multiaddrs: this.addressManager.getAddresses().map((i)=>i.decapsulateCode(KP))
                });
                const s = {
                    type: Ht.FIND_NODE,
                    clusterLevel: t.clusterLevel,
                    closer: r.map(this.peerInfoMapper).filter(({ multiaddrs: i })=>i.length).map((i)=>({
                            id: i.id.toMultihash().bytes,
                            multiaddrs: i.multiaddrs.map((l)=>l.bytes)
                        })),
                    providers: []
                };
                return s.closer.length === 0 ? this.log("could not find any peers closer to %b for %p", t.key, e) : this.log("found %d peers close to %b for %p", s.closer.length, t.key, e), s;
            } catch (r) {
                throw this.log("error during finding peers closer to %b for %p - %e", t.key, e, r), r;
            }
        }
    }
    class Nme {
        peerId;
        peerRouting;
        providers;
        peerStore;
        peerInfoMapper;
        log;
        constructor(e, t){
            const { peerRouting: r, providers: s, logPrefix: i } = t;
            this.log = e.logger.forComponent(`${i}:rpc:handlers:get-providers`), this.peerId = e.peerId, this.peerStore = e.peerStore, this.peerRouting = r, this.providers = s, this.peerInfoMapper = t.peerInfoMapper;
        }
        async handle(e, t) {
            if (t.key == null) throw new Ga("Invalid GET_PROVIDERS message received - key was missing");
            let r;
            try {
                r = ge.decode(t.key);
            } catch  {
                throw new Ga("Invalid CID");
            }
            this.log("%p asking for providers for %s", e, r);
            const [s, i] = await Promise.all([
                sf(kf(await this.providers.getProviders(r), async (u)=>{
                    const h = await this.peerStore.get(u);
                    return {
                        id: h.id,
                        multiaddrs: h.addresses.map(({ multiaddr: p })=>p)
                    };
                })),
                this.peerRouting.getClosestPeersOffline(t.key)
            ]), l = {
                type: Ht.GET_PROVIDERS,
                key: t.key,
                clusterLevel: t.clusterLevel,
                closer: i.map(this.peerInfoMapper).filter(({ id: u, multiaddrs: h })=>h.length > 0).map((u)=>({
                        id: u.id.toMultihash().bytes,
                        multiaddrs: u.multiaddrs.map((h)=>h.bytes)
                    })),
                providers: s.map(this.peerInfoMapper).filter(({ id: u, multiaddrs: h })=>h.length > 0).map((u)=>({
                        id: u.id.toMultihash().bytes,
                        multiaddrs: u.multiaddrs.map((h)=>h.bytes)
                    }))
            };
            return this.log("got %s providers %s closerPeers", l.providers.length, l.closer.length), l;
        }
        async _getAddresses(e) {
            return [];
        }
    }
    class Lme {
        peerStore;
        datastore;
        peerRouting;
        log;
        datastorePrefix;
        constructor(e, t){
            this.log = e.logger.forComponent(`${t.logPrefix}:rpc:handlers:get-value`), this.datastorePrefix = `${t.datastorePrefix}/record`, this.peerStore = e.peerStore, this.datastore = e.datastore, this.peerRouting = t.peerRouting;
        }
        async handle(e, t) {
            const r = t.key;
            if (this.log("%p asked for key %b", e, r), r == null || r.length === 0) throw new Ga("Invalid key");
            const s = {
                type: Ht.GET_VALUE,
                key: r,
                clusterLevel: t.clusterLevel,
                closer: [],
                providers: []
            };
            if (Fge(r)) {
                this.log("is public key");
                const u = Vge(r);
                let h;
                try {
                    const f = await this.peerStore.get(u);
                    if (f.id.publicKey == null) throw new Mf("No public key found in key book");
                    h = Fr(f.id.publicKey);
                } catch (f) {
                    if (f.name !== "NotFoundError") throw f;
                }
                if (h != null) return this.log("returning found public key"), s.record = new Ss(r, h, new Date).serialize(), s;
            }
            const [i, l] = await Promise.all([
                this._checkLocalDatastore(r),
                this.peerRouting.getClosestPeersOffline(r)
            ]);
            return i != null && (this.log("had record for %b in local datastore", r), s.record = i.serialize()), l.length > 0 && (this.log("had %s closer peers in routing table", l.length), s.closer = l.map((u)=>({
                    id: u.id.toMultihash().bytes,
                    multiaddrs: u.multiaddrs.map((h)=>h.bytes)
                }))), s;
        }
        async _checkLocalDatastore(e) {
            this.log("checkLocalDatastore looking for %b", e);
            const t = Td(this.datastorePrefix, e);
            let r;
            try {
                r = await this.datastore.get(t);
            } catch (i) {
                if (i.name === "NotFoundError") return;
                throw i;
            }
            const s = Ss.deserialize(r);
            if (s.timeReceived == null || Date.now() - s.timeReceived.getTime() > MP) {
                await this.datastore.delete(t);
                return;
            }
            return s;
        }
    }
    class Ume {
        log;
        constructor(e, t){
            this.log = e.logger.forComponent(`${t.logPrefix}:rpc:handlers:ping`);
        }
        async handle(e, t) {
            return this.log("ping from %p", e), t;
        }
    }
    class zme {
        components;
        validators;
        log;
        datastorePrefix;
        constructor(e, t){
            const { validators: r } = t;
            this.components = e, this.log = e.logger.forComponent(`${t.logPrefix}:rpc:handlers:put-value`), this.datastorePrefix = `${t.datastorePrefix}/record`, this.validators = r;
        }
        async handle(e, t) {
            const r = t.key;
            if (this.log("%p asked us to store value for key %b", e, r), t.record == null) throw this.log.error("empty record from %p", e), new Ga(`Empty record from: ${e}`);
            try {
                const s = Ss.deserialize(t.record);
                await F8(this.validators, s), s.timeReceived = new Date;
                const i = Td(this.datastorePrefix, s.key);
                await this.components.datastore.put(i, s.serialize().subarray()), this.log("put record for %b into datastore under key %k", r, i);
            } catch (s) {
                this.log("did not put record for key %b into datastore %o", r, s);
            }
            return t;
        }
    }
    let Fme = class {
        handlers;
        log;
        metrics;
        incomingMessageTimeout;
        constructor(e, t){
            this.metrics = {
                operations: e.metrics?.registerCounterGroup(`${t.metricsPrefix}_inbound_rpc_requests_total`),
                errors: e.metrics?.registerCounterGroup(`${t.metricsPrefix}_inbound_rpc_errors_total`),
                rpcTime: e.metrics?.registerMetricGroup(`${t.metricsPrefix}_inbound_rpc_time_seconds`, {
                    label: "operation"
                })
            }, this.log = e.logger.forComponent(`${t.logPrefix}:rpc`), this.incomingMessageTimeout = t.incomingMessageTimeout ?? 1e4, this.handlers = {
                [Ht.GET_VALUE.toString()]: new Lme(e, t),
                [Ht.PUT_VALUE.toString()]: new zme(e, t),
                [Ht.FIND_NODE.toString()]: new Mme(e, t),
                [Ht.ADD_PROVIDER.toString()]: new $me(e, t),
                [Ht.GET_PROVIDERS.toString()]: new Nme(e, t),
                [Ht.PING.toString()]: new Ume(e, t)
            };
        }
        async handleMessage(e, t) {
            const r = this.handlers[t.type];
            if (r == null) {
                this.log.error(`no handler found for message type: ${t.type}`);
                return;
            }
            try {
                return this.metrics.operations?.increment({
                    [t.type]: !0
                }), await r.handle(e, t);
            } catch  {
                this.metrics.errors?.increment({
                    [t.type]: !0
                });
            }
        }
        async onIncomingStream(e, t) {
            const r = ()=>{
                e.abort(new tge);
            };
            let s = AbortSignal.timeout(this.incomingMessageTimeout);
            s.addEventListener("abort", r);
            const i = Jn(e).pb(Pc);
            for(;;){
                if (e.readStatus !== "readable") {
                    await e.close({
                        signal: s
                    });
                    break;
                }
                const l = await i.read({
                    signal: s
                }), u = this.metrics?.rpcTime?.timer(l.type.toString()), h = this.metrics?.rpcTime?.timer(l.type.toString());
                let f = !1;
                try {
                    this.log("incoming %s from %p", l.type, t.remotePeer);
                    const p = await this.handleMessage(t.remotePeer, l);
                    p != null && await i.write(p, {
                        signal: s
                    });
                } catch (p) {
                    throw f = !0, h?.(), p;
                } finally{
                    f || u?.();
                }
                s.removeEventListener("abort", r), s = AbortSignal.timeout(this.incomingMessageTimeout), s.addEventListener("abort", r);
            }
        }
    };
    class Vme extends Lt {
        log;
        components;
        protocol;
        running;
        registrarId;
        constructor(e, t){
            super();
            const { protocol: r, logPrefix: s } = t;
            this.components = e, this.log = e.logger.forComponent(`${s}:topology-listener`), this.running = !1, this.protocol = r;
        }
        isStarted() {
            return this.running;
        }
        async start() {
            this.running || (this.running = !0, this.registrarId = await this.components.registrar.register(this.protocol, {
                onConnect: (e)=>{
                    this.log("observed peer %p with protocol %s", e, this.protocol), this.dispatchEvent(new CustomEvent("peer", {
                        detail: e
                    }));
                }
            }));
        }
        async stop() {
            this.running = !1, this.registrarId != null && (this.components.registrar.unregister(this.registrarId), this.registrarId = void 0);
        }
    }
    class Hme {
        dht;
        constructor(e){
            this.dht = e;
        }
        async provide(e, t = {}) {
            await qo(this.dht.provide(e, t));
        }
        async cancelReprovide(e) {
            await this.dht.cancelReprovide(e);
        }
        async *findProviders(e, t = {}) {
            for await (const r of this.dht.findProviders(e, t))r.name === "PROVIDER" && (yield* r.providers.map((s)=>({
                    ...s,
                    routing: "kad-dht"
                })));
        }
        async put(e, t, r) {
            await qo(this.dht.put(e, t, r));
        }
        async get(e, t) {
            for await (const r of this.dht.get(e, t))if (r.name === "VALUE") return r.value;
            throw new Mf("Could not find value for key");
        }
    }
    class Qme {
        dht;
        constructor(e){
            this.dht = e;
        }
        async findPeer(e, t = {}) {
            for await (const r of this.dht.findPeer(e, t))if (r.name === "FINAL_PEER") return r.peer;
            throw new Mf("Peer not found");
        }
        async *getClosestPeers(e, t = {}) {
            for await (const r of this.dht.getClosestPeers(e, t))r.name === "FINAL_PEER" && (yield r.peer);
        }
    }
    const qme = 32, Kme = 64;
    class Gme extends Lt {
        k;
        a;
        d;
        protocol;
        routingTable;
        providers;
        network;
        peerRouting;
        components;
        log;
        running;
        clientMode;
        validators;
        selectors;
        queryManager;
        contentFetching;
        contentRouting;
        routingTableRefresh;
        rpc;
        topologyListener;
        querySelf;
        maxInboundStreams;
        maxOutboundStreams;
        dhtContentRouting;
        dhtPeerRouting;
        peerInfoMapper;
        reprovider;
        onPeerConnectTimeout;
        constructor(e, t = {}){
            super();
            const r = t.logPrefix ?? "libp2p:kad-dht", s = t.datastorePrefix ?? "/dht", i = t.metricsPrefix ?? "libp2p_kad_dht", l = {
                queries: e.metrics?.registerMetricGroup(`${i}_operations_total`, {
                    label: "operation"
                }),
                errors: e.metrics?.registerCounterGroup(`${i}_operation_errors_total`, {
                    label: "operation"
                }),
                queryTime: e.metrics?.registerMetricGroup(`${i}_operation_time_seconds`, {
                    label: "operation"
                }),
                errorTime: e.metrics?.registerMetricGroup(`${i}_operation_error_time_seconds`, {
                    label: "operation"
                })
            };
            this.running = !1, this.components = e, this.log = e.logger.forComponent(r), this.k = t.kBucketSize ?? q8, this.a = t.alpha ?? Ug, this.d = t.disjointPaths ?? this.a, this.protocol = t.protocol ?? lge, this.clientMode = t.clientMode ?? !0, this.maxInboundStreams = t.maxInboundStreams ?? qme, this.maxOutboundStreams = t.maxOutboundStreams ?? Kme, this.peerInfoMapper = t.peerInfoMapper ?? Uge, this.onPeerConnectTimeout = t.onPeerConnectTimeout ?? fge, this.providers = new lme(e, {
                ...t.providers,
                logPrefix: r,
                datastorePrefix: s
            }), this.validators = {
                ...Dge,
                ...t.validators
            }, this.selectors = {
                ..._ge,
                ...t.selectors
            }, this.network = new ome(e, {
                protocol: this.protocol,
                logPrefix: r,
                metricsPrefix: i
            }), this.routingTable = new kme(e, {
                kBucketSize: this.k,
                pingOldContactTimeout: t.pingOldContactTimeout,
                pingOldContactConcurrency: t.pingOldContactConcurrency,
                pingOldContactMaxQueueSize: t.pingOldContactMaxQueueSize,
                pingNewContactTimeout: t.pingNewContactTimeout,
                pingNewContactConcurrency: t.pingNewContactConcurrency,
                pingNewContactMaxQueueSize: t.pingNewContactMaxQueueSize,
                protocol: this.protocol,
                logPrefix: r,
                metricsPrefix: i,
                prefixLength: t.prefixLength,
                splitThreshold: t.kBucketSplitThreshold,
                network: this.network
            });
            const u = xt();
            t.allowQueryWithZeroPeers === !0 && u.resolve(), this.queryManager = new ume(e, {
                disjointPaths: this.d,
                alpha: this.a,
                logPrefix: r,
                metricsPrefix: i,
                initialQuerySelfHasRun: u,
                routingTable: this.routingTable,
                allowQueryWithZeroPeers: t.allowQueryWithZeroPeers
            }), this.peerRouting = new ame(e, {
                routingTable: this.routingTable,
                network: this.network,
                validators: this.validators,
                queryManager: this.queryManager,
                logPrefix: r
            }), this.contentFetching = new Hge(e, {
                validators: this.validators,
                selectors: this.selectors,
                peerRouting: this.peerRouting,
                queryManager: this.queryManager,
                network: this.network,
                logPrefix: r,
                datastorePrefix: s
            }), this.contentRouting = new ime(e, {
                network: this.network,
                peerRouting: this.peerRouting,
                queryManager: this.queryManager,
                routingTable: this.routingTable,
                providers: this.providers,
                logPrefix: r
            }), this.routingTableRefresh = new Ome(e, {
                peerRouting: this.peerRouting,
                routingTable: this.routingTable,
                logPrefix: r
            }), this.rpc = new Fme(e, {
                routingTable: this.routingTable,
                providers: this.providers,
                peerRouting: this.peerRouting,
                validators: this.validators,
                logPrefix: r,
                metricsPrefix: i,
                datastorePrefix: s,
                peerInfoMapper: this.peerInfoMapper
            }), this.topologyListener = new Vme(e, {
                protocol: this.protocol,
                logPrefix: r
            }), this.querySelf = new dme(e, {
                peerRouting: this.peerRouting,
                interval: t.querySelfInterval,
                initialInterval: t.initialQuerySelfInterval,
                logPrefix: r,
                initialQuerySelfHasRun: u,
                operationMetrics: l
            }), this.reprovider = new fme(e, {
                ...t.reprovide,
                logPrefix: r,
                metricsPrefix: i,
                datastorePrefix: s,
                contentRouting: this.contentRouting,
                operationMetrics: l
            }), this.network.addEventListener("peer", (h)=>{
                const f = h.detail;
                this.onPeerConnect(f).catch((p)=>{
                    this.log.error("could not add %p to routing table - %e", f.id, p);
                }), this.dispatchEvent(new CustomEvent("peer", {
                    detail: f
                }));
            }), this.topologyListener.addEventListener("peer", (h)=>{
                const f = h.detail;
                Promise.resolve().then(async ()=>{
                    const p = await this.components.peerStore.get(f), m = {
                        id: f,
                        multiaddrs: p.addresses.map(({ multiaddr: w })=>w),
                        protocols: p.protocols
                    };
                    await this.onPeerConnect(m);
                }).catch((p)=>{
                    this.log.error("could not add %p to routing table - %e", f, p);
                });
            }), this.dhtPeerRouting = new Qme(this), this.dhtContentRouting = new Hme(this), t.clientMode == null && e.events.addEventListener("self:peer:update", (h)=>{
                this.log("received update of self-peer info"), Promise.resolve().then(async ()=>{
                    const f = h.detail.peer.addresses.some(({ multiaddr: m })=>!Is(m) && !di.exactMatch(m)), p = this.getMode();
                    f && p === "client" ? await this.setMode("server") : p === "server" && !f && await this.setMode("client");
                }).catch((f)=>{
                    this.log.error("error setting dht server mode - %e", f);
                });
            }), this.get = Yl(this.get.bind(this), l, "GET_VALUE"), this.findProviders = Yl(this.findProviders.bind(this), l, "FIND_PROVIDERS"), this.findPeer = Yl(this.findPeer.bind(this), l, "FIND_PEER"), this.getClosestPeers = Yl(this.getClosestPeers.bind(this), l, "GET_CLOSEST_PEERS"), this.provide = Yl(this.provide.bind(this), l, "PROVIDE"), this.put = Yl(this.put.bind(this), l, "PUT_VALUE");
        }
        [Symbol.toStringTag] = "@libp2p/kad-dht";
        [oge] = [
            "@libp2p/content-routing",
            "@libp2p/peer-routing",
            "@libp2p/peer-discovery",
            "@libp2p/kad-dht"
        ];
        [age] = [
            "@libp2p/identify",
            "@libp2p/ping"
        ];
        get [Xpe]() {
            return this.dhtContentRouting;
        }
        get [sge]() {
            return this.dhtPeerRouting;
        }
        get [rge]() {
            return this;
        }
        async onPeerConnect(e) {
            if (this.log.trace("peer %p connected", e.id, e.multiaddrs), e = this.peerInfoMapper(e), e.multiaddrs.length === 0) {
                this.log.trace("ignoring %p as there were no valid addresses in %s after filtering", e.id, e.multiaddrs.map((r)=>r.toString()));
                return;
            }
            const t = AbortSignal.timeout(this.onPeerConnectTimeout);
            try {
                await this.routingTable.add(e.id, {
                    signal: t
                });
            } catch (r) {
                this.log.error("could not add %p to routing table - %e", e.id, r);
            }
        }
        isStarted() {
            return this.running;
        }
        getMode() {
            return this.clientMode ? "client" : "server";
        }
        async setMode(e, t) {
            if (e === this.getMode() && t?.force !== !0) {
                this.log("already in %s mode", e);
                return;
            }
            if (await this.components.registrar.unhandle(this.protocol, t), e === this.getMode() && t?.force !== !0) {
                this.log("already in %s mode", e);
                return;
            }
            e === "client" ? (this.log("enabling client mode while in %s mode", this.getMode()), this.clientMode = !0) : (this.log("enabling server mode while in %s mode", this.getMode()), this.clientMode = !1, await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
                signal: t?.signal,
                maxInboundStreams: this.maxInboundStreams,
                maxOutboundStreams: this.maxOutboundStreams
            }));
        }
        async start() {
            this.running || (this.running = !0, await this.setMode(this.clientMode ? "client" : "server", {
                force: !0
            }), await $4(this.routingTable, this.queryManager, this.network, this.topologyListener, this.routingTableRefresh, this.reprovider), await $4(this.querySelf));
        }
        async stop() {
            this.running = !1, await $P(this.querySelf, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener, this.reprovider);
        }
        async *put(e, t, r = {}) {
            yield* this.contentFetching.put(e, t, r);
        }
        async *get(e, t = {}) {
            yield* this.contentFetching.get(e, t);
        }
        async *provide(e, t = {}) {
            yield* this.contentRouting.provide(e, this.components.addressManager.getAddresses(), t);
        }
        async cancelReprovide(e, t) {
            await this.providers.removeProvider(e, this.components.peerId, t);
        }
        async *findProviders(e, t = {}) {
            yield* this.contentRouting.findProviders(e, t);
        }
        async *findPeer(e, t = {}) {
            yield* this.peerRouting.findPeer(e, t);
        }
        async *getClosestPeers(e, t = {}) {
            yield* this.peerRouting.getClosestPeers(e, t);
        }
        async refreshRoutingTable(e) {
            this.routingTableRefresh.refreshTable(!0, e);
        }
    }
    var iS;
    (function(n) {
        n[n.SEND_QUERY = 0] = "SEND_QUERY", n[n.PEER_RESPONSE = 1] = "PEER_RESPONSE", n[n.FINAL_PEER = 2] = "FINAL_PEER", n[n.QUERY_ERROR = 3] = "QUERY_ERROR", n[n.PROVIDER = 4] = "PROVIDER", n[n.VALUE = 5] = "VALUE", n[n.ADD_PEER = 6] = "ADD_PEER", n[n.DIAL_PEER = 7] = "DIAL_PEER", n[n.PATH_ENDED = 8] = "PATH_ENDED";
    })(iS || (iS = {}));
    function Yme(n = {}) {
        return (e)=>new Gme(e, n);
    }
    class Wme extends Error {
        static name = "MuxerClosedError";
        constructor(e = "The muxer is closed"){
            super(e), this.name = "MuxerClosedError";
        }
    }
    let oS = class extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    };
    const jme = Symbol.for("@libp2p/service-capabilities");
    var Et;
    (function(n) {
        n[n.NEW_STREAM = 0] = "NEW_STREAM", n[n.MESSAGE_RECEIVER = 1] = "MESSAGE_RECEIVER", n[n.MESSAGE_INITIATOR = 2] = "MESSAGE_INITIATOR", n[n.CLOSE_RECEIVER = 3] = "CLOSE_RECEIVER", n[n.CLOSE_INITIATOR = 4] = "CLOSE_INITIATOR", n[n.RESET_RECEIVER = 5] = "RESET_RECEIVER", n[n.RESET_INITIATOR = 6] = "RESET_INITIATOR";
    })(Et || (Et = {}));
    const K8 = Object.freeze({
        0: "NEW_STREAM",
        1: "MESSAGE_RECEIVER",
        2: "MESSAGE_INITIATOR",
        3: "CLOSE_RECEIVER",
        4: "CLOSE_INITIATOR",
        5: "RESET_RECEIVER",
        6: "RESET_INITIATOR"
    }), aS = Object.freeze({
        NEW_STREAM: Et.NEW_STREAM,
        MESSAGE: Et.MESSAGE_INITIATOR,
        CLOSE: Et.CLOSE_INITIATOR,
        RESET: Et.RESET_INITIATOR
    }), Xme = Object.freeze({
        MESSAGE: Et.MESSAGE_RECEIVER,
        CLOSE: Et.CLOSE_RECEIVER,
        RESET: Et.RESET_RECEIVER
    }), G8 = 1 << 20, XP = 4 << 20;
    class Jme {
        _buffer;
        _headerInfo;
        _maxMessageSize;
        _maxUnprocessedMessageQueueSize;
        constructor(e = G8, t = XP){
            this._buffer = new Re, this._headerInfo = null, this._maxMessageSize = e, this._maxUnprocessedMessageQueueSize = t;
        }
        write(e) {
            if (e == null || e.length === 0) return [];
            if (this._buffer.append(e), this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) throw new oS("Unprocessed message queue size too large!");
            const t = [];
            for(; this._buffer.length !== 0;){
                if (this._headerInfo == null) try {
                    this._headerInfo = this._decodeHeader(this._buffer);
                } catch (f) {
                    if (f.name === "InvalidMessageError") throw f;
                    break;
                }
                const { id: r, type: s, length: i, offset: l } = this._headerInfo;
                if (this._buffer.length - l < i) break;
                const h = {
                    id: r,
                    type: s
                };
                (s === Et.NEW_STREAM || s === Et.MESSAGE_INITIATOR || s === Et.MESSAGE_RECEIVER) && (h.data = this._buffer.sublist(l, l + i)), t.push(h), this._buffer.consume(l + i), this._headerInfo = null;
            }
            return t;
        }
        _decodeHeader(e) {
            const { value: t, offset: r } = cS(e), { value: s, offset: i } = cS(e, r), l = t & 7;
            if (K8[l] == null) throw new Error(`Invalid type received: ${l}`);
            if (s > this._maxMessageSize) throw new oS("Message size too large");
            return {
                id: t >> 3,
                type: l,
                offset: r + i,
                length: s
            };
        }
    }
    const Zme = 128, lS = 127;
    function cS(n, e = 0) {
        let t = 0, r = 0, s = e, i;
        const l = n.length;
        do {
            if (s >= l || r > 49) throw e = 0, new RangeError("Could not decode varint");
            i = n.get(s++), t += r < 28 ? (i & lS) << r : (i & lS) * Math.pow(2, r), r += 7;
        }while (i >= Zme);
        return e = s - e, {
            value: t,
            offset: e
        };
    }
    const wy = 10 * 1024;
    class e3e {
        _pool;
        _poolOffset;
        constructor(){
            this._pool = Wn(wy), this._poolOffset = 0;
        }
        write(e, t) {
            const r = this._pool;
            let s = this._poolOffset;
            zr(e.id << 3 | e.type, r, s), s += be(e.id << 3 | e.type), (e.type === Et.NEW_STREAM || e.type === Et.MESSAGE_INITIATOR || e.type === Et.MESSAGE_RECEIVER) && e.data != null ? (zr(e.data.length, r, s), s += be(e.data.length)) : (zr(0, r, s), s += be(0));
            const i = r.subarray(this._poolOffset, s);
            wy - s < 100 ? (this._pool = Wn(wy), this._poolOffset = 0) : this._poolOffset = s, t.append(i), (e.type === Et.NEW_STREAM || e.type === Et.MESSAGE_INITIATOR || e.type === Et.MESSAGE_RECEIVER) && e.data != null && t.append(e.data);
        }
    }
    const t3e = new e3e;
    function W0(n) {
        const e = new Re;
        return t3e.write(n, e), e;
    }
    class n3e extends P6 {
        streamId;
        types;
        maxDataSize;
        muxer;
        constructor(e){
            super(e), this.types = e.direction === "outbound" ? aS : Xme, this.maxDataSize = e.maxDataSize, this.muxer = e.muxer, this.streamId = parseInt(this.id.substring(1)), e.direction === "outbound" && queueMicrotask(()=>{
                this.muxer.send(W0({
                    id: this.streamId,
                    type: aS.NEW_STREAM,
                    data: new Re(re(this.id))
                }));
            });
        }
        sendData(e) {
            const t = new Re, r = e.byteLength;
            for(; e.byteLength > 0;){
                const s = Math.min(e.byteLength, this.maxDataSize), i = e.sublist(0, s);
                e = e.sublist(s), t.append(W0({
                    id: this.streamId,
                    type: this.types.MESSAGE,
                    data: i
                }));
            }
            return {
                sentBytes: r,
                canSendMore: this.muxer.send(t)
            };
        }
        sendReset() {
            return this.muxer.send(W0({
                id: this.streamId,
                type: this.types.RESET
            }));
        }
        async sendCloseWrite(e) {
            this.muxer.send(W0({
                id: this.streamId,
                type: this.types.CLOSE
            })), e?.signal?.throwIfAborted();
        }
        async sendCloseRead(e) {
            e?.signal?.throwIfAborted();
        }
        sendPause() {}
        sendResume() {}
    }
    function r3e(n) {
        const { id: e, muxer: t, direction: r, maxMsgSize: s = G8 } = n;
        return new n3e({
            ...n,
            id: r === "outbound" ? `i${e}` : `r${e}`,
            direction: r,
            maxDataSize: s,
            muxer: t,
            log: n.log.newScope(`${r}:${e}`),
            protocol: ""
        });
    }
    const s3e = 5;
    function i3e(n) {
        const e = {
            ...n,
            type: `${K8[n.type]} (${n.type})`
        };
        return n.type === Et.NEW_STREAM && (e.data = L(n.data.subarray())), (n.type === Et.MESSAGE_INITIATOR || n.type === Et.MESSAGE_RECEIVER) && (e.data = L(n.data.subarray(), "base16")), e;
    }
    class o3e extends B6 {
        _streamId;
        rateLimiter;
        maxMessageSize;
        maxUnprocessedMessageQueueSize;
        decoder;
        constructor(e, t){
            super(e, {
                ...t,
                protocol: "/mplex/6.7.0",
                name: "mplex"
            }), this._streamId = 0, this.maxMessageSize = t.maxMessageSize ?? G8, this.maxUnprocessedMessageQueueSize = t.maxUnprocessedMessageQueueSize ?? XP, this.decoder = new Jme(this.maxMessageSize, this.maxUnprocessedMessageQueueSize), this.rateLimiter = new WC({
                points: t.disconnectThreshold ?? s3e,
                duration: 1
            });
        }
        onData(e) {
            for (const t of this.decoder.write(e))this.handleMessage(t);
        }
        onCreateStream(e) {
            if (this.status !== "open") throw new Wme("Muxer already closed");
            const t = this._streamId++;
            return this._newStream(t, "outbound", e);
        }
        _newStream(e, t, r) {
            return this.log("new %s stream %s", t, e), r3e({
                ...r,
                id: e,
                direction: t,
                maxMsgSize: this.maxMessageSize,
                log: this.log,
                muxer: this
            });
        }
        handleMessage(e) {
            if (this.log.enabled && this.log.trace("incoming message", i3e(e)), e.type === Et.NEW_STREAM) {
                try {
                    this.rateLimiter.consume("new-stream", 1);
                } catch  {
                    this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"), this.abort(new Error("Too many open streams"));
                    return;
                }
                const s = this._newStream(e.id, "inbound", this.streamOptions);
                this.onRemoteStream(s);
                return;
            }
            const t = `${(e.type & 1) === 1 ? "i" : "r"}${e.id}`, r = this.streams.find((s)=>s.id === t);
            if (r == null) {
                this.log("missing stream %s for message type %s", t, K8[e.type]);
                try {
                    this.rateLimiter.consume("missing-stream", 1);
                } catch  {
                    this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection"), this.abort(new Error("Too many messages for missing streams"));
                    return;
                }
                return;
            }
            try {
                switch(e.type){
                    case Et.MESSAGE_INITIATOR:
                    case Et.MESSAGE_RECEIVER:
                        r.onData(e.data);
                        break;
                    case Et.CLOSE_INITIATOR:
                    case Et.CLOSE_RECEIVER:
                        r.onRemoteCloseWrite();
                        break;
                    case Et.RESET_INITIATOR:
                    case Et.RESET_RECEIVER:
                        r.onRemoteReset();
                        break;
                    default:
                        this.log("unknown message type");
                }
            } catch (s) {
                this.log.error("error while processing message - %e", s), r.abort(s);
            }
        }
    }
    class a3e {
        protocol = "/mplex/6.7.0";
        _init;
        constructor(e = {}){
            this._init = e;
        }
        [Symbol.toStringTag] = "@libp2p/mplex";
        [jme] = [
            "@libp2p/stream-multiplexing"
        ];
        createStreamMuxer(e) {
            return new o3e(e, {
                ...this._init
            });
        }
    }
    function l3e(n = {}) {
        return ()=>new a3e(n);
    }
    class c3e extends Error {
        static name = "ProtocolError";
        constructor(e = "Protocol error"){
            super(e), this.name = "ProtocolError";
        }
    }
    class u3e extends Error {
        static name = "TimeoutError";
        constructor(e = "Timed out"){
            super(e), this.name = "TimeoutError";
        }
    }
    const h3e = Symbol.for("@libp2p/service-capabilities"), uS = 32, d3e = "1.0.0", f3e = "ping", p3e = "ipfs", g3e = 1e4, m3e = 2, y3e = 1;
    class w3e {
        protocol;
        components;
        started;
        timeout;
        maxInboundStreams;
        maxOutboundStreams;
        runOnLimitedConnection;
        constructor(e, t = {}){
            this.components = e, this.started = !1, this.protocol = `/${t.protocolPrefix ?? p3e}/${f3e}/${d3e}`, this.timeout = t.timeout ?? g3e, this.maxInboundStreams = t.maxInboundStreams ?? m3e, this.maxOutboundStreams = t.maxOutboundStreams ?? y3e, this.runOnLimitedConnection = t.runOnLimitedConnection ?? !0, this.handlePing = this.handlePing.bind(this);
        }
        [Symbol.toStringTag] = "@libp2p/ping";
        [h3e] = [
            "@libp2p/ping"
        ];
        async start() {
            await this.components.registrar.handle(this.protocol, this.handlePing, {
                maxInboundStreams: this.maxInboundStreams,
                maxOutboundStreams: this.maxOutboundStreams,
                runOnLimitedConnection: this.runOnLimitedConnection
            }), this.started = !0;
        }
        async stop() {
            await this.components.registrar.unhandle(this.protocol), this.started = !1;
        }
        isStarted() {
            return this.started;
        }
        async handlePing(e, t) {
            const r = e.log.newScope("ping");
            r.trace("ping from %p", t.remotePeer);
            const s = AbortSignal.timeout(this.timeout);
            s.addEventListener("abort", ()=>{
                e.abort(new u3e("Ping timed out"));
            });
            const i = Date.now();
            for await (const l of e){
                if (e.status !== "open") {
                    r("stream status changed to %s", e.status);
                    break;
                }
                e.send(l) || (r("waiting for stream to drain"), await an(e, "drain", {
                    rejectionEvents: [
                        "close"
                    ],
                    signal: s
                }), r("stream drained"));
            }
            r("ping from %p complete in %dms", t.remotePeer, Date.now() - i), await e.close({
                signal: s
            });
        }
        async ping(e, t = {}) {
            const r = Go(uS), s = await this.components.connectionManager.openStream(e, this.protocol, {
                runOnLimitedConnection: this.runOnLimitedConnection,
                ...t
            }), i = s.log.newScope("ping");
            try {
                const l = Date.now(), u = Promise.withResolvers(), h = new Re, f = (p)=>{
                    if (h.append(p.data), h.byteLength === uS) {
                        s.removeEventListener("message", f);
                        const m = Date.now() - l;
                        Promise.all([
                            s.closeRead(t)
                        ]).then(()=>{
                            if (Ee(r, h.subarray())) u.resolve(m);
                            else throw new c3e(`Received wrong ping ack after ${m}ms`);
                        }).catch((w)=>{
                            s.abort(w), u.reject(w);
                        });
                    }
                };
                return s.addEventListener("message", f), s.send(r), await s.close(t), await Xn(u.promise, t.signal);
            } catch (l) {
                throw i.error("error while pinging %o - %e", e, l), s?.abort(l), l;
            } finally{
                s?.close();
            }
        }
    }
    function b3e(n = {}) {
        return (e)=>new w3e(e, n);
    }
    let Su = class extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }, v3e = class extends Error {
        static name = "ConnectionFailedError";
        constructor(e = "Connection failed"){
            super(e), this.name = "ConnectionFailedError";
        }
    };
    class E3e extends Error {
        static name = "StreamResetError";
        constructor(e = "The stream has been reset"){
            super(e), this.name = "StreamResetError";
        }
    }
    class A3e extends Error {
        static name = "StreamStateError";
        constructor(e = "The stream is in an invalid state"){
            super(e), this.name = "StreamStateError";
        }
    }
    let S3e = class extends Error {
        static name = "InvalidMultiaddrError";
        constructor(e = "Invalid multiaddr"){
            super(e), this.name = "InvalidMultiaddrError";
        }
    }, I3e = class extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }, C3e = class extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    };
    class T3e extends Error {
        static name = "InvalidMessageError";
        constructor(e = "Invalid message"){
            super(e), this.name = "InvalidMessageError";
        }
    }
    const JP = Symbol.for("@libp2p/peer-id"), ZP = Symbol.for("@libp2p/transport");
    var hS;
    (function(n) {
        n[n.FATAL_ALL = 0] = "FATAL_ALL", n[n.NO_FATAL = 1] = "NO_FATAL";
    })(hS || (hS = {}));
    const ek = Symbol.for("@libp2p/service-capabilities"), _3e = Symbol.for("@libp2p/service-dependencies"), tk = Symbol.for("nodejs.util.inspect.custom"), x3e = 114;
    let Y8 = class {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [JP] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(x3e, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [tk]() {
            return `PeerId(${this.toString()})`;
        }
    }, D3e = class extends Y8 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }, B3e = class extends Y8 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }, P3e = class extends Y8 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    };
    const k3e = 2336;
    let nk = class {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [tk]() {
            return `PeerId(${this.url})`;
        }
        [JP] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(k3e, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    };
    const R3e = 114, dS = 2336;
    function W8(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return O3e(ge.parse(n));
            throw new Su('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return rk(t);
    }
    function rk(n) {
        if (M3e(n)) return new D3e({
            multihash: n
        });
        if ($3e(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new B3e({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new P3e({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new nk(new URL(t));
        }
        throw new C3e("Supplied PeerID Multihash is invalid");
    }
    function O3e(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== R3e && n.code !== dS) throw new I3e("Supplied PeerID CID is invalid");
        if (n.code === dS) {
            const e = L(n.multihash.digest);
            return new nk(new URL(e));
        }
        return rk(n.multihash);
    }
    function $3e(n) {
        return n.code === nt.code;
    }
    function M3e(n) {
        return n.code === Ut.code;
    }
    let Es = class extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }, bf = class extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }, N3e = class extends Error {
        static name = "InvalidParametersError";
        name = "InvalidParametersError";
    }, L3e = class extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    };
    const U3e = 4, z3e = 6, F3e = 273, V3e = 33, H3e = 41, Q3e = 42, q3e = 43, K3e = 53, G3e = 54, Y3e = 55, W3e = 56, j3e = 132, X3e = 301, J3e = 302, Z3e = 400, sk = 421, eye = 444, tye = 445, nye = 446, rye = 447, sye = 448, iye = 449, oye = 454, aye = 460, lye = 461, cye = 465, ik = 466, uye = 480, hye = 481, dye = 443, fye = 477, pye = 478, gye = 479, mye = 277, yye = 275, wye = 276, bye = 280, vye = 281, ok = 290, Eye = 777;
    function fS(n) {
        return (e)=>L(e, n);
    }
    function pS(n) {
        return (e)=>re(e, n);
    }
    function hd(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function pc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function Aye(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = pc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function Sye(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = pc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function gS(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = hd(t);
        return `${r}:${s}`;
    }
    const ak = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new Es("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, Iye = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = ak(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new Es("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, Cye = function(n) {
        if (n.byteLength !== 4) throw new Es("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, Tye = function(n) {
        if (n.byteLength !== 16) throw new Es("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new Es(`Invalid IPv6 address "${t}"`);
        }
    };
    function _ye(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new Es(`Invalid IPv6 address "${n}"`);
        }
    }
    const by = Object.values(un).map((n)=>n.decoder), xye = (function() {
        let n = by[0].or(by[1]);
        return by.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function Dye(n) {
        return xye.decode(n);
    }
    function Bye(n) {
        return (e)=>n.encoder.encode(e);
    }
    function Pye(n) {
        if (parseInt(n).toString() !== n) throw new bf("Value must be an integer");
    }
    function kye(n) {
        if (n < 0) throw new bf("Value must be a positive integer, or zero");
    }
    function Rye(n) {
        return (e)=>{
            if (e > n) throw new bf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function Oye(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const j0 = Oye(Pye, kye, Rye(65535)), Qn = -1;
    let $ye = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new L3e(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const Iu = new $ye, Mye = [
        {
            code: U3e,
            name: "ip4",
            size: 32,
            valueToBytes: ak,
            bytesToValue: Cye,
            validate: (n)=>{
                if (!Je(n)) throw new bf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: z3e,
            name: "tcp",
            size: 16,
            valueToBytes: pc,
            bytesToValue: hd,
            validate: j0
        },
        {
            code: F3e,
            name: "udp",
            size: 16,
            valueToBytes: pc,
            bytesToValue: hd,
            validate: j0
        },
        {
            code: V3e,
            name: "dccp",
            size: 16,
            valueToBytes: pc,
            bytesToValue: hd,
            validate: j0
        },
        {
            code: H3e,
            name: "ip6",
            size: 128,
            valueToBytes: Iye,
            bytesToValue: Tye,
            stringToValue: _ye,
            validate: (n)=>{
                if (!xn(n)) throw new bf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: Q3e,
            name: "ip6zone",
            size: Qn
        },
        {
            code: q3e,
            name: "ipcidr",
            size: 8,
            bytesToValue: fS("base10"),
            valueToBytes: pS("base10")
        },
        {
            code: K3e,
            name: "dns",
            size: Qn
        },
        {
            code: G3e,
            name: "dns4",
            size: Qn
        },
        {
            code: Y3e,
            name: "dns6",
            size: Qn
        },
        {
            code: W3e,
            name: "dnsaddr",
            size: Qn
        },
        {
            code: j3e,
            name: "sctp",
            size: 16,
            valueToBytes: pc,
            bytesToValue: hd,
            validate: j0
        },
        {
            code: X3e,
            name: "udt"
        },
        {
            code: J3e,
            name: "utp"
        },
        {
            code: Z3e,
            name: "unix",
            size: Qn,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: sk,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Qn,
            bytesToValue: fS("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? pS("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: eye,
            name: "onion",
            size: 96,
            bytesToValue: gS,
            valueToBytes: Aye
        },
        {
            code: tye,
            name: "onion3",
            size: 296,
            bytesToValue: gS,
            valueToBytes: Sye
        },
        {
            code: nye,
            name: "garlic64",
            size: Qn
        },
        {
            code: rye,
            name: "garlic32",
            size: Qn
        },
        {
            code: sye,
            name: "tls"
        },
        {
            code: iye,
            name: "sni",
            size: Qn
        },
        {
            code: oye,
            name: "noise"
        },
        {
            code: aye,
            name: "quic"
        },
        {
            code: lye,
            name: "quic-v1"
        },
        {
            code: cye,
            name: "webtransport"
        },
        {
            code: ik,
            name: "certhash",
            size: Qn,
            bytesToValue: Bye(yn),
            valueToBytes: Dye
        },
        {
            code: uye,
            name: "http"
        },
        {
            code: hye,
            name: "http-path",
            size: Qn,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: dye,
            name: "https"
        },
        {
            code: fye,
            name: "ws"
        },
        {
            code: pye,
            name: "wss"
        },
        {
            code: gye,
            name: "p2p-websocket-star"
        },
        {
            code: mye,
            name: "p2p-stardust"
        },
        {
            code: yye,
            name: "p2p-webrtc-star"
        },
        {
            code: wye,
            name: "p2p-webrtc-direct"
        },
        {
            code: bye,
            name: "webrtc-direct"
        },
        {
            code: vye,
            name: "webrtc"
        },
        {
            code: ok,
            name: "p2p-circuit"
        },
        {
            code: Eye,
            name: "memory",
            size: Qn
        }
    ];
    Mye.forEach((n)=>{
        Iu.addProtocol(n);
    });
    function Nye(n) {
        const e = [];
        let t = 0;
        for(; t < n.length;){
            const r = et(n, t), s = Iu.getProtocol(r), i = be(r), l = Fye(s, n, t + i);
            let u = 0;
            l > 0 && s.size === Qn && (u = be(l));
            const h = i + u + l, f = {
                code: r,
                name: s.name,
                bytes: n.subarray(t, t + h)
            };
            if (l > 0) {
                const p = t + i + u, m = n.subarray(p, p + l);
                f.value = s.bytesToValue?.(m) ?? L(m);
            }
            e.push(f), t += h;
        }
        return e;
    }
    function Lye(n) {
        let e = 0;
        const t = [];
        for (const r of n){
            if (r.bytes == null) {
                const s = Iu.getProtocol(r.code), i = be(r.code);
                let l, u = 0, h = 0;
                r.value != null && (l = s.valueToBytes?.(r.value) ?? re(r.value), u = l.byteLength, s.size === Qn && (h = be(u)));
                const f = new Uint8Array(i + h + u);
                let p = 0;
                dt(r.code, f, p), p += i, l != null && (s.size === Qn && (dt(u, f, p), p += h), f.set(l, p)), r.bytes = f;
            }
            t.push(r.bytes), e += r.bytes.byteLength;
        }
        return xe(t, e);
    }
    function Uye(n) {
        if (n.charAt(0) !== "/") throw new Es('String multiaddr must start with "/"');
        const e = [];
        let t = "protocol", r = "", s = "";
        for(let i = 1; i < n.length; i++){
            const l = n.charAt(i);
            l !== "/" && (t === "protocol" ? s += n.charAt(i) : r += n.charAt(i));
            const u = i === n.length - 1;
            if (l === "/" || u) {
                const h = Iu.getProtocol(s);
                if (t === "protocol") {
                    if (h.size == null || h.size === 0) {
                        e.push({
                            code: h.code,
                            name: h.name
                        }), r = "", s = "", t = "protocol";
                        continue;
                    } else if (u) throw new Es(`Component ${s} was missing value`);
                    t = "value";
                } else if (t === "value") {
                    const f = {
                        code: h.code,
                        name: h.name
                    };
                    if (h.size != null && h.size !== 0) {
                        if (r === "") throw new Es(`Component ${s} was missing value`);
                        f.value = h.stringToValue?.(r) ?? r;
                    }
                    e.push(f), r = "", s = "", t = "protocol";
                }
            }
        }
        if (s !== "" && r !== "") throw new Es("Incomplete multiaddr");
        return e;
    }
    function zye(n) {
        return `/${n.flatMap((e)=>{
            if (e.value == null) return e.name;
            const t = Iu.getProtocol(e.code);
            if (t == null) throw new Es(`Unknown protocol code ${e.code}`);
            return [
                e.name,
                t.valueToString?.(e.value) ?? e.value
            ];
        }).join("/")}`;
    }
    function Fye(n, e, t) {
        return n.size == null || n.size === 0 ? 0 : n.size > 0 ? n.size / 8 : et(e, t);
    }
    const Vye = Symbol.for("nodejs.util.inspect.custom"), lk = Symbol.for("@multiformats/multiaddr");
    function Hye(n) {
        if (n == null && (n = "/"), qye(n)) return n.getComponents();
        if (n instanceof Uint8Array) return Nye(n);
        if (typeof n == "string") return n = n.replace(/\/(\/)+/, "/").replace(/(\/)+$/, ""), n === "" && (n = "/"), Uye(n);
        if (Array.isArray(n)) return n;
        throw new Es("Must be a string, Uint8Array, Component[], or another Multiaddr");
    }
    class gc {
        [lk] = !0;
        #e;
        #t;
        #n;
        constructor(e = "/", t = {}){
            this.#e = Hye(e), t.validate !== !1 && Qye(this);
        }
        get bytes() {
            return this.#n == null && (this.#n = Lye(this.#e)), this.#n;
        }
        toString() {
            return this.#t == null && (this.#t = zye(this.#e)), this.#t;
        }
        toJSON() {
            return this.toString();
        }
        getComponents() {
            return [
                ...this.#e.map((e)=>({
                        ...e
                    }))
            ];
        }
        encapsulate(e) {
            const t = new gc(e);
            return new gc([
                ...this.#e,
                ...t.getComponents()
            ], {
                validate: !1
            });
        }
        decapsulate(e) {
            const t = e.toString(), r = this.toString(), s = r.lastIndexOf(t);
            if (s < 0) throw new N3e(`Address ${this.toString()} does not contain subaddress: ${t}`);
            return new gc(r.slice(0, s), {
                validate: !1
            });
        }
        decapsulateCode(e) {
            let t;
            for(let r = this.#e.length - 1; r > -1; r--)if (this.#e[r].code === e) {
                t = r;
                break;
            }
            return new gc(this.#e.slice(0, t), {
                validate: !1
            });
        }
        equals(e) {
            return Ee(this.bytes, e.bytes);
        }
        [Vye]() {
            return `Multiaddr(${this.toString()})`;
        }
    }
    function Qye(n) {
        n.getComponents().forEach((e)=>{
            const t = Iu.getProtocol(e.code);
            e.value != null && t.validate?.(e.value);
        });
    }
    function qye(n) {
        return !!n?.[lk];
    }
    function j8(n) {
        return new gc(n);
    }
    var fr;
    (function(n) {
        (function(r) {
            r.FIN = "FIN", r.STOP_SENDING = "STOP_SENDING", r.RESET = "RESET", r.FIN_ACK = "FIN_ACK";
        })(n.Flag || (n.Flag = {}));
        let e;
        (function(r) {
            r[r.FIN = 0] = "FIN", r[r.STOP_SENDING = 1] = "STOP_SENDING", r[r.RESET = 2] = "RESET", r[r.FIN_ACK = 3] = "FIN_ACK";
        })(e || (e = {})), (function(r) {
            r.codec = ()=>vr(e);
        })(n.Flag || (n.Flag = {}));
        let t;
        n.codec = ()=>(t == null && (t = Le((r, s, i = {})=>{
                i.lengthDelimited !== !1 && s.fork(), r.flag != null && (s.uint32(8), n.Flag.codec().encode(r.flag, s)), r.message != null && (s.uint32(18), s.bytes(r.message)), i.lengthDelimited !== !1 && s.ldelim();
            }, (r, s, i = {})=>{
                const l = {}, u = s == null ? r.len : r.pos + s;
                for(; r.pos < u;){
                    const h = r.uint32();
                    switch(h >>> 3){
                        case 1:
                            {
                                l.flag = n.Flag.codec().decode(r);
                                break;
                            }
                        case 2:
                            {
                                l.message = r.bytes();
                                break;
                            }
                        default:
                            {
                                r.skipType(h & 7);
                                break;
                            }
                    }
                }
                return l;
            })), t), n.encode = (r)=>Ne(r, n.codec()), n.decode = (r, s)=>Me(r, n.codec(), s);
    })(fr || (fr = {}));
    const Kye = [
        "stun:stun.l.google.com:19302",
        "stun:global.stun.twilio.com:3478",
        "stun:stun.cloudflare.com:3478",
        "stun:stun.services.mozilla.com:3478"
    ], mS = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"), Gye = "libp2p+webrtc+v1/", Yye = 2 * 1024 * 1024, zg = 16 * 1024;
    function Wye(n = zg) {
        const e = be(n - be(n)), t = 1 + be(Object.keys(fr.Flag).length - 1), r = 1, s = n - e - t - r, i = be(s);
        return e + t + r + i;
    }
    const jye = Wye(), Xye = 1e4, ck = "/webrtc", U4 = "/webrtc-signaling/0.0.1", Jye = 8, X8 = 1024 * 1024 * 4;
    let Zye = class extends Error {
        name = "InvalidMessageLengthError";
        code = "ERR_INVALID_MSG_LENGTH";
    }, uk = class extends Error {
        name = "InvalidDataLengthError";
        code = "ERR_MSG_DATA_TOO_LONG";
    }, e4e = class extends Error {
        name = "InvalidDataLengthLengthError";
        code = "ERR_MSG_LENGTH_TOO_LONG";
    }, yS = class extends Error {
        name = "UnexpectedEOFError";
        code = "ERR_UNEXPECTED_EOF";
    };
    function hk(n) {
        return n[Symbol.asyncIterator] != null;
    }
    function dk(n, e) {
        if (n.byteLength > e) throw new uk("Message length too long");
    }
    const Fg = (n)=>{
        const e = be(n), t = Wn(e);
        return zr(n, t), Fg.bytes = e, t;
    };
    Fg.bytes = 0;
    function z4(n, e) {
        e = e ?? {};
        const t = e.lengthEncoder ?? Fg, r = e?.maxDataLength ?? X8;
        function* s(i) {
            dk(i, r);
            const l = t(i.byteLength);
            l instanceof Uint8Array ? yield l : yield* l, i instanceof Uint8Array ? yield i : yield* i;
        }
        return hk(n) ? (async function*() {
            for await (const i of n)yield* s(i);
        })() : (function*() {
            for (const i of n)yield* s(i);
        })();
    }
    z4.single = (n, e)=>{
        e = e ?? {};
        const t = e.lengthEncoder ?? Fg, r = e?.maxDataLength ?? X8;
        return dk(n, r), new Re(t(n.byteLength), n);
    };
    var _a;
    (function(n) {
        n[n.LENGTH = 0] = "LENGTH", n[n.DATA = 1] = "DATA";
    })(_a || (_a = {}));
    const J8 = (n)=>{
        const e = et(n);
        return J8.bytes = be(e), e;
    };
    J8.bytes = 0;
    function F4(n, e) {
        const t = new Re;
        let r = _a.LENGTH, s = -1;
        const i = e?.lengthDecoder ?? J8, l = e?.maxLengthLength ?? Jye, u = e?.maxDataLength ?? X8;
        function* h() {
            for(; t.byteLength > 0;){
                if (r === _a.LENGTH) try {
                    if (s = i(t), s < 0) throw new Zye("Invalid message length");
                    if (s > u) throw new uk("Message length too long");
                    const f = i.bytes;
                    t.consume(f), e?.onLength != null && e.onLength(s), r = _a.DATA;
                } catch (f) {
                    if (f instanceof RangeError) {
                        if (t.byteLength > l) throw new e4e("Message length length too long");
                        break;
                    }
                    throw f;
                }
                if (r === _a.DATA) {
                    if (t.byteLength < s) break;
                    const f = t.sublist(0, s);
                    t.consume(s), e?.onData != null && e.onData(f), yield f, r = _a.LENGTH;
                }
            }
        }
        return hk(n) ? (async function*() {
            for await (const f of n)t.append(f), yield* h();
            if (t.byteLength > 0) throw new yS("Unexpected end of input");
        })() : (function*() {
            for (const f of n)t.append(f), yield* h();
            if (t.byteLength > 0) throw new yS("Unexpected end of input");
        })();
    }
    F4.fromReader = (n, e)=>{
        let t = 1;
        const r = (async function*() {
            for(;;)try {
                const { done: i, value: l } = await n.next(t);
                if (i === !0) return;
                l != null && (yield l);
            } catch (i) {
                if (i.code === "ERR_UNDER_READ") return {
                    done: !0,
                    value: null
                };
                throw i;
            } finally{
                t = 1;
            }
        })();
        return F4(r, {
            ...e ?? {},
            onLength: (i)=>{
                t = i;
            }
        });
    };
    var wS = function(n, e, t) {
        if (t || arguments.length === 2) for(var r = 0, s = e.length, i; r < s; r++)(i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
        return n.concat(i || Array.prototype.slice.call(e));
    }, t4e = (function() {
        function n(e, t, r) {
            this.name = e, this.version = t, this.os = r, this.type = "browser";
        }
        return n;
    })(), n4e = (function() {
        function n(e) {
            this.version = e, this.type = "node", this.name = "node", this.os = ai.platform;
        }
        return n;
    })(), r4e = (function() {
        function n(e, t, r, s) {
            this.name = e, this.version = t, this.os = r, this.bot = s, this.type = "bot-device";
        }
        return n;
    })(), s4e = (function() {
        function n() {
            this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
        }
        return n;
    })(), i4e = (function() {
        function n() {
            this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
        }
        return n;
    })(), o4e = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, a4e = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, bS = 3, l4e = [
        [
            "aol",
            /AOLShield\/([0-9\._]+)/
        ],
        [
            "edge",
            /Edge\/([0-9\._]+)/
        ],
        [
            "edge-ios",
            /EdgiOS\/([0-9\._]+)/
        ],
        [
            "yandexbrowser",
            /YaBrowser\/([0-9\._]+)/
        ],
        [
            "kakaotalk",
            /KAKAOTALK\s([0-9\.]+)/
        ],
        [
            "samsung",
            /SamsungBrowser\/([0-9\.]+)/
        ],
        [
            "silk",
            /\bSilk\/([0-9._-]+)\b/
        ],
        [
            "miui",
            /MiuiBrowser\/([0-9\.]+)$/
        ],
        [
            "beaker",
            /BeakerBrowser\/([0-9\.]+)/
        ],
        [
            "edge-chromium",
            /EdgA?\/([0-9\.]+)/
        ],
        [
            "chromium-webview",
            /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
        ],
        [
            "chrome",
            /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
        ],
        [
            "phantomjs",
            /PhantomJS\/([0-9\.]+)(:?\s|$)/
        ],
        [
            "crios",
            /CriOS\/([0-9\.]+)(:?\s|$)/
        ],
        [
            "firefox",
            /Firefox\/([0-9\.]+)(?:\s|$)/
        ],
        [
            "fxios",
            /FxiOS\/([0-9\.]+)/
        ],
        [
            "opera-mini",
            /Opera Mini.*Version\/([0-9\.]+)/
        ],
        [
            "opera",
            /Opera\/([0-9\.]+)(?:\s|$)/
        ],
        [
            "opera",
            /OPR\/([0-9\.]+)(:?\s|$)/
        ],
        [
            "pie",
            /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/
        ],
        [
            "pie",
            /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/
        ],
        [
            "netfront",
            /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/
        ],
        [
            "ie",
            /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/
        ],
        [
            "ie",
            /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/
        ],
        [
            "ie",
            /MSIE\s(7\.0)/
        ],
        [
            "bb10",
            /BB10;\sTouch.*Version\/([0-9\.]+)/
        ],
        [
            "android",
            /Android\s([0-9\.]+)/
        ],
        [
            "ios",
            /Version\/([0-9\._]+).*Mobile.*Safari.*/
        ],
        [
            "safari",
            /Version\/([0-9\._]+).*Safari/
        ],
        [
            "facebook",
            /FB[AS]V\/([0-9\.]+)/
        ],
        [
            "instagram",
            /Instagram\s([0-9\.]+)/
        ],
        [
            "ios-webview",
            /AppleWebKit\/([0-9\.]+).*Mobile/
        ],
        [
            "ios-webview",
            /AppleWebKit\/([0-9\.]+).*Gecko\)$/
        ],
        [
            "curl",
            /^curl\/([0-9\.]+)$/
        ],
        [
            "searchbot",
            o4e
        ]
    ], vS = [
        [
            "iOS",
            /iP(hone|od|ad)/
        ],
        [
            "Android OS",
            /Android/
        ],
        [
            "BlackBerry OS",
            /BlackBerry|BB10/
        ],
        [
            "Windows Mobile",
            /IEMobile/
        ],
        [
            "Amazon OS",
            /Kindle/
        ],
        [
            "Windows 3.11",
            /Win16/
        ],
        [
            "Windows 95",
            /(Windows 95)|(Win95)|(Windows_95)/
        ],
        [
            "Windows 98",
            /(Windows 98)|(Win98)/
        ],
        [
            "Windows 2000",
            /(Windows NT 5.0)|(Windows 2000)/
        ],
        [
            "Windows XP",
            /(Windows NT 5.1)|(Windows XP)/
        ],
        [
            "Windows Server 2003",
            /(Windows NT 5.2)/
        ],
        [
            "Windows Vista",
            /(Windows NT 6.0)/
        ],
        [
            "Windows 7",
            /(Windows NT 6.1)/
        ],
        [
            "Windows 8",
            /(Windows NT 6.2)/
        ],
        [
            "Windows 8.1",
            /(Windows NT 6.3)/
        ],
        [
            "Windows 10",
            /(Windows NT 10.0)/
        ],
        [
            "Windows ME",
            /Windows ME/
        ],
        [
            "Windows CE",
            /Windows CE|WinCE|Microsoft Pocket Internet Explorer/
        ],
        [
            "Open BSD",
            /OpenBSD/
        ],
        [
            "Sun OS",
            /SunOS/
        ],
        [
            "Chrome OS",
            /CrOS/
        ],
        [
            "Linux",
            /(Linux)|(X11)/
        ],
        [
            "Mac OS",
            /(Mac_PowerPC)|(Macintosh)/
        ],
        [
            "QNX",
            /QNX/
        ],
        [
            "BeOS",
            /BeOS/
        ],
        [
            "OS/2",
            /OS\/2/
        ]
    ];
    function c4e(n) {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new i4e : typeof navigator < "u" ? h4e(navigator.userAgent) : f4e();
    }
    function u4e(n) {
        return n !== "" && l4e.reduce(function(e, t) {
            var r = t[0], s = t[1];
            if (e) return e;
            var i = s.exec(n);
            return !!i && [
                r,
                i
            ];
        }, !1);
    }
    function h4e(n) {
        var e = u4e(n);
        if (!e) return null;
        var t = e[0], r = e[1];
        if (t === "searchbot") return new s4e;
        var s = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
        s ? s.length < bS && (s = wS(wS([], s, !0), p4e(bS - s.length), !0)) : s = [];
        var i = s.join("."), l = d4e(n), u = a4e.exec(n);
        return u && u[1] ? new r4e(t, i, l, u[1]) : new t4e(t, i, l);
    }
    function d4e(n) {
        for(var e = 0, t = vS.length; e < t; e++){
            var r = vS[e], s = r[0], i = r[1], l = i.exec(n);
            if (l) return s;
        }
        return null;
    }
    function f4e() {
        var n = typeof ai < "u" && ai.version;
        return n ? new n4e(ai.version.slice(1)) : null;
    }
    function p4e(n) {
        for(var e = [], t = 0; t < n; t++)e.push("0");
        return e;
    }
    const ES = c4e(), fk = ES != null && ES.name === "firefox";
    async function AS(n) {
        return n = n ?? {}, typeof n == "function" && (n = await n()), n.iceServers = n.iceServers ?? Kye.map((e)=>({
                urls: [
                    e
                ]
            })), n;
    }
    const g4e = (n = 32)=>Gye + [
            ...Array(n)
        ].map(()=>mS.at(Math.floor(Math.random() * mS.length))).join("");
    class m4e extends P6 {
        channel;
        incomingData;
        maxBufferedAmount;
        receivedFinAck;
        finAckTimeout;
        constructor(e){
            super({
                ...e,
                maxMessageSize: (e.maxMessageSize ?? zg) - jye
            }), this.channel = e.channel, this.channel.binaryType = "arraybuffer", this.incomingData = Hs(), this.maxBufferedAmount = e.maxBufferedAmount ?? Yye, this.finAckTimeout = e.finAckTimeout ?? Xye, this.channel.onclose = ()=>{
                this.log.trace("received datachannel close event"), this.onRemoteCloseWrite(), this.onTransportClosed();
            }, this.channel.onerror = (r)=>{
                const s = r.error;
                this.log.trace("received datachannel error event - %e", s), this.abort(s);
            }, this.channel.onmessage = async (r)=>{
                this.log("incoming message %d bytes", r.data.byteLength);
                const { data: s } = r;
                s === null || s.byteLength === 0 || this.incomingData.push(new Uint8Array(s, 0, s.byteLength));
            }, this.channel.bufferedAmountLowThreshold = 0, this.channel.onbufferedamountlow = ()=>{
                this.writableNeedsDrain && this.safeDispatchEvent("drain");
            }, Promise.resolve().then(async ()=>{
                for await (const r of F4(this.incomingData))this.processIncomingProtobuf(r);
            }).catch((r)=>{
                this.log.error("error processing incoming data channel messages - %e", r);
            });
            const t = ()=>{
                this.channel.readyState === "open" && (this.log.trace("stream closed, closing underlying datachannel"), this.channel.close());
            };
            this.addEventListener("close", t), this.channel.readyState !== "open" && (this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState), an(this.channel, "open", {
                rejectionEvents: [
                    "close",
                    "error"
                ]
            }).then(()=>{
                this.log('channel ready state is now "%s", dispatching drain', this.channel.readyState), this.safeDispatchEvent("drain");
            }).catch((r)=>{
                this.abort(r.error ?? r);
            }));
        }
        sendNewStream() {}
        _sendMessage(e) {
            if (this.channel.readyState !== "open") throw new A3e(`Invalid datachannel state - ${this.channel.readyState}`);
            if (this.log.trace('sending message, channel state "%s"', this.channel.readyState), fk) {
                this.channel.send(e.subarray());
                return;
            }
            for (const t of e)this.channel.send(t);
        }
        sendData(e) {
            return this.channel.readyState !== "open" ? {
                sentBytes: 0,
                canSendMore: !1
            } : (this._sendMessage(z4.single(fr.encode({
                message: e.subarray()
            }))), {
                sentBytes: e.byteLength,
                canSendMore: this.channel.bufferedAmount < this.maxBufferedAmount
            });
        }
        sendReset(e) {
            try {
                this.log.error("sending reset - %e", e), this._sendFlag(fr.Flag.RESET), this.receivedFinAck?.reject(e);
            } catch (t) {
                this.log.error("failed to send reset - %e", t);
            }
        }
        async sendCloseWrite(e) {
            this._sendFlag(fr.Flag.FIN), e?.signal?.throwIfAborted(), this.receivedFinAck = Promise.withResolvers();
            const t = e?.signal ?? AbortSignal.timeout(this.finAckTimeout), r = [
                an(this.channel, "close", {
                    signal: t
                }),
                an(this.channel, "error", {
                    signal: t
                })
            ];
            await Promise.any([
                Xn(this.receivedFinAck.promise, t),
                ...r
            ]).finally(()=>{
                r.forEach((s)=>s.cancel());
            });
        }
        async sendCloseRead(e) {
            this._sendFlag(fr.Flag.STOP_SENDING), e?.signal?.throwIfAborted();
        }
        processIncomingProtobuf(e) {
            const t = fr.decode(e);
            t.message != null && (this.readStatus === "readable" || this.readStatus === "paused") && this.onData(new Re(t.message)), t.flag !== void 0 && (this.log.trace('incoming flag %s, write status "%s", read status "%s"', t.flag, this.writeStatus, this.readStatus), t.flag === fr.Flag.FIN && (this._sendFlag(fr.Flag.FIN_ACK), this.onRemoteCloseWrite()), t.flag === fr.Flag.RESET && (this.receivedFinAck?.reject(new E3e("The stream was reset")), this.onRemoteReset()), t.flag === fr.Flag.STOP_SENDING && this.onRemoteCloseRead(), t.flag === fr.Flag.FIN_ACK && this.receivedFinAck?.resolve());
        }
        _sendFlag(e) {
            if (this.channel.readyState !== "open") return this.log.trace('not sending flag %s because channel is "%s" and not "open"', e.toString(), this.channel.readyState), !1;
            this.log.trace("sending flag %s", e.toString());
            const t = fr.encode({
                flag: e
            }), r = z4.single(t);
            try {
                return this._sendMessage(r), !0;
            } catch (s) {
                this.log.error("could not send flag %s - %e", e.toString(), s);
            }
            return !1;
        }
        sendPause() {}
        sendResume() {}
    }
    function V4(n) {
        const { channel: e, direction: t, isHandshake: r } = n;
        return new m4e({
            ...n,
            id: `${e.id}`,
            log: n.log.newScope(`${r === !0 ? "handshake" : t}:${e.id}`),
            protocol: ""
        });
    }
    class Z8 {
        protocol;
        peerConnection;
        metrics;
        dataChannelOptions;
        earlyDataChannels;
        constructor(e){
            this.onEarlyDataChannel = this.onEarlyDataChannel.bind(this), this.peerConnection = e.peerConnection, this.metrics = e.metrics, this.protocol = e.protocol ?? ck, this.dataChannelOptions = e.dataChannelOptions ?? {}, this.peerConnection.addEventListener("datachannel", this.onEarlyDataChannel), this.earlyDataChannels = [];
        }
        onEarlyDataChannel(e) {
            this.earlyDataChannels.push(e.channel);
        }
        createStreamMuxer(e) {
            return this.peerConnection.removeEventListener("datachannel", this.onEarlyDataChannel), new y4e(e, {
                peerConnection: this.peerConnection,
                dataChannelOptions: this.dataChannelOptions,
                metrics: this.metrics,
                protocol: this.protocol,
                earlyDataChannels: this.earlyDataChannels
            });
        }
    }
    class y4e extends B6 {
        peerConnection;
        dataChannelOptions;
        constructor(e, t){
            super(e, {
                ...t,
                name: "muxer"
            }), this.peerConnection = t.peerConnection, this.protocol = t.protocol ?? ck, this.dataChannelOptions = t.dataChannelOptions ?? {}, this.peerConnection.ondatachannel = ({ channel: r })=>{
                this.onDataChannel(r);
            }, queueMicrotask(()=>{
                if (this.status !== "open") {
                    t.earlyDataChannels.forEach((r)=>{
                        r.close();
                    });
                    return;
                }
                t.earlyDataChannels.forEach((r)=>{
                    this.onDataChannel(r);
                });
            });
        }
        onDataChannel(e) {
            if (this.log("incoming datachannel with channel id %d, protocol %s and status %s", e.id, e.protocol, e.readyState), e.label === "init") {
                this.log.trace("closing init channel %d", e.id), e.close();
                return;
            }
            const t = V4({
                ...this.streamOptions,
                ...this.dataChannelOptions,
                channel: e,
                direction: "inbound",
                log: this.log
            });
            this.onRemoteStream(t);
        }
        async onCreateStream(e) {
            const t = this.peerConnection.createDataChannel("", {});
            return this.log("open channel %d for protocol %s", t.id, e?.protocol), V4({
                ...e,
                ...this.dataChannelOptions,
                channel: t,
                direction: "outbound",
                log: this.log
            });
        }
        onData() {}
    }
    class w4e extends D6 {
        peerConnection;
        constructor(e){
            super(e), this.peerConnection = e.peerConnection;
            const t = e.peerConnection.connectionState;
            this.peerConnection.onconnectionstatechange = ()=>{
                this.log.trace("peer connection state change %s initial state %s", this.peerConnection.connectionState, t), (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") && (this.onTransportClosed(), this.peerConnection.close());
            };
        }
        sendData(e) {
            return {
                sentBytes: e.byteLength,
                canSendMore: !0
            };
        }
        async sendClose(e) {
            this.peerConnection.close(), e?.signal?.throwIfAborted();
        }
        sendReset() {
            this.peerConnection.close();
        }
        sendPause() {}
        sendResume() {}
    }
    const H4 = (n)=>new w4e(n), pk = globalThis.RTCPeerConnection, gk = globalThis.RTCSessionDescription, b4e = globalThis.RTCIceCandidate;
    class Nf extends Error {
        constructor(e){
            super(`WebRTC transport error: ${e}`), this.name = "WebRTCTransportError";
        }
    }
    class Mo extends Nf {
        constructor(e = "SDP handshake failed"){
            super(e), this.name = "SDPHandshakeFailedError";
        }
    }
    class v4e extends Nf {
        constructor(e, t){
            super(`Invalid fingerprint "${e}" within ${t}`), this.name = "WebRTC/InvalidFingerprintError";
        }
    }
    class E4e extends Nf {
        constructor(e){
            super(`A method (${e}) was called though it has been intentionally left unimplemented.`), this.name = "WebRTC/UnimplementedError";
        }
    }
    class A4e extends Nf {
        constructor(e){
            super(`unsupported hash algorithm code: ${e} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `), this.name = "WebRTC/UnsupportedHashAlgorithmError";
        }
    }
    var Ls;
    (function(n) {
        (function(r) {
            r.SDP_OFFER = "SDP_OFFER", r.SDP_ANSWER = "SDP_ANSWER", r.ICE_CANDIDATE = "ICE_CANDIDATE";
        })(n.Type || (n.Type = {}));
        let e;
        (function(r) {
            r[r.SDP_OFFER = 0] = "SDP_OFFER", r[r.SDP_ANSWER = 1] = "SDP_ANSWER", r[r.ICE_CANDIDATE = 2] = "ICE_CANDIDATE";
        })(e || (e = {})), (function(r) {
            r.codec = ()=>vr(e);
        })(n.Type || (n.Type = {}));
        let t;
        n.codec = ()=>(t == null && (t = Le((r, s, i = {})=>{
                i.lengthDelimited !== !1 && s.fork(), r.type != null && (s.uint32(8), n.Type.codec().encode(r.type, s)), r.data != null && (s.uint32(18), s.string(r.data)), i.lengthDelimited !== !1 && s.ldelim();
            }, (r, s, i = {})=>{
                const l = {}, u = s == null ? r.len : r.pos + s;
                for(; r.pos < u;){
                    const h = r.uint32();
                    switch(h >>> 3){
                        case 1:
                            {
                                l.type = n.Type.codec().decode(r);
                                break;
                            }
                        case 2:
                            {
                                l.data = r.string();
                                break;
                            }
                        default:
                            {
                                r.skipType(h & 7);
                                break;
                            }
                    }
                }
                return l;
            })), t), n.encode = (r)=>Ne(r, n.codec()), n.decode = (r, s)=>Me(r, n.codec(), s);
    })(Ls || (Ls = {}));
    const mk = async (n, e, t)=>{
        try {
            const r = Promise.withResolvers();
            for(S4e(n, r);;){
                const s = await Promise.race([
                    r.promise,
                    e.read({
                        signal: t.signal
                    })
                ]);
                if (s == null) {
                    t.signal?.throwIfAborted();
                    break;
                }
                if (s.type !== Ls.Type.ICE_CANDIDATE) throw new T3e("ICE candidate message expected");
                const i = JSON.parse(s.data ?? "null");
                if (i === "" || i === null) {
                    t.onProgress?.(new Be("webrtc:end-of-ice-candidates")), t.log.trace("end-of-candidates received");
                    continue;
                }
                const l = new b4e(i);
                t.log.trace("%s received new ICE candidate %o", t.direction, i);
                try {
                    t.onProgress?.(new Be("webrtc:add-ice-candidate", l.candidate)), await n.addIceCandidate(l);
                } catch (u) {
                    t.log.error("%s bad candidate received %o - %e", t.direction, i, u);
                }
            }
        } catch (r) {
            if (t.log.error("%s error parsing ICE candidate - %e", t.direction, r), t.signal?.aborted === !0 && n.connectionState !== "connected") throw r;
        }
    };
    function S4e(n, e) {
        if (n.connectionState === "connected") {
            e.resolve();
            return;
        }
        n.onconnectionstatechange = (t)=>{
            switch(n.connectionState){
                case "connected":
                    e.resolve();
                    break;
                case "failed":
                case "disconnected":
                case "closed":
                    e.reject(new v3e(`RTCPeerConnection connection state became "${n.connectionState}"`));
                    break;
            }
        };
    }
    function yk(n) {
        let e;
        for (const t of n.getComponents())t.name === "p2p" && (e = W8(t.value ?? ""));
        if (e == null) throw new S3e("Remote peerId must be present in multiaddr");
        return e;
    }
    async function I4e({ rtcConfiguration: n, dataChannel: e, signal: t, metrics: r, multiaddr: s, connectionManager: i, transportManager: l, log: u, logger: h, onProgress: f }) {
        const { circuitAddress: p, targetPeer: m } = _4e(s);
        r?.dialerEvents.increment({
            open: !0
        }), u.trace("dialing circuit address: %a", p);
        const w = i.getConnections(m);
        let A;
        w.length === 0 ? (f?.(new Be("webrtc:dial-relay")), A = await l.dial(p, {
            signal: t,
            onProgress: f
        })) : (f?.(new Be("webrtc:reuse-relay-connection")), A = w[0]), f?.(new Be("webrtc:open-signaling-stream"));
        const S = await A.newStream(U4, {
            signal: t,
            runOnLimitedConnection: !0
        }), _ = Jn(S).pb(Ls), I = new pk(n);
        I.addEventListener("connectionstatechange", ()=>{
            I.connectionState === "closed" && I.close();
        });
        const k = new Z8({
            peerConnection: I,
            dataChannelOptions: e
        });
        try {
            const G = I.createDataChannel("init");
            I.onicecandidate = ({ candidate: F })=>{
                if (I.connectionState === "connected") {
                    u.trace("ignore new ice candidate as peer connection is already connected");
                    return;
                }
                if (F == null || F?.candidate === "") {
                    u.trace("initiator detected end of ICE candidates");
                    return;
                }
                const $ = JSON.stringify(F?.toJSON() ?? null);
                u.trace("initiator sending ICE candidate %o", F), _.write({
                    type: Ls.Type.ICE_CANDIDATE,
                    data: $
                }, {
                    signal: t
                }).catch((Y)=>{
                    u.error("error sending ICE candidate - %e", Y);
                });
            }, I.onicecandidateerror = (F)=>{
                u.error("initiator ICE candidate error", F);
            };
            const P = await I.createOffer().catch((F)=>{
                throw u.error("could not execute createOffer - %e", F), new Mo("Failed to set createOffer");
            });
            u.trace("initiator send SDP offer %s", P.sdp), f?.(new Be("webrtc:send-sdp-offer")), await _.write({
                type: Ls.Type.SDP_OFFER,
                data: P.sdp
            }, {
                signal: t
            }), await I.setLocalDescription(P).catch((F)=>{
                throw u.error("could not execute setLocalDescription - %e", F), new Mo("Failed to set localDescription");
            }), f?.(new Be("webrtc:read-sdp-answer")), u.trace("initiator read SDP answer");
            const J = await _.read({
                signal: t
            });
            if (J.type !== Ls.Type.SDP_ANSWER) throw new Mo("Remote should send an SDP answer");
            u.trace("initiator received SDP answer %s", J.data);
            const H = new gk({
                type: "answer",
                sdp: J.data
            });
            return await I.setRemoteDescription(H).catch((F)=>{
                throw u.error("could not execute setRemoteDescription - %e", F), new Mo("Failed to set remoteDescription");
            }), u.trace("initiator read candidates until connected"), f?.(new Be("webrtc:read-ice-candidates")), await mk(I, _, {
                direction: "initiator",
                signal: t,
                log: u,
                onProgress: f
            }), u.trace("initiator connected"), G.readyState !== "open" && (u.trace("wait for init channel to open"), await an(G, "open", {
                signal: t
            })), u.trace("closing init channel"), G.close(), u.trace("waiting for init channel to close"), await an(G, "close", {
                signal: t
            }), f?.(new Be("webrtc:close-signaling-stream")), u.trace("closing signaling channel"), await S.close({
                signal: t
            }), u.trace("initiator connected to remote address %s", s), {
                remoteAddress: s,
                peerConnection: I,
                muxerFactory: k
            };
        } catch (G) {
            throw u.error("outgoing signaling error - %e", G), I.close(), S.abort(G), G;
        } finally{
            I.onicecandidate = null, I.onicecandidateerror = null;
        }
    }
    const SS = Rt(r8.matchers[0], Bt(ok));
    class e5 extends Lt {
        transportManager;
        shutdownController;
        events;
        constructor(e, t){
            super(), this.transportManager = e.transportManager, this.events = e.events, this.shutdownController = t.shutdownController, this.onTransportListening = this.onTransportListening.bind(this);
        }
        async listen() {
            this.events.addEventListener("transport:listening", this.onTransportListening);
        }
        onTransportListening(e) {
            e.detail.getAddrs().filter((r)=>SS.exactMatch(r)).map((r)=>r.encapsulate("/webrtc")).length > 0 && this.safeDispatchEvent("listening");
        }
        getAddrs() {
            return this.transportManager.getListeners().filter((e)=>!(e instanceof e5)).map((e)=>e.getAddrs().filter((t)=>SS.exactMatch(t)).map((t)=>t.encapsulate("/webrtc"))).flat();
        }
        updateAnnounceAddrs() {}
        async close() {
            this.events.removeEventListener("transport:listening", this.onTransportListening), this.shutdownController.abort(), queueMicrotask(()=>{
                this.safeDispatchEvent("close");
            });
        }
    }
    async function C4e(n, e, { peerConnection: t, signal: r, log: s }) {
        s.trace("new inbound signaling stream");
        const i = Jn(n).pb(Ls);
        try {
            t.onicecandidate = ({ candidate: m })=>{
                if (t.connectionState === "connected") {
                    s.trace("ignore new ice candidate as peer connection is already connected");
                    return;
                }
                if (m == null || m?.candidate === "") {
                    s.trace("recipient detected end of ICE candidates");
                    return;
                }
                const w = JSON.stringify(m?.toJSON() ?? null);
                s.trace("recipient sending ICE candidate %s", w), i.write({
                    type: Ls.Type.ICE_CANDIDATE,
                    data: w
                }, {
                    signal: r
                }).catch((A)=>{
                    s.error("error sending ICE candidate - %e", A);
                });
            }, s.trace("recipient read SDP offer");
            const h = await i.read({
                signal: r
            });
            if (h.type !== Ls.Type.SDP_OFFER) throw new Mo(`expected message type SDP_OFFER, received: ${h.type ?? "undefined"} `);
            s.trace("recipient received SDP offer %s", h.data);
            const f = new gk({
                type: "offer",
                sdp: h.data
            });
            await t.setRemoteDescription(f).catch((m)=>{
                throw s.error("could not execute setRemoteDescription - %e", m), new Mo("Failed to set remoteDescription");
            });
            const p = await t.createAnswer().catch((m)=>{
                throw s.error("could not execute createAnswer - %e", m), new Mo("Failed to create answer");
            });
            s.trace("recipient send SDP answer %s", p.sdp), await i.write({
                type: Ls.Type.SDP_ANSWER,
                data: p.sdp
            }, {
                signal: r
            }), await t.setLocalDescription(p).catch((m)=>{
                throw s.error("could not execute setLocalDescription - %e", m), new Mo("Failed to set localDescription");
            }), s.trace("recipient read candidates until connected"), await mk(t, i, {
                direction: "recipient",
                signal: r,
                log: s
            });
        } catch (h) {
            if (t.connectionState !== "connected") throw s.error("error while handling signaling stream from peer %a - %e", e.remoteAddr, h), t.close(), h;
            s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", e.remoteAddr, h);
        }
        const l = yk(e.remoteAddr), u = j8(`/webrtc/p2p/${l}`);
        return s.trace("recipient connected to remote address %s", u), {
            remoteAddress: u,
            remotePeer: l
        };
    }
    class T4e {
        components;
        init;
        log;
        _started = !1;
        metrics;
        shutdownController;
        constructor(e, t = {}){
            this.components = e, this.init = t, this.log = e.logger.forComponent("libp2p:webrtc"), this.shutdownController = new AbortController, this.shutdownController.signal, e.metrics != null && (this.metrics = {
                dialerEvents: e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
                    label: "event",
                    help: "Total count of WebRTC dialer events by type"
                }),
                listenerEvents: e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
                    label: "event",
                    help: "Total count of WebRTC listener events by type"
                })
            });
        }
        [ZP] = !0;
        [Symbol.toStringTag] = "@libp2p/webrtc";
        [ek] = [
            "@libp2p/transport"
        ];
        [_3e] = [
            "@libp2p/identify",
            "@libp2p/circuit-relay-v2-transport"
        ];
        isStarted() {
            return this._started;
        }
        async start() {
            await this.components.registrar.handle(U4, (e, t)=>{
                const r = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
                this._onProtocol(e, t, r).catch((s)=>{
                    this.log.error("failed to handle incoming connect from %p - %e", t.remotePeer, s);
                }).finally(()=>{
                    r.clear();
                });
            }, {
                runOnLimitedConnection: !0
            }), this._started = !0;
        }
        async stop() {
            await this.components.registrar.unhandle(U4), this._started = !1;
        }
        createListener(e) {
            return new e5(this.components, {
                shutdownController: this.shutdownController
            });
        }
        listenFilter(e) {
            return e.filter(t4.exactMatch);
        }
        dialFilter(e) {
            return this.listenFilter(e);
        }
        async dial(e, t) {
            this.log.trace("dialing address: %a", e);
            const { remoteAddress: r, peerConnection: s, muxerFactory: i } = await I4e({
                rtcConfiguration: await AS(this.init.rtcConfiguration),
                dataChannel: this.init.dataChannel,
                multiaddr: e,
                dataChannelOptions: this.init.dataChannel,
                signal: t.signal,
                connectionManager: this.components.connectionManager,
                transportManager: this.components.transportManager,
                log: this.log,
                logger: this.components.logger,
                onProgress: t.onProgress
            }), l = H4({
                peerConnection: s,
                remoteAddr: r,
                metrics: this.metrics?.dialerEvents,
                direction: "outbound",
                log: this.components.logger.forComponent("libp2p:webrtc:connection")
            }), u = await t.upgrader.upgradeOutbound(l, {
                skipProtection: !0,
                skipEncryption: !0,
                remotePeer: yk(e),
                muxerFactory: i,
                onProgress: t.onProgress,
                signal: t.signal
            });
            return this._closeOnShutdown(s, l), u;
        }
        async _onProtocol(e, t, r) {
            const s = new pk(await AS(this.init.rtcConfiguration));
            s.addEventListener("connectionstatechange", ()=>{
                s.connectionState === "closed" && s.close();
            });
            const i = new Z8({
                peerConnection: s,
                dataChannelOptions: this.init.dataChannel
            });
            try {
                const { remoteAddress: l, remotePeer: u } = await C4e(e, t, {
                    peerConnection: s,
                    signal: r,
                    log: this.log
                });
                await e.close({
                    signal: r
                });
                const h = H4({
                    peerConnection: s,
                    remoteAddr: l,
                    metrics: this.metrics?.listenerEvents,
                    direction: "inbound",
                    log: this.components.logger.forComponent("libp2p:webrtc:connection")
                });
                await this.components.upgrader.upgradeInbound(h, {
                    skipEncryption: !0,
                    skipProtection: !0,
                    remotePeer: u,
                    muxerFactory: i,
                    signal: r
                }), this._closeOnShutdown(s, h);
            } catch (l) {
                throw this.log.error("incoming signaling error - %e", l), s.close(), e.abort(l), l;
            }
        }
        _closeOnShutdown(e, t) {
            const r = ()=>{
                t.close().catch((s)=>{
                    this.log.error("could not close WebRTCMultiaddrConnection - %e", s);
                });
            };
            this.shutdownController.signal.addEventListener("abort", r), e.addEventListener("close", ()=>{
                this.shutdownController.signal.removeEventListener("abort", r);
            });
        }
    }
    function _4e(n) {
        const e = n.getComponents().filter(({ name: r })=>r === "p2p").map(({ value: r })=>r).pop();
        if (e == null) throw new Su("Destination peer id was missing");
        return {
            circuitAddress: j8(n.getComponents().filter(({ name: r })=>r !== "webrtc")),
            targetPeer: W8(e)
        };
    }
    const wk = Object.values(un).map((n)=>n.decoder).reduce((n, e)=>n.or(e)), x4e = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
    function D4e(n) {
        return n?.match(x4e)?.groups?.fingerprint;
    }
    function bk(n) {
        const t = n.getComponents().find((r)=>r.code === ik)?.value;
        if (t === void 0 || t === "") throw new Su(`Couldn't find a certhash component of multiaddr: ${n.toString()}`);
        return t;
    }
    function B4e(n) {
        return kt(wk.decode(n));
    }
    function P4e(n) {
        const e = B4e(bk(n)), t = R4e(e.code), r = e.digest.reduce((i, l)=>i + l.toString(16).padStart(2, "0"), ""), s = r.match(/.{1,2}/g);
        if (s == null) throw new v4e(r, n.toString());
        return `${t} ${s.join(":").toUpperCase()}`;
    }
    function k4e(n) {
        const e = n.split(":").map((s)=>parseInt(s, 16)), t = Uint8Array.from(e), r = jo(Ut.code, t);
        return j8(`/certhash/${yn.encode(r.bytes)}`);
    }
    function R4e(n) {
        switch(n){
            case 17:
                return "sha-1";
            case 18:
                return "sha-256";
            case 19:
                return "sha-512";
            default:
                throw new A4e(n);
        }
    }
    function O4e(n, e) {
        const { host: t, port: r, type: s } = Xe(n);
        if (s !== "ip4" && s !== "ip6") throw new Su(`Multiaddr ${n} was not an IPv4 or IPv6 address`);
        const i = P4e(n);
        return {
            type: "answer",
            sdp: `v=0
o=- 0 0 IN IP${s === "ip4" ? 4 : 6} ${t}
s=-
t=0 0
a=ice-lite
m=application ${r} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${s === "ip4" ? 4 : 6} ${t}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:${i}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${zg}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${r} typ host
a=end-of-candidates
`
        };
    }
    function $4e(n, e) {
        const { host: t, port: r, type: s } = Xe(n);
        if (s !== "ip4" && s !== "ip6") throw new Su(`Multiaddr ${n} was not an IPv4 or IPv6 address`);
        return {
            type: "offer",
            sdp: `v=0
o=- 0 0 IN IP${s === "ip4" ? 4 : 6} ${t}
s=-
c=IN IP${s === "ip4" ? 4 : 6} ${t}
t=0 0
a=ice-options:ice2,trickle
m=application ${r} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${zg}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${r} typ host
a=end-of-candidates
`
        };
    }
    function IS(n, e) {
        if (n.sdp === void 0) throw new Su("Can't munge a missing SDP");
        const t = n.sdp.includes(`\r
`) ? `\r
` : `
`;
        try {
            n.sdp = n.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, `
a=ice-ufrag:` + e + t).replace(/\na=ice-pwd:[^\n]*\n/, `
a=ice-pwd:` + e + t);
        } catch  {}
        return n;
    }
    const vy = re("libp2p-webrtc-noise:");
    function M4e(n, e, t) {
        const r = n.trim().toLowerCase().replaceAll(":", ""), s = re(r, "hex"), i = jo(Ut.code, s), l = wk.decode(bk(e)), u = vy.byteLength + i.bytes.byteLength + l.byteLength;
        return xe(t === "server" ? [
            vy,
            l,
            i.bytes
        ] : [
            vy,
            i.bytes,
            l
        ], u);
    }
    const N4e = fk ? "iceconnectionstatechange" : "connectionstatechange";
    function L4e(n, e) {
        return n.role === "server";
    }
    async function U4e(n, e, t, r) {
        const s = n.createDataChannel("", {
            negotiated: !0,
            id: 0
        });
        try {
            if (r.role === "client") {
                r.log.trace("client creating local offer");
                const m = await n.createOffer();
                r.log.trace("client created local offer %s", m.sdp);
                const w = IS(m, t);
                r.log.trace("client setting local offer %s", w.sdp), await n.setLocalDescription(w);
                const A = O4e(r.remoteAddr, t);
                r.log.trace("client setting server description %s", A.sdp), await n.setRemoteDescription(A);
            } else {
                const m = $4e(r.remoteAddr, t);
                r.log.trace("server setting client %s %s", m.type, m.sdp), await n.setRemoteDescription(m), r.log.trace("server creating local answer");
                const w = await n.createAnswer();
                r.log.trace("server created local answer");
                const A = IS(w, t);
                r.log.trace("server setting local description %s", w.sdp), await n.setLocalDescription(A);
            }
            if (s.readyState !== "open" && (r.log.trace("%s wait for handshake channel to open, starting status %s", r.role, s.readyState), await an(s, "open", r)), r.log.trace("%s handshake channel opened", r.role), L4e(r, n)) {
                const m = n.remoteFingerprint()?.value ?? "";
                r.remoteAddr = r.remoteAddr.encapsulate(k4e(m));
            }
            const i = D4e(n.localDescription?.sdp);
            if (i == null) throw new Nf("Could not get fingerprint from local description sdp");
            r.log.trace("%s performing noise handshake", r.role);
            const l = M4e(i, r.remoteAddr, r.role), u = x8({
                prologueBytes: l
            })(r), h = V4({
                channel: s,
                direction: "outbound",
                isHandshake: !0,
                log: r.log,
                ...r.dataChannel ?? {}
            }), f = H4({
                peerConnection: n,
                remoteAddr: r.remoteAddr,
                metrics: r.events,
                direction: r.role === "client" ? "outbound" : "inbound",
                log: r.logger.forComponent("libp2p:webrtc-direct:connection")
            });
            if (n.addEventListener(N4e, ()=>{
                switch(n.connectionState){
                    case "failed":
                    case "disconnected":
                    case "closed":
                        f.close().catch((m)=>{
                            r.log.error("error closing connection - %e", m), f.abort(m);
                        });
                        break;
                    default:
                        break;
                }
            }), r.events?.increment({
                peer_connection: !0
            }), r.role === "client") {
                r.log.trace("%s secure inbound", r.role);
                const m = await u.secureInbound(h, {
                    remotePeer: r.remotePeer,
                    signal: r.signal,
                    skipStreamMuxerNegotiation: !0
                });
                return r.log.trace("%s upgrade outbound", r.role), await r.upgrader.upgradeOutbound(f, {
                    skipProtection: !0,
                    skipEncryption: !0,
                    remotePeer: m.remotePeer,
                    muxerFactory: e,
                    signal: r.signal
                });
            }
            r.log.trace("%s secure outbound", r.role);
            const p = await u.secureOutbound(h, {
                remotePeer: r.remotePeer,
                signal: r.signal,
                skipStreamMuxerNegotiation: !0
            });
            f.remoteAddr = f.remoteAddr.encapsulate(`/p2p/${p.remotePeer}`), r.log.trace("%s upgrade inbound", r.role), await r.upgrader.upgradeInbound(f, {
                skipProtection: !0,
                skipEncryption: !0,
                remotePeer: p.remotePeer,
                muxerFactory: e,
                signal: r.signal
            });
        } catch (i) {
            throw s.close(), n.close(), i;
        }
    }
    async function z4e(n, e, t = {}) {
        let r = t.certificate;
        r == null && (r = await RTCPeerConnection.generateCertificate({
            name: "ECDSA",
            namedCurve: "P-256"
        }));
        const s = typeof t.rtcConfiguration == "function" ? await t.rtcConfiguration() : t.rtcConfiguration, i = new RTCPeerConnection({
            ...s ?? {},
            certificates: [
                r
            ]
        }), l = new Z8({
            peerConnection: i,
            metrics: t.events,
            dataChannelOptions: t.dataChannel
        });
        return {
            peerConnection: i,
            muxerFactory: l
        };
    }
    class F4e {
        log;
        metrics;
        components;
        init;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:webrtc-direct"), this.components = e, this.init = t, e.metrics != null && (this.metrics = {
                dialerEvents: e.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
                    label: "event",
                    help: "Total count of WebRTC-direct dial events by type"
                })
            });
        }
        [ZP] = !0;
        [Symbol.toStringTag] = "@libp2p/webrtc-direct";
        [ek] = [
            "@libp2p/transport"
        ];
        async dial(e, t) {
            this.log("dial %a", e), t.signal.throwIfAborted();
            let r;
            const s = e.getComponents().findLast((h)=>h.code === sk)?.value;
            s != null && (r = W8(s));
            const i = g4e(), { peerConnection: l, muxerFactory: u } = await z4e("client", i, {
                rtcConfiguration: typeof this.init.rtcConfiguration == "function" ? await this.init.rtcConfiguration() : this.init.rtcConfiguration ?? {},
                dataChannel: this.init.dataChannel
            });
            try {
                return await U4e(l, u, i, {
                    role: "client",
                    log: this.log,
                    logger: this.components.logger,
                    events: this.metrics?.dialerEvents,
                    signal: t.signal,
                    remoteAddr: e,
                    dataChannel: this.init.dataChannel,
                    upgrader: t.upgrader,
                    peerId: this.components.peerId,
                    remotePeer: r,
                    privateKey: this.components.privateKey
                });
            } catch (h) {
                throw l.close(), h;
            }
        }
        createListener(e) {
            throw new E4e("WebRTCDirectTransport.createListener");
        }
        listenFilter(e) {
            return [];
        }
        dialFilter(e) {
            return e.filter(e4.exactMatch);
        }
    }
    function V4e(n) {
        return (e)=>new F4e(e, n);
    }
    function vk(n) {
        return (e)=>new T4e(e, n);
    }
    class H4e extends Error {
        static name = "ConnectionFailedError";
        constructor(e = "Connection failed"){
            super(e), this.name = "ConnectionFailedError";
        }
    }
    const Q4e = Symbol.for("@libp2p/transport");
    var CS;
    (function(n) {
        n[n.FATAL_ALL = 0] = "FATAL_ALL", n[n.NO_FATAL = 1] = "NO_FATAL";
    })(CS || (CS = {}));
    const q4e = Symbol.for("@libp2p/service-capabilities");
    function K4e() {
        throw new Error("WebSocket Servers can not be created in the browser!");
    }
    const G4e = 1024 * 1024 * 4, Y4e = 10;
    class W4e extends D6 {
        websocket;
        maxBufferedAmount;
        checkBufferedAmountTask;
        constructor(e){
            super(e), this.websocket = e.websocket, this.maxBufferedAmount = e.maxBufferedAmount ?? G4e, this.checkBufferedAmountTask = V6(this.checkBufferedAmount.bind(this), e.bufferedAmountPollInterval ?? Y4e), this.websocket.addEventListener("close", (t)=>{
                if (this.log('closed - code %d, reason "%s", wasClean %s', t.code, t.reason, t.wasClean), this.checkBufferedAmountTask.stop(), !t.wasClean) {
                    this.onRemoteReset();
                    return;
                }
                this.onTransportClosed();
            }, {
                once: !0
            }), this.websocket.addEventListener("message", (t)=>{
                try {
                    let r;
                    if (typeof t.data == "string") r = re(t.data);
                    else if (t.data instanceof ArrayBuffer) r = new Uint8Array(t.data, 0, t.data.byteLength);
                    else {
                        this.abort(new Error("Incorrect binary type"));
                        return;
                    }
                    this.onData(r);
                } catch (r) {
                    this.log.error("error receiving data - %e", r);
                }
            });
        }
        sendData(e) {
            for (const r of e)this.websocket.send(r);
            const t = this.websocket.bufferedAmount < this.maxBufferedAmount;
            return t || this.checkBufferedAmountTask.start(), {
                sentBytes: e.byteLength,
                canSendMore: t
            };
        }
        sendReset() {
            this.websocket.close(1006);
        }
        async sendClose(e) {
            this.websocket.close(), e?.signal?.throwIfAborted();
        }
        sendPause() {}
        sendResume() {}
        checkBufferedAmount() {
            this.log("buffered amount now %d", this.websocket.bufferedAmount), this.websocket.bufferedAmount === 0 && (this.checkBufferedAmountTask.stop(), this.safeDispatchEvent("drain"));
        }
    }
    function j4e(n) {
        return new W4e(n);
    }
    class X4e {
        log;
        init;
        logger;
        metrics;
        components;
        constructor(e, t = {}){
            this.log = e.logger.forComponent("libp2p:websockets"), this.logger = e.logger, this.components = e, this.init = t, e.metrics != null && (this.metrics = {
                dialerEvents: e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
                    label: "event",
                    help: "Total count of WebSockets dialer events by type"
                })
            });
        }
        [Q4e] = !0;
        [Symbol.toStringTag] = "@libp2p/websockets";
        [q4e] = [
            "@libp2p/transport"
        ];
        async dial(e, t) {
            this.log("dialing %s", e), t = t ?? {};
            const r = j4e({
                websocket: await this._connect(e, t),
                remoteAddr: e,
                metrics: this.metrics?.dialerEvents,
                direction: "outbound",
                log: this.components.logger.forComponent("libp2p:websockets:connection"),
                maxBufferedAmount: this.init.maxBufferedAmount,
                bufferedAmountPollInterval: this.init.bufferedAmountPollInterval
            });
            this.log("new outbound connection %s", r.remoteAddr);
            const s = await t.upgrader.upgradeOutbound(r, t);
            return this.log("outbound connection %s upgraded", r.remoteAddr), s;
        }
        async _connect(e, t) {
            t?.signal?.throwIfAborted();
            const r = Sg(e);
            this.log("create websocket connection to %s", r);
            const s = new WebSocket(r);
            s.binaryType = "arraybuffer";
            try {
                t.onProgress?.(new Be("websockets:open-connection")), await an(s, "open", t);
            } catch (i) {
                if (t.signal?.aborted) throw this.metrics?.dialerEvents.increment({
                    abort: !0
                }), new H4e(`Could not connect to ${r}`);
                this.metrics?.dialerEvents.increment({
                    error: !0
                });
                try {
                    s.close();
                } catch  {}
                throw i;
            }
            return this.log("connected %s", e), this.metrics?.dialerEvents.increment({
                connect: !0
            }), s;
        }
        createListener(e) {
            return K4e({
                logger: this.logger,
                events: this.components.events,
                metrics: this.components.metrics
            }, {
                ...this.init,
                ...e
            });
        }
        listenFilter(e) {
            return e.filter((t)=>tf.exactMatch(t) || $p.exactMatch(t));
        }
        dialFilter(e) {
            return this.listenFilter(e);
        }
    }
    function Ek(n = {}) {
        return (e)=>new X4e(e, n);
    }
    function J4e(n, e) {
        const t = e.map((r, s)=>({
                record: Of(r),
                index: s
            }));
        return t.sort((r, s)=>{
            const i = r.record.sequence, l = s.record.sequence;
            if (i > l) return -1;
            if (i < l) return 1;
            if (r.record.validityType === Fs.ValidityType.EOL && s.record.validityType === Fs.ValidityType.EOL) {
                const u = n4.fromString(r.record.validity).toDate(), h = n4.fromString(s.record.validity).toDate();
                if (u.getTime() > h.getTime()) return -1;
                if (u.getTime() < h.getTime()) return 1;
            }
            return 0;
        }), t[0].index;
    }
    const Z4e = "6.0.20", e6e = "helia", t6e = {
        list: [
            "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
            "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
            "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
            "/dnsaddr/va1.bootstrap.libp2p.io/p2p/12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8",
            "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
        ]
    };
    function n6e(n = {}) {
        const e = `${e6e}/${Z4e} ${zx()}`;
        return {
            privateKey: n.privateKey,
            dns: n.dns,
            nodeInfo: {
                userAgent: e
            },
            addresses: {
                listen: [
                    "/p2p-circuit",
                    "/webrtc"
                ]
            },
            transports: [
                qB(),
                vk(),
                V4e(),
                Ek()
            ],
            connectionEncrypters: [
                x8()
            ],
            streamMuxers: [
                IB(),
                l3e()
            ],
            peerDiscovery: [
                Ice(t6e)
            ],
            services: {
                autoNAT: qae(),
                dcutr: Nde(),
                delegatedRouting: LW(FW()),
                dht: Yme({
                    clientMode: !0,
                    validators: {
                        ipns: O_
                    },
                    selectors: {
                        ipns: J4e
                    }
                }),
                identify: kP(),
                identifyPush: jpe(),
                keychain: hB(n.keychain),
                ping: b3e(),
                http: w0e()
            }
        };
    }
    async function r6e(n) {
        const e = n.libp2p ?? {};
        e.privateKey == null && n.datastore != null && (e.privateKey = await Kse(n.datastore, n.keychain));
        const t = n6e(e);
        return t.datastore = t.datastore ?? n.datastore, await Vx({
            ...t,
            ...e,
            start: !1
        });
    }
    async function s6e(n = {}) {
        const e = n.datastore ?? new l8, t = n.blockstore ?? new H_;
        let r;
        return ose(n.libp2p) ? r = n.libp2p : r = await r6e({
            ...n,
            libp2p: {
                dns: n.dns,
                ...n.libp2p,
                start: void 0
            },
            datastore: e
        }), {
            ...n,
            libp2p: r,
            datastore: e,
            blockstore: t,
            blockBrokers: n.blockBrokers ?? [
                NG(),
                Dq()
            ],
            routers: n.routers ?? [
                MX(r),
                OX()
            ],
            metrics: r.metrics
        };
    }
    async function i6e(n = {}) {
        const e = await s6e(n), t = new UQ(e);
        return e.start !== !1 && await t.start(), t;
    }
    const Ak = Symbol.for("@libp2p/peer-id"), ig = "StrictSign", t5 = "StrictNoSign";
    var as;
    (function(n) {
        n.Accept = "accept", n.Ignore = "ignore", n.Reject = "reject";
    })(as || (as = {}));
    class o6e extends Error {
        static name = "InvalidParametersError";
        constructor(e = "Invalid parameters"){
            super(e), this.name = "InvalidParametersError";
        }
    }
    class a6e extends Error {
        static name = "InvalidCIDError";
        constructor(e = "Invalid CID"){
            super(e), this.name = "InvalidCIDError";
        }
    }
    class l6e extends Error {
        static name = "InvalidMultihashError";
        constructor(e = "Invalid Multihash"){
            super(e), this.name = "InvalidMultihashError";
        }
    }
    const c6e = Symbol.for("@libp2p/service-capabilities"), u6e = Symbol.for("@libp2p/service-dependencies"), Sk = Symbol.for("nodejs.util.inspect.custom"), h6e = 114;
    class n5 {
        type;
        multihash;
        publicKey;
        string;
        constructor(e){
            this.type = e.type, this.multihash = e.multihash, Object.defineProperty(this, "string", {
                enumerable: !1,
                writable: !0
            });
        }
        get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
        }
        [Ak] = !0;
        toString() {
            return this.string == null && (this.string = He.encode(this.multihash.bytes).slice(1)), this.string;
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(h6e, this.multihash);
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            if (e == null) return !1;
            if (e instanceof Uint8Array) return Ee(this.multihash.bytes, e);
            if (typeof e == "string") return this.toString() === e;
            if (e?.toMultihash()?.bytes != null) return Ee(this.multihash.bytes, e.toMultihash().bytes);
            throw new Error("not valid Id");
        }
        [Sk]() {
            return `PeerId(${this.toString()})`;
        }
    }
    class d6e extends n5 {
        type = "RSA";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "RSA"
            }), this.publicKey = e.publicKey;
        }
    }
    class f6e extends n5 {
        type = "Ed25519";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "Ed25519"
            }), this.publicKey = e.publicKey;
        }
    }
    class p6e extends n5 {
        type = "secp256k1";
        publicKey;
        constructor(e){
            super({
                ...e,
                type: "secp256k1"
            }), this.publicKey = e.publicKey;
        }
    }
    const g6e = 2336;
    class Ik {
        type = "url";
        multihash;
        publicKey;
        url;
        constructor(e){
            this.url = e.toString(), this.multihash = nt.digest(re(this.url));
        }
        [Sk]() {
            return `PeerId(${this.url})`;
        }
        [Ak] = !0;
        toString() {
            return this.toCID().toString();
        }
        toMultihash() {
            return this.multihash;
        }
        toCID() {
            return ge.createV1(g6e, this.toMultihash());
        }
        toJSON() {
            return this.toString();
        }
        equals(e) {
            return e == null ? !1 : (e instanceof Uint8Array && (e = L(e)), e.toString() === this.toString());
        }
    }
    const m6e = 114, TS = 2336;
    function Wl(n, e) {
        let t;
        if (n.charAt(0) === "1" || n.charAt(0) === "Q") t = kt(He.decode(`z${n}`));
        else {
            if (n.startsWith("k51qzi5uqu5") || n.startsWith("kzwfwjn5ji4") || n.startsWith("k2k4r8") || n.startsWith("bafz")) return y6e(ge.parse(n));
            throw new o6e('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
        }
        return Vg(t);
    }
    function Vg(n) {
        if (b6e(n)) return new d6e({
            multihash: n
        });
        if (w6e(n)) try {
            const e = ir(n);
            if (e.type === "Ed25519") return new f6e({
                multihash: n,
                publicKey: e
            });
            if (e.type === "secp256k1") return new p6e({
                multihash: n,
                publicKey: e
            });
        } catch  {
            const t = L(n.digest);
            return new Ik(new URL(t));
        }
        throw new l6e("Supplied PeerID Multihash is invalid");
    }
    function y6e(n) {
        if (n?.multihash == null || n.version == null || n.version === 1 && n.code !== m6e && n.code !== TS) throw new a6e("Supplied PeerID CID is invalid");
        if (n.code === TS) {
            const e = L(n.multihash.digest);
            return new Ik(new URL(e));
        }
        return Vg(n.multihash);
    }
    function w6e(n) {
        return n.code === nt.code;
    }
    function b6e(n) {
        return n.code === Ut.code;
    }
    function Ck(n) {
        return n[Symbol.asyncIterator] != null;
    }
    const Hg = (n)=>{
        const e = be(n), t = Wn(e);
        return zr(n, t), Hg.bytes = e, t;
    };
    Hg.bytes = 0;
    function r5(n, e) {
        e = e ?? {};
        const t = e.lengthEncoder ?? Hg;
        function* r(s) {
            const i = t(s.byteLength);
            i instanceof Uint8Array ? yield i : yield* i, s instanceof Uint8Array ? yield s : yield* s;
        }
        return Ck(n) ? (async function*() {
            for await (const s of n)yield* r(s);
        })() : (function*() {
            for (const s of n)yield* r(s);
        })();
    }
    r5.single = (n, e)=>{
        e = e ?? {};
        const t = e.lengthEncoder ?? Hg;
        return new Re(t(n.byteLength), n);
    };
    class v6e extends Error {
        name = "InvalidMessageLengthError";
        code = "ERR_INVALID_MSG_LENGTH";
    }
    class E6e extends Error {
        name = "InvalidDataLengthError";
        code = "ERR_MSG_DATA_TOO_LONG";
    }
    class A6e extends Error {
        name = "InvalidDataLengthLengthError";
        code = "ERR_MSG_LENGTH_TOO_LONG";
    }
    class _S extends Error {
        name = "UnexpectedEOFError";
        code = "ERR_UNEXPECTED_EOF";
    }
    const S6e = 8, I6e = 1024 * 1024 * 4;
    var xa;
    (function(n) {
        n[n.LENGTH = 0] = "LENGTH", n[n.DATA = 1] = "DATA";
    })(xa || (xa = {}));
    const s5 = (n)=>{
        const e = et(n);
        return s5.bytes = be(e), e;
    };
    s5.bytes = 0;
    function Q4(n, e) {
        const t = new Re;
        let r = xa.LENGTH, s = -1;
        const i = e?.lengthDecoder ?? s5, l = e?.maxLengthLength ?? S6e, u = e?.maxDataLength ?? I6e;
        function* h() {
            for(; t.byteLength > 0;){
                if (r === xa.LENGTH) try {
                    if (s = i(t), s < 0) throw new v6e("Invalid message length");
                    if (s > u) throw new E6e("Message length too long");
                    const f = i.bytes;
                    t.consume(f), e?.onLength != null && e.onLength(s), r = xa.DATA;
                } catch (f) {
                    if (f instanceof RangeError) {
                        if (t.byteLength > l) throw new A6e("Message length length too long");
                        break;
                    }
                    throw f;
                }
                if (r === xa.DATA) {
                    if (t.byteLength < s) break;
                    const f = t.sublist(0, s);
                    t.consume(s), e?.onData != null && e.onData(f), yield f, r = xa.LENGTH;
                }
            }
        }
        return Ck(n) ? (async function*() {
            for await (const f of n)t.append(f), yield* h();
            if (t.byteLength > 0) throw new _S("Unexpected end of input");
        })() : (function*() {
            for (const f of n)t.append(f), yield* h();
            if (t.byteLength > 0) throw new _S("Unexpected end of input");
        })();
    }
    Q4.fromReader = (n, e)=>{
        let t = 1;
        const r = (async function*() {
            for(;;)try {
                const { done: i, value: l } = await n.next(t);
                if (i === !0) return;
                l != null && (yield l);
            } catch (i) {
                if (i.code === "ERR_UNDER_READ") return {
                    done: !0,
                    value: null
                };
                throw i;
            } finally{
                t = 1;
            }
        })();
        return Q4(r, {
            ...e ?? {},
            onLength: (i)=>{
                t = i;
            }
        });
    };
    const Cu = 1e3, i5 = 60 * Cu, xS = "/floodsub/1.0.0", DS = "/meshsub/1.0.0", C6e = "/meshsub/1.1.0", Ey = "/meshsub/1.2.0", T6e = 6, _6e = 4, x6e = 12, D6e = 4, B6e = 2, P6e = 5, k6e = 3, R6e = 6, O6e = .25, $6e = 3, BS = 100, M6e = Cu, N6e = i5, L6e = 16, U6e = i5, z6e = 10 * Cu, F6e = 15, V6e = 300, H6e = Cu, Q6e = 60, q6e = 2, K6e = 10 * Cu, jl = 5e3, G6e = 10, Y6e = 3 * Cu, W6e = 2 * i5, j6e = 120 * 1e3, X6e = "ERR_TOPIC_VALIDATOR_REJECT", J6e = "ERR_TOPIC_VALIDATOR_IGNORE", Z6e = 0, e8e = 128, t8e = 1e3, n8e = 1e3, r8e = 1, s8e = 512, i8e = 512, o8e = {
        maxSubscriptions: 1 / 0,
        maxMessages: 1 / 0,
        maxIhaveMessageIDs: 1 / 0,
        maxIwantMessageIDs: 1 / 0,
        maxIdontwantMessageIDs: 1 / 0,
        maxControlMessages: 1 / 0,
        maxPeerInfos: 1 / 0
    };
    var za;
    (function(n) {
        (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.subscribe != null && (i.uint32(8), i.bool(s.subscribe)), s.topic != null && (i.uint32(18), i.string(s.topic)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {}, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.subscribe = s.bool();
                                    break;
                                }
                            case 2:
                                {
                                    u.topic = s.string();
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.SubOpts || (n.SubOpts = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.from != null && (i.uint32(10), i.bytes(s.from)), s.data != null && (i.uint32(18), i.bytes(s.data)), s.seqno != null && (i.uint32(26), i.bytes(s.seqno)), s.topic != null && s.topic !== "" && (i.uint32(34), i.string(s.topic)), s.signature != null && (i.uint32(42), i.bytes(s.signature)), s.key != null && (i.uint32(50), i.bytes(s.key)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        topic: ""
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.from = s.bytes();
                                    break;
                                }
                            case 2:
                                {
                                    u.data = s.bytes();
                                    break;
                                }
                            case 3:
                                {
                                    u.seqno = s.bytes();
                                    break;
                                }
                            case 4:
                                {
                                    u.topic = s.string();
                                    break;
                                }
                            case 5:
                                {
                                    u.signature = s.bytes();
                                    break;
                                }
                            case 6:
                                {
                                    u.key = s.bytes();
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.Message || (n.Message = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    if (l.lengthDelimited !== !1 && i.fork(), s.ihave != null) for (const u of s.ihave)i.uint32(10), n.ControlIHave.codec().encode(u, i);
                    if (s.iwant != null) for (const u of s.iwant)i.uint32(18), n.ControlIWant.codec().encode(u, i);
                    if (s.graft != null) for (const u of s.graft)i.uint32(26), n.ControlGraft.codec().encode(u, i);
                    if (s.prune != null) for (const u of s.prune)i.uint32(34), n.ControlPrune.codec().encode(u, i);
                    if (s.idontwant != null) for (const u of s.idontwant)i.uint32(42), n.ControlIDontWant.codec().encode(u, i);
                    l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        ihave: [],
                        iwant: [],
                        graft: [],
                        prune: [],
                        idontwant: []
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    if (l.limits?.ihave != null && u.ihave.length === l.limits.ihave) throw new vt('Decode error - map field "ihave" had too many elements');
                                    u.ihave.push(n.ControlIHave.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.ihave$
                                    }));
                                    break;
                                }
                            case 2:
                                {
                                    if (l.limits?.iwant != null && u.iwant.length === l.limits.iwant) throw new vt('Decode error - map field "iwant" had too many elements');
                                    u.iwant.push(n.ControlIWant.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.iwant$
                                    }));
                                    break;
                                }
                            case 3:
                                {
                                    if (l.limits?.graft != null && u.graft.length === l.limits.graft) throw new vt('Decode error - map field "graft" had too many elements');
                                    u.graft.push(n.ControlGraft.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.graft$
                                    }));
                                    break;
                                }
                            case 4:
                                {
                                    if (l.limits?.prune != null && u.prune.length === l.limits.prune) throw new vt('Decode error - map field "prune" had too many elements');
                                    u.prune.push(n.ControlPrune.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.prune$
                                    }));
                                    break;
                                }
                            case 5:
                                {
                                    if (l.limits?.idontwant != null && u.idontwant.length === l.limits.idontwant) throw new vt('Decode error - map field "idontwant" had too many elements');
                                    u.idontwant.push(n.ControlIDontWant.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.idontwant$
                                    }));
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.ControlMessage || (n.ControlMessage = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    if (l.lengthDelimited !== !1 && i.fork(), s.topicID != null && (i.uint32(10), i.string(s.topicID)), s.messageIDs != null) for (const u of s.messageIDs)i.uint32(18), i.bytes(u);
                    l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        messageIDs: []
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.topicID = s.string();
                                    break;
                                }
                            case 2:
                                {
                                    if (l.limits?.messageIDs != null && u.messageIDs.length === l.limits.messageIDs) throw new vt('Decode error - map field "messageIDs" had too many elements');
                                    u.messageIDs.push(s.bytes());
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.ControlIHave || (n.ControlIHave = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    if (l.lengthDelimited !== !1 && i.fork(), s.messageIDs != null) for (const u of s.messageIDs)i.uint32(10), i.bytes(u);
                    l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        messageIDs: []
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    if (l.limits?.messageIDs != null && u.messageIDs.length === l.limits.messageIDs) throw new vt('Decode error - map field "messageIDs" had too many elements');
                                    u.messageIDs.push(s.bytes());
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.ControlIWant || (n.ControlIWant = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.topicID != null && (i.uint32(10), i.string(s.topicID)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {}, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        f >>> 3 === 1 ? u.topicID = s.string() : s.skipType(f & 7);
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.ControlGraft || (n.ControlGraft = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    if (l.lengthDelimited !== !1 && i.fork(), s.topicID != null && (i.uint32(10), i.string(s.topicID)), s.peers != null) for (const u of s.peers)i.uint32(18), n.PeerInfo.codec().encode(u, i);
                    s.backoff != null && (i.uint32(24), i.uint64Number(s.backoff)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        peers: []
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.topicID = s.string();
                                    break;
                                }
                            case 2:
                                {
                                    if (l.limits?.peers != null && u.peers.length === l.limits.peers) throw new vt('Decode error - map field "peers" had too many elements');
                                    u.peers.push(n.PeerInfo.codec().decode(s, s.uint32(), {
                                        limits: l.limits?.peers$
                                    }));
                                    break;
                                }
                            case 3:
                                {
                                    u.backoff = s.uint64Number();
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.ControlPrune || (n.ControlPrune = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    l.lengthDelimited !== !1 && i.fork(), s.peerID != null && (i.uint32(10), i.bytes(s.peerID)), s.signedPeerRecord != null && (i.uint32(18), i.bytes(s.signedPeerRecord)), l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {}, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    u.peerID = s.bytes();
                                    break;
                                }
                            case 2:
                                {
                                    u.signedPeerRecord = s.bytes();
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.PeerInfo || (n.PeerInfo = {})), (function(t) {
            let r;
            t.codec = ()=>(r == null && (r = Le((s, i, l = {})=>{
                    if (l.lengthDelimited !== !1 && i.fork(), s.messageIDs != null) for (const u of s.messageIDs)i.uint32(10), i.bytes(u);
                    l.lengthDelimited !== !1 && i.ldelim();
                }, (s, i, l = {})=>{
                    const u = {
                        messageIDs: []
                    }, h = i == null ? s.len : s.pos + i;
                    for(; s.pos < h;){
                        const f = s.uint32();
                        switch(f >>> 3){
                            case 1:
                                {
                                    if (l.limits?.messageIDs != null && u.messageIDs.length === l.limits.messageIDs) throw new vt('Decode error - map field "messageIDs" had too many elements');
                                    u.messageIDs.push(s.bytes());
                                    break;
                                }
                            default:
                                {
                                    s.skipType(f & 7);
                                    break;
                                }
                        }
                    }
                    return u;
                })), r), t.encode = (s)=>Ne(s, t.codec()), t.decode = (s, i)=>Me(s, t.codec(), i);
        })(n.ControlIDontWant || (n.ControlIDontWant = {}));
        let e;
        n.codec = ()=>(e == null && (e = Le((t, r, s = {})=>{
                if (s.lengthDelimited !== !1 && r.fork(), t.subscriptions != null) for (const i of t.subscriptions)r.uint32(10), n.SubOpts.codec().encode(i, r);
                if (t.messages != null) for (const i of t.messages)r.uint32(18), n.Message.codec().encode(i, r);
                t.control != null && (r.uint32(26), n.ControlMessage.codec().encode(t.control, r)), s.lengthDelimited !== !1 && r.ldelim();
            }, (t, r, s = {})=>{
                const i = {
                    subscriptions: [],
                    messages: []
                }, l = r == null ? t.len : t.pos + r;
                for(; t.pos < l;){
                    const u = t.uint32();
                    switch(u >>> 3){
                        case 1:
                            {
                                if (s.limits?.subscriptions != null && i.subscriptions.length === s.limits.subscriptions) throw new vt('Decode error - map field "subscriptions" had too many elements');
                                i.subscriptions.push(n.SubOpts.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.subscriptions$
                                }));
                                break;
                            }
                        case 2:
                            {
                                if (s.limits?.messages != null && i.messages.length === s.limits.messages) throw new vt('Decode error - map field "messages" had too many elements');
                                i.messages.push(n.Message.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.messages$
                                }));
                                break;
                            }
                        case 3:
                            {
                                i.control = n.ControlMessage.codec().decode(t, t.uint32(), {
                                    limits: s.limits?.control
                                });
                                break;
                            }
                        default:
                            {
                                t.skipType(u & 7);
                                break;
                            }
                    }
                }
                return i;
            })), e), n.encode = (t)=>Ne(t, n.codec()), n.decode = (t, r)=>Me(t, n.codec(), r);
    })(za || (za = {}));
    class a8e {
        gossip;
        msgs = new Map;
        msgIdToStrFn;
        history = [];
        notValidatedCount = 0;
        constructor(e, t, r){
            this.gossip = e, this.msgIdToStrFn = r;
            for(let s = 0; s < t; s++)this.history[s] = [];
        }
        get size() {
            return this.msgs.size;
        }
        put(e, t, r = !1) {
            const { msgIdStr: s } = e;
            return this.msgs.has(s) ? !1 : (this.msgs.set(s, {
                message: t,
                validated: r,
                originatingPeers: new Set,
                iwantCounts: new Map
            }), this.history[0].push({
                ...e,
                topic: t.topic
            }), r || this.notValidatedCount++, !0);
        }
        observeDuplicate(e, t) {
            const r = this.msgs.get(e);
            r != null && !r.validated && r.originatingPeers.add(t);
        }
        get(e) {
            return this.msgs.get(this.msgIdToStrFn(e))?.message;
        }
        getWithIWantCount(e, t) {
            const r = this.msgs.get(e);
            if (r == null) return null;
            const s = (r.iwantCounts.get(t) ?? 0) + 1;
            return r.iwantCounts.set(t, s), {
                msg: r.message,
                count: s
            };
        }
        getGossipIDs(e) {
            const t = new Map;
            for(let r = 0; r < this.gossip; r++)this.history[r].forEach((s)=>{
                if ((this.msgs.get(s.msgIdStr)?.validated ?? !1) && e.has(s.topic)) {
                    let l = t.get(s.topic);
                    l == null && (l = [], t.set(s.topic, l)), l.push(s.msgId);
                }
            });
            return t;
        }
        validate(e) {
            const t = this.msgs.get(e);
            if (t == null) return null;
            t.validated || this.notValidatedCount--;
            const { message: r, originatingPeers: s } = t;
            return t.validated = !0, t.originatingPeers = new Set, {
                message: r,
                originatingPeers: s
            };
        }
        shift() {
            this.history[this.history.length - 1].forEach((t)=>{
                const r = this.msgs.get(t.msgIdStr);
                r != null && (this.msgs.delete(t.msgIdStr), r.validated || this.notValidatedCount--);
            }), this.history.pop(), this.history.unshift([]);
        }
        remove(e) {
            const t = this.msgs.get(e);
            return t == null ? null : (this.msgs.delete(e), t);
        }
    }
    var PS;
    (function(n) {
        n.StrictSign = "StrictSign", n.StrictNoSign = "StrictNoSign";
    })(PS || (PS = {}));
    var Xc;
    (function(n) {
        n[n.Signing = 0] = "Signing", n[n.Anonymous = 1] = "Anonymous";
    })(Xc || (Xc = {}));
    var Vs;
    (function(n) {
        n.Error = "error", n.Ignore = "ignore", n.Reject = "reject", n.Blacklisted = "blacklisted";
    })(Vs || (Vs = {}));
    var pr;
    (function(n) {
        n.InvalidSignature = "invalid_signature", n.InvalidSeqno = "invalid_seqno", n.InvalidPeerId = "invalid_peerid", n.SignaturePresent = "signature_present", n.SeqnoPresent = "seqno_present", n.FromPresent = "from_present", n.TransformFailed = "transform_failed";
    })(pr || (pr = {}));
    var yr;
    (function(n) {
        n.duplicate = "duplicate", n.invalid = "invalid", n.valid = "valid";
    })(yr || (yr = {}));
    function kS(n) {
        switch(n){
            case as.Ignore:
                return Vs.Ignore;
            case as.Reject:
                return Vs.Reject;
            default:
                throw new Error("Unreachable");
        }
    }
    var RS;
    (function(n) {
        n.forward = "forward", n.publish = "publish";
    })(RS || (RS = {}));
    var wr;
    (function(n) {
        n.Fanout = "fanout", n.Random = "random", n.Subscribed = "subscribed", n.Outbound = "outbound", n.NotEnough = "not_enough", n.Opportunistic = "opportunistic";
    })(wr || (wr = {}));
    var oi;
    (function(n) {
        n.Dc = "disconnected", n.BadScore = "bad_score", n.Prune = "prune", n.Excess = "excess";
    })(oi || (oi = {}));
    var Dd;
    (function(n) {
        n.GraftBackoff = "graft_backoff", n.BrokenPromise = "broken_promise", n.MessageDeficit = "message_deficit", n.IPColocation = "IP_colocation";
    })(Dd || (Dd = {}));
    var Bd;
    (function(n) {
        n.LowScore = "low_score", n.MaxIhave = "max_ihave", n.MaxIasked = "max_iasked";
    })(Bd || (Bd = {}));
    var mc;
    (function(n) {
        n.graylist = "graylist", n.publish = "publish", n.gossip = "gossip", n.mesh = "mesh";
    })(mc || (mc = {}));
    function l8e(n, e, t) {
        return {
            protocolsEnabled: n.gauge({
                name: "gossipsub_protocol",
                help: "Status of enabled protocols",
                labelNames: [
                    "protocol"
                ]
            }),
            topicSubscriptionStatus: n.gauge({
                name: "gossipsub_topic_subscription_status",
                help: "Status of our subscription to this topic",
                labelNames: [
                    "topicStr"
                ]
            }),
            topicPeersCount: n.gauge({
                name: "gossipsub_topic_peer_count",
                help: "Number of peers subscribed to each topic",
                labelNames: [
                    "topicStr"
                ]
            }),
            meshPeerCounts: n.gauge({
                name: "gossipsub_mesh_peer_count",
                help: "Number of peers in our mesh",
                labelNames: [
                    "topicStr"
                ]
            }),
            meshPeerInclusionEventsFanout: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_fanout_total",
                help: "Number of times we include peers in a topic mesh for fanout reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerInclusionEventsRandom: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_random_total",
                help: "Number of times we include peers in a topic mesh for random reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerInclusionEventsSubscribed: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_subscribed_total",
                help: "Number of times we include peers in a topic mesh for subscribed reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerInclusionEventsOutbound: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_outbound_total",
                help: "Number of times we include peers in a topic mesh for outbound reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerInclusionEventsNotEnough: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_not_enough_total",
                help: "Number of times we include peers in a topic mesh for not_enough reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerInclusionEventsOpportunistic: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_opportunistic_total",
                help: "Number of times we include peers in a topic mesh for opportunistic reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerInclusionEventsUnknown: n.gauge({
                name: "gossipsub_mesh_peer_inclusion_events_unknown_total",
                help: "Number of times we include peers in a topic mesh for unknown reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerChurnEventsDisconnected: n.gauge({
                name: "gossipsub_peer_churn_events_disconnected_total",
                help: "Number of times we remove peers in a topic mesh for disconnected reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerChurnEventsBadScore: n.gauge({
                name: "gossipsub_peer_churn_events_bad_score_total",
                help: "Number of times we remove peers in a topic mesh for bad_score reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerChurnEventsPrune: n.gauge({
                name: "gossipsub_peer_churn_events_prune_total",
                help: "Number of times we remove peers in a topic mesh for prune reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerChurnEventsExcess: n.gauge({
                name: "gossipsub_peer_churn_events_excess_total",
                help: "Number of times we remove peers in a topic mesh for excess reasons",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeerChurnEventsUnknown: n.gauge({
                name: "gossipsub_peer_churn_events_unknown_total",
                help: "Number of times we remove peers in a topic mesh for unknown reasons",
                labelNames: [
                    "topic"
                ]
            }),
            peersPerProtocol: n.gauge({
                name: "gossipsub_peers_per_protocol_count",
                help: "Peers connected for each topic",
                labelNames: [
                    "protocol"
                ]
            }),
            heartbeatDuration: n.histogram({
                name: "gossipsub_heartbeat_duration_seconds",
                help: "The time it takes to complete one iteration of the heartbeat",
                buckets: [
                    .01,
                    .1,
                    1
                ]
            }),
            heartbeatSkipped: n.gauge({
                name: "gossipsub_heartbeat_skipped",
                help: "Heartbeat run took longer than heartbeat interval so next is skipped"
            }),
            acceptedMessagesTotal: n.gauge({
                name: "gossipsub_accepted_messages_total",
                help: "Total accepted messages for each topic",
                labelNames: [
                    "topic"
                ]
            }),
            ignoredMessagesTotal: n.gauge({
                name: "gossipsub_ignored_messages_total",
                help: "Total ignored messages for each topic",
                labelNames: [
                    "topic"
                ]
            }),
            rejectedMessagesTotal: n.gauge({
                name: "gossipsub_rejected_messages_total",
                help: "Total rejected messages for each topic",
                labelNames: [
                    "topic"
                ]
            }),
            unknownValidationResultsTotal: n.gauge({
                name: "gossipsub_unknown_validation_results_total",
                help: "Total unknown validation results for each topic",
                labelNames: [
                    "topic"
                ]
            }),
            asyncValidationMcacheHit: n.gauge({
                name: "gossipsub_async_validation_mcache_hit_total",
                help: "Async validation result reported by the user layer",
                labelNames: [
                    "hit"
                ]
            }),
            asyncValidationDelayFromFirstSeenSec: n.histogram({
                name: "gossipsub_async_validation_delay_from_first_seen",
                help: "Async validation report delay from first seen in second",
                buckets: [
                    .01,
                    .03,
                    .1,
                    .3,
                    1,
                    3,
                    10
                ]
            }),
            asyncValidationUnknownFirstSeen: n.gauge({
                name: "gossipsub_async_validation_unknown_first_seen_count_total",
                help: "Async validation report unknown first seen value for message"
            }),
            peerReadStreamError: n.gauge({
                name: "gossipsub_peer_read_stream_err_count_total",
                help: "Peer read stream error"
            }),
            rpcRecvBytes: n.gauge({
                name: "gossipsub_rpc_recv_bytes_total",
                help: "RPC recv"
            }),
            rpcRecvCount: n.gauge({
                name: "gossipsub_rpc_recv_count_total",
                help: "RPC recv"
            }),
            rpcRecvSubscription: n.gauge({
                name: "gossipsub_rpc_recv_subscription_total",
                help: "RPC recv"
            }),
            rpcRecvMessage: n.gauge({
                name: "gossipsub_rpc_recv_message_total",
                help: "RPC recv"
            }),
            rpcRecvControl: n.gauge({
                name: "gossipsub_rpc_recv_control_total",
                help: "RPC recv"
            }),
            rpcRecvIHave: n.gauge({
                name: "gossipsub_rpc_recv_ihave_total",
                help: "RPC recv"
            }),
            rpcRecvIWant: n.gauge({
                name: "gossipsub_rpc_recv_iwant_total",
                help: "RPC recv"
            }),
            rpcRecvGraft: n.gauge({
                name: "gossipsub_rpc_recv_graft_total",
                help: "RPC recv"
            }),
            rpcRecvPrune: n.gauge({
                name: "gossipsub_rpc_recv_prune_total",
                help: "RPC recv"
            }),
            rpcDataError: n.gauge({
                name: "gossipsub_rpc_data_err_count_total",
                help: "RPC data error"
            }),
            rpcRecvError: n.gauge({
                name: "gossipsub_rpc_recv_err_count_total",
                help: "RPC recv error"
            }),
            rpcRecvNotAccepted: n.gauge({
                name: "gossipsub_rpc_rcv_not_accepted_total",
                help: "Total count of RPC dropped because acceptFrom() == false"
            }),
            rpcSentBytes: n.gauge({
                name: "gossipsub_rpc_sent_bytes_total",
                help: "RPC sent"
            }),
            rpcSentCount: n.gauge({
                name: "gossipsub_rpc_sent_count_total",
                help: "RPC sent"
            }),
            rpcSentSubscription: n.gauge({
                name: "gossipsub_rpc_sent_subscription_total",
                help: "RPC sent"
            }),
            rpcSentMessage: n.gauge({
                name: "gossipsub_rpc_sent_message_total",
                help: "RPC sent"
            }),
            rpcSentControl: n.gauge({
                name: "gossipsub_rpc_sent_control_total",
                help: "RPC sent"
            }),
            rpcSentIHave: n.gauge({
                name: "gossipsub_rpc_sent_ihave_total",
                help: "RPC sent"
            }),
            rpcSentIWant: n.gauge({
                name: "gossipsub_rpc_sent_iwant_total",
                help: "RPC sent"
            }),
            rpcSentGraft: n.gauge({
                name: "gossipsub_rpc_sent_graft_total",
                help: "RPC sent"
            }),
            rpcSentPrune: n.gauge({
                name: "gossipsub_rpc_sent_prune_total",
                help: "RPC sent"
            }),
            rpcSentIDontWant: n.gauge({
                name: "gossipsub_rpc_sent_idontwant_total",
                help: "RPC sent"
            }),
            msgPublishCount: n.gauge({
                name: "gossipsub_msg_publish_count_total",
                help: "Total count of msg published by topic",
                labelNames: [
                    "topic"
                ]
            }),
            msgPublishPeersByTopic: n.gauge({
                name: "gossipsub_msg_publish_peers_total",
                help: "Total count of peers that we publish a msg to",
                labelNames: [
                    "topic"
                ]
            }),
            directPeersPublishedTotal: n.gauge({
                name: "gossipsub_direct_peers_published_total",
                help: "Total direct peers that we publish a msg to",
                labelNames: [
                    "topic"
                ]
            }),
            floodsubPeersPublishedTotal: n.gauge({
                name: "gossipsub_floodsub_peers_published_total",
                help: "Total floodsub peers that we publish a msg to",
                labelNames: [
                    "topic"
                ]
            }),
            meshPeersPublishedTotal: n.gauge({
                name: "gossipsub_mesh_peers_published_total",
                help: "Total mesh peers that we publish a msg to",
                labelNames: [
                    "topic"
                ]
            }),
            fanoutPeersPublishedTotal: n.gauge({
                name: "gossipsub_fanout_peers_published_total",
                help: "Total fanout peers that we publish a msg to",
                labelNames: [
                    "topic"
                ]
            }),
            msgPublishBytes: n.gauge({
                name: "gossipsub_msg_publish_bytes_total",
                help: "Total count of msg publish data.length bytes",
                labelNames: [
                    "topic"
                ]
            }),
            msgPublishTime: n.histogram({
                name: "gossipsub_msg_publish_seconds",
                help: "Total time in seconds to publish a message",
                buckets: [
                    .001,
                    .002,
                    .005,
                    .01,
                    .1,
                    .5,
                    1
                ],
                labelNames: [
                    "topic"
                ]
            }),
            msgForwardCount: n.gauge({
                name: "gossipsub_msg_forward_count_total",
                help: "Total count of msg forwarded by topic",
                labelNames: [
                    "topic"
                ]
            }),
            msgForwardPeers: n.gauge({
                name: "gossipsub_msg_forward_peers_total",
                help: "Total count of peers that we forward a msg to",
                labelNames: [
                    "topic"
                ]
            }),
            msgReceivedPreValidation: n.gauge({
                name: "gossipsub_msg_received_prevalidation_total",
                help: "Total count of recv msgs before any validation",
                labelNames: [
                    "topic"
                ]
            }),
            msgReceivedError: n.gauge({
                name: "gossipsub_msg_received_error_total",
                help: "Total count of recv msgs error",
                labelNames: [
                    "topic"
                ]
            }),
            prevalidationInvalidTotal: n.gauge({
                name: "gossipsub_pre_validation_invalid_total",
                help: "Total count of invalid messages received",
                labelNames: [
                    "topic"
                ]
            }),
            prevalidationValidTotal: n.gauge({
                name: "gossipsub_pre_validation_valid_total",
                help: "Total count of valid messages received",
                labelNames: [
                    "topic"
                ]
            }),
            prevalidationDuplicateTotal: n.gauge({
                name: "gossipsub_pre_validation_duplicate_total",
                help: "Total count of duplicate messages received",
                labelNames: [
                    "topic"
                ]
            }),
            prevalidationUnknownTotal: n.gauge({
                name: "gossipsub_pre_validation_unknown_status_total",
                help: "Total count of unknown_status messages received",
                labelNames: [
                    "topic"
                ]
            }),
            msgReceivedInvalid: n.gauge({
                name: "gossipsub_msg_received_invalid_total",
                help: "Tracks specific reason of invalid",
                labelNames: [
                    "error"
                ]
            }),
            msgReceivedInvalidByTopic: n.gauge({
                name: "gossipsub_msg_received_invalid_by_topic_total",
                help: "Tracks specific invalid message by topic",
                labelNames: [
                    "topic"
                ]
            }),
            duplicateMsgDeliveryDelay: n.histogram({
                name: "gossisub_duplicate_msg_delivery_delay_seconds",
                help: "Time since the 1st duplicated message validated",
                labelNames: [
                    "topic"
                ],
                buckets: [
                    .25 * t.maxMeshMessageDeliveriesWindowSec,
                    .5 * t.maxMeshMessageDeliveriesWindowSec,
                    Number(t.maxMeshMessageDeliveriesWindowSec),
                    2 * t.maxMeshMessageDeliveriesWindowSec,
                    4 * t.maxMeshMessageDeliveriesWindowSec
                ]
            }),
            duplicateMsgLateDelivery: n.gauge({
                name: "gossisub_duplicate_msg_late_delivery_total",
                help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
                labelNames: [
                    "topic"
                ]
            }),
            duplicateMsgIgnored: n.gauge({
                name: "gossisub_ignored_published_duplicate_msgs_total",
                help: "Total count of published duplicate message ignored by topic",
                labelNames: [
                    "topic"
                ]
            }),
            scoreFnCalls: n.gauge({
                name: "gossipsub_score_fn_calls_total",
                help: "Total times score() is called"
            }),
            scoreFnRuns: n.gauge({
                name: "gossipsub_score_fn_runs_total",
                help: "Total times score() call actually computed computeScore(), no cache"
            }),
            scoreCachedDelta: n.histogram({
                name: "gossipsub_score_cache_delta",
                help: "Delta of score between cached values that expired",
                buckets: [
                    10,
                    100,
                    1e3
                ]
            }),
            peersByScoreThreshold: n.gauge({
                name: "gossipsub_peers_by_score_threshold_count",
                help: "Current count of peers by score threshold",
                labelNames: [
                    "threshold"
                ]
            }),
            score: n.avgMinMax({
                name: "gossipsub_score",
                help: "Avg min max of gossip scores"
            }),
            scoreWeights: n.avgMinMax({
                name: "gossipsub_score_weights",
                help: "Separate score weights",
                labelNames: [
                    "topic",
                    "p"
                ]
            }),
            scorePerMesh: n.avgMinMax({
                name: "gossipsub_score_per_mesh",
                help: "Histogram of the scores for each mesh topic",
                labelNames: [
                    "topic"
                ]
            }),
            scoringPenalties: n.gauge({
                name: "gossipsub_scoring_penalties_total",
                help: "A counter of the kind of penalties being applied to peers",
                labelNames: [
                    "penalty"
                ]
            }),
            behaviourPenalty: n.histogram({
                name: "gossipsub_peer_stat_behaviour_penalty",
                help: "Current peer stat behaviour_penalty at each scrape",
                buckets: [
                    .25 * t.behaviourPenaltyThreshold,
                    .5 * t.behaviourPenaltyThreshold,
                    Number(t.behaviourPenaltyThreshold),
                    2 * t.behaviourPenaltyThreshold,
                    4 * t.behaviourPenaltyThreshold
                ]
            }),
            ihaveRcvIgnored: n.gauge({
                name: "gossipsub_ihave_rcv_ignored_total",
                help: "Total received IHAVE messages that we ignore for some reason",
                labelNames: [
                    "reason"
                ]
            }),
            ihaveRcvMsgids: n.gauge({
                name: "gossipsub_ihave_rcv_msgids_total",
                help: "Total received IHAVE messages by topic",
                labelNames: [
                    "topic"
                ]
            }),
            ihaveRcvNotSeenMsgids: n.gauge({
                name: "gossipsub_ihave_rcv_not_seen_msgids_total",
                help: "Total messages per topic we do not have, not actual requests",
                labelNames: [
                    "topic"
                ]
            }),
            iwantRcvMsgids: n.gauge({
                name: "gossipsub_iwant_rcv_msgids_total",
                help: "Total received IWANT messages by topic",
                labelNames: [
                    "topic"
                ]
            }),
            iwantRcvDonthaveMsgids: n.gauge({
                name: "gossipsub_iwant_rcv_dont_have_msgids_total",
                help: "Total requested messageIDs that we do not have"
            }),
            idontwantRcvMsgids: n.gauge({
                name: "gossipsub_idontwant_rcv_msgids_total",
                help: "Total received IDONTWANT messages"
            }),
            idontwantRcvDonthaveMsgids: n.gauge({
                name: "gossipsub_idontwant_rcv_dont_have_msgids_total",
                help: "Total received IDONTWANT messageIDs that we do not have in mcache"
            }),
            iwantPromiseStarted: n.gauge({
                name: "gossipsub_iwant_promise_sent_total",
                help: "Total count of started IWANT promises"
            }),
            iwantPromiseResolved: n.gauge({
                name: "gossipsub_iwant_promise_resolved_total",
                help: "Total count of resolved IWANT promises"
            }),
            iwantPromiseResolvedFromDuplicate: n.gauge({
                name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
                help: "Total count of resolved IWANT promises from duplicate messages"
            }),
            iwantPromiseResolvedPeers: n.gauge({
                name: "gossipsub_iwant_promise_resolved_peers",
                help: "Total count of peers we have asked IWANT promises that are resolved"
            }),
            iwantPromiseBroken: n.gauge({
                name: "gossipsub_iwant_promise_broken",
                help: "Total count of broken IWANT promises"
            }),
            iwantMessagePruned: n.gauge({
                name: "gossipsub_iwant_message_pruned",
                help: "Total count of pruned IWANT messages"
            }),
            iwantPromiseDeliveryTime: n.histogram({
                name: "gossipsub_iwant_promise_delivery_seconds",
                help: "Histogram of delivery time of resolved IWANT promises",
                buckets: [
                    .5 * t.gossipPromiseExpireSec,
                    Number(t.gossipPromiseExpireSec),
                    2 * t.gossipPromiseExpireSec,
                    4 * t.gossipPromiseExpireSec
                ]
            }),
            iwantPromiseUntracked: n.gauge({
                name: "gossip_iwant_promise_untracked",
                help: "Total count of untracked IWANT promise"
            }),
            connectedPeersBackoffSec: n.histogram({
                name: "gossipsub_connected_peers_backoff_seconds",
                help: "Backoff time in seconds",
                buckets: [
                    1,
                    2,
                    4,
                    10,
                    20,
                    60,
                    120
                ]
            }),
            cacheSize: n.gauge({
                name: "gossipsub_cache_size",
                help: "Unbounded cache sizes",
                labelNames: [
                    "cache"
                ]
            }),
            mcacheSize: n.gauge({
                name: "gossipsub_mcache_size",
                help: "Current mcache msg count"
            }),
            mcacheNotValidatedCount: n.gauge({
                name: "gossipsub_mcache_not_validated_count",
                help: "Current mcache msg count not validated"
            }),
            fastMsgIdCacheCollision: n.gauge({
                name: "gossipsub_fastmsgid_cache_collision_total",
                help: "Total count of key collisions on fastmsgid cache put"
            }),
            newConnectionCount: n.gauge({
                name: "gossipsub_new_connection_total",
                help: "Total new connection by status",
                labelNames: [
                    "status"
                ]
            }),
            topicStrToLabel: e,
            toTopic (r) {
                return this.topicStrToLabel.get(r) ?? r;
            },
            onJoin (r) {
                this.topicSubscriptionStatus.set({
                    topicStr: r
                }, 1), this.meshPeerCounts.set({
                    topicStr: r
                }, 0);
            },
            onLeave (r) {
                this.topicSubscriptionStatus.set({
                    topicStr: r
                }, 0), this.meshPeerCounts.set({
                    topicStr: r
                }, 0);
            },
            onAddToMesh (r, s, i) {
                const l = this.toTopic(r);
                switch(s){
                    case wr.Fanout:
                        this.meshPeerInclusionEventsFanout.inc({
                            topic: l
                        }, i);
                        break;
                    case wr.Random:
                        this.meshPeerInclusionEventsRandom.inc({
                            topic: l
                        }, i);
                        break;
                    case wr.Subscribed:
                        this.meshPeerInclusionEventsSubscribed.inc({
                            topic: l
                        }, i);
                        break;
                    case wr.Outbound:
                        this.meshPeerInclusionEventsOutbound.inc({
                            topic: l
                        }, i);
                        break;
                    case wr.NotEnough:
                        this.meshPeerInclusionEventsNotEnough.inc({
                            topic: l
                        }, i);
                        break;
                    case wr.Opportunistic:
                        this.meshPeerInclusionEventsOpportunistic.inc({
                            topic: l
                        }, i);
                        break;
                    default:
                        this.meshPeerInclusionEventsUnknown.inc({
                            topic: l
                        }, i);
                        break;
                }
            },
            onRemoveFromMesh (r, s, i) {
                const l = this.toTopic(r);
                switch(s){
                    case oi.Dc:
                        this.meshPeerChurnEventsDisconnected.inc({
                            topic: l
                        }, i);
                        break;
                    case oi.BadScore:
                        this.meshPeerChurnEventsBadScore.inc({
                            topic: l
                        }, i);
                        break;
                    case oi.Prune:
                        this.meshPeerChurnEventsPrune.inc({
                            topic: l
                        }, i);
                        break;
                    case oi.Excess:
                        this.meshPeerChurnEventsExcess.inc({
                            topic: l
                        }, i);
                        break;
                    default:
                        this.meshPeerChurnEventsUnknown.inc({
                            topic: l
                        }, i);
                        break;
                }
            },
            onReportValidation (r, s, i) {
                if (this.asyncValidationMcacheHit.inc({
                    hit: r != null ? "hit" : "miss"
                }), r != null) {
                    const l = this.toTopic(r.message.topic);
                    switch(s){
                        case as.Accept:
                            this.acceptedMessagesTotal.inc({
                                topic: l
                            });
                            break;
                        case as.Ignore:
                            this.ignoredMessagesTotal.inc({
                                topic: l
                            });
                            break;
                        case as.Reject:
                            this.rejectedMessagesTotal.inc({
                                topic: l
                            });
                            break;
                        default:
                            this.unknownValidationResultsTotal.inc({
                                topic: l
                            });
                            break;
                    }
                }
                i != null ? this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - i) / 1e3) : this.asyncValidationUnknownFirstSeen.inc();
            },
            onScorePenalty (r) {
                this.scoringPenalties.inc({
                    penalty: r
                }, 1);
            },
            onIhaveRcv (r, s, i) {
                const l = this.toTopic(r);
                this.ihaveRcvMsgids.inc({
                    topic: l
                }, s), this.ihaveRcvNotSeenMsgids.inc({
                    topic: l
                }, i);
            },
            onIwantRcv (r, s) {
                for (const [i, l] of r){
                    const u = this.toTopic(i);
                    this.iwantRcvMsgids.inc({
                        topic: u
                    }, l);
                }
                this.iwantRcvDonthaveMsgids.inc(s);
            },
            onIdontwantRcv (r, s) {
                this.idontwantRcvMsgids.inc(r), this.idontwantRcvDonthaveMsgids.inc(s);
            },
            onForwardMsg (r, s) {
                const i = this.toTopic(r);
                this.msgForwardCount.inc({
                    topic: i
                }, 1), this.msgForwardPeers.inc({
                    topic: i
                }, s);
            },
            onPublishMsg (r, s, i, l, u) {
                const h = this.toTopic(r);
                this.msgPublishCount.inc({
                    topic: h
                }, 1), this.msgPublishBytes.inc({
                    topic: h
                }, i * l), this.msgPublishPeersByTopic.inc({
                    topic: h
                }, i), this.directPeersPublishedTotal.inc({
                    topic: h
                }, s.direct), this.floodsubPeersPublishedTotal.inc({
                    topic: h
                }, s.floodsub), this.meshPeersPublishedTotal.inc({
                    topic: h
                }, s.mesh), this.fanoutPeersPublishedTotal.inc({
                    topic: h
                }, s.fanout), this.msgPublishTime.observe({
                    topic: h
                }, u / 1e3);
            },
            onMsgRecvPreValidation (r) {
                const s = this.toTopic(r);
                this.msgReceivedPreValidation.inc({
                    topic: s
                }, 1);
            },
            onMsgRecvError (r) {
                const s = this.toTopic(r);
                this.msgReceivedError.inc({
                    topic: s
                }, 1);
            },
            onPrevalidationResult (r, s) {
                const i = this.toTopic(r);
                switch(s){
                    case yr.duplicate:
                        this.prevalidationDuplicateTotal.inc({
                            topic: i
                        });
                        break;
                    case yr.invalid:
                        this.prevalidationInvalidTotal.inc({
                            topic: i
                        });
                        break;
                    case yr.valid:
                        this.prevalidationValidTotal.inc({
                            topic: i
                        });
                        break;
                    default:
                        this.prevalidationUnknownTotal.inc({
                            topic: i
                        });
                        break;
                }
            },
            onMsgRecvInvalid (r, s) {
                const i = this.toTopic(r), l = s.reason === Vs.Error ? s.error : s.reason;
                this.msgReceivedInvalid.inc({
                    error: l
                }, 1), this.msgReceivedInvalidByTopic.inc({
                    topic: i
                }, 1);
            },
            onDuplicateMsgDelivery (r, s, i) {
                const l = this.toTopic(r);
                this.duplicateMsgDeliveryDelay.observe({
                    topic: l
                }, s / 1e3), i && this.duplicateMsgLateDelivery.inc({
                    topic: l
                }, 1);
            },
            onPublishDuplicateMsg (r) {
                const s = this.toTopic(r);
                this.duplicateMsgIgnored.inc({
                    topic: s
                }, 1);
            },
            onPeerReadStreamError () {
                this.peerReadStreamError.inc(1);
            },
            onRpcRecvError () {
                this.rpcRecvError.inc(1);
            },
            onRpcDataError () {
                this.rpcDataError.inc(1);
            },
            onRpcRecv (r, s) {
                this.rpcRecvBytes.inc(s), this.rpcRecvCount.inc(1), r.subscriptions != null && this.rpcRecvSubscription.inc(r.subscriptions.length), r.messages != null && this.rpcRecvMessage.inc(r.messages.length), r.control != null && (this.rpcRecvControl.inc(1), r.control.ihave != null && this.rpcRecvIHave.inc(r.control.ihave.length), r.control.iwant != null && this.rpcRecvIWant.inc(r.control.iwant.length), r.control.graft != null && this.rpcRecvGraft.inc(r.control.graft.length), r.control.prune != null && this.rpcRecvPrune.inc(r.control.prune.length));
            },
            onRpcSent (r, s) {
                if (this.rpcSentBytes.inc(s), this.rpcSentCount.inc(1), r.subscriptions != null && this.rpcSentSubscription.inc(r.subscriptions.length), r.messages != null && this.rpcSentMessage.inc(r.messages.length), r.control != null) {
                    const i = r.control.ihave?.length ?? 0, l = r.control.iwant?.length ?? 0, u = r.control.graft?.length ?? 0, h = r.control.prune?.length ?? 0, f = r.control.idontwant?.length ?? 0;
                    i > 0 && this.rpcSentIHave.inc(i), l > 0 && this.rpcSentIWant.inc(l), u > 0 && this.rpcSentGraft.inc(u), h > 0 && this.rpcSentPrune.inc(h), f > 0 && this.rpcSentIDontWant.inc(f), (i > 0 || l > 0 || u > 0 || h > 0 || f > 0) && this.rpcSentControl.inc(1);
                }
            },
            registerScores (r, s) {
                let i = 0, l = 0, u = 0, h = 0;
                for (const f of r)f >= s.graylistThreshold && i++, f >= s.publishThreshold && l++, f >= s.gossipThreshold && u++, f >= 0 && h++;
                this.peersByScoreThreshold.set({
                    threshold: mc.graylist
                }, i), this.peersByScoreThreshold.set({
                    threshold: mc.publish
                }, l), this.peersByScoreThreshold.set({
                    threshold: mc.gossip
                }, u), this.peersByScoreThreshold.set({
                    threshold: mc.mesh
                }, h), this.score.set(r);
            },
            registerScoreWeights (r) {
                for (const [s, i] of r.byTopic)this.scoreWeights.set({
                    topic: s,
                    p: "p1"
                }, i.p1w), this.scoreWeights.set({
                    topic: s,
                    p: "p2"
                }, i.p2w), this.scoreWeights.set({
                    topic: s,
                    p: "p3"
                }, i.p3w), this.scoreWeights.set({
                    topic: s,
                    p: "p3b"
                }, i.p3bw), this.scoreWeights.set({
                    topic: s,
                    p: "p4"
                }, i.p4w);
                this.scoreWeights.set({
                    p: "p5"
                }, r.p5w), this.scoreWeights.set({
                    p: "p6"
                }, r.p6w), this.scoreWeights.set({
                    p: "p7"
                }, r.p7w);
            },
            registerScorePerMesh (r, s) {
                const i = new Map;
                r.forEach((l, u)=>{
                    const h = this.topicStrToLabel.get(u) ?? "unknown";
                    let f = i.get(h);
                    f == null && (f = new Set, i.set(h, f)), l.forEach((p)=>f?.add(p));
                });
                for (const [l, u] of i){
                    const h = [];
                    u.forEach((f)=>{
                        h.push(s.get(f) ?? 0);
                    }), this.scorePerMesh.set({
                        topic: l
                    }, h);
                }
            }
        };
    }
    class Tt extends Error {
        static name = "InvalidPeerScoreParamsError";
        constructor(e = "Invalid peer score params"){
            super(e), this.name = "InvalidPeerScoreParamsError";
        }
    }
    const c8e = {
        topics: {},
        topicScoreCap: 10,
        appSpecificScore: ()=>0,
        appSpecificWeight: 10,
        IPColocationFactorWeight: -5,
        IPColocationFactorThreshold: 10,
        IPColocationFactorWhitelist: new Set,
        behaviourPenaltyWeight: -10,
        behaviourPenaltyThreshold: 0,
        behaviourPenaltyDecay: .2,
        decayInterval: 1e3,
        decayToZero: .1,
        retainScore: 3600 * 1e3
    }, u8e = {
        topicWeight: .5,
        timeInMeshWeight: 1,
        timeInMeshQuantum: 1,
        timeInMeshCap: 3600,
        firstMessageDeliveriesWeight: 1,
        firstMessageDeliveriesDecay: .5,
        firstMessageDeliveriesCap: 2e3,
        meshMessageDeliveriesWeight: -1,
        meshMessageDeliveriesDecay: .5,
        meshMessageDeliveriesCap: 100,
        meshMessageDeliveriesThreshold: 20,
        meshMessageDeliveriesWindow: 10,
        meshMessageDeliveriesActivation: 5e3,
        meshFailurePenaltyWeight: -1,
        meshFailurePenaltyDecay: .5,
        invalidMessageDeliveriesWeight: -1,
        invalidMessageDeliveriesDecay: .3
    };
    function h8e(n = {}) {
        return {
            ...c8e,
            ...n,
            topics: n.topics != null ? Object.entries(n.topics).reduce((e, [t, r])=>(e[t] = d8e(r), e), {}) : {}
        };
    }
    function d8e(n = {}) {
        return {
            ...u8e,
            ...n
        };
    }
    function f8e(n) {
        for (const [e, t] of Object.entries(n.topics))try {
            p8e(t);
        } catch (r) {
            throw new Tt(`invalid score parameters for topic ${e}: ${r.message}`);
        }
        if (n.topicScoreCap < 0) throw new Tt("invalid topic score cap; must be positive (or 0 for no cap)");
        if (n.appSpecificScore === null || n.appSpecificScore === void 0) throw new Tt("missing application specific score function");
        if (n.IPColocationFactorWeight > 0) throw new Tt("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");
        if (n.IPColocationFactorWeight !== 0 && n.IPColocationFactorThreshold < 1) throw new Tt("invalid IPColocationFactorThreshold; must be at least 1");
        if (n.behaviourPenaltyWeight > 0) throw new Tt("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");
        if (n.behaviourPenaltyWeight !== 0 && (n.behaviourPenaltyDecay <= 0 || n.behaviourPenaltyDecay >= 1)) throw new Tt("invalid BehaviourPenaltyDecay; must be between 0 and 1");
        if (n.decayInterval < 1e3) throw new Tt("invalid DecayInterval; must be at least 1s");
        if (n.decayToZero <= 0 || n.decayToZero >= 1) throw new Tt("invalid DecayToZero; must be between 0 and 1");
    }
    function p8e(n) {
        if (n.topicWeight < 0) throw new Tt("invalid topic weight; must be >= 0");
        if (n.timeInMeshQuantum === 0) throw new Tt("invalid TimeInMeshQuantum; must be non zero");
        if (n.timeInMeshWeight < 0) throw new Tt("invalid TimeInMeshWeight; must be positive (or 0 to disable)");
        if (n.timeInMeshWeight !== 0 && n.timeInMeshQuantum <= 0) throw new Tt("invalid TimeInMeshQuantum; must be positive");
        if (n.timeInMeshWeight !== 0 && n.timeInMeshCap <= 0) throw new Tt("invalid TimeInMeshCap; must be positive");
        if (n.firstMessageDeliveriesWeight < 0) throw new Tt("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");
        if (n.firstMessageDeliveriesWeight !== 0 && (n.firstMessageDeliveriesDecay <= 0 || n.firstMessageDeliveriesDecay >= 1)) throw new Tt("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");
        if (n.firstMessageDeliveriesWeight !== 0 && n.firstMessageDeliveriesCap <= 0) throw new Tt("invalid FirstMessageDeliveriesCap; must be positive");
        if (n.meshMessageDeliveriesWeight > 0) throw new Tt("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");
        if (n.meshMessageDeliveriesWeight !== 0 && (n.meshMessageDeliveriesDecay <= 0 || n.meshMessageDeliveriesDecay >= 1)) throw new Tt("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");
        if (n.meshMessageDeliveriesWeight !== 0 && n.meshMessageDeliveriesCap <= 0) throw new Tt("invalid MeshMessageDeliveriesCap; must be positive");
        if (n.meshMessageDeliveriesWeight !== 0 && n.meshMessageDeliveriesThreshold <= 0) throw new Tt("invalid MeshMessageDeliveriesThreshold; must be positive");
        if (n.meshMessageDeliveriesWindow < 0) throw new Tt("invalid MeshMessageDeliveriesWindow; must be non-negative");
        if (n.meshMessageDeliveriesWeight !== 0 && n.meshMessageDeliveriesActivation < 1e3) throw new Tt("invalid MeshMessageDeliveriesActivation; must be at least 1s");
        if (n.meshFailurePenaltyWeight > 0) throw new Tt("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");
        if (n.meshFailurePenaltyWeight !== 0 && (n.meshFailurePenaltyDecay <= 0 || n.meshFailurePenaltyDecay >= 1)) throw new Tt("invalid MeshFailurePenaltyDecay; must be between 0 and 1");
        if (n.invalidMessageDeliveriesWeight > 0) throw new Tt("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");
        if (n.invalidMessageDeliveriesDecay <= 0 || n.invalidMessageDeliveriesDecay >= 1) throw new Tt("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1");
    }
    const g8e = {
        gossipThreshold: -10,
        publishThreshold: -50,
        graylistThreshold: -80,
        acceptPXThreshold: 10,
        opportunisticGraftThreshold: 20
    };
    function m8e(n = {}) {
        return {
            ...g8e,
            ...n
        };
    }
    function q4(n, e, t = ()=>!0) {
        const r = new Set;
        if (e <= 0) return r;
        for (const s of n){
            if (r.size >= e) break;
            t(s) && (r.add(s), n.delete(s));
        }
        return r;
    }
    function y8e(n, e) {
        return q4(n, e, ()=>!0);
    }
    class w8e extends Map {
        getDefault;
        constructor(e){
            super(), this.getDefault = e;
        }
        getOrDefault(e) {
            let t = super.get(e);
            return t === void 0 && (t = this.getDefault(), this.set(e, t)), t;
        }
    }
    function b8e(n, e, t, r) {
        let s = 0;
        Object.entries(e.topics).forEach(([l, u])=>{
            const h = t.topics[l];
            if (h === void 0) return;
            let f = 0;
            if (u.inMesh) {
                let A = u.meshTime / h.timeInMeshQuantum;
                A > h.timeInMeshCap && (A = h.timeInMeshCap), f += A * h.timeInMeshWeight;
            }
            let p = u.firstMessageDeliveries;
            if (p > h.firstMessageDeliveriesCap && (p = h.firstMessageDeliveriesCap), f += p * h.firstMessageDeliveriesWeight, u.meshMessageDeliveriesActive && u.meshMessageDeliveries < h.meshMessageDeliveriesThreshold) {
                const A = h.meshMessageDeliveriesThreshold - u.meshMessageDeliveries, S = A * A;
                f += S * h.meshMessageDeliveriesWeight;
            }
            const m = u.meshFailurePenalty;
            f += m * h.meshFailurePenaltyWeight;
            const w = u.invalidMessageDeliveries * u.invalidMessageDeliveries;
            f += w * h.invalidMessageDeliveriesWeight, s += f * h.topicWeight;
        }), t.topicScoreCap > 0 && s > t.topicScoreCap && (s = t.topicScoreCap);
        const i = t.appSpecificScore(n);
        if (s += i * t.appSpecificWeight, e.knownIPs.forEach((l)=>{
            if (t.IPColocationFactorWhitelist.has(l)) return;
            const u = r.get(l), h = u != null ? u.size : 0;
            if (h > t.IPColocationFactorThreshold) {
                const f = h - t.IPColocationFactorThreshold, p = f * f;
                s += p * t.IPColocationFactorWeight;
            }
        }), e.behaviourPenalty > t.behaviourPenaltyThreshold) {
            const l = e.behaviourPenalty - t.behaviourPenaltyThreshold, u = l * l;
            s += u * t.behaviourPenaltyWeight;
        }
        return s;
    }
    var Ay, OS;
    function v8e() {
        if (OS) return Ay;
        OS = 1;
        function n(e, r) {
            var r = r || {};
            this._capacity = r.capacity, this._head = 0, this._tail = 0, Array.isArray(e) ? this._fromArray(e) : (this._capacityMask = 3, this._list = new Array(4));
        }
        return n.prototype.peekAt = function(t) {
            var r = t;
            if (r === (r | 0)) {
                var s = this.size();
                if (!(r >= s || r < -s)) return r < 0 && (r += s), r = this._head + r & this._capacityMask, this._list[r];
            }
        }, n.prototype.get = function(t) {
            return this.peekAt(t);
        }, n.prototype.peek = function() {
            if (this._head !== this._tail) return this._list[this._head];
        }, n.prototype.peekFront = function() {
            return this.peek();
        }, n.prototype.peekBack = function() {
            return this.peekAt(-1);
        }, Object.defineProperty(n.prototype, "length", {
            get: function() {
                return this.size();
            }
        }), n.prototype.size = function() {
            return this._head === this._tail ? 0 : this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail);
        }, n.prototype.unshift = function(t) {
            if (arguments.length === 0) return this.size();
            var r = this._list.length;
            return this._head = this._head - 1 + r & this._capacityMask, this._list[this._head] = t, this._tail === this._head && this._growArray(), this._capacity && this.size() > this._capacity && this.pop(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail);
        }, n.prototype.shift = function() {
            var t = this._head;
            if (t !== this._tail) {
                var r = this._list[t];
                return this._list[t] = void 0, this._head = t + 1 & this._capacityMask, t < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2 && this._shrinkArray(), r;
            }
        }, n.prototype.push = function(t) {
            if (arguments.length === 0) return this.size();
            var r = this._tail;
            return this._list[r] = t, this._tail = r + 1 & this._capacityMask, this._tail === this._head && this._growArray(), this._capacity && this.size() > this._capacity && this.shift(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail);
        }, n.prototype.pop = function() {
            var t = this._tail;
            if (t !== this._head) {
                var r = this._list.length;
                this._tail = t - 1 + r & this._capacityMask;
                var s = this._list[this._tail];
                return this._list[this._tail] = void 0, this._head < 2 && t > 1e4 && t <= r >>> 2 && this._shrinkArray(), s;
            }
        }, n.prototype.removeOne = function(t) {
            var r = t;
            if (r === (r | 0) && this._head !== this._tail) {
                var s = this.size(), i = this._list.length;
                if (!(r >= s || r < -s)) {
                    r < 0 && (r += s), r = this._head + r & this._capacityMask;
                    var l = this._list[r], u;
                    if (t < s / 2) {
                        for(u = t; u > 0; u--)this._list[r] = this._list[r = r - 1 + i & this._capacityMask];
                        this._list[r] = void 0, this._head = this._head + 1 + i & this._capacityMask;
                    } else {
                        for(u = s - 1 - t; u > 0; u--)this._list[r] = this._list[r = r + 1 + i & this._capacityMask];
                        this._list[r] = void 0, this._tail = this._tail - 1 + i & this._capacityMask;
                    }
                    return l;
                }
            }
        }, n.prototype.remove = function(t, r) {
            var s = t, i, l = r;
            if (s === (s | 0) && this._head !== this._tail) {
                var u = this.size(), h = this._list.length;
                if (!(s >= u || s < -u || r < 1)) {
                    if (s < 0 && (s += u), r === 1 || !r) return i = new Array(1), i[0] = this.removeOne(s), i;
                    if (s === 0 && s + r >= u) return i = this.toArray(), this.clear(), i;
                    s + r > u && (r = u - s);
                    var f;
                    for(i = new Array(r), f = 0; f < r; f++)i[f] = this._list[this._head + s + f & this._capacityMask];
                    if (s = this._head + s & this._capacityMask, t + r === u) {
                        for(this._tail = this._tail - r + h & this._capacityMask, f = r; f > 0; f--)this._list[s = s + 1 + h & this._capacityMask] = void 0;
                        return i;
                    }
                    if (t === 0) {
                        for(this._head = this._head + r + h & this._capacityMask, f = r - 1; f > 0; f--)this._list[s = s + 1 + h & this._capacityMask] = void 0;
                        return i;
                    }
                    if (s < u / 2) {
                        for(this._head = this._head + t + r + h & this._capacityMask, f = t; f > 0; f--)this.unshift(this._list[s = s - 1 + h & this._capacityMask]);
                        for(s = this._head - 1 + h & this._capacityMask; l > 0;)this._list[s = s - 1 + h & this._capacityMask] = void 0, l--;
                        t < 0 && (this._tail = s);
                    } else {
                        for(this._tail = s, s = s + r + h & this._capacityMask, f = u - (r + t); f > 0; f--)this.push(this._list[s++]);
                        for(s = this._tail; l > 0;)this._list[s = s + 1 + h & this._capacityMask] = void 0, l--;
                    }
                    return this._head < 2 && this._tail > 1e4 && this._tail <= h >>> 2 && this._shrinkArray(), i;
                }
            }
        }, n.prototype.splice = function(t, r) {
            var s = t;
            if (s === (s | 0)) {
                var i = this.size();
                if (s < 0 && (s += i), !(s > i)) if (arguments.length > 2) {
                    var l, u, h, f = arguments.length, p = this._list.length, m = 2;
                    if (!i || s < i / 2) {
                        for(u = new Array(s), l = 0; l < s; l++)u[l] = this._list[this._head + l & this._capacityMask];
                        for(r === 0 ? (h = [], s > 0 && (this._head = this._head + s + p & this._capacityMask)) : (h = this.remove(s, r), this._head = this._head + s + p & this._capacityMask); f > m;)this.unshift(arguments[--f]);
                        for(l = s; l > 0; l--)this.unshift(u[l - 1]);
                    } else {
                        u = new Array(i - (s + r));
                        var w = u.length;
                        for(l = 0; l < w; l++)u[l] = this._list[this._head + s + r + l & this._capacityMask];
                        for(r === 0 ? (h = [], s != i && (this._tail = this._head + s + p & this._capacityMask)) : (h = this.remove(s, r), this._tail = this._tail - w + p & this._capacityMask); m < f;)this.push(arguments[m++]);
                        for(l = 0; l < w; l++)this.push(u[l]);
                    }
                    return h;
                } else return this.remove(s, r);
            }
        }, n.prototype.clear = function() {
            this._list = new Array(this._list.length), this._head = 0, this._tail = 0;
        }, n.prototype.isEmpty = function() {
            return this._head === this._tail;
        }, n.prototype.toArray = function() {
            return this._copyArray(!1);
        }, n.prototype._fromArray = function(t) {
            var r = t.length, s = this._nextPowerOf2(r);
            this._list = new Array(s), this._capacityMask = s - 1, this._tail = r;
            for(var i = 0; i < r; i++)this._list[i] = t[i];
        }, n.prototype._copyArray = function(t, r) {
            var s = this._list, i = s.length, l = this.length;
            if (r = r | l, r == l && this._head < this._tail) return this._list.slice(this._head, this._tail);
            var u = new Array(r), h = 0, f;
            if (t || this._head > this._tail) {
                for(f = this._head; f < i; f++)u[h++] = s[f];
                for(f = 0; f < this._tail; f++)u[h++] = s[f];
            } else for(f = this._head; f < this._tail; f++)u[h++] = s[f];
            return u;
        }, n.prototype._growArray = function() {
            if (this._head != 0) {
                var t = this._copyArray(!0, this._list.length << 1);
                this._tail = this._list.length, this._head = 0, this._list = t;
            } else this._tail = this._list.length, this._list.length <<= 1;
            this._capacityMask = this._capacityMask << 1 | 1;
        }, n.prototype._shrinkArray = function() {
            this._list.length >>>= 1, this._capacityMask >>>= 1;
        }, n.prototype._nextPowerOf2 = function(t) {
            var r = Math.log(t) / Math.log(2), s = 1 << r + 1;
            return Math.max(s, 4);
        }, Ay = n, Ay;
    }
    var E8e = v8e();
    const A8e = Zc(E8e);
    var gr;
    (function(n) {
        n[n.unknown = 0] = "unknown", n[n.valid = 1] = "valid", n[n.invalid = 2] = "invalid", n[n.ignored = 3] = "ignored";
    })(gr || (gr = {}));
    class S8e {
        records;
        queue;
        constructor(){
            this.records = new Map, this.queue = new A8e;
        }
        getRecord(e) {
            return this.records.get(e);
        }
        ensureRecord(e) {
            let t = this.records.get(e);
            if (t != null) return t;
            t = {
                status: gr.unknown,
                firstSeenTsMs: Date.now(),
                validated: 0,
                peers: new Set
            }, this.records.set(e, t);
            const r = {
                msgId: e,
                expire: Date.now() + j6e
            };
            return this.queue.push(r), t;
        }
        gc() {
            const e = Date.now();
            let t = this.queue.peekFront();
            for(; t != null && t.expire < e;)this.records.delete(t.msgId), this.queue.shift(), t = this.queue.peekFront();
        }
        clear() {
            this.records.clear(), this.queue.clear();
        }
    }
    class I8e {
        params;
        metrics;
        peerStats = new Map;
        peerIPs = new w8e(()=>new Set);
        scoreCache = new Map;
        deliveryRecords = new S8e;
        _backgroundInterval;
        scoreCacheValidityMs;
        computeScore;
        log;
        constructor(e, t, r, s){
            this.params = e, this.metrics = t, f8e(e), this.scoreCacheValidityMs = s.scoreCacheValidityMs, this.computeScore = s.computeScore ?? b8e, this.log = r.forComponent("libp2p:gossipsub:score");
        }
        get size() {
            return this.peerStats.size;
        }
        start() {
            if (this._backgroundInterval != null) {
                this.log("Peer score already running");
                return;
            }
            this._backgroundInterval = setInterval(()=>{
                this.background();
            }, this.params.decayInterval), this.log("started");
        }
        stop() {
            if (this._backgroundInterval == null) {
                this.log("Peer score already stopped");
                return;
            }
            clearInterval(this._backgroundInterval), delete this._backgroundInterval, this.peerIPs.clear(), this.peerStats.clear(), this.deliveryRecords.clear(), this.log("stopped");
        }
        background() {
            this.refreshScores(), this.deliveryRecords.gc();
        }
        dumpPeerScoreStats() {
            return Object.fromEntries(Array.from(this.peerStats.entries()).map(([e, t])=>[
                    e,
                    t
                ]));
        }
        messageFirstSeenTimestampMs(e) {
            const t = this.deliveryRecords.getRecord(e);
            return t != null ? t.firstSeenTsMs : null;
        }
        refreshScores() {
            const e = Date.now(), t = this.params.decayToZero;
            this.peerStats.forEach((r, s)=>{
                if (!r.connected) {
                    e > r.expire && (this.removeIPsForPeer(s, r.knownIPs), this.peerStats.delete(s), this.scoreCache.delete(s));
                    return;
                }
                Object.entries(r.topics).forEach(([i, l])=>{
                    const u = this.params.topics[i];
                    u !== void 0 && (l.firstMessageDeliveries *= u.firstMessageDeliveriesDecay, l.firstMessageDeliveries < t && (l.firstMessageDeliveries = 0), l.meshMessageDeliveries *= u.meshMessageDeliveriesDecay, l.meshMessageDeliveries < t && (l.meshMessageDeliveries = 0), l.meshFailurePenalty *= u.meshFailurePenaltyDecay, l.meshFailurePenalty < t && (l.meshFailurePenalty = 0), l.invalidMessageDeliveries *= u.invalidMessageDeliveriesDecay, l.invalidMessageDeliveries < t && (l.invalidMessageDeliveries = 0), l.inMesh && (l.meshTime = e - l.graftTime, l.meshTime > u.meshMessageDeliveriesActivation && (l.meshMessageDeliveriesActive = !0)));
                }), r.behaviourPenalty *= this.params.behaviourPenaltyDecay, r.behaviourPenalty < t && (r.behaviourPenalty = 0);
            });
        }
        score(e) {
            this.metrics?.scoreFnCalls.inc();
            const t = this.peerStats.get(e);
            if (t == null) return 0;
            const r = Date.now(), s = this.scoreCache.get(e);
            if (s != null && s.cacheUntil > r) return s.score;
            this.metrics?.scoreFnRuns.inc();
            const i = this.computeScore(e, t, this.params, this.peerIPs), l = r + this.scoreCacheValidityMs;
            return s != null ? (this.metrics?.scoreCachedDelta.observe(Math.abs(i - s.score)), s.score = i, s.cacheUntil = l) : this.scoreCache.set(e, {
                score: i,
                cacheUntil: l
            }), i;
        }
        addPenalty(e, t, r) {
            const s = this.peerStats.get(e);
            s != null && (s.behaviourPenalty += t, this.metrics?.onScorePenalty(r));
        }
        addPeer(e) {
            const t = {
                connected: !0,
                expire: 0,
                topics: {},
                knownIPs: new Set,
                behaviourPenalty: 0
            };
            this.peerStats.set(e, t);
        }
        addIP(e, t) {
            const r = this.peerStats.get(e);
            r?.knownIPs.add(t), this.peerIPs.getOrDefault(t).add(e);
        }
        removeIP(e, t) {
            const r = this.peerStats.get(e);
            r?.knownIPs.delete(t);
            const s = this.peerIPs.get(t);
            s != null && (s.delete(e), s.size === 0 && this.peerIPs.delete(t));
        }
        removePeer(e) {
            const t = this.peerStats.get(e);
            if (t != null) {
                if (this.score(e) > 0) {
                    this.removeIPsForPeer(e, t.knownIPs), this.peerStats.delete(e);
                    return;
                }
                Object.entries(t.topics).forEach(([r, s])=>{
                    s.firstMessageDeliveries = 0;
                    const i = this.params.topics[r].meshMessageDeliveriesThreshold;
                    if (s.inMesh && s.meshMessageDeliveriesActive && s.meshMessageDeliveries < i) {
                        const l = i - s.meshMessageDeliveries;
                        s.meshFailurePenalty += l * l;
                    }
                    s.inMesh = !1, s.meshMessageDeliveriesActive = !1;
                }), t.connected = !1, t.expire = Date.now() + this.params.retainScore;
            }
        }
        graft(e, t) {
            const r = this.peerStats.get(e);
            if (r != null) {
                const s = this.getPtopicStats(r, t);
                s != null && (s.inMesh = !0, s.graftTime = Date.now(), s.meshTime = 0, s.meshMessageDeliveriesActive = !1);
            }
        }
        prune(e, t) {
            const r = this.peerStats.get(e);
            if (r != null) {
                const s = this.getPtopicStats(r, t);
                if (s != null) {
                    const i = this.params.topics[t].meshMessageDeliveriesThreshold;
                    if (s.meshMessageDeliveriesActive && s.meshMessageDeliveries < i) {
                        const l = i - s.meshMessageDeliveries;
                        s.meshFailurePenalty += l * l;
                    }
                    s.meshMessageDeliveriesActive = !1, s.inMesh = !1;
                }
            }
        }
        validateMessage(e) {
            this.deliveryRecords.ensureRecord(e);
        }
        deliverMessage(e, t, r) {
            this.markFirstMessageDelivery(e, r);
            const s = this.deliveryRecords.ensureRecord(t), i = Date.now();
            if (s.status !== gr.unknown) {
                this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", e, i - s.firstSeenTsMs, gr[s.status]);
                return;
            }
            s.status = gr.valid, s.validated = i, s.peers.forEach((l)=>{
                l !== e.toString() && this.markDuplicateMessageDelivery(l, r);
            });
        }
        rejectInvalidMessage(e, t) {
            this.markInvalidMessageDelivery(e, t);
        }
        rejectMessage(e, t, r, s) {
            switch(s){
                case Vs.Error:
                    this.markInvalidMessageDelivery(e, r);
                    return;
                case Vs.Blacklisted:
                    return;
            }
            const i = this.deliveryRecords.ensureRecord(t);
            if (i.status !== gr.unknown) {
                this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", e, Date.now() - i.firstSeenTsMs, gr[i.status]);
                return;
            }
            if (s === Vs.Ignore) {
                i.status = gr.ignored, i.peers.clear();
                return;
            }
            i.status = gr.invalid, this.markInvalidMessageDelivery(e, r), i.peers.forEach((l)=>{
                this.markInvalidMessageDelivery(l, r);
            }), i.peers.clear();
        }
        duplicateMessage(e, t, r) {
            const s = this.deliveryRecords.ensureRecord(t);
            if (!s.peers.has(e)) switch(s.status){
                case gr.unknown:
                    s.peers.add(e);
                    break;
                case gr.valid:
                    s.peers.add(e), this.markDuplicateMessageDelivery(e, r, s.validated);
                    break;
                case gr.invalid:
                    this.markInvalidMessageDelivery(e, r);
                    break;
                case gr.ignored:
                    break;
            }
        }
        markInvalidMessageDelivery(e, t) {
            const r = this.peerStats.get(e);
            if (r != null) {
                const s = this.getPtopicStats(r, t);
                s != null && (s.invalidMessageDeliveries += 1);
            }
        }
        markFirstMessageDelivery(e, t) {
            const r = this.peerStats.get(e);
            if (r != null) {
                const s = this.getPtopicStats(r, t);
                if (s != null) {
                    let i = this.params.topics[t].firstMessageDeliveriesCap;
                    s.firstMessageDeliveries = Math.min(i, s.firstMessageDeliveries + 1), s.inMesh && (i = this.params.topics[t].meshMessageDeliveriesCap, s.meshMessageDeliveries = Math.min(i, s.meshMessageDeliveries + 1));
                }
            }
        }
        markDuplicateMessageDelivery(e, t, r) {
            const s = this.peerStats.get(e);
            if (s != null) {
                const i = r !== void 0 ? Date.now() : 0, l = this.getPtopicStats(s, t);
                if (l != null && l.inMesh) {
                    const u = this.params.topics[t];
                    if (r !== void 0) {
                        const f = i - r, p = f > u.meshMessageDeliveriesWindow;
                        if (this.metrics?.onDuplicateMsgDelivery(t, f, p), p) return;
                    }
                    const h = u.meshMessageDeliveriesCap;
                    l.meshMessageDeliveries = Math.min(h, l.meshMessageDeliveries + 1);
                }
            }
        }
        removeIPsForPeer(e, t) {
            for (const r of t){
                const s = this.peerIPs.get(r);
                s != null && (s.delete(e), s.size === 0 && this.peerIPs.delete(r));
            }
        }
        getPtopicStats(e, t) {
            let r = e.topics[t];
            return r !== void 0 ? r : this.params.topics[t] !== void 0 ? (r = {
                inMesh: !1,
                graftTime: 0,
                meshTime: 0,
                firstMessageDeliveries: 0,
                meshMessageDeliveries: 0,
                meshMessageDeliveriesActive: !1,
                meshFailurePenalty: 0,
                invalidMessageDeliveries: 0
            }, e.topics[t] = r, r) : null;
        }
    }
    function C8e(n, e, t, r, s) {
        let i = 0;
        const l = new Map;
        if (Object.entries(e.topics).forEach(([w, A])=>{
            const S = s.get(w) ?? "unknown", _ = t.topics[w];
            if (_ === void 0) return;
            let I = l.get(S);
            I == null && (I = {
                p1w: 0,
                p2w: 0,
                p3w: 0,
                p3bw: 0,
                p4w: 0
            }, l.set(S, I));
            let k = 0, G = 0, P = 0, J = 0, H = 0;
            if (A.inMesh) {
                const O = Math.max(A.meshTime / _.timeInMeshQuantum, _.timeInMeshCap);
                k += O * _.timeInMeshWeight;
            }
            let F = A.firstMessageDeliveries;
            if (F > _.firstMessageDeliveriesCap && (F = _.firstMessageDeliveriesCap), G += F * _.firstMessageDeliveriesWeight, A.meshMessageDeliveriesActive && A.meshMessageDeliveries < _.meshMessageDeliveriesThreshold) {
                const O = _.meshMessageDeliveriesThreshold - A.meshMessageDeliveries, se = O * O;
                P += se * _.meshMessageDeliveriesWeight;
            }
            const $ = A.meshFailurePenalty;
            J += $ * _.meshFailurePenaltyWeight;
            const Y = A.invalidMessageDeliveries * A.invalidMessageDeliveries;
            H += Y * _.invalidMessageDeliveriesWeight, i += (k + G + P + J + H) * _.topicWeight, I.p1w += k, I.p2w += G, I.p3w += P, I.p3bw += J, I.p4w += H;
        }), t.topicScoreCap > 0 && i > t.topicScoreCap) {
            i = t.topicScoreCap;
            const w = t.topicScoreCap / i;
            for (const A of l.values())A.p1w *= w, A.p2w *= w, A.p3w *= w, A.p3bw *= w, A.p4w *= w;
        }
        let u = 0, h = 0, f = 0;
        const p = t.appSpecificScore(n);
        u += p * t.appSpecificWeight, e.knownIPs.forEach((w)=>{
            if (t.IPColocationFactorWhitelist.has(w)) return;
            const A = r.get(w), S = A != null ? A.size : 0;
            if (S > t.IPColocationFactorThreshold) {
                const _ = S - t.IPColocationFactorThreshold, I = _ * _;
                h += I * t.IPColocationFactorWeight;
            }
        });
        const m = e.behaviourPenalty * e.behaviourPenalty;
        return f += m * t.behaviourPenaltyWeight, i += u + h + f, {
            byTopic: l,
            p5w: u,
            p6w: h,
            p7w: f,
            score: i
        };
    }
    function T8e(n, e, t, r, s) {
        const i = {
            byTopic: new Map,
            p5w: [],
            p6w: [],
            p7w: [],
            score: []
        };
        for (const l of n){
            const u = e.get(l);
            if (u != null) {
                const h = C8e(l, u, t, r, s);
                for (const [f, p] of h.byTopic){
                    let m = i.byTopic.get(f);
                    m == null && (m = {
                        p1w: [],
                        p2w: [],
                        p3w: [],
                        p3bw: [],
                        p4w: []
                    }, i.byTopic.set(f, m)), m.p1w.push(p.p1w), m.p2w.push(p.p2w), m.p3w.push(p.p3w), m.p3bw.push(p.p3bw), m.p4w.push(p.p4w);
                }
                i.p5w.push(h.p5w), i.p6w.push(h.p6w), i.p7w.push(h.p7w), i.score.push(h.score);
            } else i.p5w.push(0), i.p6w.push(0), i.p7w.push(0), i.score.push(0);
        }
        return i;
    }
    class _8e {
        rawStream;
        pushable;
        closeController;
        maxBufferSize;
        constructor(e, t, r){
            this.rawStream = e, this.pushable = Hs(), this.closeController = new AbortController, this.maxBufferSize = r.maxBufferSize ?? 1 / 0, this.closeController.signal.addEventListener("abort", ()=>{
                e.close().catch((s)=>{
                    e.abort(s);
                });
            }), Oc(this.pushable, this.rawStream).catch(t);
        }
        get protocol() {
            return this.rawStream.protocol;
        }
        push(e) {
            if (this.pushable.readableLength > this.maxBufferSize) throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
            this.pushable.push(r5.single(e));
        }
        pushPrefixed(e) {
            if (this.pushable.readableLength > this.maxBufferSize) throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
            this.pushable.push(e);
        }
        async close() {
            this.closeController.abort(), await this.pushable.return();
        }
    }
    class x8e {
        source;
        rawStream;
        closeController;
        constructor(e, t = {}){
            this.rawStream = e, this.closeController = new AbortController, this.closeController.signal.addEventListener("abort", ()=>{
                e.close().catch((r)=>{
                    e.abort(r);
                });
            }), this.source = Oc(this.rawStream, (r)=>Q4(r, t));
        }
        async close() {
            this.closeController.abort();
        }
    }
    class D8e {
        gossipsubIWantFollowupMs;
        msgIdToStrFn;
        metrics;
        promises = new Map;
        requestMsByMsg = new Map;
        requestMsByMsgExpire;
        constructor(e, t, r){
            this.gossipsubIWantFollowupMs = e, this.msgIdToStrFn = t, this.metrics = r, this.requestMsByMsgExpire = 10 * e;
        }
        get size() {
            return this.promises.size;
        }
        get requestMsByMsgSize() {
            return this.requestMsByMsg.size;
        }
        addPromise(e, t) {
            const r = Math.floor(Math.random() * t.length), s = t[r], i = this.msgIdToStrFn(s);
            let l = this.promises.get(i);
            l == null && (l = new Map, this.promises.set(i, l));
            const u = Date.now();
            l.has(e) || (l.set(e, u + this.gossipsubIWantFollowupMs), this.metrics != null && (this.metrics.iwantPromiseStarted.inc(1), this.requestMsByMsg.has(i) || this.requestMsByMsg.set(i, u)));
        }
        getBrokenPromises() {
            const e = Date.now(), t = new Map;
            let r = 0;
            return this.promises.forEach((s, i)=>{
                s.forEach((l, u)=>{
                    l < e && (t.set(u, (t.get(u) ?? 0) + 1), s.delete(u), r++);
                }), s.size === 0 && this.promises.delete(i);
            }), this.metrics?.iwantPromiseBroken.inc(r), t;
        }
        deliverMessage(e, t = !1) {
            this.trackMessage(e);
            const r = this.promises.get(e);
            r != null && (this.promises.delete(e), this.metrics != null && (this.metrics.iwantPromiseResolved.inc(1), t && this.metrics.iwantPromiseResolvedFromDuplicate.inc(1), this.metrics.iwantPromiseResolvedPeers.inc(r.size)));
        }
        rejectMessage(e, t) {
            this.trackMessage(e), t !== Vs.Error && this.promises.delete(e);
        }
        clear() {
            this.promises.clear();
        }
        prune() {
            const e = Date.now() - this.requestMsByMsgExpire;
            let t = 0;
            for (const [r, s] of this.requestMsByMsg.entries())if (s < e) this.requestMsByMsg.delete(r), t++;
            else break;
            this.metrics?.iwantMessagePruned.inc(t);
        }
        trackMessage(e) {
            if (this.metrics != null) {
                const t = this.requestMsByMsg.get(e);
                t !== void 0 && (this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - t) / 1e3), this.requestMsByMsg.delete(e));
            }
        }
    }
    const Tk = re("libp2p-pubsub:");
    async function B8e(n, e, t, r) {
        switch(n.type){
            case Xc.Signing:
                {
                    const s = {
                        from: n.author.toMultihash().bytes,
                        data: r,
                        seqno: Go(8),
                        topic: e,
                        signature: void 0,
                        key: void 0
                    }, i = xe([
                        Tk,
                        za.Message.encode(s)
                    ]);
                    s.signature = await n.privateKey.sign(i), s.key = n.key;
                    const l = {
                        type: "signed",
                        from: n.author,
                        data: t,
                        sequenceNumber: BigInt(`0x${L(s.seqno ?? new Uint8Array(0), "base16")}`),
                        topic: e,
                        signature: s.signature,
                        key: Er(s.key)
                    };
                    return {
                        raw: s,
                        msg: l
                    };
                }
            case Xc.Anonymous:
                return {
                    raw: {
                        from: void 0,
                        data: r,
                        seqno: void 0,
                        topic: e,
                        signature: void 0,
                        key: void 0
                    },
                    msg: {
                        type: "unsigned",
                        data: t,
                        topic: e
                    }
                };
            default:
                throw new Error("Unreachable");
        }
    }
    async function P8e(n, e) {
        switch(n){
            case t5:
                return e.signature != null ? {
                    valid: !1,
                    error: pr.SignaturePresent
                } : e.seqno != null ? {
                    valid: !1,
                    error: pr.SeqnoPresent
                } : e.from != null ? {
                    valid: !1,
                    error: pr.FromPresent
                } : {
                    valid: !0,
                    message: {
                        type: "unsigned",
                        topic: e.topic,
                        data: e.data ?? new Uint8Array(0)
                    }
                };
            case ig:
                {
                    if (e.seqno == null) return {
                        valid: !1,
                        error: pr.InvalidSeqno
                    };
                    if (e.seqno.length !== 8) return {
                        valid: !1,
                        error: pr.InvalidSeqno
                    };
                    if (e.signature == null) return {
                        valid: !1,
                        error: pr.InvalidSignature
                    };
                    if (e.from == null) return {
                        valid: !1,
                        error: pr.InvalidPeerId
                    };
                    let t;
                    try {
                        t = Vg(kt(e.from));
                    } catch  {
                        return {
                            valid: !1,
                            error: pr.InvalidPeerId
                        };
                    }
                    let r;
                    if (e.key != null) {
                        if (r = Er(e.key), t.publicKey !== void 0 && !r.equals(t.publicKey)) return {
                            valid: !1,
                            error: pr.InvalidPeerId
                        };
                    } else {
                        if (t.publicKey == null) return {
                            valid: !1,
                            error: pr.InvalidPeerId
                        };
                        r = t.publicKey;
                    }
                    const s = {
                        from: e.from,
                        data: e.data,
                        seqno: e.seqno,
                        topic: e.topic,
                        signature: void 0,
                        key: void 0
                    }, i = xe([
                        Tk,
                        za.Message.encode(s)
                    ]);
                    return await r.verify(i, e.signature) ? {
                        valid: !0,
                        message: {
                            type: "signed",
                            from: t,
                            data: e.data ?? new Uint8Array(0),
                            sequenceNumber: BigInt(`0x${L(e.seqno, "base16")}`),
                            topic: e.topic,
                            signature: e.signature,
                            key: r
                        }
                    } : {
                        valid: !1,
                        error: pr.InvalidSignature
                    };
                }
            default:
                throw new Error("Unreachable");
        }
    }
    function Xs(n = [], e) {
        return {
            subscriptions: [],
            messages: n,
            control: e !== void 0 ? {
                graft: e.graft ?? [],
                prune: e.prune ?? [],
                ihave: e.ihave ?? [],
                iwant: e.iwant ?? [],
                idontwant: e.idontwant ?? []
            } : void 0
        };
    }
    function $S(n) {
        return n.control === void 0 && (n.control = {
            graft: [],
            prune: [],
            ihave: [],
            iwant: [],
            idontwant: []
        }), n;
    }
    function Ui(n) {
        if (n.length <= 1) return n;
        const e = ()=>Math.floor(Math.random() * Math.floor(n.length));
        for(let t = 0; t < n.length; t++){
            const r = e(), s = n[t];
            n[t] = n[r], n[r] = s;
        }
        return n;
    }
    function k8e(n) {
        return L(n, "base64");
    }
    function R8e(n, e, t) {
        switch(n){
            case ig:
                return {
                    type: Xc.Signing,
                    author: e,
                    key: Fr(t.publicKey),
                    privateKey: t
                };
            case t5:
                return {
                    type: Xc.Anonymous
                };
            default:
                throw new Error(`Unknown signature policy "${n}"`);
        }
    }
    const O8e = (n, e)=>{
        const t = re(e.toString(16).padStart(16, "0"), "base16"), r = Fr(n), s = new Uint8Array(r.byteLength + t.length);
        return s.set(r, 0), s.set(t, r.byteLength), s;
    };
    function $8e(n) {
        if (n.type !== "signed") throw new Error("expected signed message type");
        if (n.sequenceNumber == null) throw Error("missing seqno field");
        return O8e(n.from.publicKey ?? n.key, n.sequenceNumber);
    }
    async function M8e(n) {
        return Ut.encode(n.data);
    }
    const N8e = 4, L8e = 6, U8e = 273, z8e = 33, F8e = 41, V8e = 42, H8e = 43, Q8e = 53, q8e = 54, K8e = 55, G8e = 56, Y8e = 132, W8e = 301, j8e = 302, X8e = 400, J8e = 421, Z8e = 444, e5e = 445, t5e = 446, n5e = 447, r5e = 448, s5e = 449, i5e = 454, o5e = 460, a5e = 461, l5e = 465, c5e = 466, u5e = 480, h5e = 481, d5e = 443, f5e = 477, p5e = 478, g5e = 479, m5e = 277, y5e = 275, w5e = 276, b5e = 280, v5e = 281, E5e = 290, A5e = 777;
    class Jc extends Error {
        static name = "InvalidMultiaddrError";
        name = "InvalidMultiaddrError";
    }
    class vf extends Error {
        static name = "ValidationError";
        name = "ValidationError";
    }
    class S5e extends Error {
        static name = "UnknownProtocolError";
        name = "UnknownProtocolError";
    }
    function MS(n) {
        return (e)=>L(e, n);
    }
    function NS(n) {
        return (e)=>re(e, n);
    }
    function dd(n) {
        return new DataView(n.buffer).getUint16(n.byteOffset).toString();
    }
    function yc(n) {
        const e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, typeof n == "string" ? parseInt(n) : n), new Uint8Array(e);
    }
    function I5e(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        const t = re(e[0], "base32"), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = yc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function C5e(n) {
        const e = n.split(":");
        if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        const t = At.decode(`b${e[0]}`), r = parseInt(e[1], 10);
        if (r < 1 || r > 65536) throw new Error("Port number is not in range(1, 65536)");
        const s = yc(r);
        return xe([
            t,
            s
        ], t.length + s.length);
    }
    function LS(n) {
        const e = n.subarray(0, n.length - 2), t = n.subarray(n.length - 2), r = L(e, "base32"), s = dd(t);
        return `${r}:${s}`;
    }
    const _k = function(n) {
        n = n.toString().trim();
        const e = new Uint8Array(4);
        return n.split(/\./g).forEach((t, r)=>{
            const s = parseInt(t, 10);
            if (isNaN(s) || s < 0 || s > 255) throw new Jc("Invalid byte value in IP address");
            e[r] = s;
        }), e;
    }, T5e = function(n) {
        let e = 0;
        n = n.toString().trim();
        const t = n.split(":", 8);
        let r;
        for(r = 0; r < t.length; r++){
            const i = Je(t[r]);
            let l;
            i && (l = _k(t[r]), t[r] = L(l.subarray(0, 2), "base16")), l != null && ++r < 8 && t.splice(r, 0, L(l.subarray(2, 4), "base16"));
        }
        if (t[0] === "") for(; t.length < 8;)t.unshift("0");
        else if (t[t.length - 1] === "") for(; t.length < 8;)t.push("0");
        else if (t.length < 8) {
            for(r = 0; r < t.length && t[r] !== ""; r++);
            const i = [
                r,
                1
            ];
            for(r = 9 - t.length; r > 0; r--)i.push("0");
            t.splice.apply(t, i);
        }
        const s = new Uint8Array(e + 16);
        for(r = 0; r < t.length; r++){
            t[r] === "" && (t[r] = "0");
            const i = parseInt(t[r], 16);
            if (isNaN(i) || i < 0 || i > 65535) throw new Jc("Invalid byte value in IP address");
            s[e++] = i >> 8 & 255, s[e++] = i & 255;
        }
        return s;
    }, _5e = function(n) {
        if (n.byteLength !== 4) throw new Jc("IPv4 address was incorrect length");
        const e = [];
        for(let t = 0; t < n.byteLength; t++)e.push(n[t]);
        return e.join(".");
    }, x5e = function(n) {
        if (n.byteLength !== 16) throw new Jc("IPv6 address was incorrect length");
        const e = [];
        for(let r = 0; r < n.byteLength; r += 2){
            const s = n[r], i = n[r + 1], l = `${s.toString(16).padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
            e.push(l);
        }
        const t = e.join(":");
        try {
            const r = new URL(`http://[${t}]`);
            return r.hostname.substring(1, r.hostname.length - 1);
        } catch  {
            throw new Jc(`Invalid IPv6 address "${t}"`);
        }
    };
    function D5e(n) {
        try {
            const e = new URL(`http://[${n}]`);
            return e.hostname.substring(1, e.hostname.length - 1);
        } catch  {
            throw new Jc(`Invalid IPv6 address "${n}"`);
        }
    }
    const Sy = Object.values(un).map((n)=>n.decoder), B5e = (function() {
        let n = Sy[0].or(Sy[1]);
        return Sy.slice(2).forEach((e)=>n = n.or(e)), n;
    })();
    function P5e(n) {
        return B5e.decode(n);
    }
    function k5e(n) {
        return (e)=>n.encoder.encode(e);
    }
    function R5e(n) {
        if (parseInt(n).toString() !== n) throw new vf("Value must be an integer");
    }
    function O5e(n) {
        if (n < 0) throw new vf("Value must be a positive integer, or zero");
    }
    function $5e(n) {
        return (e)=>{
            if (e > n) throw new vf(`Value must be smaller than or equal to ${n}`);
        };
    }
    function M5e(...n) {
        return (e)=>{
            for (const t of n)t(e);
        };
    }
    const X0 = M5e(R5e, O5e, $5e(65535)), Rr = -1;
    let N5e = class {
        protocolsByCode = new Map;
        protocolsByName = new Map;
        getProtocol(e) {
            let t;
            if (typeof e == "string" ? t = this.protocolsByName.get(e) : t = this.protocolsByCode.get(e), t == null) throw new S5e(`Protocol ${e} was unknown`);
            return t;
        }
        addProtocol(e) {
            this.protocolsByCode.set(e.code, e), this.protocolsByName.set(e.name, e), e.aliases?.forEach((t)=>{
                this.protocolsByName.set(t, e);
            });
        }
        removeProtocol(e) {
            const t = this.protocolsByCode.get(e);
            t != null && (this.protocolsByCode.delete(t.code), this.protocolsByName.delete(t.name), t.aliases?.forEach((r)=>{
                this.protocolsByName.delete(r);
            }));
        }
    };
    const xk = new N5e, L5e = [
        {
            code: N8e,
            name: "ip4",
            size: 32,
            valueToBytes: _k,
            bytesToValue: _5e,
            validate: (n)=>{
                if (!Je(n)) throw new vf(`Invalid IPv4 address "${n}"`);
            }
        },
        {
            code: L8e,
            name: "tcp",
            size: 16,
            valueToBytes: yc,
            bytesToValue: dd,
            validate: X0
        },
        {
            code: U8e,
            name: "udp",
            size: 16,
            valueToBytes: yc,
            bytesToValue: dd,
            validate: X0
        },
        {
            code: z8e,
            name: "dccp",
            size: 16,
            valueToBytes: yc,
            bytesToValue: dd,
            validate: X0
        },
        {
            code: F8e,
            name: "ip6",
            size: 128,
            valueToBytes: T5e,
            bytesToValue: x5e,
            stringToValue: D5e,
            validate: (n)=>{
                if (!xn(n)) throw new vf(`Invalid IPv6 address "${n}"`);
            }
        },
        {
            code: V8e,
            name: "ip6zone",
            size: Rr
        },
        {
            code: H8e,
            name: "ipcidr",
            size: 8,
            bytesToValue: MS("base10"),
            valueToBytes: NS("base10")
        },
        {
            code: Q8e,
            name: "dns",
            size: Rr,
            resolvable: !0
        },
        {
            code: q8e,
            name: "dns4",
            size: Rr,
            resolvable: !0
        },
        {
            code: K8e,
            name: "dns6",
            size: Rr,
            resolvable: !0
        },
        {
            code: G8e,
            name: "dnsaddr",
            size: Rr,
            resolvable: !0
        },
        {
            code: Y8e,
            name: "sctp",
            size: 16,
            valueToBytes: yc,
            bytesToValue: dd,
            validate: X0
        },
        {
            code: W8e,
            name: "udt"
        },
        {
            code: j8e,
            name: "utp"
        },
        {
            code: X8e,
            name: "unix",
            size: Rr,
            path: !0,
            stringToValue: (n)=>decodeURIComponent(n),
            valueToString: (n)=>encodeURIComponent(n)
        },
        {
            code: J8e,
            name: "p2p",
            aliases: [
                "ipfs"
            ],
            size: Rr,
            bytesToValue: MS("base58btc"),
            valueToBytes: (n)=>n.startsWith("Q") || n.startsWith("1") ? NS("base58btc")(n) : ge.parse(n).multihash.bytes
        },
        {
            code: Z8e,
            name: "onion",
            size: 96,
            bytesToValue: LS,
            valueToBytes: I5e
        },
        {
            code: e5e,
            name: "onion3",
            size: 296,
            bytesToValue: LS,
            valueToBytes: C5e
        },
        {
            code: t5e,
            name: "garlic64",
            size: Rr
        },
        {
            code: n5e,
            name: "garlic32",
            size: Rr
        },
        {
            code: r5e,
            name: "tls"
        },
        {
            code: s5e,
            name: "sni",
            size: Rr
        },
        {
            code: i5e,
            name: "noise"
        },
        {
            code: o5e,
            name: "quic"
        },
        {
            code: a5e,
            name: "quic-v1"
        },
        {
            code: l5e,
            name: "webtransport"
        },
        {
            code: c5e,
            name: "certhash",
            size: Rr,
            bytesToValue: k5e(yn),
            valueToBytes: P5e
        },
        {
            code: u5e,
            name: "http"
        },
        {
            code: h5e,
            name: "http-path",
            size: Rr,
            stringToValue: (n)=>`/${decodeURIComponent(n)}`,
            valueToString: (n)=>encodeURIComponent(n.substring(1))
        },
        {
            code: d5e,
            name: "https"
        },
        {
            code: f5e,
            name: "ws"
        },
        {
            code: p5e,
            name: "wss"
        },
        {
            code: g5e,
            name: "p2p-websocket-star"
        },
        {
            code: m5e,
            name: "p2p-stardust"
        },
        {
            code: y5e,
            name: "p2p-webrtc-star"
        },
        {
            code: w5e,
            name: "p2p-webrtc-direct"
        },
        {
            code: b5e,
            name: "webrtc-direct"
        },
        {
            code: v5e,
            name: "webrtc"
        },
        {
            code: E5e,
            name: "p2p-circuit"
        },
        {
            code: A5e,
            name: "memory",
            size: Rr
        }
    ];
    L5e.forEach((n)=>{
        xk.addProtocol(n);
    });
    function U5e(n, e) {
        return xk.getProtocol(n).bytesToValue?.(e) ?? L(e, "base16");
    }
    var og;
    (function(n) {
        n[n.ip4 = 4] = "ip4", n[n.ip6 = 41] = "ip6";
    })(og || (og = {}));
    function z5e(n) {
        for (const e of n.tuples())switch(e[0]){
            case og.ip4:
            case og.ip6:
                return U5e(e[0], e[1]);
        }
        return null;
    }
    class Iy {
        entries = new Map;
        validityMs;
        constructor(e){
            this.validityMs = e.validityMs;
        }
        get size() {
            return this.entries.size;
        }
        put(e, t) {
            return this.entries.has(e) ? !0 : (this.entries.set(e, {
                value: t,
                validUntilMs: Date.now() + this.validityMs
            }), !1);
        }
        prune() {
            const e = Date.now();
            for (const [t, r] of this.entries.entries())if (r.validUntilMs < e) this.entries.delete(t);
            else break;
        }
        has(e) {
            return this.entries.has(e);
        }
        get(e) {
            const t = this.entries.get(e);
            return t != null && t.validUntilMs >= Date.now() ? t.value : void 0;
        }
        clear() {
            this.entries.clear();
        }
    }
    var Or;
    (function(n) {
        n[n.started = 0] = "started", n[n.stopped = 1] = "stopped";
    })(Or || (Or = {}));
    class F5e extends Lt {
        globalSignaturePolicy;
        multicodecs = [
            Ey,
            C6e,
            DS
        ];
        publishConfig;
        dataTransform;
        peers = new Map;
        streamsInbound = new Map;
        streamsOutbound = new Map;
        outboundInflightQueue = Hs({
            objectMode: !0
        });
        direct = new Set;
        floodsubPeers = new Set;
        seenCache;
        acceptFromWhitelist = new Map;
        topics = new Map;
        subscriptions = new Set;
        mesh = new Map;
        fanout = new Map;
        fanoutLastpub = new Map;
        gossip = new Map;
        control = new Map;
        peerhave = new Map;
        iasked = new Map;
        backoff = new Map;
        outbound = new Map;
        msgIdFn;
        fastMsgIdFn;
        msgIdToStrFn;
        fastMsgIdCache;
        publishedMessageIds;
        mcache;
        score;
        topicValidators = new Map;
        log;
        heartbeatTicks = 0;
        gossipTracer;
        idontwantCounts = new Map;
        idontwants = new Map;
        components;
        directPeerInitial = null;
        static multicodec = Ey;
        opts;
        decodeRpcLimits;
        metrics;
        status = {
            code: Or.stopped
        };
        maxInboundStreams;
        maxOutboundStreams;
        runOnLimitedConnection;
        allowedTopics;
        heartbeatTimer = null;
        constructor(e, t = {}){
            super();
            const r = {
                fallbackToFloodsub: !0,
                floodPublish: !0,
                batchPublish: !1,
                tagMeshPeers: !0,
                doPX: !1,
                directPeers: [],
                D: T6e,
                Dlo: _6e,
                Dhi: x6e,
                Dscore: D6e,
                Dout: B6e,
                Dlazy: R6e,
                heartbeatInterval: M6e,
                fanoutTTL: N6e,
                mcacheLength: P6e,
                mcacheGossip: k6e,
                seenTTL: W6e,
                gossipsubIWantFollowupMs: Y6e,
                prunePeers: L6e,
                pruneBackoff: U6e,
                unsubcribeBackoff: z6e,
                graftFloodThreshold: K6e,
                opportunisticGraftPeers: q6e,
                opportunisticGraftTicks: Q6e,
                directConnectTicks: V6e,
                gossipFactor: O6e,
                idontwantMinDataSize: s8e,
                idontwantMaxMessages: i8e,
                ...t,
                scoreParams: h8e(t.scoreParams),
                scoreThresholds: m8e(t.scoreThresholds)
            };
            if (this.components = e, this.decodeRpcLimits = r.decodeRpcLimits ?? o8e, this.globalSignaturePolicy = r.globalSignaturePolicy ?? ig, r.fallbackToFloodsub && this.multicodecs.push(xS), this.log = e.logger.forComponent(r.debugName ?? "libp2p:gossipsub"), this.opts = r, this.direct = new Set(r.directPeers.map((s)=>s.id.toString())), this.seenCache = new Iy({
                validityMs: r.seenTTL
            }), this.publishedMessageIds = new Iy({
                validityMs: r.seenTTL
            }), t.msgIdFn != null) this.msgIdFn = t.msgIdFn;
            else switch(this.globalSignaturePolicy){
                case ig:
                    this.msgIdFn = $8e;
                    break;
                case t5:
                    this.msgIdFn = M8e;
                    break;
                default:
                    throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`);
            }
            if (t.fastMsgIdFn != null && (this.fastMsgIdFn = t.fastMsgIdFn, this.fastMsgIdCache = new Iy({
                validityMs: r.seenTTL
            })), this.msgIdToStrFn = t.msgIdToStrFn ?? k8e, this.mcache = t.messageCache ?? new a8e(r.mcacheGossip, r.mcacheLength, this.msgIdToStrFn), t.dataTransform != null && (this.dataTransform = t.dataTransform), t.metricsRegister != null) {
                if (t.metricsTopicStrToLabel == null) throw Error("Must set metricsTopicStrToLabel with metrics");
                const s = Math.max(...Object.values(r.scoreParams.topics).map((l)=>l.meshMessageDeliveriesWindow), n8e), i = l8e(t.metricsRegister, t.metricsTopicStrToLabel, {
                    gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
                    behaviourPenaltyThreshold: r.scoreParams.behaviourPenaltyThreshold,
                    maxMeshMessageDeliveriesWindowSec: s / 1e3
                });
                i.mcacheSize.addCollect(()=>{
                    this.onScrapeMetrics(i);
                });
                for (const l of this.multicodecs)i.protocolsEnabled.set({
                    protocol: l
                }, 1);
                this.metrics = i;
            } else this.metrics = null;
            this.gossipTracer = new D8e(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics), this.score = new I8e(this.opts.scoreParams, this.metrics, this.components.logger, {
                scoreCacheValidityMs: r.heartbeatInterval
            }), this.maxInboundStreams = t.maxInboundStreams, this.maxOutboundStreams = t.maxOutboundStreams, this.runOnLimitedConnection = t.runOnLimitedConnection, this.allowedTopics = r.allowedTopics != null ? new Set(r.allowedTopics) : null;
        }
        [Symbol.toStringTag] = "@chainsafe/libp2p-gossipsub";
        [c6e] = [
            "@libp2p/pubsub"
        ];
        [u6e] = [
            "@libp2p/identify"
        ];
        getPeers() {
            return [
                ...this.peers.values()
            ];
        }
        isStarted() {
            return this.status.code === Or.started;
        }
        async start() {
            if (this.isStarted()) return;
            this.log("starting"), this.publishConfig = R8e(this.globalSignaturePolicy, this.components.peerId, this.components.privateKey), this.outboundInflightQueue = Hs({
                objectMode: !0
            }), Oc(this.outboundInflightQueue, async (i)=>{
                for await (const { peerId: l, connection: u } of i)await this.createOutboundStream(l, u);
            }).catch((i)=>{
                this.log.error("outbound inflight queue error", i);
            }), await Promise.all(this.opts.directPeers.map(async (i)=>{
                await this.components.peerStore.merge(i.id, {
                    multiaddrs: i.addrs
                });
            }));
            const e = this.components.registrar;
            await Promise.all(this.multicodecs.map(async (i)=>e.handle(i, this.onIncomingStream.bind(this), {
                    maxInboundStreams: this.maxInboundStreams,
                    maxOutboundStreams: this.maxOutboundStreams,
                    runOnLimitedConnection: this.runOnLimitedConnection
                })));
            const t = {
                onConnect: this.onPeerConnected.bind(this),
                onDisconnect: this.onPeerDisconnected.bind(this),
                notifyOnLimitedConnection: this.runOnLimitedConnection
            }, r = await Promise.all(this.multicodecs.map(async (i)=>e.register(i, t))), s = setTimeout(this.runHeartbeat, BS);
            this.status = {
                code: Or.started,
                registrarTopologyIds: r,
                heartbeatTimeout: s,
                hearbeatStartMs: Date.now() + BS
            }, this.score.start(), this.directPeerInitial = setTimeout(()=>{
                Promise.resolve().then(async ()=>{
                    await Promise.all(Array.from(this.direct).map(async (i)=>this.connect(i)));
                }).catch((i)=>{
                    this.log(i);
                });
            }, H6e), this.opts.tagMeshPeers && (this.addEventListener("gossipsub:graft", this.tagMeshPeer), this.addEventListener("gossipsub:prune", this.untagMeshPeer)), this.log("started");
        }
        async stop() {
            if (this.log("stopping"), this.status.code !== Or.started) return;
            const { registrarTopologyIds: e } = this.status;
            this.status = {
                code: Or.stopped
            }, this.opts.tagMeshPeers && (this.removeEventListener("gossipsub:graft", this.tagMeshPeer), this.removeEventListener("gossipsub:prune", this.untagMeshPeer));
            const t = this.components.registrar;
            await Promise.all(this.multicodecs.map(async (s)=>t.unhandle(s))), e.forEach((s)=>{
                t.unregister(s);
            }), this.outboundInflightQueue.end();
            const r = [];
            for (const s of this.streamsOutbound.values())r.push(s.close());
            this.streamsOutbound.clear();
            for (const s of this.streamsInbound.values())r.push(s.close());
            this.streamsInbound.clear(), await Promise.all(r), this.peers.clear(), this.subscriptions.clear(), this.heartbeatTimer != null && (this.heartbeatTimer.cancel(), this.heartbeatTimer = null), this.score.stop(), this.mesh.clear(), this.fanout.clear(), this.fanoutLastpub.clear(), this.gossip.clear(), this.control.clear(), this.peerhave.clear(), this.iasked.clear(), this.backoff.clear(), this.outbound.clear(), this.gossipTracer.clear(), this.seenCache.clear(), this.fastMsgIdCache != null && this.fastMsgIdCache.clear(), this.directPeerInitial != null && clearTimeout(this.directPeerInitial), this.idontwantCounts.clear(), this.idontwants.clear(), this.log("stopped");
        }
        dumpPeerScoreStats() {
            return this.score.dumpPeerScoreStats();
        }
        onIncomingStream({ stream: e, connection: t }) {
            if (!this.isStarted()) return;
            const r = t.remotePeer;
            this.addPeer(r, t.direction, t.remoteAddr), this.createInboundStream(r, e), this.outboundInflightQueue.push({
                peerId: r,
                connection: t
            });
        }
        onPeerConnected(e, t) {
            this.metrics?.newConnectionCount.inc({
                status: t.status
            }), !(!this.isStarted() || t.status !== "open") && (this.addPeer(e, t.direction, t.remoteAddr), this.outboundInflightQueue.push({
                peerId: e,
                connection: t
            }));
        }
        onPeerDisconnected(e) {
            this.log("connection ended %p", e), this.removePeer(e);
        }
        async createOutboundStream(e, t) {
            if (!this.isStarted()) return;
            const r = e.toString();
            if (this.peers.has(r) && !this.streamsOutbound.has(r)) try {
                const s = new _8e(await t.newStream(this.multicodecs, {
                    runOnLimitedConnection: this.runOnLimitedConnection
                }), (l)=>{
                    this.log.error("outbound pipe error", l);
                }, {
                    maxBufferSize: this.opts.maxOutboundBufferSize
                });
                this.log("create outbound stream %p", e), this.streamsOutbound.set(r, s);
                const i = s.protocol;
                i === xS && this.floodsubPeers.add(r), this.metrics?.peersPerProtocol.inc({
                    protocol: i
                }, 1), this.subscriptions.size > 0 && (this.log("send subscriptions to", r), this.sendSubscriptions(r, Array.from(this.subscriptions), !0));
            } catch (s) {
                this.log.error("createOutboundStream error", s);
            }
        }
        createInboundStream(e, t) {
            if (!this.isStarted()) return;
            const r = e.toString();
            if (!this.peers.has(r)) return;
            const s = this.streamsInbound.get(r);
            s !== void 0 && (this.log("replacing existing inbound steam %s", r), s.close().catch((l)=>{
                this.log.error(l);
            })), this.log("create inbound stream %s", r);
            const i = new x8e(t, {
                maxDataLength: this.opts.maxInboundDataLength
            });
            this.streamsInbound.set(r, i), this.pipePeerReadStream(e, i.source).catch((l)=>{
                this.log(l);
            });
        }
        addPeer(e, t, r) {
            const s = e.toString();
            if (!this.peers.has(s)) {
                this.log("new peer %p", e), this.peers.set(s, e), this.score.addPeer(s);
                const i = z5e(r);
                i !== null ? this.score.addIP(s, i) : this.log("Added peer has no IP in current address %s %s", s, r.toString()), this.outbound.has(s) || this.outbound.set(s, t === "outbound");
            }
        }
        removePeer(e) {
            const t = e.toString();
            if (!this.peers.has(t)) return;
            this.log("delete peer %p", e), this.peers.delete(t);
            const r = this.streamsOutbound.get(t), s = this.streamsInbound.get(t);
            r != null && this.metrics?.peersPerProtocol.inc({
                protocol: r.protocol
            }, -1), r?.close().catch((i)=>{
                this.log.error(i);
            }), s?.close().catch((i)=>{
                this.log.error(i);
            }), this.streamsOutbound.delete(t), this.streamsInbound.delete(t);
            for (const i of this.topics.values())i.delete(t);
            for (const [i, l] of this.mesh)l.delete(t) && this.metrics?.onRemoveFromMesh(i, oi.Dc, 1);
            for (const i of this.fanout.values())i.delete(t);
            this.floodsubPeers.delete(t), this.gossip.delete(t), this.control.delete(t), this.outbound.delete(t), this.idontwantCounts.delete(t), this.idontwants.delete(t), this.score.removePeer(t), this.acceptFromWhitelist.delete(t);
        }
        get started() {
            return this.status.code === Or.started;
        }
        getMeshPeers(e) {
            const t = this.mesh.get(e);
            return t != null ? Array.from(t) : [];
        }
        getSubscribers(e) {
            const t = this.topics.get(e);
            return (t != null ? Array.from(t) : []).map((r)=>this.peers.get(r) ?? Wl(r));
        }
        getTopics() {
            return Array.from(this.subscriptions);
        }
        async pipePeerReadStream(e, t) {
            try {
                await Oc(t, async (r)=>{
                    for await (const s of r)try {
                        const i = s.subarray(), l = za.decode(i, {
                            limits: {
                                subscriptions: this.decodeRpcLimits.maxSubscriptions,
                                messages: this.decodeRpcLimits.maxMessages,
                                control$: {
                                    ihave: this.decodeRpcLimits.maxIhaveMessageIDs,
                                    iwant: this.decodeRpcLimits.maxIwantMessageIDs,
                                    graft: this.decodeRpcLimits.maxControlMessages,
                                    prune: this.decodeRpcLimits.maxControlMessages,
                                    prune$: {
                                        peers: this.decodeRpcLimits.maxPeerInfos
                                    },
                                    idontwant: this.decodeRpcLimits.maxControlMessages,
                                    idontwant$: {
                                        messageIDs: this.decodeRpcLimits.maxIdontwantMessageIDs
                                    }
                                }
                            }
                        });
                        if (this.metrics?.onRpcRecv(l, i.length), this.opts.awaitRpcHandler) try {
                            await this.handleReceivedRpc(e, l);
                        } catch (u) {
                            this.metrics?.onRpcRecvError(), this.log(u);
                        }
                        else this.handleReceivedRpc(e, l).catch((u)=>{
                            this.metrics?.onRpcRecvError(), this.log(u);
                        });
                    } catch (i) {
                        this.metrics?.onRpcDataError(), this.log(i);
                    }
                });
            } catch (r) {
                this.metrics?.onPeerReadStreamError(), this.handlePeerReadStreamError(r, e);
            }
        }
        handlePeerReadStreamError(e, t) {
            this.log.error(e), this.onPeerDisconnected(t);
        }
        async handleReceivedRpc(e, t) {
            if (!this.acceptFrom(e.toString())) {
                this.log("received message from unacceptable peer %p", e), this.metrics?.rpcRecvNotAccepted.inc();
                return;
            }
            const r = t.subscriptions != null ? t.subscriptions.length : 0, s = t.messages != null ? t.messages.length : 0;
            let i = 0, l = 0, u = 0, h = 0;
            if (t.control != null && (t.control.ihave != null && (i = t.control.ihave.length), t.control.iwant != null && (l = t.control.iwant.length), t.control.graft != null && (u = t.control.graft.length), t.control.prune != null && (h = t.control.prune.length)), this.log(`rpc.from ${e.toString()} subscriptions ${r} messages ${s} ihave ${i} iwant ${l} graft ${u} prune ${h}`), t.subscriptions != null && t.subscriptions.length > 0) {
                const f = [];
                t.subscriptions.forEach((p)=>{
                    const m = p.topic, w = p.subscribe === !0;
                    if (m != null) {
                        if (this.allowedTopics != null && !this.allowedTopics.has(m)) return;
                        this.handleReceivedSubscription(e, m, w), f.push({
                            topic: m,
                            subscribe: w
                        });
                    }
                }), this.safeDispatchEvent("subscription-change", {
                    detail: {
                        peerId: e,
                        subscriptions: f
                    }
                });
            }
            for (const f of t.messages){
                if (this.allowedTopics != null && !this.allowedTopics.has(f.topic)) continue;
                const p = this.handleReceivedMessage(e, f).catch((m)=>{
                    this.metrics?.onMsgRecvError(f.topic), this.log(m);
                });
                this.opts.awaitRpcMessageHandler && await p;
            }
            t.control != null && await this.handleControlMessage(e.toString(), t.control);
        }
        handleReceivedSubscription(e, t, r) {
            this.log("subscription update from %p topic %s", e, t);
            let s = this.topics.get(t);
            s == null && (s = new Set, this.topics.set(t, s)), r ? s.add(e.toString()) : s.delete(e.toString());
        }
        async handleReceivedMessage(e, t) {
            this.metrics?.onMsgRecvPreValidation(t.topic);
            const r = await this.validateReceivedMessage(e, t);
            this.metrics?.onPrevalidationResult(t.topic, r.code);
            const s = r.code;
            switch(s){
                case yr.duplicate:
                    this.score.duplicateMessage(e.toString(), r.msgIdStr, t.topic), this.gossipTracer.deliverMessage(r.msgIdStr, !0), this.mcache.observeDuplicate(r.msgIdStr, e.toString());
                    return;
                case yr.invalid:
                    if (r.msgIdStr != null) {
                        const i = r.msgIdStr;
                        this.score.rejectMessage(e.toString(), i, t.topic, r.reason), this.gossipTracer.rejectMessage(i, r.reason);
                    } else this.score.rejectInvalidMessage(e.toString(), t.topic);
                    this.metrics?.onMsgRecvInvalid(t.topic, r);
                    return;
                case yr.valid:
                    this.score.validateMessage(r.messageId.msgIdStr), this.gossipTracer.deliverMessage(r.messageId.msgIdStr), this.mcache.put(r.messageId, t, !this.opts.asyncValidation), this.subscriptions.has(t.topic) && (!this.components.peerId.equals(e) || this.opts.emitSelf) && (super.dispatchEvent(new CustomEvent("gossipsub:message", {
                        detail: {
                            propagationSource: e,
                            msgId: r.messageId.msgIdStr,
                            msg: r.msg
                        }
                    })), super.dispatchEvent(new CustomEvent("message", {
                        detail: r.msg
                    }))), this.opts.asyncValidation || this.forwardMessage(r.messageId.msgIdStr, t, e.toString());
                    break;
                default:
                    throw new Error(`Invalid validation result: ${s}`);
            }
        }
        async validateReceivedMessage(e, t) {
            const r = this.fastMsgIdFn?.(t), s = r !== void 0 ? this.fastMsgIdCache?.get(r) : void 0;
            if (s != null) return {
                code: yr.duplicate,
                msgIdStr: s
            };
            const i = await P8e(this.globalSignaturePolicy, t);
            if (!i.valid) return {
                code: yr.invalid,
                reason: Vs.Error,
                error: i.error
            };
            const l = i.message;
            try {
                this.dataTransform != null && (l.data = this.dataTransform.inboundTransform(t.topic, l.data));
            } catch (m) {
                return this.log("Invalid message, transform failed", m), {
                    code: yr.invalid,
                    reason: Vs.Error,
                    error: pr.TransformFailed
                };
            }
            const u = await this.msgIdFn(l), h = this.msgIdToStrFn(u), f = {
                msgId: u,
                msgIdStr: h
            };
            if (r !== void 0 && this.fastMsgIdCache != null && this.fastMsgIdCache.put(r, h) && this.metrics?.fastMsgIdCacheCollision.inc(), this.seenCache.has(h)) return {
                code: yr.duplicate,
                msgIdStr: h
            };
            this.seenCache.put(h), (t.data?.length ?? 0) >= this.opts.idontwantMinDataSize && this.sendIDontWants(u, t.topic, e.toString());
            const p = this.topicValidators.get(t.topic);
            if (p != null) {
                let m;
                try {
                    m = await p(e, l);
                } catch (w) {
                    const A = w.code;
                    A === J6e && (m = as.Ignore), A === X6e ? m = as.Reject : m = as.Ignore;
                }
                if (m !== as.Accept) return {
                    code: yr.invalid,
                    reason: kS(m),
                    msgIdStr: h
                };
            }
            return {
                code: yr.valid,
                messageId: f,
                msg: l
            };
        }
        getScore(e) {
            return this.score.score(e);
        }
        sendSubscriptions(e, t, r) {
            this.sendRpc(e, {
                subscriptions: t.map((s)=>({
                        topic: s,
                        subscribe: r
                    })),
                messages: []
            });
        }
        async handleControlMessage(e, t) {
            if (t === void 0) return;
            const r = t.ihave?.length > 0 ? this.handleIHave(e, t.ihave) : [], s = t.iwant?.length > 0 ? this.handleIWant(e, t.iwant) : [], i = t.graft?.length > 0 ? await this.handleGraft(e, t.graft) : [];
            if (t.prune?.length > 0 && await this.handlePrune(e, t.prune), t.idontwant?.length > 0 && this.handleIdontwant(e, t.idontwant), r.length === 0 && s.length === 0 && i.length === 0) return;
            const l = this.sendRpc(e, Xs(s, {
                iwant: r,
                prune: i
            })), u = r[0]?.messageIDs;
            u != null && (l ? this.gossipTracer.addPromise(e, u) : this.metrics?.iwantPromiseUntracked.inc(1));
        }
        acceptFrom(e) {
            if (this.direct.has(e)) return !0;
            const t = Date.now(), r = this.acceptFromWhitelist.get(e);
            if (r != null && r.messagesAccepted < e8e && r.acceptUntil >= t) return r.messagesAccepted += 1, !0;
            const s = this.score.score(e);
            return s >= Z6e ? this.acceptFromWhitelist.set(e, {
                messagesAccepted: 0,
                acceptUntil: t + t8e
            }) : this.acceptFromWhitelist.delete(e), s >= this.opts.scoreThresholds.graylistThreshold;
        }
        handleIHave(e, t) {
            if (t.length === 0) return [];
            const r = this.score.score(e);
            if (r < this.opts.scoreThresholds.gossipThreshold) return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", e, r), this.metrics?.ihaveRcvIgnored.inc({
                reason: Bd.LowScore
            }), [];
            const s = (this.peerhave.get(e) ?? 0) + 1;
            if (this.peerhave.set(e, s), s > G6e) return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", e, s), this.metrics?.ihaveRcvIgnored.inc({
                reason: Bd.MaxIhave
            }), [];
            const i = this.iasked.get(e) ?? 0;
            if (i >= jl) return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", e, i), this.metrics?.ihaveRcvIgnored.inc({
                reason: Bd.MaxIasked
            }), [];
            const l = new Map;
            if (t.forEach(({ topicID: f, messageIDs: p })=>{
                if (f == null || p == null || !this.mesh.has(f)) return;
                let m = 0;
                p.forEach((w)=>{
                    const A = this.msgIdToStrFn(w);
                    this.seenCache.has(A) || (l.set(A, w), m++);
                }), this.metrics?.onIhaveRcv(f, p.length, m);
            }), l.size === 0) return [];
            let u = l.size;
            u + i > jl && (u = jl - i), this.log("IHAVE: Asking for %d out of %d messages from %s", u, l.size, e);
            let h = Array.from(l.values());
            return Ui(h), h = h.slice(0, u), this.iasked.set(e, i + u), [
                {
                    messageIDs: h
                }
            ];
        }
        handleIWant(e, t) {
            if (t.length === 0) return [];
            const r = this.score.score(e);
            if (r < this.opts.scoreThresholds.gossipThreshold) return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", e, r), [];
            const s = new Map, i = new Map;
            let l = 0;
            return t.forEach(({ messageIDs: u })=>{
                u?.forEach((h)=>{
                    const f = this.msgIdToStrFn(h), p = this.mcache.getWithIWantCount(f, e);
                    if (p == null) {
                        l++;
                        return;
                    }
                    if (i.set(p.msg.topic, 1 + (i.get(p.msg.topic) ?? 0)), p.count > $6e) {
                        this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", e, h);
                        return;
                    }
                    s.set(f, p.msg);
                });
            }), this.metrics?.onIwantRcv(i, l), s.size === 0 ? (this.log("IWANT: Could not provide any wanted messages to %s", e), []) : (this.log("IWANT: Sending %d messages to %s", s.size, e), Array.from(s.values()));
        }
        async handleGraft(e, t) {
            const r = [], s = this.score.score(e), i = Date.now();
            let l = this.opts.doPX;
            if (t.forEach(({ topicID: h })=>{
                if (h == null) return;
                const f = this.mesh.get(h);
                if (f == null) {
                    l = !1;
                    return;
                }
                if (f.has(e)) return;
                const p = this.backoff.get(h)?.get(e);
                if (this.direct.has(e)) this.log("GRAFT: ignoring request from direct peer %s", e), r.push(h), l = !1;
                else if (typeof p == "number" && i < p) {
                    this.log("GRAFT: ignoring backed off peer %s", e), this.score.addPenalty(e, 1, Dd.GraftBackoff), l = !1;
                    const m = p + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
                    i < m && this.score.addPenalty(e, 1, Dd.GraftBackoff), this.addBackoff(e, h), r.push(h);
                } else s < 0 ? (this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", e, s, h), r.push(h), l = !1, this.addBackoff(e, h)) : f.size >= this.opts.Dhi && !(this.outbound.get(e) ?? !1) ? (r.push(h), this.addBackoff(e, h)) : (this.log("GRAFT: Add mesh link from %s in %s", e, h), this.score.graft(e, h), f.add(e), this.metrics?.onAddToMesh(h, wr.Subscribed, 1));
                this.safeDispatchEvent("gossipsub:graft", {
                    detail: {
                        peerId: e,
                        topic: h,
                        direction: "inbound"
                    }
                });
            }), r.length === 0) return [];
            const u = !1;
            return Promise.all(r.map(async (h)=>this.makePrune(e, h, l, u)));
        }
        async handlePrune(e, t) {
            const r = this.score.score(e);
            for (const { topicID: s, backoff: i, peers: l } of t){
                if (s == null) continue;
                const u = this.mesh.get(s);
                if (u == null) return;
                this.log("PRUNE: Remove mesh link to %s in %s", e, s), this.score.prune(e, s), u.has(e) && (u.delete(e), this.metrics?.onRemoveFromMesh(s, oi.Prune, 1)), typeof i == "number" && i > 0 ? this.doAddBackoff(e, s, i * 1e3) : this.addBackoff(e, s), l != null && l.length > 0 && (r < this.opts.scoreThresholds.acceptPXThreshold ? this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", e, r, s) : await this.pxConnect(l)), this.safeDispatchEvent("gossipsub:prune", {
                    detail: {
                        peerId: e,
                        topic: s,
                        direction: "inbound"
                    }
                });
            }
        }
        handleIdontwant(e, t) {
            let r = this.idontwantCounts.get(e) ?? 0;
            if (r >= this.opts.idontwantMaxMessages) return;
            const s = r;
            let i = this.idontwants.get(e);
            i == null && (i = new Map, this.idontwants.set(e, i));
            let l = 0;
            e: for (const { messageIDs: h } of t)for (const f of h){
                if (r >= this.opts.idontwantMaxMessages) break e;
                r++;
                const p = this.msgIdToStrFn(f);
                i.set(p, this.heartbeatTicks), this.mcache.msgs.has(p) || l++;
            }
            this.idontwantCounts.set(e, r);
            const u = r - s;
            this.metrics?.onIdontwantRcv(u, l);
        }
        addBackoff(e, t) {
            this.doAddBackoff(e, t, this.opts.pruneBackoff);
        }
        doAddBackoff(e, t, r) {
            let s = this.backoff.get(t);
            s == null && (s = new Map, this.backoff.set(t, s));
            const i = Date.now() + r;
            (s.get(e) ?? 0) < i && s.set(e, i);
        }
        applyIwantPenalties() {
            this.gossipTracer.getBrokenPromises().forEach((e, t)=>{
                this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", t, e), this.score.addPenalty(t, e, Dd.BrokenPromise);
            });
        }
        clearBackoff() {
            if (this.heartbeatTicks % F6e !== 0) return;
            const e = Date.now();
            this.backoff.forEach((t, r)=>{
                t.forEach((s, i)=>{
                    s + r8e * this.opts.heartbeatInterval < e && t.delete(i);
                }), t.size === 0 && this.backoff.delete(r);
            });
        }
        async directConnect() {
            const e = [];
            this.direct.forEach((t)=>{
                this.streamsOutbound.has(t) || e.push(t);
            }), await Promise.all(e.map(async (t)=>this.connect(t)));
        }
        async pxConnect(e) {
            e.length > this.opts.prunePeers && (Ui(e), e = e.slice(0, this.opts.prunePeers));
            const t = [];
            await Promise.all(e.map(async (r)=>{
                if (r.peerID == null) return;
                const s = Vg(kt(r.peerID)), i = s.toString();
                if (!this.peers.has(i)) {
                    if (r.signedPeerRecord == null) {
                        t.push(i);
                        return;
                    }
                    try {
                        if (!await this.components.peerStore.consumePeerRecord(r.signedPeerRecord, s)) {
                            this.log("bogus peer record obtained through px: could not add peer record to address book");
                            return;
                        }
                        t.push(i);
                    } catch  {
                        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
                    }
                }
            })), t.length !== 0 && await Promise.all(t.map(async (r)=>this.connect(r)));
        }
        async connect(e) {
            this.log("Initiating connection with %s", e);
            const t = Wl(e), r = await this.components.connectionManager.openConnection(t);
            for (const s of this.multicodecs)for (const i of this.components.registrar.getTopologies(s))i.onConnect?.(t, r);
        }
        subscribe(e) {
            if (this.status.code !== Or.started) throw new Error("Pubsub has not started");
            if (!this.subscriptions.has(e)) {
                this.subscriptions.add(e);
                for (const t of this.peers.keys())this.sendSubscriptions(t, [
                    e
                ], !0);
            }
            this.join(e);
        }
        unsubscribe(e) {
            if (this.status.code !== Or.started) throw new Error("Pubsub is not started");
            const t = this.subscriptions.delete(e);
            if (this.log("unsubscribe from %s - am subscribed %s", e, t), t) for (const r of this.peers.keys())this.sendSubscriptions(r, [
                e
            ], !1);
            this.leave(e);
        }
        join(e) {
            if (this.status.code !== Or.started) throw new Error("Gossipsub has not started");
            if (this.mesh.has(e)) return;
            this.log("JOIN %s", e), this.metrics?.onJoin(e);
            const t = new Set, r = this.backoff.get(e), s = this.fanout.get(e);
            if (s != null && (this.fanout.delete(e), this.fanoutLastpub.delete(e), s.forEach((i)=>{
                !this.direct.has(i) && this.score.score(i) >= 0 && r?.has(i) !== !0 && t.add(i);
            }), this.metrics?.onAddToMesh(e, wr.Fanout, t.size)), t.size < this.opts.D) {
                const i = t.size;
                this.getRandomGossipPeers(e, this.opts.D, (u)=>!t.has(u) && !this.direct.has(u) && this.score.score(u) >= 0 && r?.has(u) !== !0).forEach((u)=>{
                    t.add(u);
                }), this.metrics?.onAddToMesh(e, wr.Random, t.size - i);
            }
            this.mesh.set(e, t), t.forEach((i)=>{
                this.log("JOIN: Add mesh link to %s in %s", i, e), this.sendGraft(i, e);
            });
        }
        leave(e) {
            if (this.status.code !== Or.started) throw new Error("Gossipsub has not started");
            this.log("LEAVE %s", e), this.metrics?.onLeave(e);
            const t = this.mesh.get(e);
            t != null && (Promise.all(Array.from(t).map(async (r)=>{
                this.log("LEAVE: Remove mesh link to %s in %s", r, e), await this.sendPrune(r, e);
            })).catch((r)=>{
                this.log("Error sending prunes to mesh peers", r);
            }), this.mesh.delete(e));
        }
        selectPeersToForward(e, t, r) {
            const s = new Set, i = this.topics.get(e);
            i != null && (this.direct.forEach((u)=>{
                i.has(u) && t !== u && !(r?.has(u) ?? !1) && s.add(u);
            }), this.floodsubPeers.forEach((u)=>{
                i.has(u) && t !== u && !(r?.has(u) ?? !1) && this.score.score(u) >= this.opts.scoreThresholds.publishThreshold && s.add(u);
            }));
            const l = this.mesh.get(e);
            return l != null && l.size > 0 && l.forEach((u)=>{
                t !== u && !(r?.has(u) ?? !1) && s.add(u);
            }), s;
        }
        selectPeersToPublish(e) {
            const t = new Set, r = {
                direct: 0,
                floodsub: 0,
                mesh: 0,
                fanout: 0
            }, s = this.topics.get(e);
            if (s != null) if (this.opts.floodPublish) s.forEach((i)=>{
                this.direct.has(i) ? (t.add(i), r.direct++) : this.score.score(i) >= this.opts.scoreThresholds.publishThreshold && (t.add(i), r.floodsub++);
            });
            else {
                this.direct.forEach((l)=>{
                    s.has(l) && (t.add(l), r.direct++);
                }), this.floodsubPeers.forEach((l)=>{
                    s.has(l) && this.score.score(l) >= this.opts.scoreThresholds.publishThreshold && (t.add(l), r.floodsub++);
                });
                const i = this.mesh.get(e);
                if (i != null && i.size > 0) i.forEach((l)=>{
                    t.add(l), r.mesh++;
                }), i.size < this.opts.D && this.getRandomGossipPeers(e, this.opts.D - i.size, (u)=>!i.has(u) && !this.direct.has(u) && !this.floodsubPeers.has(u) && this.score.score(u) >= this.opts.scoreThresholds.publishThreshold).forEach((u)=>{
                    t.add(u), r.mesh++;
                });
                else {
                    const l = this.fanout.get(e);
                    if (l != null && l.size > 0) l.forEach((u)=>{
                        t.add(u), r.fanout++;
                    });
                    else {
                        const u = this.getRandomGossipPeers(e, this.opts.D, (h)=>this.score.score(h) >= this.opts.scoreThresholds.publishThreshold);
                        u.size > 0 && (this.fanout.set(e, u), u.forEach((h)=>{
                            t.add(h), r.fanout++;
                        }));
                    }
                    this.fanoutLastpub.set(e, Date.now());
                }
            }
            return {
                tosend: t,
                tosendCount: r
            };
        }
        forwardMessage(e, t, r, s) {
            r != null && this.score.deliverMessage(r, e, t.topic);
            const i = this.selectPeersToForward(t.topic, r, s);
            i.forEach((l)=>{
                this.sendRpc(l, Xs([
                    t
                ]));
            }), this.metrics?.onForwardMsg(t.topic, i.size);
        }
        async publish(e, t, r) {
            const s = Date.now(), i = this.dataTransform != null ? this.dataTransform.outboundTransform(e, t) : t;
            if (this.publishConfig == null) throw Error("PublishError.Uninitialized");
            const { raw: l, msg: u } = await B8e(this.publishConfig, e, t, i), h = await this.msgIdFn(u), f = this.msgIdToStrFn(h), p = r?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;
            if (this.seenCache.has(f)) {
                if (p) return this.metrics?.onPublishDuplicateMsg(e), {
                    recipients: []
                };
                throw Error("PublishError.Duplicate");
            }
            const { tosend: m, tosendCount: w } = this.selectPeersToPublish(e), A = this.opts.emitSelf && this.subscriptions.has(e), S = r?.allowPublishToZeroTopicPeers ?? this.opts.allowPublishToZeroTopicPeers;
            if (m.size === 0 && !S && !A) throw Error("PublishError.NoPeersSubscribedToTopic");
            this.seenCache.put(f), this.mcache.put({
                msgId: h,
                msgIdStr: f
            }, l, !0), this.gossipTracer.deliverMessage(f), this.publishedMessageIds.put(f);
            const _ = r?.batchPublish ?? this.opts.batchPublish, I = Xs([
                l
            ]);
            if (_) this.sendRpcInBatch(m, I);
            else for (const G of m)this.sendRpc(G, I) || m.delete(G);
            const k = Date.now() - s;
            return this.metrics?.onPublishMsg(e, w, m.size, l.data != null ? l.data.length : 0, k), A && (m.add(this.components.peerId.toString()), super.dispatchEvent(new CustomEvent("gossipsub:message", {
                detail: {
                    propagationSource: this.components.peerId,
                    msgId: f,
                    msg: u
                }
            })), super.dispatchEvent(new CustomEvent("message", {
                detail: u
            }))), {
                recipients: Array.from(m.values()).map((G)=>this.peers.get(G) ?? Wl(G))
            };
        }
        sendRpcInBatch(e, t) {
            const r = za.encode(t), s = r5.single(r);
            for (const i of e){
                const l = this.streamsOutbound.get(i);
                if (l == null) {
                    this.log(`Cannot send RPC to ${i} as there is no open stream to it available`), e.delete(i);
                    continue;
                }
                try {
                    l.pushPrefixed(s);
                } catch (u) {
                    e.delete(i), this.log.error(`Cannot send rpc to ${i}`, u);
                }
                this.metrics?.onRpcSent(t, r.length);
            }
        }
        reportMessageValidationResult(e, t, r) {
            let s;
            if (r === as.Accept) {
                if (s = this.mcache.validate(e), s != null) {
                    const { message: l, originatingPeers: u } = s;
                    this.score.deliverMessage(t, e, l.topic), this.forwardMessage(e, s.message, t, u);
                }
            } else if (s = this.mcache.remove(e), s != null) {
                const l = kS(r), { message: u, originatingPeers: h } = s;
                this.score.rejectMessage(t, e, u.topic, l);
                for (const f of h)this.score.rejectMessage(f, e, u.topic, l);
            }
            const i = this.score.messageFirstSeenTimestampMs(e);
            this.metrics?.onReportValidation(s, r, i);
        }
        sendGraft(e, t) {
            const s = Xs([], {
                graft: [
                    {
                        topicID: t
                    }
                ]
            });
            this.sendRpc(e, s);
        }
        async sendPrune(e, t) {
            const s = [
                await this.makePrune(e, t, this.opts.doPX, !0)
            ], i = Xs([], {
                prune: s
            });
            this.sendRpc(e, i);
        }
        sendIDontWants(e, t, r) {
            const s = this.mesh.get(t);
            if (s == null) return;
            const i = new Set(s);
            i.delete(r);
            for (const u of i)this.streamsOutbound.get(u)?.protocol !== Ey && i.delete(u);
            const l = Xs([], {
                idontwant: [
                    {
                        messageIDs: [
                            e
                        ]
                    }
                ]
            });
            this.sendRpcInBatch(i, l);
        }
        sendRpc(e, t) {
            const r = this.streamsOutbound.get(e);
            if (r == null) return this.log(`Cannot send RPC to ${e} as there is no open stream to it available`), !1;
            const s = this.control.get(e);
            s != null && (this.piggybackControl(e, t, s), this.control.delete(e));
            const i = this.gossip.get(e);
            i != null && (this.piggybackGossip(e, t, i), this.gossip.delete(e));
            const l = za.encode(t);
            try {
                r.push(l);
            } catch (u) {
                return this.log.error(`Cannot send rpc to ${e}`, u), s != null && this.control.set(e, s), i != null && this.gossip.set(e, i), !1;
            }
            if (this.metrics?.onRpcSent(t, l.length), t.control?.graft != null) for (const u of t.control?.graft)u.topicID != null && this.safeDispatchEvent("gossipsub:graft", {
                detail: {
                    peerId: e,
                    topic: u.topicID,
                    direction: "outbound"
                }
            });
            if (t.control?.prune != null) for (const u of t.control?.prune)u.topicID != null && this.safeDispatchEvent("gossipsub:prune", {
                detail: {
                    peerId: e,
                    topic: u.topicID,
                    direction: "outbound"
                }
            });
            return !0;
        }
        piggybackControl(e, t, r) {
            const s = $S(t);
            for (const i of r.graft)i.topicID != null && (this.mesh.get(i.topicID)?.has(e) ?? !1) && s.control.graft.push(i);
            for (const i of r.prune)i.topicID != null && !(this.mesh.get(i.topicID)?.has(e) ?? !1) && s.control.prune.push(i);
        }
        piggybackGossip(e, t, r) {
            const s = $S(t);
            s.control.ihave = r;
        }
        async sendGraftPrune(e, t, r) {
            const s = this.opts.doPX, i = !1;
            for (const [l, u] of e){
                const h = u.map((m)=>({
                        topicID: m
                    }));
                let f = [];
                const p = t.get(l);
                p != null && (f = await Promise.all(p.map(async (m)=>this.makePrune(l, m, s && !(r.get(l) ?? !1), i))), t.delete(l)), this.sendRpc(l, Xs([], {
                    graft: h,
                    prune: f
                }));
            }
            for (const [l, u] of t){
                const h = await Promise.all(u.map(async (f)=>this.makePrune(l, f, s && !(r.get(l) ?? !1), i)));
                this.sendRpc(l, Xs([], {
                    prune: h
                }));
            }
        }
        emitGossip(e) {
            const t = this.mcache.getGossipIDs(new Set(e.keys()));
            for (const [r, s] of e)this.doEmitGossip(r, s, t.get(r) ?? []);
        }
        doEmitGossip(e, t, r) {
            if (r.length === 0 || (Ui(r), r.length > jl && this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", r.length), t.size === 0)) return;
            let s = this.opts.Dlazy;
            const l = this.opts.gossipFactor * t.size;
            let u = t;
            l > s && (s = l), s > u.size ? s = u.size : u = Ui(Array.from(u)).slice(0, s), u.forEach((h)=>{
                let f = r;
                r.length > jl && (f = Ui(f.slice()).slice(0, jl)), this.pushGossip(h, {
                    topicID: e,
                    messageIDs: f
                });
            });
        }
        flush() {
            for (const [e, t] of this.gossip.entries())this.gossip.delete(e), this.sendRpc(e, Xs([], {
                ihave: t
            }));
            for (const [e, t] of this.control.entries()){
                this.control.delete(e);
                const r = Xs([], {
                    graft: t.graft,
                    prune: t.prune
                });
                this.sendRpc(e, r);
            }
        }
        pushGossip(e, t) {
            this.log("Add gossip to %s", e);
            const r = this.gossip.get(e) ?? [];
            this.gossip.set(e, r.concat(t));
        }
        async makePrune(e, t, r, s) {
            if (this.score.prune(e, t), this.streamsOutbound.get(e)?.protocol === DS) return {
                topicID: t,
                peers: []
            };
            const i = s ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff, l = i / 1e3;
            if (this.doAddBackoff(e, t, i), !r) return {
                topicID: t,
                peers: [],
                backoff: l
            };
            const u = this.getRandomGossipPeers(t, this.opts.prunePeers, (f)=>f !== e && this.score.score(f) >= 0), h = await Promise.all(Array.from(u).map(async (f)=>{
                const p = this.peers.get(f) ?? Wl(f);
                let m;
                try {
                    m = await this.components.peerStore.get(p);
                } catch (w) {
                    if (w.name !== "NotFoundError") throw w;
                }
                return {
                    peerID: p.toMultihash().bytes,
                    signedPeerRecord: m?.peerRecordEnvelope
                };
            }));
            return {
                topicID: t,
                peers: h,
                backoff: l
            };
        }
        runHeartbeat = ()=>{
            const e = this.metrics?.heartbeatDuration.startTimer();
            this.heartbeat().catch((t)=>{
                this.log("Error running heartbeat", t);
            }).finally(()=>{
                if (e?.(), this.status.code === Or.started) {
                    clearTimeout(this.status.heartbeatTimeout);
                    let t = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
                    t < this.opts.heartbeatInterval * .25 && (t += this.opts.heartbeatInterval, this.metrics?.heartbeatSkipped.inc()), this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, t);
                }
            });
        };
        async heartbeat() {
            const { D: e, Dlo: t, Dhi: r, Dscore: s, Dout: i, fanoutTTL: l } = this.opts;
            this.heartbeatTicks++;
            const u = new Map, h = (S)=>{
                let _ = u.get(S);
                return _ === void 0 && (_ = this.score.score(S), u.set(S, _)), _;
            }, f = new Map, p = new Map, m = new Map;
            this.clearBackoff(), this.peerhave.clear(), this.metrics?.cacheSize.set({
                cache: "iasked"
            }, this.iasked.size), this.iasked.clear(), this.applyIwantPenalties(), this.idontwantCounts.clear();
            for (const S of this.idontwants.values())for (const [_, I] of S)this.heartbeatTicks - I >= this.opts.mcacheLength && S.delete(_);
            this.heartbeatTicks % this.opts.directConnectTicks === 0 && await this.directConnect(), this.fastMsgIdCache?.prune(), this.seenCache.prune(), this.gossipTracer.prune(), this.publishedMessageIds.prune();
            const w = new Map;
            this.mesh.forEach((S, _)=>{
                const I = this.topics.get(_), k = new Set, G = new Set;
                if (w.set(_, G), I != null) {
                    const H = Ui(Array.from(I)), F = this.backoff.get(_);
                    for (const $ of H){
                        const Y = this.streamsOutbound.get($);
                        if (Y != null && this.multicodecs.includes(Y.protocol) && !S.has($) && !this.direct.has($)) {
                            const O = h($);
                            F?.has($) !== !0 && O >= 0 && k.add($), O >= this.opts.scoreThresholds.gossipThreshold && G.add($);
                        }
                    }
                }
                const P = (H, F)=>{
                    this.log("HEARTBEAT: Remove mesh link to %s in %s", H, _), this.addBackoff(H, _), S.delete(H), h(H) >= this.opts.scoreThresholds.gossipThreshold && G.add(H), this.metrics?.onRemoveFromMesh(_, F, 1);
                    const $ = p.get(H);
                    $ == null ? p.set(H, [
                        _
                    ]) : $.push(_);
                }, J = (H, F)=>{
                    this.log("HEARTBEAT: Add mesh link to %s in %s", H, _), this.score.graft(H, _), S.add(H), G.delete(H), this.metrics?.onAddToMesh(_, F, 1);
                    const $ = f.get(H);
                    $ == null ? f.set(H, [
                        _
                    ]) : $.push(_);
                };
                if (S.forEach((H)=>{
                    const F = h(H);
                    F < 0 && (this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", H, F, _), P(H, oi.BadScore), m.set(H, !0));
                }), S.size < t) {
                    const H = e - S.size;
                    y8e(k, H).forEach(($)=>{
                        J($, wr.NotEnough);
                    });
                }
                if (S.size > r) {
                    let H = Array.from(S);
                    H.sort(($, Y)=>h(Y) - h($)), H = H.slice(0, s).concat(Ui(H.slice(s)));
                    let F = 0;
                    if (H.slice(0, e).forEach(($)=>{
                        (this.outbound.get($) ?? !1) && F++;
                    }), F < i) {
                        const $ = (O)=>{
                            const se = H[O];
                            for(let ae = O; ae > 0; ae--)H[ae] = H[ae - 1];
                            H[0] = se;
                        };
                        if (F > 0) {
                            let O = F;
                            for(let se = 1; se < e && O > 0; se++)(this.outbound.get(H[se]) ?? !1) && ($(se), O--);
                        }
                        let Y = e - F;
                        for(let O = e; O < H.length && Y > 0; O++)(this.outbound.get(H[O]) ?? !1) && ($(O), Y--);
                    }
                    H.slice(e).forEach(($)=>{
                        P($, oi.Excess);
                    });
                }
                if (S.size >= t) {
                    let H = 0;
                    if (S.forEach((F)=>{
                        (this.outbound.get(F) ?? !1) && H++;
                    }), H < i) {
                        const F = i - H;
                        q4(k, F, (Y)=>this.outbound.get(Y) === !0).forEach((Y)=>{
                            J(Y, wr.Outbound);
                        });
                    }
                }
                if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && S.size > 1) {
                    const H = Array.from(S).sort((Y, O)=>h(Y) - h(O)), F = Math.floor(S.size / 2), $ = h(H[F]);
                    if ($ < this.opts.scoreThresholds.opportunisticGraftThreshold) {
                        const Y = this.opts.opportunisticGraftPeers, O = q4(k, Y, (se)=>h(se) > $);
                        for (const se of O)this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", se, _), J(se, wr.Opportunistic);
                    }
                }
            });
            const A = Date.now();
            this.fanoutLastpub.forEach((S, _)=>{
                S + l < A && (this.fanout.delete(_), this.fanoutLastpub.delete(_));
            }), this.fanout.forEach((S, _)=>{
                const I = this.topics.get(_);
                S.forEach((J)=>{
                    (!(I?.has(J) ?? !1) || h(J) < this.opts.scoreThresholds.publishThreshold) && S.delete(J);
                });
                const k = this.topics.get(_), G = [], P = new Set;
                if (w.set(_, P), k != null) {
                    const J = Ui(Array.from(k));
                    for (const H of J){
                        const F = this.streamsOutbound.get(H);
                        if (F != null && this.multicodecs.includes(F.protocol) && !S.has(H) && !this.direct.has(H)) {
                            const $ = h(H);
                            $ >= this.opts.scoreThresholds.publishThreshold && G.push(H), $ >= this.opts.scoreThresholds.gossipThreshold && P.add(H);
                        }
                    }
                }
                if (S.size < e) {
                    const J = e - S.size;
                    G.slice(0, J).forEach((H)=>{
                        S.add(H), P?.delete(H);
                    });
                }
            }), this.emitGossip(w), await this.sendGraftPrune(f, p, m), this.flush(), this.mcache.shift(), this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
        }
        getRandomGossipPeers(e, t, r = ()=>!0) {
            const s = this.topics.get(e);
            if (s == null) return new Set;
            let i = [];
            return s.forEach((l)=>{
                const u = this.streamsOutbound.get(l);
                u != null && this.multicodecs.includes(u.protocol) && r(l) && i.push(l);
            }), i = Ui(i), t > 0 && i.length > t && (i = i.slice(0, t)), new Set(i);
        }
        onScrapeMetrics(e) {
            e.mcacheSize.set(this.mcache.size), e.mcacheNotValidatedCount.set(this.mcache.notValidatedCount), e.cacheSize.set({
                cache: "direct"
            }, this.direct.size), e.cacheSize.set({
                cache: "seenCache"
            }, this.seenCache.size), e.cacheSize.set({
                cache: "fastMsgIdCache"
            }, this.fastMsgIdCache?.size ?? 0), e.cacheSize.set({
                cache: "publishedMessageIds"
            }, this.publishedMessageIds.size), e.cacheSize.set({
                cache: "mcache"
            }, this.mcache.size), e.cacheSize.set({
                cache: "score"
            }, this.score.size), e.cacheSize.set({
                cache: "gossipTracer.promises"
            }, this.gossipTracer.size), e.cacheSize.set({
                cache: "gossipTracer.requests"
            }, this.gossipTracer.requestMsByMsgSize), e.cacheSize.set({
                cache: "topics"
            }, this.topics.size), e.cacheSize.set({
                cache: "subscriptions"
            }, this.subscriptions.size), e.cacheSize.set({
                cache: "mesh"
            }, this.mesh.size), e.cacheSize.set({
                cache: "fanout"
            }, this.fanout.size), e.cacheSize.set({
                cache: "peers"
            }, this.peers.size), e.cacheSize.set({
                cache: "streamsOutbound"
            }, this.streamsOutbound.size), e.cacheSize.set({
                cache: "streamsInbound"
            }, this.streamsInbound.size), e.cacheSize.set({
                cache: "acceptFromWhitelist"
            }, this.acceptFromWhitelist.size), e.cacheSize.set({
                cache: "gossip"
            }, this.gossip.size), e.cacheSize.set({
                cache: "control"
            }, this.control.size), e.cacheSize.set({
                cache: "peerhave"
            }, this.peerhave.size), e.cacheSize.set({
                cache: "outbound"
            }, this.outbound.size);
            let t = 0;
            const r = Date.now();
            e.connectedPeersBackoffSec.reset();
            for (const h of this.backoff.values()){
                t += h.size;
                for (const [f, p] of h.entries())this.peers.has(f) && e.connectedPeersBackoffSec.observe(Math.max(0, p - r) / 1e3);
            }
            e.cacheSize.set({
                cache: "backoff"
            }, t);
            let s = 0;
            for (const h of this.idontwants.values())s += h.size;
            e.cacheSize.set({
                cache: "idontwants"
            }, s);
            for (const [h, f] of this.topics)e.topicPeersCount.set({
                topicStr: h
            }, f.size);
            for (const [h, f] of this.mesh)e.meshPeerCounts.set({
                topicStr: h
            }, f.size);
            const i = [], l = new Map;
            e.behaviourPenalty.reset();
            for (const h of this.peers.keys()){
                const f = this.score.score(h);
                i.push(f), l.set(h, f), e.behaviourPenalty.observe(this.score.peerStats.get(h)?.behaviourPenalty ?? 0);
            }
            e.registerScores(i, this.opts.scoreThresholds), e.registerScorePerMesh(this.mesh, l);
            const u = T8e(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, e.topicStrToLabel);
            e.registerScoreWeights(u);
        }
        tagMeshPeer = (e)=>{
            const { peerId: t, topic: r } = e.detail;
            this.components.peerStore.merge(this.peers.get(t) ?? Wl(t), {
                tags: {
                    [r]: {
                        value: 100
                    }
                }
            }).catch((s)=>{
                this.log.error("Error tagging peer %s with topic %s", t, r, s);
            });
        };
        untagMeshPeer = (e)=>{
            const { peerId: t, topic: r } = e.detail;
            this.components.peerStore.merge(this.peers.get(t) ?? Wl(t), {
                tags: {
                    [r]: void 0
                }
            }).catch((s)=>{
                this.log.error("Error untagging peer %s with topic %s", t, r, s);
            });
        };
    }
    function V5e(n = {}) {
        return (e)=>new F5e(e, n);
    }
    const H5e = "modulepreload", Q5e = function(n) {
        return "/" + n;
    }, US = {}, Dk = function(e, t, r) {
        let s = Promise.resolve();
        if (t && t.length > 0) {
            let h = function(f) {
                return Promise.all(f.map((p)=>Promise.resolve(p).then((m)=>({
                            status: "fulfilled",
                            value: m
                        }), (m)=>({
                            status: "rejected",
                            reason: m
                        }))));
            };
            document.getElementsByTagName("link");
            const l = document.querySelector("meta[property=csp-nonce]"), u = l?.nonce || l?.getAttribute("nonce");
            s = h(t.map((f)=>{
                if (f = Q5e(f), f in US) return;
                US[f] = !0;
                const p = f.endsWith(".css"), m = p ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${f}"]${m}`)) return;
                const w = document.createElement("link");
                if (w.rel = p ? "stylesheet" : H5e, p || (w.as = "script"), w.crossOrigin = "", w.href = f, u && w.setAttribute("nonce", u), document.head.appendChild(w), p) return new Promise((A, S)=>{
                    w.addEventListener("load", A), w.addEventListener("error", ()=>S(new Error(`Unable to preload CSS for ${f}`)));
                });
            }));
        }
        function i(l) {
            const u = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (u.payload = l, window.dispatchEvent(u), !u.defaultPrevented) throw l;
        }
        return s.then((l)=>{
            for (const u of l || [])u.status === "rejected" && i(u.reason);
            return e().catch(i);
        });
    };
    class q5e {
        db = null;
        orbitdb = null;
        async init(e) {
            const { createOrbitDB: t } = await Dk(async ()=>{
                const { createOrbitDB: r } = await import("./index-BS7M71oZ.js");
                return {
                    createOrbitDB: r
                };
            }, []);
            this.orbitdb = await t({
                ipfs: e
            }), this.db = await this.orbitdb.open("beacon-registry", {
                type: "keyvalue"
            }), console.log("[Registry] Initialized:", this.db?.address.toString() ?? "unknown");
        }
        async lookup(e) {
            if (!this.db) throw new Error("Registry not initialized");
            return await this.db.get(e);
        }
        async register(e, t) {
            if (!this.db) throw new Error("Registry not initialized");
            return await this.db.get(e) ? (console.log("[Registry] Username already taken:", e), !1) : (await this.db.put(e, t), console.log("[Registry] Registered:", e), !0);
        }
        async all() {
            if (!this.db) throw new Error("Registry not initialized");
            return (await this.db.all()).map(({ key: t, value: r })=>({
                    username: t,
                    entry: r
                }));
        }
        async stop() {
            this.orbitdb && (await this.orbitdb.stop(), this.orbitdb = null, this.db = null);
        }
    }
    const Pd = new q5e;
    function K5e() {
        const [n, e] = Dt.useState(null), [t, r] = Dt.useState(!1), [s, i] = Dt.useState(!1), [l, u] = Dt.useState(null), [h, f] = Dt.useState(null), [p, m] = Dt.useState(0), w = Dt.useRef(!1);
        return Dt.useEffect(()=>w.current ? void 0 : (w.current = !0, (async ()=>{
                try {
                    console.log("[Helia] Starting node initialization...");
                    const S = await Vx({
                        transports: [
                            Ek(),
                            vk(),
                            qB()
                        ],
                        connectionEncrypters: [
                            x8()
                        ],
                        streamMuxers: [
                            IB()
                        ],
                        services: {
                            identify: kP(),
                            pubsub: V5e({
                                allowPublishToZeroTopicPeers: !0
                            })
                        }
                    }), _ = await i6e({
                        libp2p: S,
                        blockstore: new H_,
                        datastore: new l8
                    }), I = _.libp2p.peerId.toString();
                    console.log("[Helia] Node ready. PeerId:", I), e(_), f(I), r(!0), _.libp2p.addEventListener("peer:connect", ()=>{
                        m(_.libp2p.getPeers().length);
                    }), _.libp2p.addEventListener("peer:disconnect", ()=>{
                        m(_.libp2p.getPeers().length);
                    }), console.log("[Registry] Initializing..."), await Pd.init(_), i(!0), console.log("[Registry] Ready");
                } catch (S) {
                    console.error("[Helia] Initialization failed:", S), u(S instanceof Error ? S : new Error(String(S)));
                }
            })(), ()=>{
                Pd.stop().catch(console.error), n && (console.log("[Helia] Stopping node..."), n.stop().catch(console.error));
            }), []), {
            helia: n,
            isReady: t,
            registryReady: s,
            error: l,
            peerId: h,
            peerCount: p
        };
    }
    const G5e = globalThis || void 0 || self;
    function Fa(n, e, t, r) {
        function s(i) {
            return i instanceof t ? i : new t(function(l) {
                l(i);
            });
        }
        return new (t || (t = Promise))(function(i, l) {
            function u(p) {
                try {
                    f(r.next(p));
                } catch (m) {
                    l(m);
                }
            }
            function h(p) {
                try {
                    f(r.throw(p));
                } catch (m) {
                    l(m);
                }
            }
            function f(p) {
                p.done ? i(p.value) : s(p.value).then(u, h);
            }
            f((r = r.apply(n, [])).next());
        });
    }
    class Kt {
        constructor(){
            this.mutex = Promise.resolve();
        }
        lock() {
            let e = ()=>{};
            return this.mutex = this.mutex.then(()=>new Promise(e)), new Promise((t)=>{
                e = t;
            });
        }
        dispatch(e) {
            return Fa(this, void 0, void 0, function*() {
                const t = yield this.lock();
                try {
                    return yield Promise.resolve(e());
                } finally{
                    t();
                }
            });
        }
    }
    var Cy;
    function Y5e() {
        return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : G5e;
    }
    const K4 = Y5e(), Ty = (Cy = K4.Buffer) !== null && Cy !== void 0 ? Cy : null, W5e = K4.TextEncoder ? new K4.TextEncoder : null;
    function Bk(n, e) {
        return (n & 15) + (n >> 6 | n >> 3 & 8) << 4 | (e & 15) + (e >> 6 | e >> 3 & 8);
    }
    function Pk(n, e) {
        const t = e.length >> 1;
        for(let r = 0; r < t; r++){
            const s = r << 1;
            n[r] = Bk(e.charCodeAt(s), e.charCodeAt(s + 1));
        }
    }
    function j5e(n, e) {
        if (n.length !== e.length * 2) return !1;
        for(let t = 0; t < e.length; t++){
            const r = t << 1;
            if (e[t] !== Bk(n.charCodeAt(r), n.charCodeAt(r + 1))) return !1;
        }
        return !0;
    }
    const zS = 87, FS = 48;
    function G4(n, e, t) {
        let r = 0;
        for(let s = 0; s < t; s++){
            let i = e[s] >>> 4;
            n[r++] = i > 9 ? i + zS : i + FS, i = e[s] & 15, n[r++] = i > 9 ? i + zS : i + FS;
        }
        return String.fromCharCode.apply(null, n);
    }
    const Gi = Ty !== null ? (n)=>{
        if (typeof n == "string") {
            const e = Ty.from(n, "utf8");
            return new Uint8Array(e.buffer, e.byteOffset, e.length);
        }
        if (Ty.isBuffer(n)) return new Uint8Array(n.buffer, n.byteOffset, n.length);
        if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
        throw new Error("Invalid data type!");
    } : (n)=>{
        if (typeof n == "string") return W5e.encode(n);
        if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
        throw new Error("Invalid data type!");
    }, Ms = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fd = new Uint8Array(256);
    for(let n = 0; n < Ms.length; n++)fd[Ms.charCodeAt(n)] = n;
    function VS(n, e = !0) {
        const t = n.length, r = t % 3, s = [], i = t - r;
        for(let l = 0; l < i; l += 3){
            const u = (n[l] << 16 & 16711680) + (n[l + 1] << 8 & 65280) + (n[l + 2] & 255), h = Ms.charAt(u >> 18 & 63) + Ms.charAt(u >> 12 & 63) + Ms.charAt(u >> 6 & 63) + Ms.charAt(u & 63);
            s.push(h);
        }
        if (r === 1) {
            const l = n[t - 1], u = Ms.charAt(l >> 2), h = Ms.charAt(l << 4 & 63);
            s.push(`${u}${h}`), e && s.push("==");
        } else if (r === 2) {
            const l = (n[t - 2] << 8) + n[t - 1], u = Ms.charAt(l >> 10), h = Ms.charAt(l >> 4 & 63), f = Ms.charAt(l << 2 & 63);
            s.push(`${u}${h}${f}`), e && s.push("=");
        }
        return s.join("");
    }
    function X5e(n) {
        let e = Math.floor(n.length * .75);
        const t = n.length;
        return n[t - 1] === "=" && (e -= 1, n[t - 2] === "=" && (e -= 1)), e;
    }
    function J5e(n) {
        const e = X5e(n), t = n.length, r = new Uint8Array(e);
        let s = 0;
        for(let i = 0; i < t; i += 4){
            const l = fd[n.charCodeAt(i)], u = fd[n.charCodeAt(i + 1)], h = fd[n.charCodeAt(i + 2)], f = fd[n.charCodeAt(i + 3)];
            r[s] = l << 2 | u >> 4, s += 1, r[s] = (u & 15) << 4 | h >> 2, s += 1, r[s] = (h & 3) << 6 | f & 63, s += 1;
        }
        return r;
    }
    const J0 = 16 * 1024, Rh = 4, Z5e = new Kt, _y = new Map;
    function kk(n, e) {
        return Fa(this, void 0, void 0, function*() {
            let t = null, r = null, s = !1;
            if (typeof WebAssembly > "u") throw new Error("WebAssembly is not supported in this environment!");
            const i = (F, $ = 0)=>{
                r.set(F, $);
            }, l = ()=>r, u = ()=>t.exports, h = (F)=>{
                t.exports.Hash_SetMemorySize(F);
                const $ = t.exports.Hash_GetBuffer(), Y = t.exports.memory.buffer;
                r = new Uint8Array(Y, $, F);
            }, f = ()=>new DataView(t.exports.memory.buffer).getUint32(t.exports.STATE_SIZE, !0), p = Z5e.dispatch(()=>Fa(this, void 0, void 0, function*() {
                    if (!_y.has(n.name)) {
                        const $ = J5e(n.data), Y = WebAssembly.compile($);
                        _y.set(n.name, Y);
                    }
                    const F = yield _y.get(n.name);
                    t = yield WebAssembly.instantiate(F, {});
                })), m = ()=>Fa(this, void 0, void 0, function*() {
                    t || (yield p);
                    const F = t.exports.Hash_GetBuffer(), $ = t.exports.memory.buffer;
                    r = new Uint8Array($, F, J0);
                }), w = (F = null)=>{
                s = !0, t.exports.Hash_Init(F);
            }, A = (F)=>{
                let $ = 0;
                for(; $ < F.length;){
                    const Y = F.subarray($, $ + J0);
                    $ += Y.length, r.set(Y), t.exports.Hash_Update(Y.length);
                }
            }, S = (F)=>{
                if (!s) throw new Error("update() called before init()");
                const $ = Gi(F);
                A($);
            }, _ = new Uint8Array(e * 2), I = (F, $ = null)=>{
                if (!s) throw new Error("digest() called before init()");
                return s = !1, t.exports.Hash_Final($), F === "binary" ? r.slice(0, e) : G4(_, r, e);
            }, k = ()=>{
                if (!s) throw new Error("save() can only be called after init() and before digest()");
                const F = t.exports.Hash_GetState(), $ = f(), Y = t.exports.memory.buffer, O = new Uint8Array(Y, F, $), se = new Uint8Array(Rh + $);
                return Pk(se, n.hash), se.set(O, Rh), se;
            }, G = (F)=>{
                if (!(F instanceof Uint8Array)) throw new Error("load() expects an Uint8Array generated by save()");
                const $ = t.exports.Hash_GetState(), Y = f(), O = Rh + Y, se = t.exports.memory.buffer;
                if (F.length !== O) throw new Error(`Bad state length (expected ${O} bytes, got ${F.length})`);
                if (!j5e(n.hash, F.subarray(0, Rh))) throw new Error("This state was written by an incompatible hash implementation");
                const ae = F.subarray(Rh);
                new Uint8Array(se, $, Y).set(ae), s = !0;
            }, P = (F)=>typeof F == "string" ? F.length < J0 / 4 : F.byteLength < J0;
            let J = P;
            switch(n.name){
                case "argon2":
                case "scrypt":
                    J = ()=>!0;
                    break;
                case "blake2b":
                case "blake2s":
                    J = (F, $)=>$ <= 512 && P(F);
                    break;
                case "blake3":
                    J = (F, $)=>$ === 0 && P(F);
                    break;
                case "xxhash64":
                case "xxhash3":
                case "xxhash128":
                case "crc64":
                    J = ()=>!1;
                    break;
            }
            const H = (F, $ = null, Y = null)=>{
                if (!J(F, $)) return w($), S(F), I("hex", Y);
                const O = Gi(F);
                return r.set(O), t.exports.Hash_Calculate(O.length, $, Y), G4(_, r, e);
            };
            return yield m(), {
                getMemory: l,
                writeMemory: i,
                getExports: u,
                setMemorySize: h,
                init: w,
                update: S,
                digest: I,
                save: k,
                load: G,
                calculate: H,
                hashLength: e
            };
        });
    }
    new Kt;
    var ewe = "argon2", twe = "AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvEyBVgBAn9BACEBAkAgAEEAKAKICCICRg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkDyAGFNwPYCUEAIAIpA9ABIAEpA9ABhTcD4AlBACACKQPYASABKQPYAYU3A+gJQQAgAikD4AEgASkD4AGFNwPwCUEAIAIpA+gBIAEpA+gBhTcD+AlBACACKQPwASABKQPwAYU3A4AKQQAgAikD+AEgASkD+AGFNwOICkEAIAIpA4ACIAEpA4AChTcDkApBACACKQOIAiABKQOIAoU3A5gKQQAgAikDkAIgASkDkAKFNwOgCkEAIAIpA5gCIAEpA5gChTcDqApBACACKQOgAiABKQOgAoU3A7AKQQAgAikDqAIgASkDqAKFNwO4CkEAIAIpA7ACIAEpA7AChTcDwApBACACKQO4AiABKQO4AoU3A8gKQQAgAikDwAIgASkDwAKFNwPQCkEAIAIpA8gCIAEpA8gChTcD2ApBACACKQPQAiABKQPQAoU3A+AKQQAgAikD2AIgASkD2AKFNwPoCkEAIAIpA+ACIAEpA+AChTcD8ApBACACKQPoAiABKQPoAoU3A/gKQQAgAikD8AIgASkD8AKFNwOAC0EAIAIpA/gCIAEpA/gChTcDiAtBACACKQOAAyABKQOAA4U3A5ALQQAgAikDiAMgASkDiAOFNwOYC0EAIAIpA5ADIAEpA5ADhTcDoAtBACACKQOYAyABKQOYA4U3A6gLQQAgAikDoAMgASkDoAOFNwOwC0EAIAIpA6gDIAEpA6gDhTcDuAtBACACKQOwAyABKQOwA4U3A8ALQQAgAikDuAMgASkDuAOFNwPIC0EAIAIpA8ADIAEpA8ADhTcD0AtBACACKQPIAyABKQPIA4U3A9gLQQAgAikD0AMgASkD0AOFNwPgC0EAIAIpA9gDIAEpA9gDhTcD6AtBACACKQPgAyABKQPgA4U3A/ALQQAgAikD6AMgASkD6AOFNwP4C0EAIAIpA/ADIAEpA/ADhTcDgAxBACACKQP4AyABKQP4A4U3A4gMQQAgAikDgAQgASkDgASFNwOQDEEAIAIpA4gEIAEpA4gEhTcDmAxBACACKQOQBCABKQOQBIU3A6AMQQAgAikDmAQgASkDmASFNwOoDEEAIAIpA6AEIAEpA6AEhTcDsAxBACACKQOoBCABKQOoBIU3A7gMQQAgAikDsAQgASkDsASFNwPADEEAIAIpA7gEIAEpA7gEhTcDyAxBACACKQPABCABKQPABIU3A9AMQQAgAikDyAQgASkDyASFNwPYDEEAIAIpA9AEIAEpA9AEhTcD4AxBACACKQPYBCABKQPYBIU3A+gMQQAgAikD4AQgASkD4ASFNwPwDEEAIAIpA+gEIAEpA+gEhTcD+AxBACACKQPwBCABKQPwBIU3A4ANQQAgAikD+AQgASkD+ASFNwOIDUEAIAIpA4AFIAEpA4AFhTcDkA1BACACKQOIBSABKQOIBYU3A5gNQQAgAikDkAUgASkDkAWFNwOgDUEAIAIpA5gFIAEpA5gFhTcDqA1BACACKQOgBSABKQOgBYU3A7ANQQAgAikDqAUgASkDqAWFNwO4DUEAIAIpA7AFIAEpA7AFhTcDwA1BACACKQO4BSABKQO4BYU3A8gNQQAgAikDwAUgASkDwAWFNwPQDUEAIAIpA8gFIAEpA8gFhTcD2A1BACACKQPQBSABKQPQBYU3A+ANQQAgAikD2AUgASkD2AWFNwPoDUEAIAIpA+AFIAEpA+AFhTcD8A1BACACKQPoBSABKQPoBYU3A/gNQQAgAikD8AUgASkD8AWFNwOADkEAIAIpA/gFIAEpA/gFhTcDiA5BACACKQOABiABKQOABoU3A5AOQQAgAikDiAYgASkDiAaFNwOYDkEAIAIpA5AGIAEpA5AGhTcDoA5BACACKQOYBiABKQOYBoU3A6gOQQAgAikDoAYgASkDoAaFNwOwDkEAIAIpA6gGIAEpA6gGhTcDuA5BACACKQOwBiABKQOwBoU3A8AOQQAgAikDuAYgASkDuAaFNwPIDkEAIAIpA8AGIAEpA8AGhTcD0A5BACACKQPIBiABKQPIBoU3A9gOQQAgAikD0AYgASkD0AaFNwPgDkEAIAIpA9gGIAEpA9gGhTcD6A5BACACKQPgBiABKQPgBoU3A/AOQQAgAikD6AYgASkD6AaFNwP4DkEAIAIpA/AGIAEpA/AGhTcDgA9BACACKQP4BiABKQP4BoU3A4gPQQAgAikDgAcgASkDgAeFNwOQD0EAIAIpA4gHIAEpA4gHhTcDmA9BACACKQOQByABKQOQB4U3A6APQQAgAikDmAcgASkDmAeFNwOoD0EAIAIpA6AHIAEpA6AHhTcDsA9BACACKQOoByABKQOoB4U3A7gPQQAgAikDsAcgASkDsAeFNwPAD0EAIAIpA7gHIAEpA7gHhTcDyA9BACACKQPAByABKQPAB4U3A9APQQAgAikDyAcgASkDyAeFNwPYD0EAIAIpA9AHIAEpA9AHhTcD4A9BACACKQPYByABKQPYB4U3A+gPQQAgAikD4AcgASkD4AeFNwPwD0EAIAIpA+gHIAEpA+gHhTcD+A9BACACKQPwByABKQPwB4U3A4AQQQAgAikD+AcgASkD+AeFNwOIEEGQCEGYCEGgCEGoCEGwCEG4CEHACEHICEHQCEHYCEHgCEHoCEHwCEH4CEGACUGICRACQZAJQZgJQaAJQagJQbAJQbgJQcAJQcgJQdAJQdgJQeAJQegJQfAJQfgJQYAKQYgKEAJBkApBmApBoApBqApBsApBuApBwApByApB0ApB2ApB4ApB6ApB8ApB+ApBgAtBiAsQAkGQC0GYC0GgC0GoC0GwC0G4C0HAC0HIC0HQC0HYC0HgC0HoC0HwC0H4C0GADEGIDBACQZAMQZgMQaAMQagMQbAMQbgMQcAMQcgMQdAMQdgMQeAMQegMQfAMQfgMQYANQYgNEAJBkA1BmA1BoA1BqA1BsA1BuA1BwA1ByA1B0A1B2A1B4A1B6A1B8A1B+A1BgA5BiA4QAkGQDkGYDkGgDkGoDkGwDkG4DkHADkHIDkHQDkHYDkHgDkHoDkHwDkH4DkGAD0GIDxACQZAPQZgPQaAPQagPQbAPQbgPQcAPQcgPQdAPQdgPQeAPQegPQfAPQfgPQYAQQYgQEAJBkAhBmAhBkAlBmAlBkApBmApBkAtBmAtBkAxBmAxBkA1BmA1BkA5BmA5BkA9BmA8QAkGgCEGoCEGgCUGoCUGgCkGoCkGgC0GoC0GgDEGoDEGgDUGoDUGgDkGoDkGgD0GoDxACQbAIQbgIQbAJQbgJQbAKQbgKQbALQbgLQbAMQbgMQbANQbgNQbAOQbgOQbAPQbgPEAJBwAhByAhBwAlByAlBwApByApBwAtByAtBwAxByAxBwA1ByA1BwA5ByA5BwA9ByA8QAkHQCEHYCEHQCUHYCUHQCkHYCkHQC0HYC0HQDEHYDEHQDUHYDUHQDkHYDkHQD0HYDxACQeAIQegIQeAJQegJQeAKQegKQeALQegLQeAMQegMQeANQegNQeAOQegOQeAPQegPEAJB8AhB+AhB8AlB+AlB8ApB+ApB8AtB+AtB8AxB+AxB8A1B+A1B8A5B+A5B8A9B+A8QAkGACUGICUGACkGICkGAC0GIC0GADEGIDEGADUGIDUGADkGIDkGAD0GID0GAEEGIEBACAkACQCADRQ0AA0AgACAEaiIDIAIgBGoiBSkDACABIARqIgYpAwCFIARBkAhqKQMAhSADKQMAhTcDACADQQhqIgMgBUEIaikDACAGQQhqKQMAhSAEQZgIaikDAIUgAykDAIU3AwAgBEEQaiIEQYAIRw0ADAILC0EAIQQDQCAAIARqIgMgAiAEaiIFKQMAIAEgBGoiBikDAIUgBEGQCGopAwCFNwMAIANBCGogBUEIaikDACAGQQhqKQMAhSAEQZgIaikDAIU3AwAgBEEQaiIEQYAIRw0ACwsL5QcMBX8BfgR/An4BfwF+AX8Bfgd/AX4DfwF+AkBBACgCgAgiAiABQQp0aiIDKAIIIAFHDQAgAygCDCEEIAMoAgAhBUEAIAMoAhQiBq03A7gQQQAgBK0iBzcDsBBBACAFIAEgBUECdG4iCGwiCUECdK03A6gQAkACQAJAAkAgBEUNAEF/IQogBUUNASAIQQNsIQsgCEECdCIErSEMIAWtIQ0gBkF/akECSSEOQgAhDwNAQQAgDzcDkBAgD6chEEIAIRFBACEBA0BBACARNwOgECAPIBGEUCIDIA5xIRIgBkEBRiAPUCITIAZBAkYgEUICVHFxciEUQX8gAUEBakEDcSAIbEF/aiATGyEVIAEgEHIhFiABIAhsIRcgA0EBdCEYQgAhGQNAQQBCADcDwBBBACAZNwOYECAYIQECQCASRQ0AQQBCATcDwBBBkBhBkBBBkCBBABADQZAYQZAYQZAgQQAQA0ECIQELAkAgASAITw0AIAQgGaciGmwgF2ogAWohAwNAIANBACAEIAEbQQAgEVAiGxtqQX9qIRwCQAJAIBQNAEEAKAKACCICIBxBCnQiHGohCgwBCwJAIAFB/wBxIgINAEEAQQApA8AQQgF8NwPAEEGQGEGQEEGQIEEAEANBkBhBkBhBkCBBABADCyAcQQp0IRwgAkEDdEGQGGohCkEAKAKACCECCyACIANBCnRqIAIgHGogAiAKKQMAIh1CIIinIAVwIBogFhsiHCAEbCABIAFBACAZIBytUSIcGyIKIBsbIBdqIAogC2ogExsgAUUgHHJrIhsgFWqtIB1C/////w+DIh0gHX5CIIggG61+QiCIfSAMgqdqQQp0akEBEAMgA0EBaiEDIAggAUEBaiIBRw0ACwsgGUIBfCIZIA1SDQALIBFCAXwiEachASARQgRSDQALIA9CAXwiDyAHUg0AC0EAKAKACCECCyAJQQx0QYB4aiEXIAVBf2oiCkUNAgwBC0EAQgM3A6AQQQAgBEF/aq03A5AQQYB4IRcLIAIgF2ohGyAIQQx0IQhBACEcA0AgCCAcQQFqIhxsQYB4aiEEQQAhAQNAIBsgAWoiAyADKQMAIAIgBCABamopAwCFNwMAIANBCGoiAyADKQMAIAIgBCABQQhyamopAwCFNwMAIAFBCGohAyABQRBqIQEgA0H4B0kNAAsgHCAKRw0ACwsgAiAXaiEbQXghAQNAIAIgAWoiA0EIaiAbIAFqIgRBCGopAwA3AwAgA0EQaiAEQRBqKQMANwMAIANBGGogBEEYaikDADcDACADQSBqIARBIGopAwA3AwAgAUEgaiIBQfgHSQ0ACwsL", nwe = "e4cdc523", rwe = {
        name: ewe,
        data: twe,
        hash: nwe
    }, swe = "blake2b", iwe = "AGFzbQEAAAABEQRgAAF/YAJ/fwBgAX8AYAAAAwoJAAECAwECAgABBQQBAQICBg4CfwFBsIsFC38AQYAICwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACkhhc2hfRmluYWwAAwlIYXNoX0luaXQABQtIYXNoX1VwZGF0ZQAGDUhhc2hfR2V0U3RhdGUABw5IYXNoX0NhbGN1bGF0ZQAIClNUQVRFX1NJWkUDAQrTOAkFAEGACQvrAgIFfwF+AkAgAUEBSA0AAkACQAJAIAFBgAFBACgC4IoBIgJrIgNKDQAgASEEDAELQQBBADYC4IoBAkAgAkH/AEoNACACQeCJAWohBSAAIQRBACEGA0AgBSAELQAAOgAAIARBAWohBCAFQQFqIQUgAyAGQQFqIgZB/wFxSg0ACwtBAEEAKQPAiQEiB0KAAXw3A8CJAUEAQQApA8iJASAHQv9+Vq18NwPIiQFB4IkBEAIgACADaiEAAkAgASADayIEQYEBSA0AIAIgAWohBQNAQQBBACkDwIkBIgdCgAF8NwPAiQFBAEEAKQPIiQEgB0L/flatfDcDyIkBIAAQAiAAQYABaiEAIAVBgH9qIgVBgAJLDQALIAVBgH9qIQQMAQsgBEEATA0BC0EAIQUDQCAFQQAoAuCKAWpB4IkBaiAAIAVqLQAAOgAAIAQgBUEBaiIFQf8BcUoNAAsLQQBBACgC4IoBIARqNgLgigELC78uASR+QQBBACkD0IkBQQApA7CJASIBQQApA5CJAXwgACkDICICfCIDhULr+obav7X2wR+FQiCJIgRCq/DT9K/uvLc8fCIFIAGFQiiJIgYgA3wgACkDKCIBfCIHIASFQjCJIgggBXwiCSAGhUIBiSIKQQApA8iJAUEAKQOoiQEiBEEAKQOIiQF8IAApAxAiA3wiBYVCn9j52cKR2oKbf4VCIIkiC0K7zqqm2NDrs7t/fCIMIASFQiiJIg0gBXwgACkDGCIEfCIOfCAAKQNQIgV8Ig9BACkDwIkBQQApA6CJASIQQQApA4CJASIRfCAAKQMAIgZ8IhKFQtGFmu/6z5SH0QCFQiCJIhNCiJLznf/M+YTqAHwiFCAQhUIoiSIVIBJ8IAApAwgiEHwiFiAThUIwiSIXhUIgiSIYQQApA9iJAUEAKQO4iQEiE0EAKQOYiQF8IAApAzAiEnwiGYVC+cL4m5Gjs/DbAIVCIIkiGkLx7fT4paf9p6V/fCIbIBOFQiiJIhwgGXwgACkDOCITfCIZIBqFQjCJIhogG3wiG3wiHSAKhUIoiSIeIA98IAApA1giCnwiDyAYhUIwiSIYIB18Ih0gDiALhUIwiSIOIAx8Ih8gDYVCAYkiDCAWfCAAKQNAIgt8Ig0gGoVCIIkiFiAJfCIaIAyFQiiJIiAgDXwgACkDSCIJfCIhIBaFQjCJIhYgGyAchUIBiSIMIAd8IAApA2AiB3wiDSAOhUIgiSIOIBcgFHwiFHwiFyAMhUIoiSIbIA18IAApA2giDHwiHCAOhUIwiSIOIBd8IhcgG4VCAYkiGyAZIBQgFYVCAYkiFHwgACkDcCINfCIVIAiFQiCJIhkgH3wiHyAUhUIoiSIUIBV8IAApA3giCHwiFXwgDHwiIoVCIIkiI3wiJCAbhUIoiSIbICJ8IBJ8IiIgFyAYIBUgGYVCMIkiFSAffCIZIBSFQgGJIhQgIXwgDXwiH4VCIIkiGHwiFyAUhUIoiSIUIB98IAV8Ih8gGIVCMIkiGCAXfCIXIBSFQgGJIhR8IAF8IiEgFiAafCIWIBUgHSAehUIBiSIaIBx8IAl8IhyFQiCJIhV8Ih0gGoVCKIkiGiAcfCAIfCIcIBWFQjCJIhWFQiCJIh4gGSAOIBYgIIVCAYkiFiAPfCACfCIPhUIgiSIOfCIZIBaFQiiJIhYgD3wgC3wiDyAOhUIwiSIOIBl8Ihl8IiAgFIVCKIkiFCAhfCAEfCIhIB6FQjCJIh4gIHwiICAiICOFQjCJIiIgJHwiIyAbhUIBiSIbIBx8IAp8IhwgDoVCIIkiDiAXfCIXIBuFQiiJIhsgHHwgE3wiHCAOhUIwiSIOIBkgFoVCAYkiFiAffCAQfCIZICKFQiCJIh8gFSAdfCIVfCIdIBaFQiiJIhYgGXwgB3wiGSAfhUIwiSIfIB18Ih0gFoVCAYkiFiAVIBqFQgGJIhUgD3wgBnwiDyAYhUIgiSIYICN8IhogFYVCKIkiFSAPfCADfCIPfCAHfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgBnwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAOIBd8Ig4gDyAYhUIwiSIPICAgFIVCAYkiFCAZfCAKfCIXhUIgiSIYfCIZIBSFQiiJIhQgF3wgC3wiF3wgBXwiICAPIBp8Ig8gHyAOIBuFQgGJIg4gIXwgCHwiGoVCIIkiG3wiHyAOhUIoiSIOIBp8IAx8IhogG4VCMIkiG4VCIIkiISAdIB4gDyAVhUIBiSIPIBx8IAF8IhWFQiCJIhx8Ih0gD4VCKIkiDyAVfCADfCIVIByFQjCJIhwgHXwiHXwiHiAWhUIoiSIWICB8IA18IiAgIYVCMIkiISAefCIeIBogFyAYhUIwiSIXIBl8IhggFIVCAYkiFHwgCXwiGSAchUIgiSIaICR8IhwgFIVCKIkiFCAZfCACfCIZIBqFQjCJIhogHSAPhUIBiSIPICJ8IAR8Ih0gF4VCIIkiFyAbIB98Iht8Ih8gD4VCKIkiDyAdfCASfCIdIBeFQjCJIhcgH3wiHyAPhUIBiSIPIBsgDoVCAYkiDiAVfCATfCIVICOFQiCJIhsgGHwiGCAOhUIoiSIOIBV8IBB8IhV8IAx8IiKFQiCJIiN8IiQgD4VCKIkiDyAifCAHfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBogHHwiGiAVIBuFQjCJIhUgHiAWhUIBiSIWIB18IAR8IhuFQiCJIhx8Ih0gFoVCKIkiFiAbfCAQfCIbfCABfCIeIBUgGHwiFSAXIBogFIVCAYkiFCAgfCATfCIYhUIgiSIXfCIaIBSFQiiJIhQgGHwgCXwiGCAXhUIwiSIXhUIgiSIgIB8gISAVIA6FQgGJIg4gGXwgCnwiFYVCIIkiGXwiHyAOhUIoiSIOIBV8IA18IhUgGYVCMIkiGSAffCIffCIhIA+FQiiJIg8gHnwgBXwiHiAghUIwiSIgICF8IiEgGyAchUIwiSIbIB18IhwgFoVCAYkiFiAYfCADfCIYIBmFQiCJIhkgJHwiHSAWhUIoiSIWIBh8IBJ8IhggGYVCMIkiGSAfIA6FQgGJIg4gInwgAnwiHyAbhUIgiSIbIBcgGnwiF3wiGiAOhUIoiSIOIB98IAZ8Ih8gG4VCMIkiGyAafCIaIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAh8IhUgI4VCIIkiFyAcfCIcIBSFQiiJIhQgFXwgC3wiFXwgBXwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IAh8IiIgGiAgIBUgF4VCMIkiFSAcfCIXIBSFQgGJIhQgGHwgCXwiGIVCIIkiHHwiGiAUhUIoiSIUIBh8IAZ8IhggHIVCMIkiHCAafCIaIBSFQgGJIhR8IAR8IiAgGSAdfCIZIBUgISAPhUIBiSIPIB98IAN8Ih2FQiCJIhV8Ih8gD4VCKIkiDyAdfCACfCIdIBWFQjCJIhWFQiCJIiEgFyAbIBkgFoVCAYkiFiAefCABfCIZhUIgiSIbfCIXIBaFQiiJIhYgGXwgE3wiGSAbhUIwiSIbIBd8Ihd8Ih4gFIVCKIkiFCAgfCAMfCIgICGFQjCJIiEgHnwiHiAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIB18IBJ8Ih0gG4VCIIkiGyAafCIaIA6FQiiJIg4gHXwgC3wiHSAbhUIwiSIbIBcgFoVCAYkiFiAYfCANfCIXICKFQiCJIhggFSAffCIVfCIfIBaFQiiJIhYgF3wgEHwiFyAYhUIwiSIYIB98Ih8gFoVCAYkiFiAVIA+FQgGJIg8gGXwgCnwiFSAchUIgiSIZICN8IhwgD4VCKIkiDyAVfCAHfCIVfCASfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgBXwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAbIBp8IhogFSAZhUIwiSIVIB4gFIVCAYkiFCAXfCADfCIXhUIgiSIZfCIbIBSFQiiJIhQgF3wgB3wiF3wgAnwiHiAVIBx8IhUgGCAaIA6FQgGJIg4gIHwgC3wiGoVCIIkiGHwiHCAOhUIoiSIOIBp8IAR8IhogGIVCMIkiGIVCIIkiICAfICEgFSAPhUIBiSIPIB18IAZ8IhWFQiCJIh18Ih8gD4VCKIkiDyAVfCAKfCIVIB2FQjCJIh0gH3wiH3wiISAWhUIoiSIWIB58IAx8Ih4gIIVCMIkiICAhfCIhIBogFyAZhUIwiSIXIBt8IhkgFIVCAYkiFHwgEHwiGiAdhUIgiSIbICR8Ih0gFIVCKIkiFCAafCAJfCIaIBuFQjCJIhsgHyAPhUIBiSIPICJ8IBN8Ih8gF4VCIIkiFyAYIBx8Ihh8IhwgD4VCKIkiDyAffCABfCIfIBeFQjCJIhcgHHwiHCAPhUIBiSIPIBggDoVCAYkiDiAVfCAIfCIVICOFQiCJIhggGXwiGSAOhUIoiSIOIBV8IA18IhV8IA18IiKFQiCJIiN8IiQgD4VCKIkiDyAifCAMfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBsgHXwiGyAVIBiFQjCJIhUgISAWhUIBiSIWIB98IBB8IhiFQiCJIh18Ih8gFoVCKIkiFiAYfCAIfCIYfCASfCIhIBUgGXwiFSAXIBsgFIVCAYkiFCAefCAHfCIZhUIgiSIXfCIbIBSFQiiJIhQgGXwgAXwiGSAXhUIwiSIXhUIgiSIeIBwgICAVIA6FQgGJIg4gGnwgAnwiFYVCIIkiGnwiHCAOhUIoiSIOIBV8IAV8IhUgGoVCMIkiGiAcfCIcfCIgIA+FQiiJIg8gIXwgBHwiISAehUIwiSIeICB8IiAgGCAdhUIwiSIYIB98Ih0gFoVCAYkiFiAZfCAGfCIZIBqFQiCJIhogJHwiHyAWhUIoiSIWIBl8IBN8IhkgGoVCMIkiGiAcIA6FQgGJIg4gInwgCXwiHCAYhUIgiSIYIBcgG3wiF3wiGyAOhUIoiSIOIBx8IAN8IhwgGIVCMIkiGCAbfCIbIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAt8IhUgI4VCIIkiFyAdfCIdIBSFQiiJIhQgFXwgCnwiFXwgBHwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IAl8IiIgGyAeIBUgF4VCMIkiFSAdfCIXIBSFQgGJIhQgGXwgDHwiGYVCIIkiHXwiGyAUhUIoiSIUIBl8IAp8IhkgHYVCMIkiHSAbfCIbIBSFQgGJIhR8IAN8Ih4gGiAffCIaIBUgICAPhUIBiSIPIBx8IAd8IhyFQiCJIhV8Ih8gD4VCKIkiDyAcfCAQfCIcIBWFQjCJIhWFQiCJIiAgFyAYIBogFoVCAYkiFiAhfCATfCIahUIgiSIYfCIXIBaFQiiJIhYgGnwgDXwiGiAYhUIwiSIYIBd8Ihd8IiEgFIVCKIkiFCAefCAFfCIeICCFQjCJIiAgIXwiISAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIBx8IAt8IhwgGIVCIIkiGCAbfCIbIA6FQiiJIg4gHHwgEnwiHCAYhUIwiSIYIBcgFoVCAYkiFiAZfCABfCIXICKFQiCJIhkgFSAffCIVfCIfIBaFQiiJIhYgF3wgBnwiFyAZhUIwiSIZIB98Ih8gFoVCAYkiFiAVIA+FQgGJIg8gGnwgCHwiFSAdhUIgiSIaICN8Ih0gD4VCKIkiDyAVfCACfCIVfCANfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgCXwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAYIBt8IhggFSAahUIwiSIVICEgFIVCAYkiFCAXfCASfCIXhUIgiSIafCIbIBSFQiiJIhQgF3wgCHwiF3wgB3wiISAVIB18IhUgGSAYIA6FQgGJIg4gHnwgBnwiGIVCIIkiGXwiHSAOhUIoiSIOIBh8IAt8IhggGYVCMIkiGYVCIIkiHiAfICAgFSAPhUIBiSIPIBx8IAp8IhWFQiCJIhx8Ih8gD4VCKIkiDyAVfCAEfCIVIByFQjCJIhwgH3wiH3wiICAWhUIoiSIWICF8IAN8IiEgHoVCMIkiHiAgfCIgIBggFyAahUIwiSIXIBt8IhogFIVCAYkiFHwgBXwiGCAchUIgiSIbICR8IhwgFIVCKIkiFCAYfCABfCIYIBuFQjCJIhsgHyAPhUIBiSIPICJ8IAx8Ih8gF4VCIIkiFyAZIB18Ihl8Ih0gD4VCKIkiDyAffCATfCIfIBeFQjCJIhcgHXwiHSAPhUIBiSIPIBkgDoVCAYkiDiAVfCAQfCIVICOFQiCJIhkgGnwiGiAOhUIoiSIOIBV8IAJ8IhV8IBN8IiKFQiCJIiN8IiQgD4VCKIkiDyAifCASfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBsgHHwiGyAVIBmFQjCJIhUgICAWhUIBiSIWIB98IAt8IhmFQiCJIhx8Ih8gFoVCKIkiFiAZfCACfCIZfCAJfCIgIBUgGnwiFSAXIBsgFIVCAYkiFCAhfCAFfCIahUIgiSIXfCIbIBSFQiiJIhQgGnwgA3wiGiAXhUIwiSIXhUIgiSIhIB0gHiAVIA6FQgGJIg4gGHwgEHwiFYVCIIkiGHwiHSAOhUIoiSIOIBV8IAF8IhUgGIVCMIkiGCAdfCIdfCIeIA+FQiiJIg8gIHwgDXwiICAhhUIwiSIhIB58Ih4gGSAchUIwiSIZIB98IhwgFoVCAYkiFiAafCAIfCIaIBiFQiCJIhggJHwiHyAWhUIoiSIWIBp8IAp8IhogGIVCMIkiGCAdIA6FQgGJIg4gInwgBHwiHSAZhUIgiSIZIBcgG3wiF3wiGyAOhUIoiSIOIB18IAd8Ih0gGYVCMIkiGSAbfCIbIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAx8IhUgI4VCIIkiFyAcfCIcIBSFQiiJIhQgFXwgBnwiFXwgEnwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IBN8IiIgGyAhIBUgF4VCMIkiFSAcfCIXIBSFQgGJIhQgGnwgBnwiGoVCIIkiHHwiGyAUhUIoiSIUIBp8IBB8IhogHIVCMIkiHCAbfCIbIBSFQgGJIhR8IA18IiEgGCAffCIYIBUgHiAPhUIBiSIPIB18IAJ8Ih2FQiCJIhV8Ih4gD4VCKIkiDyAdfCABfCIdIBWFQjCJIhWFQiCJIh8gFyAZIBggFoVCAYkiFiAgfCADfCIYhUIgiSIZfCIXIBaFQiiJIhYgGHwgBHwiGCAZhUIwiSIZIBd8Ihd8IiAgFIVCKIkiFCAhfCAIfCIhIB+FQjCJIh8gIHwiICAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIB18IAd8Ih0gGYVCIIkiGSAbfCIbIA6FQiiJIg4gHXwgDHwiHSAZhUIwiSIZIBcgFoVCAYkiFiAafCALfCIXICKFQiCJIhogFSAefCIVfCIeIBaFQiiJIhYgF3wgCXwiFyAahUIwiSIaIB58Ih4gFoVCAYkiFiAVIA+FQgGJIg8gGHwgBXwiFSAchUIgiSIYICN8IhwgD4VCKIkiDyAVfCAKfCIVfCACfCIChUIgiSIifCIjIBaFQiiJIhYgAnwgC3wiAiAihUIwiSILICN8IiIgFoVCAYkiFiAZIBt8IhkgFSAYhUIwiSIVICAgFIVCAYkiFCAXfCANfCINhUIgiSIXfCIYIBSFQiiJIhQgDXwgBXwiBXwgEHwiECAVIBx8Ig0gGiAZIA6FQgGJIg4gIXwgDHwiDIVCIIkiFXwiGSAOhUIoiSIOIAx8IBJ8IhIgFYVCMIkiDIVCIIkiFSAeIB8gDSAPhUIBiSINIB18IAl8IgmFQiCJIg98IhogDYVCKIkiDSAJfCAIfCIJIA+FQjCJIgggGnwiD3wiGiAWhUIoiSIWIBB8IAd8IhAgEYUgDCAZfCIHIA6FQgGJIgwgCXwgCnwiCiALhUIgiSILIAUgF4VCMIkiBSAYfCIJfCIOIAyFQiiJIgwgCnwgE3wiEyALhUIwiSIKIA58IguFNwOAiQFBACADIAYgDyANhUIBiSINIAJ8fCICIAWFQiCJIgUgB3wiBiANhUIoiSIHIAJ8fCICQQApA4iJAYUgBCABIBIgCSAUhUIBiSIDfHwiASAIhUIgiSISICJ8IgkgA4VCKIkiAyABfHwiASAShUIwiSIEIAl8IhKFNwOIiQFBACATQQApA5CJAYUgECAVhUIwiSIQIBp8IhOFNwOQiQFBACABQQApA5iJAYUgAiAFhUIwiSICIAZ8IgGFNwOYiQFBACASIAOFQgGJQQApA6CJAYUgAoU3A6CJAUEAIBMgFoVCAYlBACkDqIkBhSAKhTcDqIkBQQAgASAHhUIBiUEAKQOwiQGFIASFNwOwiQFBACALIAyFQgGJQQApA7iJAYUgEIU3A7iJAQvdAgUBfwF+AX8BfgJ/IwBBwABrIgAkAAJAQQApA9CJAUIAUg0AQQBBACkDwIkBIgFBACgC4IoBIgKsfCIDNwPAiQFBAEEAKQPIiQEgAyABVK18NwPIiQECQEEALQDoigFFDQBBAEJ/NwPYiQELQQBCfzcD0IkBAkAgAkH/AEoNAEEAIQQDQCACIARqQeCJAWpBADoAACAEQQFqIgRBgAFBACgC4IoBIgJrSA0ACwtB4IkBEAIgAEEAKQOAiQE3AwAgAEEAKQOIiQE3AwggAEEAKQOQiQE3AxAgAEEAKQOYiQE3AxggAEEAKQOgiQE3AyAgAEEAKQOoiQE3AyggAEEAKQOwiQE3AzAgAEEAKQO4iQE3AzhBACgC5IoBIgVBAUgNAEEAIQRBACECA0AgBEGACWogACAEai0AADoAACAEQQFqIQQgBSACQQFqIgJB/wFxSg0ACwsgAEHAAGokAAv9AwMBfwF+AX8jAEGAAWsiAiQAQQBBgQI7AfKKAUEAIAE6APGKAUEAIAA6APCKAUGQfiEAA0AgAEGAiwFqQgA3AAAgAEH4igFqQgA3AAAgAEHwigFqQgA3AAAgAEEYaiIADQALQQAhAEEAQQApA/CKASIDQoiS853/zPmE6gCFNwOAiQFBAEEAKQP4igFCu86qptjQ67O7f4U3A4iJAUEAQQApA4CLAUKr8NP0r+68tzyFNwOQiQFBAEEAKQOIiwFC8e30+KWn/aelf4U3A5iJAUEAQQApA5CLAULRhZrv+s+Uh9EAhTcDoIkBQQBBACkDmIsBQp/Y+dnCkdqCm3+FNwOoiQFBAEEAKQOgiwFC6/qG2r+19sEfhTcDsIkBQQBBACkDqIsBQvnC+JuRo7Pw2wCFNwO4iQFBACADp0H/AXE2AuSKAQJAIAFBAUgNACACQgA3A3ggAkIANwNwIAJCADcDaCACQgA3A2AgAkIANwNYIAJCADcDUCACQgA3A0ggAkIANwNAIAJCADcDOCACQgA3AzAgAkIANwMoIAJCADcDICACQgA3AxggAkIANwMQIAJCADcDCCACQgA3AwBBACEEA0AgAiAAaiAAQYAJai0AADoAACAAQQFqIQAgBEEBaiIEQf8BcSABSA0ACyACQYABEAELIAJBgAFqJAALEgAgAEEDdkH/P3EgAEEQdhAECwkAQYAJIAAQAQsGAEGAiQELGwAgAUEDdkH/P3EgAUEQdhAEQYAJIAAQARADCwsLAQBBgAgLBPAAAAA=", owe = "c6f286e6", awe = {
        name: swe,
        data: iwe,
        hash: owe
    };
    new Kt;
    function HS(n) {
        return !Number.isInteger(n) || n < 8 || n > 512 || n % 8 !== 0 ? new Error("Invalid variant! Valid values: 8, 16, ..., 512") : null;
    }
    function lwe(n, e) {
        return n | e << 16;
    }
    function Y4(n = 512, e = null) {
        if (HS(n)) return Promise.reject(HS(n));
        let t = null, r = n;
        if (e !== null) {
            if (t = Gi(e), t.length > 64) return Promise.reject(new Error("Max key length is 64 bytes"));
            r = lwe(n, t.length);
        }
        const s = n / 8;
        return kk(awe, s).then((i)=>{
            r > 512 && i.writeMemory(t), i.init(r);
            const l = {
                init: r > 512 ? ()=>(i.writeMemory(t), i.init(r), l) : ()=>(i.init(r), l),
                update: (u)=>(i.update(u), l),
                digest: (u)=>i.digest(u),
                save: ()=>i.save(),
                load: (u)=>(i.load(u), l),
                blockSize: 128,
                digestSize: s
            };
            return l;
        });
    }
    function cwe(n, e, t) {
        const r = [
            `m=${e.memorySize}`,
            `t=${e.iterations}`,
            `p=${e.parallelism}`
        ].join(",");
        return `$argon2${e.hashType}$v=19$${r}$${VS(n, !1)}$${VS(t, !1)}`;
    }
    const QS = new DataView(new ArrayBuffer(4));
    function Hi(n) {
        return QS.setInt32(0, n, !0), new Uint8Array(QS.buffer);
    }
    function xy(n, e, t) {
        return Fa(this, void 0, void 0, function*() {
            if (t <= 64) {
                const h = yield Y4(t * 8);
                return h.update(Hi(t)), h.update(e), h.digest("binary");
            }
            const r = Math.ceil(t / 32) - 2, s = new Uint8Array(t);
            n.init(), n.update(Hi(t)), n.update(e);
            let i = n.digest("binary");
            s.set(i.subarray(0, 32), 0);
            for(let h = 1; h < r; h++)n.init(), n.update(i), i = n.digest("binary"), s.set(i.subarray(0, 32), h * 32);
            const l = t - 32 * r;
            let u;
            return l === 64 ? (u = n, u.init()) : u = yield Y4(l * 8), u.update(i), i = u.digest("binary"), s.set(i.subarray(0, l), r * 32), s;
        });
    }
    function uwe(n) {
        switch(n){
            case "d":
                return 0;
            case "i":
                return 1;
            default:
                return 2;
        }
    }
    function hwe(n) {
        return Fa(this, void 0, void 0, function*() {
            var e;
            const { parallelism: t, iterations: r, hashLength: s } = n, i = Gi(n.password), l = Gi(n.salt), u = 19, h = uwe(n.hashType), { memorySize: f } = n, p = Gi((e = n.secret) !== null && e !== void 0 ? e : ""), [m, w] = yield Promise.all([
                kk(rwe, 1024),
                Y4(512)
            ]);
            m.setMemorySize(f * 1024 + 1024);
            const A = new Uint8Array(24), S = new DataView(A.buffer);
            S.setInt32(0, t, !0), S.setInt32(4, s, !0), S.setInt32(8, f, !0), S.setInt32(12, r, !0), S.setInt32(16, u, !0), S.setInt32(20, h, !0), m.writeMemory(A, f * 1024), w.init(), w.update(A), w.update(Hi(i.length)), w.update(i), w.update(Hi(l.length)), w.update(l), w.update(Hi(p.length)), w.update(p), w.update(Hi(0));
            const I = Math.floor(f / (t * 4)) * 4, k = new Uint8Array(72), G = w.digest("binary");
            k.set(G);
            for(let H = 0; H < t; H++){
                k.set(Hi(0), 64), k.set(Hi(H), 68);
                let F = H * I, $ = yield xy(w, k, 1024);
                m.writeMemory($, F * 1024), F += 1, k.set(Hi(1), 64), $ = yield xy(w, k, 1024), m.writeMemory($, F * 1024);
            }
            const P = new Uint8Array(1024);
            Pk(P, m.calculate(new Uint8Array([]), f));
            const J = yield xy(w, P, s);
            if (n.outputType === "hex") {
                const H = new Uint8Array(s * 2);
                return G4(H, J, s);
            }
            return n.outputType === "encoded" ? cwe(l, n, J) : J;
        });
    }
    const dwe = (n)=>{
        var e;
        if (!n || typeof n != "object") throw new Error("Invalid options parameter. It requires an object.");
        if (!n.password) throw new Error("Password must be specified");
        if (n.password = Gi(n.password), n.password.length < 1) throw new Error("Password must be specified");
        if (!n.salt) throw new Error("Salt must be specified");
        if (n.salt = Gi(n.salt), n.salt.length < 8) throw new Error("Salt should be at least 8 bytes long");
        if (n.secret = Gi((e = n.secret) !== null && e !== void 0 ? e : ""), !Number.isInteger(n.iterations) || n.iterations < 1) throw new Error("Iterations should be a positive number");
        if (!Number.isInteger(n.parallelism) || n.parallelism < 1) throw new Error("Parallelism should be a positive number");
        if (!Number.isInteger(n.hashLength) || n.hashLength < 4) throw new Error("Hash length should be at least 4 bytes.");
        if (!Number.isInteger(n.memorySize)) throw new Error("Memory size should be specified.");
        if (n.memorySize < 8 * n.parallelism) throw new Error("Memory size should be at least 8 * parallelism.");
        if (n.outputType === void 0 && (n.outputType = "hex"), ![
            "hex",
            "binary",
            "encoded"
        ].includes(n.outputType)) throw new Error(`Insupported output type ${n.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
    };
    function fwe(n) {
        return Fa(this, void 0, void 0, function*() {
            return dwe(n), hwe(Object.assign(Object.assign({}, n), {
                hashType: "id"
            }));
        });
    }
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    new Kt;
    const pwe = {
        parallelism: 1,
        iterations: 2,
        memorySize: 4096,
        hashLength: 32
    };
    async function Rk(n, e, t) {
        const r = re(t, "base64"), s = new TextEncoder().encode(e), i = await fwe({
            password: s,
            salt: r,
            ...pwe,
            outputType: "hex"
        }), l = re(i, "base16");
        return await gwe(l);
    }
    async function gwe(n) {
        const { generateKeyPairFromSeed: e } = await Dk(async ()=>{
            const { generateKeyPairFromSeed: r } = await Promise.resolve().then(()=>FU);
            return {
                generateKeyPairFromSeed: r
            };
        }, void 0), t = await e("Ed25519", n);
        return {
            publicKey: t.publicKey.raw,
            privateKey: t.raw
        };
    }
    function mwe() {
        const n = new Uint8Array(16);
        return crypto.getRandomValues(n), L(n, "base64");
    }
    function o5(n) {
        return L(n, "base16");
    }
    function ywe(n) {
        return o5(n).slice(0, 8);
    }
    async function wwe(n, e, t, r) {
        if (await t(n)) return {
            ok: !1,
            error: "Username already taken"
        };
        const i = mwe(), l = await Rk(n, e, i), u = o5(l.publicKey), h = {
            publicKey: u,
            salt: i,
            profileCid: null,
            createdAt: Date.now()
        };
        return await r(n, h) ? {
            ok: !0,
            value: {
                username: n,
                keyPair: l,
                publicKeyHex: u
            }
        } : {
            ok: !1,
            error: "Failed to register (username may have been claimed)"
        };
    }
    async function bwe(n, e, t) {
        const r = await t(n);
        if (!r) return {
            ok: !1,
            error: "Username not found"
        };
        const s = await Rk(n, e, r.salt), i = o5(s.publicKey);
        return i !== r.publicKey ? {
            ok: !1,
            error: "Invalid password"
        } : {
            ok: !0,
            value: {
                username: n,
                keyPair: s,
                publicKeyHex: i
            }
        };
    }
    function vwe() {
        const [n, e] = Dt.useState(null), t = Dt.useCallback(async (i, l)=>{
            const u = await bwe(i, l, (h)=>Pd.lookup(h));
            return u.ok ? (e(u.value), console.log("[Identity] Logged in:", i), {
                ok: !0,
                value: void 0
            }) : {
                ok: !1,
                error: u.error
            };
        }, []), r = Dt.useCallback(async (i, l)=>{
            const u = await wwe(i, l, (h)=>Pd.lookup(h), (h, f)=>Pd.register(h, f));
            return u.ok ? (e(u.value), console.log("[Identity] Registered:", i), {
                ok: !0,
                value: void 0
            }) : {
                ok: !1,
                error: u.error
            };
        }, []), s = Dt.useCallback(()=>{
            e(null), console.log("[Identity] Logged out");
        }, []);
        return {
            isAuthenticated: n !== null,
            username: n?.username ?? null,
            publicKeyShort: n ? ywe(n.keyPair.publicKey) : null,
            login: t,
            register: r,
            logout: s
        };
    }
    const Ok = (...n)=>n.filter((e, t, r)=>!!e && e.trim() !== "" && r.indexOf(e) === t).join(" ").trim();
    const Ewe = (n)=>n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    const Awe = (n)=>n.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, r)=>r ? r.toUpperCase() : t.toLowerCase());
    const qS = (n)=>{
        const e = Awe(n);
        return e.charAt(0).toUpperCase() + e.slice(1);
    };
    var Swe = {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
    };
    const Iwe = (n)=>{
        for(const e in n)if (e.startsWith("aria-") || e === "role" || e === "title") return !0;
        return !1;
    };
    const Cwe = Dt.forwardRef(({ color: n = "currentColor", size: e = 24, strokeWidth: t = 2, absoluteStrokeWidth: r, className: s = "", children: i, iconNode: l, ...u }, h)=>Dt.createElement("svg", {
            ref: h,
            ...Swe,
            width: e,
            height: e,
            stroke: n,
            strokeWidth: r ? Number(t) * 24 / Number(e) : t,
            className: Ok("lucide", s),
            ...!i && !Iwe(u) && {
                "aria-hidden": "true"
            },
            ...u
        }, [
            ...l.map(([f, p])=>Dt.createElement(f, p)),
            ...Array.isArray(i) ? i : [
                i
            ]
        ]));
    const Cs = (n, e)=>{
        const t = Dt.forwardRef(({ className: r, ...s }, i)=>Dt.createElement(Cwe, {
                ref: i,
                iconNode: e,
                className: Ok(`lucide-${Ewe(qS(n))}`, `lucide-${n}`, r),
                ...s
            }));
        return t.displayName = qS(n), t;
    };
    const Twe = [
        [
            "path",
            {
                d: "M10.268 21a2 2 0 0 0 3.464 0",
                key: "vwvbt9"
            }
        ],
        [
            "path",
            {
                d: "M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326",
                key: "11g9vi"
            }
        ]
    ], _we = Cs("bell", Twe);
    const xwe = [
        [
            "path",
            {
                d: "M15 3h6v6",
                key: "1q9fwt"
            }
        ],
        [
            "path",
            {
                d: "M10 14 21 3",
                key: "gplh6r"
            }
        ],
        [
            "path",
            {
                d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
                key: "a6xqqp"
            }
        ]
    ], Dwe = Cs("external-link", xwe);
    const Bwe = [
        [
            "rect",
            {
                width: "18",
                height: "18",
                x: "3",
                y: "3",
                rx: "2",
                key: "afitv7"
            }
        ],
        [
            "path",
            {
                d: "M3 9h18",
                key: "1pudct"
            }
        ],
        [
            "path",
            {
                d: "M3 15h18",
                key: "5xshup"
            }
        ],
        [
            "path",
            {
                d: "M9 3v18",
                key: "fh3hqa"
            }
        ],
        [
            "path",
            {
                d: "M15 3v18",
                key: "14nvp0"
            }
        ]
    ], Pwe = Cs("grid-3x3", Bwe);
    const kwe = [
        [
            "polyline",
            {
                points: "22 12 16 12 14 15 10 15 8 12 2 12",
                key: "o97t9d"
            }
        ],
        [
            "path",
            {
                d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
                key: "oot6mr"
            }
        ]
    ], Rwe = Cs("inbox", kwe);
    const Owe = [
        [
            "path",
            {
                d: "M3 5h.01",
                key: "18ugdj"
            }
        ],
        [
            "path",
            {
                d: "M3 12h.01",
                key: "nlz23k"
            }
        ],
        [
            "path",
            {
                d: "M3 19h.01",
                key: "noohij"
            }
        ],
        [
            "path",
            {
                d: "M8 5h13",
                key: "1pao27"
            }
        ],
        [
            "path",
            {
                d: "M8 12h13",
                key: "1za7za"
            }
        ],
        [
            "path",
            {
                d: "M8 19h13",
                key: "m83p4d"
            }
        ]
    ], $we = Cs("list", Owe);
    const Mwe = [
        [
            "path",
            {
                d: "m16 17 5-5-5-5",
                key: "1bji2h"
            }
        ],
        [
            "path",
            {
                d: "M21 12H9",
                key: "dn1m92"
            }
        ],
        [
            "path",
            {
                d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",
                key: "1uf3rs"
            }
        ]
    ], Nwe = Cs("log-out", Mwe);
    const Lwe = [
        [
            "path",
            {
                d: "M5 12h14",
                key: "1ays0h"
            }
        ],
        [
            "path",
            {
                d: "M12 5v14",
                key: "s699le"
            }
        ]
    ], Uwe = Cs("plus", Lwe);
    const zwe = [
        [
            "path",
            {
                d: "m21 21-4.34-4.34",
                key: "14j7rj"
            }
        ],
        [
            "circle",
            {
                cx: "11",
                cy: "11",
                r: "8",
                key: "4ej97u"
            }
        ]
    ], Fwe = Cs("search", zwe);
    const Vwe = [
        [
            "path",
            {
                d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
                key: "975kel"
            }
        ],
        [
            "circle",
            {
                cx: "12",
                cy: "7",
                r: "4",
                key: "17ys0d"
            }
        ]
    ], Hwe = Cs("user", Vwe);
    const Qwe = [
        [
            "path",
            {
                d: "M12 20h.01",
                key: "zekei9"
            }
        ],
        [
            "path",
            {
                d: "M8.5 16.429a5 5 0 0 1 7 0",
                key: "1bycff"
            }
        ],
        [
            "path",
            {
                d: "M5 12.859a10 10 0 0 1 5.17-2.69",
                key: "1dl1wf"
            }
        ],
        [
            "path",
            {
                d: "M19 12.859a10 10 0 0 0-2.007-1.523",
                key: "4k23kn"
            }
        ],
        [
            "path",
            {
                d: "M2 8.82a15 15 0 0 1 4.177-2.643",
                key: "1grhjp"
            }
        ],
        [
            "path",
            {
                d: "M22 8.82a15 15 0 0 0-11.288-3.764",
                key: "z3jwby"
            }
        ],
        [
            "path",
            {
                d: "m2 2 20 20",
                key: "1ooewy"
            }
        ]
    ], qwe = Cs("wifi-off", Qwe);
    const Kwe = [
        [
            "path",
            {
                d: "M12 20h.01",
                key: "zekei9"
            }
        ],
        [
            "path",
            {
                d: "M2 8.82a15 15 0 0 1 20 0",
                key: "dnpr2z"
            }
        ],
        [
            "path",
            {
                d: "M5 12.859a10 10 0 0 1 14 0",
                key: "1x1e6c"
            }
        ],
        [
            "path",
            {
                d: "M8.5 16.429a5 5 0 0 1 7 0",
                key: "1bycff"
            }
        ]
    ], Gwe = Cs("wifi", Kwe);
    const Ywe = [
        [
            "path",
            {
                d: "M18 6 6 18",
                key: "1bl5f8"
            }
        ],
        [
            "path",
            {
                d: "m6 6 12 12",
                key: "d8bk6v"
            }
        ]
    ], Wwe = Cs("x", Ywe);
    function jwe({ isOpen: n, onClose: e, onLogin: t, onRegister: r }) {
        const [s, i] = Dt.useState("login"), [l, u] = Dt.useState(""), [h, f] = Dt.useState(""), [p, m] = Dt.useState(null), [w, A] = Dt.useState(!1);
        if (!n) return null;
        const S = async (_)=>{
            _.preventDefault(), m(null), A(!0);
            const I = s === "login" ? await t(l, h) : await r(l, h);
            A(!1), I.ok ? (u(""), f(""), e()) : m(I.error ?? "Unknown error");
        };
        return ye.jsxs("div", {
            className: "fixed inset-0 z-50 flex items-center justify-center",
            children: [
                ye.jsx("div", {
                    className: "absolute inset-0 bg-black/60",
                    onClick: e
                }),
                ye.jsxs("div", {
                    className: "relative bg-bg border border-border rounded-lg w-full max-w-sm mx-4",
                    children: [
                        ye.jsxs("div", {
                            className: "flex items-center justify-between p-4 border-b border-border",
                            children: [
                                ye.jsx("h2", {
                                    className: "text-sm font-medium text-text",
                                    children: s === "login" ? "Login" : "Create Account"
                                }),
                                ye.jsx("button", {
                                    onClick: e,
                                    className: "text-text-muted hover:text-text",
                                    children: ye.jsx(Wwe, {
                                        className: "w-4 h-4"
                                    })
                                })
                            ]
                        }),
                        ye.jsxs("form", {
                            onSubmit: S,
                            className: "p-4 space-y-4",
                            children: [
                                ye.jsxs("div", {
                                    children: [
                                        ye.jsx("label", {
                                            className: "block text-xs text-text-muted mb-1",
                                            children: "Username"
                                        }),
                                        ye.jsx("input", {
                                            type: "text",
                                            value: l,
                                            onChange: (_)=>u(_.target.value),
                                            className: "w-full h-9 bg-bg-subtle border border-border rounded px-3 text-sm text-text focus:outline-none focus:border-accent",
                                            placeholder: "Enter username",
                                            required: !0
                                        })
                                    ]
                                }),
                                ye.jsxs("div", {
                                    children: [
                                        ye.jsx("label", {
                                            className: "block text-xs text-text-muted mb-1",
                                            children: "Password"
                                        }),
                                        ye.jsx("input", {
                                            type: "password",
                                            value: h,
                                            onChange: (_)=>f(_.target.value),
                                            className: "w-full h-9 bg-bg-subtle border border-border rounded px-3 text-sm text-text focus:outline-none focus:border-accent",
                                            placeholder: "Enter password",
                                            required: !0
                                        })
                                    ]
                                }),
                                p && ye.jsx("div", {
                                    className: "text-xs text-red-400 bg-red-400/10 px-3 py-2 rounded",
                                    children: p
                                }),
                                ye.jsx("button", {
                                    type: "submit",
                                    disabled: w,
                                    className: "w-full h-9 bg-accent hover:bg-accent/80 rounded text-sm font-medium text-text disabled:opacity-50",
                                    children: w ? "Processing..." : s === "login" ? "Login" : "Register"
                                }),
                                ye.jsx("div", {
                                    className: "text-center",
                                    children: ye.jsx("button", {
                                        type: "button",
                                        onClick: ()=>{
                                            i(s === "login" ? "register" : "login"), m(null);
                                        },
                                        className: "text-xs text-text-muted hover:text-text",
                                        children: s === "login" ? "Don't have an account? Register" : "Already have an account? Login"
                                    })
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    function Xwe({ peerCount: n, isConnected: e, isAuthenticated: t, username: r, publicKeyShort: s, onConnectClick: i, onLogout: l }) {
        return ye.jsx("nav", {
            className: "sticky top-0 z-50 h-14 bg-bg border-b border-border",
            children: ye.jsxs("div", {
                className: "h-full px-6 flex items-center justify-between",
                children: [
                    ye.jsxs("div", {
                        className: "flex items-center gap-6",
                        children: [
                            ye.jsx("span", {
                                className: "text-xl font-bold text-accent tracking-tight",
                                children: "Beacon"
                            }),
                            ye.jsx("div", {
                                className: "hidden sm:block w-64 lg:w-80",
                                children: ye.jsxs("div", {
                                    className: "relative",
                                    children: [
                                        ye.jsx(Fwe, {
                                            className: "absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-muted"
                                        }),
                                        ye.jsx("input", {
                                            type: "text",
                                            placeholder: "Search series...",
                                            className: "w-full h-9 bg-bg-subtle border border-border rounded px-3 pl-9 text-sm text-text placeholder-text-muted focus:outline-none focus:border-accent"
                                        })
                                    ]
                                })
                            })
                        ]
                    }),
                    ye.jsxs("div", {
                        className: "flex items-center gap-4",
                        children: [
                            ye.jsxs("div", {
                                className: "hidden sm:flex items-center gap-2 text-xs text-text-muted",
                                children: [
                                    e ? ye.jsx(Gwe, {
                                        className: "w-4 h-4 text-accent"
                                    }) : ye.jsx(qwe, {
                                        className: "w-4 h-4"
                                    }),
                                    ye.jsxs("span", {
                                        children: [
                                            n,
                                            " peers"
                                        ]
                                    })
                                ]
                            }),
                            ye.jsx("button", {
                                className: "w-8 h-8 flex items-center justify-center bg-accent rounded",
                                title: "Add Series",
                                children: ye.jsx(Uwe, {
                                    className: "w-4 h-4 text-text"
                                })
                            }),
                            ye.jsx("button", {
                                className: "w-8 h-8 flex items-center justify-center hover:bg-bg-subtle rounded",
                                title: "Notifications",
                                children: ye.jsx(_we, {
                                    className: "w-4 h-4 text-text-muted"
                                })
                            }),
                            t ? ye.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [
                                    ye.jsxs("div", {
                                        className: "hidden sm:flex flex-col items-end",
                                        children: [
                                            ye.jsx("span", {
                                                className: "text-xs text-text",
                                                children: r
                                            }),
                                            ye.jsx("span", {
                                                className: "text-xs text-text-muted font-mono",
                                                children: s
                                            })
                                        ]
                                    }),
                                    ye.jsx("button", {
                                        onClick: l,
                                        className: "w-8 h-8 flex items-center justify-center hover:bg-bg-subtle rounded",
                                        title: "Logout",
                                        children: ye.jsx(Nwe, {
                                            className: "w-4 h-4 text-text-muted"
                                        })
                                    })
                                ]
                            }) : ye.jsxs("button", {
                                onClick: i,
                                className: "h-8 px-3 flex items-center gap-2 border border-border rounded hover:border-text-muted",
                                children: [
                                    ye.jsx(Hwe, {
                                        className: "w-4 h-4 text-text-muted"
                                    }),
                                    ye.jsx("span", {
                                        className: "hidden sm:inline text-sm text-text-muted",
                                        children: "Connect"
                                    })
                                ]
                            })
                        ]
                    })
                ]
            })
        });
    }
    function Jwe({ series: n }) {
        return ye.jsx("div", {
            className: "bg-bg-subtle border border-border rounded overflow-hidden cursor-pointer hover:border-text-muted transition-colors",
            children: ye.jsxs("div", {
                className: "aspect-[2/3] relative",
                children: [
                    ye.jsx("img", {
                        src: n.cover,
                        alt: n.title,
                        className: "w-full h-full object-cover"
                    }),
                    ye.jsxs("div", {
                        className: "absolute inset-x-0 bottom-0 p-3 bg-gradient-to-t from-bg to-transparent",
                        children: [
                            ye.jsx("p", {
                                className: "text-sm font-medium text-text truncate",
                                children: n.title
                            }),
                            ye.jsxs("div", {
                                className: "flex items-center justify-between mt-1 text-xs text-text-muted",
                                children: [
                                    ye.jsxs("span", {
                                        children: [
                                            "Ch. ",
                                            n.latestChapter
                                        ]
                                    }),
                                    ye.jsx("span", {
                                        children: n.updatedAt
                                    })
                                ]
                            })
                        ]
                    })
                ]
            })
        });
    }
    function $k({ message: n }) {
        return ye.jsxs("div", {
            className: "flex flex-col items-center justify-center py-24",
            children: [
                ye.jsx(Rwe, {
                    className: "w-10 h-10 text-text-muted mb-3"
                }),
                ye.jsx("p", {
                    className: "text-sm text-text-muted",
                    children: n
                })
            ]
        });
    }
    function Zwe({ series: n }) {
        return n.length === 0 ? ye.jsx($k, {
            message: "No series yet"
        }) : ye.jsx("div", {
            className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4",
            children: n.map((e)=>ye.jsx(Jwe, {
                    series: e
                }, e.id))
        });
    }
    function ebe({ activity: n }) {
        return n.length === 0 ? ye.jsx($k, {
            message: "No activity yet"
        }) : ye.jsx("div", {
            className: "border border-border rounded overflow-hidden",
            children: ye.jsxs("table", {
                className: "w-full text-sm",
                children: [
                    ye.jsx("thead", {
                        className: "bg-bg-subtle border-b border-border",
                        children: ye.jsxs("tr", {
                            children: [
                                ye.jsx("th", {
                                    className: "px-4 py-3 text-left font-medium text-text-muted",
                                    children: "Time"
                                }),
                                ye.jsx("th", {
                                    className: "px-4 py-3 text-left font-medium text-text-muted",
                                    children: "Series"
                                }),
                                ye.jsx("th", {
                                    className: "px-4 py-3 text-left font-medium text-text-muted",
                                    children: "Event"
                                }),
                                ye.jsx("th", {
                                    className: "px-4 py-3 text-left font-medium text-text-muted",
                                    children: "Source"
                                })
                            ]
                        })
                    }),
                    ye.jsx("tbody", {
                        children: n.map((e, t)=>ye.jsxs("tr", {
                                className: "border-b border-border last:border-0 hover:bg-bg-subtle",
                                children: [
                                    ye.jsx("td", {
                                        className: "px-4 py-3 font-mono text-xs text-text-muted",
                                        children: e.time
                                    }),
                                    ye.jsx("td", {
                                        className: "px-4 py-3 text-text",
                                        children: e.series
                                    }),
                                    ye.jsx("td", {
                                        className: "px-4 py-3 text-accent",
                                        children: e.event
                                    }),
                                    ye.jsx("td", {
                                        className: "px-4 py-3 text-text-muted",
                                        children: e.user
                                    })
                                ]
                            }, t))
                    })
                ]
            })
        });
    }
    function tbe() {
        const { isReady: n, registryReady: e, peerCount: t } = K5e(), { isAuthenticated: r, username: s, publicKeyShort: i, login: l, register: u, logout: h } = vwe(), [f, p] = Dt.useState("grid"), [m, w] = Dt.useState(!1), [A] = Dt.useState([
            {
                id: "1",
                title: "Solo Leveling",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=SL",
                latestChapter: 179,
                updatedAt: "2m ago",
                source: "@reaperscans.com",
                verified: !0
            },
            {
                id: "2",
                title: "One Piece",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=OP",
                latestChapter: 1108,
                updatedAt: "15m ago",
                source: "@tcbscans.com",
                verified: !0
            },
            {
                id: "3",
                title: "Jujutsu Kaisen",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=JJK",
                latestChapter: 256,
                updatedAt: "1h ago",
                source: "@mangaplus.com",
                verified: !0
            },
            {
                id: "4",
                title: "Omniscient Reader",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=ORV",
                latestChapter: 198,
                updatedAt: "3h ago",
                source: "@flamescans.org",
                verified: !1
            },
            {
                id: "5",
                title: "Tower of God",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=ToG",
                latestChapter: 590,
                updatedAt: "5h ago",
                source: "@webtoon.com",
                verified: !0
            },
            {
                id: "6",
                title: "The Beginning After The End",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=TBATE",
                latestChapter: 187,
                updatedAt: "1d ago",
                source: "@tapas.io",
                verified: !0
            },
            {
                id: "7",
                title: "Chainsaw Man",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=CSM",
                latestChapter: 165,
                updatedAt: "2d ago",
                source: "@mangaplus.com",
                verified: !0
            },
            {
                id: "8",
                title: "Spy x Family",
                cover: "https://placehold.co/200x300/141414/3d3b8e?text=SxF",
                latestChapter: 98,
                updatedAt: "3d ago",
                source: "@mangaplus.com",
                verified: !0
            }
        ]), [S] = Dt.useState([
            {
                time: "10:45",
                series: "One Piece",
                event: "New Chapter",
                user: "@tcbscans.com"
            },
            {
                time: "10:32",
                series: "Solo Leveling",
                event: "Metadata Edit",
                user: "User_123"
            },
            {
                time: "10:15",
                series: "Jujutsu Kaisen",
                event: "Status Update",
                user: "@mangaplus.com"
            },
            {
                time: "09:58",
                series: "Omniscient Reader",
                event: "New Chapter",
                user: "@flamescans.org"
            },
            {
                time: "09:30",
                series: "Tower of God",
                event: "Delay Notice",
                user: "@webtoon.com"
            }
        ]), _ = ()=>{
            if (!e) {
                console.log("[App] Registry not ready yet");
                return;
            }
            w(!0);
        };
        return ye.jsxs("div", {
            className: "min-h-screen bg-bg flex flex-col",
            children: [
                ye.jsx(Xwe, {
                    peerCount: t,
                    isConnected: n,
                    isAuthenticated: r,
                    username: s,
                    publicKeyShort: i,
                    onConnectClick: _,
                    onLogout: h
                }),
                ye.jsxs("main", {
                    className: "flex-1 px-6 py-8",
                    children: [
                        ye.jsxs("div", {
                            className: "flex items-center justify-between mb-6",
                            children: [
                                ye.jsx("h2", {
                                    className: "text-sm font-medium text-text",
                                    children: "Latest Updates"
                                }),
                                ye.jsxs("div", {
                                    className: "flex border border-border rounded overflow-hidden",
                                    children: [
                                        ye.jsx("button", {
                                            onClick: ()=>p("grid"),
                                            className: `w-8 h-8 flex items-center justify-center ${f === "grid" ? "bg-accent" : "hover:bg-bg-subtle"}`,
                                            children: ye.jsx(Pwe, {
                                                className: "w-4 h-4 text-text"
                                            })
                                        }),
                                        ye.jsx("button", {
                                            onClick: ()=>p("list"),
                                            className: `w-8 h-8 flex items-center justify-center border-l border-border ${f === "list" ? "bg-accent" : "hover:bg-bg-subtle"}`,
                                            children: ye.jsx($we, {
                                                className: "w-4 h-4 text-text"
                                            })
                                        })
                                    ]
                                })
                            ]
                        }),
                        f === "grid" ? ye.jsx(Zwe, {
                            series: A
                        }) : ye.jsx(ebe, {
                            activity: S
                        })
                    ]
                }),
                ye.jsx("footer", {
                    className: "border-t border-border",
                    children: ye.jsxs("div", {
                        className: "px-6 py-4 flex items-center justify-between text-xs text-text-muted",
                        children: [
                            ye.jsx("span", {
                                children: "Beacon Protocol"
                            }),
                            ye.jsxs("a", {
                                href: "https://github.com",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "flex items-center gap-1 hover:text-text",
                                children: [
                                    ye.jsx(Dwe, {
                                        className: "w-3 h-3"
                                    }),
                                    ye.jsx("span", {
                                        children: "GitHub"
                                    })
                                ]
                            })
                        ]
                    })
                }),
                ye.jsx(jwe, {
                    isOpen: m,
                    onClose: ()=>w(!1),
                    onLogin: l,
                    onRegister: u
                })
            ]
        });
    }
    l$.createRoot(document.getElementById("root")).render(ye.jsx(Dt.StrictMode, {
        children: ye.jsx(tbe, {})
    }));
})();
export { JS as E, qo as a, pC as b, nbe as c, KH as d, E6 as e, re as f, Zc as g, LU as h, Oc as p, L as t, __tla };
