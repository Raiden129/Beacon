import{E as ii,g as si,d as Ye,p as fn,a as oi,c as ci,t as Kt,b as ln,e as ai,f as Ke,h as ui}from"./index-CypZWUUl.js";function hi(n,t){for(let i=0;i<n.byteLength;i++){if(n[i]<t[i])return-1;if(n[i]>t[i])return 1}return n.byteLength>t.byteLength?1:n.byteLength<t.byteLength?-1:0}var Ne={exports:{}},dn;function $t(){if(dn)return Ne.exports;dn=1;var n=typeof Reflect=="object"?Reflect:null,t=n&&typeof n.apply=="function"?n.apply:function(m,p,d){return Function.prototype.apply.call(m,p,d)},i;n&&typeof n.ownKeys=="function"?i=n.ownKeys:Object.getOwnPropertySymbols?i=function(m){return Object.getOwnPropertyNames(m).concat(Object.getOwnPropertySymbols(m))}:i=function(m){return Object.getOwnPropertyNames(m)};function s(h){console&&console.warn&&console.warn(h)}var o=Number.isNaN||function(m){return m!==m};function c(){c.init.call(this)}Ne.exports=c,Ne.exports.once=F,c.EventEmitter=c,c.prototype._events=void 0,c.prototype._eventsCount=0,c.prototype._maxListeners=void 0;var w=10;function f(h){if(typeof h!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof h)}Object.defineProperty(c,"defaultMaxListeners",{enumerable:!0,get:function(){return w},set:function(h){if(typeof h!="number"||h<0||o(h))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+h+".");w=h}}),c.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},c.prototype.setMaxListeners=function(m){if(typeof m!="number"||m<0||o(m))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+m+".");return this._maxListeners=m,this};function B(h){return h._maxListeners===void 0?c.defaultMaxListeners:h._maxListeners}c.prototype.getMaxListeners=function(){return B(this)},c.prototype.emit=function(m){for(var p=[],d=1;d<arguments.length;d++)p.push(arguments[d]);var b=m==="error",N=this._events;if(N!==void 0)b=b&&N.error===void 0;else if(!b)return!1;if(b){var P;if(p.length>0&&(P=p[0]),P instanceof Error)throw P;var q=new Error("Unhandled error."+(P?" ("+P.message+")":""));throw q.context=P,q}var E=N[m];if(E===void 0)return!1;if(typeof E=="function")t(E,this,p);else for(var K=E.length,H=x(E,K),d=0;d<K;++d)t(H[d],this,p);return!0};function R(h,m,p,d){var b,N,P;if(f(p),N=h._events,N===void 0?(N=h._events=Object.create(null),h._eventsCount=0):(N.newListener!==void 0&&(h.emit("newListener",m,p.listener?p.listener:p),N=h._events),P=N[m]),P===void 0)P=N[m]=p,++h._eventsCount;else if(typeof P=="function"?P=N[m]=d?[p,P]:[P,p]:d?P.unshift(p):P.push(p),b=B(h),b>0&&P.length>b&&!P.warned){P.warned=!0;var q=new Error("Possible EventEmitter memory leak detected. "+P.length+" "+String(m)+" listeners added. Use emitter.setMaxListeners() to increase limit");q.name="MaxListenersExceededWarning",q.emitter=h,q.type=m,q.count=P.length,s(q)}return h}c.prototype.addListener=function(m,p){return R(this,m,p,!1)},c.prototype.on=c.prototype.addListener,c.prototype.prependListener=function(m,p){return R(this,m,p,!0)};function A(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function y(h,m,p){var d={fired:!1,wrapFn:void 0,target:h,type:m,listener:p},b=A.bind(d);return b.listener=p,d.wrapFn=b,b}c.prototype.once=function(m,p){return f(p),this.on(m,y(this,m,p)),this},c.prototype.prependOnceListener=function(m,p){return f(p),this.prependListener(m,y(this,m,p)),this},c.prototype.removeListener=function(m,p){var d,b,N,P,q;if(f(p),b=this._events,b===void 0)return this;if(d=b[m],d===void 0)return this;if(d===p||d.listener===p)--this._eventsCount===0?this._events=Object.create(null):(delete b[m],b.removeListener&&this.emit("removeListener",m,d.listener||p));else if(typeof d!="function"){for(N=-1,P=d.length-1;P>=0;P--)if(d[P]===p||d[P].listener===p){q=d[P].listener,N=P;break}if(N<0)return this;N===0?d.shift():v(d,N),d.length===1&&(b[m]=d[0]),b.removeListener!==void 0&&this.emit("removeListener",m,q||p)}return this},c.prototype.off=c.prototype.removeListener,c.prototype.removeAllListeners=function(m){var p,d,b;if(d=this._events,d===void 0)return this;if(d.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):d[m]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete d[m]),this;if(arguments.length===0){var N=Object.keys(d),P;for(b=0;b<N.length;++b)P=N[b],P!=="removeListener"&&this.removeAllListeners(P);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(p=d[m],typeof p=="function")this.removeListener(m,p);else if(p!==void 0)for(b=p.length-1;b>=0;b--)this.removeListener(m,p[b]);return this};function g(h,m,p){var d=h._events;if(d===void 0)return[];var b=d[m];return b===void 0?[]:typeof b=="function"?p?[b.listener||b]:[b]:p?O(b):x(b,b.length)}c.prototype.listeners=function(m){return g(this,m,!0)},c.prototype.rawListeners=function(m){return g(this,m,!1)},c.listenerCount=function(h,m){return typeof h.listenerCount=="function"?h.listenerCount(m):T.call(h,m)},c.prototype.listenerCount=T;function T(h){var m=this._events;if(m!==void 0){var p=m[h];if(typeof p=="function")return 1;if(p!==void 0)return p.length}return 0}c.prototype.eventNames=function(){return this._eventsCount>0?i(this._events):[]};function x(h,m){for(var p=new Array(m),d=0;d<m;++d)p[d]=h[d];return p}function v(h,m){for(;m+1<h.length;m++)h[m]=h[m+1];h.pop()}function O(h){for(var m=new Array(h.length),p=0;p<m.length;++p)m[p]=h[p].listener||h[p];return m}function F(h,m){return new Promise(function(p,d){function b(P){h.removeListener(m,N),d(P)}function N(){typeof h.removeListener=="function"&&h.removeListener("error",b),p([].slice.call(arguments))}C(h,m,N,{once:!0}),m!=="error"&&L(h,b,{once:!0})})}function L(h,m,p){typeof h.on=="function"&&C(h,"error",m,p)}function C(h,m,p,d){if(typeof h.on=="function")d.once?h.once(m,p):h.on(m,p);else if(typeof h.addEventListener=="function")h.addEventListener(m,function b(N){d.once&&h.removeEventListener(m,b),p(N)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof h)}return Ne.exports}var Pe={exports:{}},yn;function fi(){return yn||(yn=1,typeof Object.create=="function"?Pe.exports=function(t,i){i&&(t.super_=i,t.prototype=Object.create(i.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:Pe.exports=function(t,i){if(i){t.super_=i;var s=function(){};s.prototype=i.prototype,t.prototype=new s,t.prototype.constructor=t}}),Pe.exports}var rt={},pn;function jt(){return pn||(pn=1,(function(n){Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});var t={},i={};i.byteLength=A,i.toByteArray=g,i.fromByteArray=v;for(var s=[],o=[],c=typeof Uint8Array<"u"?Uint8Array:Array,w="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",f=0,B=w.length;f<B;++f)s[f]=w[f],o[w.charCodeAt(f)]=f;o[45]=62,o[95]=63;function R(L){var C=L.length;if(C%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var h=L.indexOf("=");h===-1&&(h=C);var m=h===C?0:4-h%4;return[h,m]}function A(L){var C=R(L),h=C[0],m=C[1];return(h+m)*3/4-m}function y(L,C,h){return(C+h)*3/4-h}function g(L){var C,h=R(L),m=h[0],p=h[1],d=new c(y(L,m,p)),b=0,N=p>0?m-4:m,P;for(P=0;P<N;P+=4)C=o[L.charCodeAt(P)]<<18|o[L.charCodeAt(P+1)]<<12|o[L.charCodeAt(P+2)]<<6|o[L.charCodeAt(P+3)],d[b++]=C>>16&255,d[b++]=C>>8&255,d[b++]=C&255;return p===2&&(C=o[L.charCodeAt(P)]<<2|o[L.charCodeAt(P+1)]>>4,d[b++]=C&255),p===1&&(C=o[L.charCodeAt(P)]<<10|o[L.charCodeAt(P+1)]<<4|o[L.charCodeAt(P+2)]>>2,d[b++]=C>>8&255,d[b++]=C&255),d}function T(L){return s[L>>18&63]+s[L>>12&63]+s[L>>6&63]+s[L&63]}function x(L,C,h){for(var m,p=[],d=C;d<h;d+=3)m=(L[d]<<16&16711680)+(L[d+1]<<8&65280)+(L[d+2]&255),p.push(T(m));return p.join("")}function v(L){for(var C,h=L.length,m=h%3,p=[],d=16383,b=0,N=h-m;b<N;b+=d)p.push(x(L,b,b+d>N?N:b+d));return m===1?(C=L[h-1],p.push(s[C>>2]+s[C<<4&63]+"==")):m===2&&(C=(L[h-2]<<8)+L[h-1],p.push(s[C>>10]+s[C>>4&63]+s[C<<2&63]+"=")),p.join("")}var O={};O.read=function(L,C,h,m,p){var d,b,N=p*8-m-1,P=(1<<N)-1,q=P>>1,E=-7,K=h?p-1:0,H=h?-1:1,$=L[C+K];for(K+=H,d=$&(1<<-E)-1,$>>=-E,E+=N;E>0;d=d*256+L[C+K],K+=H,E-=8);for(b=d&(1<<-E)-1,d>>=-E,E+=m;E>0;b=b*256+L[C+K],K+=H,E-=8);if(d===0)d=1-q;else{if(d===P)return b?NaN:($?-1:1)*(1/0);b=b+Math.pow(2,m),d=d-q}return($?-1:1)*b*Math.pow(2,d-m)},O.write=function(L,C,h,m,p,d){var b,N,P,q=d*8-p-1,E=(1<<q)-1,K=E>>1,H=p===23?Math.pow(2,-24)-Math.pow(2,-77):0,$=m?0:d-1,G=m?1:-1,U=C<0||C===0&&1/C<0?1:0;for(C=Math.abs(C),isNaN(C)||C===1/0?(N=isNaN(C)?1:0,b=E):(b=Math.floor(Math.log(C)/Math.LN2),C*(P=Math.pow(2,-b))<1&&(b--,P*=2),b+K>=1?C+=H/P:C+=H*Math.pow(2,1-K),C*P>=2&&(b++,P/=2),b+K>=E?(N=0,b=E):b+K>=1?(N=(C*P-1)*Math.pow(2,p),b=b+K):(N=C*Math.pow(2,K-1)*Math.pow(2,p),b=0));p>=8;L[h+$]=N&255,$+=G,N/=256,p-=8);for(b=b<<p|N,q+=p;q>0;L[h+$]=b&255,$+=G,b/=256,q-=8);L[h+$-G]|=U*128};(function(L){const C=i,h=O,m=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;L.Buffer=E,L.SlowBuffer=j,L.INSPECT_MAX_BYTES=50;const p=2147483647;L.kMaxLength=p;const{Uint8Array:d,ArrayBuffer:b,SharedArrayBuffer:N}=globalThis;E.TYPED_ARRAY_SUPPORT=P(),!E.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function P(){try{const a=new d(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,d.prototype),Object.setPrototypeOf(a,e),a.foo()===42}catch{return!1}}Object.defineProperty(E.prototype,"parent",{enumerable:!0,get:function(){if(E.isBuffer(this))return this.buffer}}),Object.defineProperty(E.prototype,"offset",{enumerable:!0,get:function(){if(E.isBuffer(this))return this.byteOffset}});function q(a){if(a>p)throw new RangeError('The value "'+a+'" is invalid for option "size"');const e=new d(a);return Object.setPrototypeOf(e,E.prototype),e}function E(a,e,r){if(typeof a=="number"){if(typeof e=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return G(a)}return K(a,e,r)}E.poolSize=8192;function K(a,e,r){if(typeof a=="string")return U(a,e);if(b.isView(a))return S(a);if(a==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof a);if(ae(a,b)||a&&ae(a.buffer,b)||typeof N<"u"&&(ae(a,N)||a&&ae(a.buffer,N)))return I(a,e,r);if(typeof a=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const l=a.valueOf&&a.valueOf();if(l!=null&&l!==a)return E.from(l,e,r);const _=M(a);if(_)return _;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof a[Symbol.toPrimitive]=="function")return E.from(a[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof a)}E.from=function(a,e,r){return K(a,e,r)},Object.setPrototypeOf(E.prototype,d.prototype),Object.setPrototypeOf(E,d);function H(a){if(typeof a!="number")throw new TypeError('"size" argument must be of type number');if(a<0)throw new RangeError('The value "'+a+'" is invalid for option "size"')}function $(a,e,r){return H(a),a<=0?q(a):e!==void 0?typeof r=="string"?q(a).fill(e,r):q(a).fill(e):q(a)}E.alloc=function(a,e,r){return $(a,e,r)};function G(a){return H(a),q(a<0?0:z(a)|0)}E.allocUnsafe=function(a){return G(a)},E.allocUnsafeSlow=function(a){return G(a)};function U(a,e){if((typeof e!="string"||e==="")&&(e="utf8"),!E.isEncoding(e))throw new TypeError("Unknown encoding: "+e);const r=W(a,e)|0;let l=q(r);const _=l.write(a,e);return _!==r&&(l=l.slice(0,_)),l}function u(a){const e=a.length<0?0:z(a.length)|0,r=q(e);for(let l=0;l<e;l+=1)r[l]=a[l]&255;return r}function S(a){if(ae(a,d)){const e=new d(a);return I(e.buffer,e.byteOffset,e.byteLength)}return u(a)}function I(a,e,r){if(e<0||a.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(a.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');let l;return e===void 0&&r===void 0?l=new d(a):r===void 0?l=new d(a,e):l=new d(a,e,r),Object.setPrototypeOf(l,E.prototype),l}function M(a){if(E.isBuffer(a)){const e=z(a.length)|0,r=q(e);return r.length===0||a.copy(r,0,0,e),r}if(a.length!==void 0)return typeof a.length!="number"||nt(a.length)?q(0):u(a);if(a.type==="Buffer"&&Array.isArray(a.data))return u(a.data)}function z(a){if(a>=p)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+p.toString(16)+" bytes");return a|0}function j(a){return+a!=a&&(a=0),E.alloc(+a)}E.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==E.prototype},E.compare=function(e,r){if(ae(e,d)&&(e=E.from(e,e.offset,e.byteLength)),ae(r,d)&&(r=E.from(r,r.offset,r.byteLength)),!E.isBuffer(e)||!E.isBuffer(r))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===r)return 0;let l=e.length,_=r.length;for(let k=0,D=Math.min(l,_);k<D;++k)if(e[k]!==r[k]){l=e[k],_=r[k];break}return l<_?-1:_<l?1:0},E.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},E.concat=function(e,r){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(e.length===0)return E.alloc(0);let l;if(r===void 0)for(r=0,l=0;l<e.length;++l)r+=e[l].length;const _=E.allocUnsafe(r);let k=0;for(l=0;l<e.length;++l){let D=e[l];if(ae(D,d))k+D.length>_.length?(E.isBuffer(D)||(D=E.from(D)),D.copy(_,k)):d.prototype.set.call(_,D,k);else if(E.isBuffer(D))D.copy(_,k);else throw new TypeError('"list" argument must be an Array of Buffers');k+=D.length}return _};function W(a,e){if(E.isBuffer(a))return a.length;if(b.isView(a)||ae(a,b))return a.byteLength;if(typeof a!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof a);const r=a.length,l=arguments.length>2&&arguments[2]===!0;if(!l&&r===0)return 0;let _=!1;for(;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return tt(a).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return r*2;case"hex":return r>>>1;case"base64":return hn(a).length;default:if(_)return l?-1:tt(a).length;e=(""+e).toLowerCase(),_=!0}}E.byteLength=W;function Z(a,e,r){let l=!1;if((e===void 0||e<0)&&(e=0),e>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,e>>>=0,r<=e))return"";for(a||(a="utf8");;)switch(a){case"hex":return Yr(this,e,r);case"utf8":case"utf-8":return en(this,e,r);case"ascii":return Gr(this,e,r);case"latin1":case"binary":return Wr(this,e,r);case"base64":return zr(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Jr(this,e,r);default:if(l)throw new TypeError("Unknown encoding: "+a);a=(a+"").toLowerCase(),l=!0}}E.prototype._isBuffer=!0;function V(a,e,r){const l=a[e];a[e]=a[r],a[r]=l}E.prototype.swap16=function(){const e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let r=0;r<e;r+=2)V(this,r,r+1);return this},E.prototype.swap32=function(){const e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let r=0;r<e;r+=4)V(this,r,r+3),V(this,r+1,r+2);return this},E.prototype.swap64=function(){const e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let r=0;r<e;r+=8)V(this,r,r+7),V(this,r+1,r+6),V(this,r+2,r+5),V(this,r+3,r+4);return this},E.prototype.toString=function(){const e=this.length;return e===0?"":arguments.length===0?en(this,0,e):Z.apply(this,arguments)},E.prototype.toLocaleString=E.prototype.toString,E.prototype.equals=function(e){if(!E.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:E.compare(this,e)===0},E.prototype.inspect=function(){let e="";const r=L.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},m&&(E.prototype[m]=E.prototype.inspect),E.prototype.compare=function(e,r,l,_,k){if(ae(e,d)&&(e=E.from(e,e.offset,e.byteLength)),!E.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(r===void 0&&(r=0),l===void 0&&(l=e?e.length:0),_===void 0&&(_=0),k===void 0&&(k=this.length),r<0||l>e.length||_<0||k>this.length)throw new RangeError("out of range index");if(_>=k&&r>=l)return 0;if(_>=k)return-1;if(r>=l)return 1;if(r>>>=0,l>>>=0,_>>>=0,k>>>=0,this===e)return 0;let D=k-_,Y=l-r;const ne=Math.min(D,Y),te=this.slice(_,k),re=e.slice(r,l);for(let ee=0;ee<ne;++ee)if(te[ee]!==re[ee]){D=te[ee],Y=re[ee];break}return D<Y?-1:Y<D?1:0};function J(a,e,r,l,_){if(a.length===0)return-1;if(typeof r=="string"?(l=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,nt(r)&&(r=_?0:a.length-1),r<0&&(r=a.length+r),r>=a.length){if(_)return-1;r=a.length-1}else if(r<0)if(_)r=0;else return-1;if(typeof e=="string"&&(e=E.from(e,l)),E.isBuffer(e))return e.length===0?-1:Q(a,e,r,l,_);if(typeof e=="number")return e=e&255,typeof d.prototype.indexOf=="function"?_?d.prototype.indexOf.call(a,e,r):d.prototype.lastIndexOf.call(a,e,r):Q(a,[e],r,l,_);throw new TypeError("val must be string, number or Buffer")}function Q(a,e,r,l,_){let k=1,D=a.length,Y=e.length;if(l!==void 0&&(l=String(l).toLowerCase(),l==="ucs2"||l==="ucs-2"||l==="utf16le"||l==="utf-16le")){if(a.length<2||e.length<2)return-1;k=2,D/=2,Y/=2,r/=2}function ne(re,ee){return k===1?re[ee]:re.readUInt16BE(ee*k)}let te;if(_){let re=-1;for(te=r;te<D;te++)if(ne(a,te)===ne(e,re===-1?0:te-re)){if(re===-1&&(re=te),te-re+1===Y)return re*k}else re!==-1&&(te-=te-re),re=-1}else for(r+Y>D&&(r=D-Y),te=r;te>=0;te--){let re=!0;for(let ee=0;ee<Y;ee++)if(ne(a,te+ee)!==ne(e,ee)){re=!1;break}if(re)return te}return-1}E.prototype.includes=function(e,r,l){return this.indexOf(e,r,l)!==-1},E.prototype.indexOf=function(e,r,l){return J(this,e,r,l,!0)},E.prototype.lastIndexOf=function(e,r,l){return J(this,e,r,l,!1)};function ce(a,e,r,l){r=Number(r)||0;const _=a.length-r;l?(l=Number(l),l>_&&(l=_)):l=_;const k=e.length;l>k/2&&(l=k/2);let D;for(D=0;D<l;++D){const Y=parseInt(e.substr(D*2,2),16);if(nt(Y))return D;a[r+D]=Y}return D}function xe(a,e,r,l){return Re(tt(e,a.length-r),a,r,l)}function Ae(a,e,r,l){return Re(ei(e),a,r,l)}function Fe(a,e,r,l){return Re(hn(e),a,r,l)}function jr(a,e,r,l){return Re(ti(e,a.length-r),a,r,l)}E.prototype.write=function(e,r,l,_){if(r===void 0)_="utf8",l=this.length,r=0;else if(l===void 0&&typeof r=="string")_=r,l=this.length,r=0;else if(isFinite(r))r=r>>>0,isFinite(l)?(l=l>>>0,_===void 0&&(_="utf8")):(_=l,l=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const k=this.length-r;if((l===void 0||l>k)&&(l=k),e.length>0&&(l<0||r<0)||r>this.length)throw new RangeError("Attempt to write outside buffer bounds");_||(_="utf8");let D=!1;for(;;)switch(_){case"hex":return ce(this,e,r,l);case"utf8":case"utf-8":return xe(this,e,r,l);case"ascii":case"latin1":case"binary":return Ae(this,e,r,l);case"base64":return Fe(this,e,r,l);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return jr(this,e,r,l);default:if(D)throw new TypeError("Unknown encoding: "+_);_=(""+_).toLowerCase(),D=!0}},E.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function zr(a,e,r){return e===0&&r===a.length?C.fromByteArray(a):C.fromByteArray(a.slice(e,r))}function en(a,e,r){r=Math.min(a.length,r);const l=[];let _=e;for(;_<r;){const k=a[_];let D=null,Y=k>239?4:k>223?3:k>191?2:1;if(_+Y<=r){let ne,te,re,ee;switch(Y){case 1:k<128&&(D=k);break;case 2:ne=a[_+1],(ne&192)===128&&(ee=(k&31)<<6|ne&63,ee>127&&(D=ee));break;case 3:ne=a[_+1],te=a[_+2],(ne&192)===128&&(te&192)===128&&(ee=(k&15)<<12|(ne&63)<<6|te&63,ee>2047&&(ee<55296||ee>57343)&&(D=ee));break;case 4:ne=a[_+1],te=a[_+2],re=a[_+3],(ne&192)===128&&(te&192)===128&&(re&192)===128&&(ee=(k&15)<<18|(ne&63)<<12|(te&63)<<6|re&63,ee>65535&&ee<1114112&&(D=ee))}}D===null?(D=65533,Y=1):D>65535&&(D-=65536,l.push(D>>>10&1023|55296),D=56320|D&1023),l.push(D),_+=Y}return Hr(l)}const tn=4096;function Hr(a){const e=a.length;if(e<=tn)return String.fromCharCode.apply(String,a);let r="",l=0;for(;l<e;)r+=String.fromCharCode.apply(String,a.slice(l,l+=tn));return r}function Gr(a,e,r){let l="";r=Math.min(a.length,r);for(let _=e;_<r;++_)l+=String.fromCharCode(a[_]&127);return l}function Wr(a,e,r){let l="";r=Math.min(a.length,r);for(let _=e;_<r;++_)l+=String.fromCharCode(a[_]);return l}function Yr(a,e,r){const l=a.length;(!e||e<0)&&(e=0),(!r||r<0||r>l)&&(r=l);let _="";for(let k=e;k<r;++k)_+=ni[a[k]];return _}function Jr(a,e,r){const l=a.slice(e,r);let _="";for(let k=0;k<l.length-1;k+=2)_+=String.fromCharCode(l[k]+l[k+1]*256);return _}E.prototype.slice=function(e,r){const l=this.length;e=~~e,r=r===void 0?l:~~r,e<0?(e+=l,e<0&&(e=0)):e>l&&(e=l),r<0?(r+=l,r<0&&(r=0)):r>l&&(r=l),r<e&&(r=e);const _=this.subarray(e,r);return Object.setPrototypeOf(_,E.prototype),_};function ie(a,e,r){if(a%1!==0||a<0)throw new RangeError("offset is not uint");if(a+e>r)throw new RangeError("Trying to access beyond buffer length")}E.prototype.readUintLE=E.prototype.readUIntLE=function(e,r,l){e=e>>>0,r=r>>>0,l||ie(e,r,this.length);let _=this[e],k=1,D=0;for(;++D<r&&(k*=256);)_+=this[e+D]*k;return _},E.prototype.readUintBE=E.prototype.readUIntBE=function(e,r,l){e=e>>>0,r=r>>>0,l||ie(e,r,this.length);let _=this[e+--r],k=1;for(;r>0&&(k*=256);)_+=this[e+--r]*k;return _},E.prototype.readUint8=E.prototype.readUInt8=function(e,r){return e=e>>>0,r||ie(e,1,this.length),this[e]},E.prototype.readUint16LE=E.prototype.readUInt16LE=function(e,r){return e=e>>>0,r||ie(e,2,this.length),this[e]|this[e+1]<<8},E.prototype.readUint16BE=E.prototype.readUInt16BE=function(e,r){return e=e>>>0,r||ie(e,2,this.length),this[e]<<8|this[e+1]},E.prototype.readUint32LE=E.prototype.readUInt32LE=function(e,r){return e=e>>>0,r||ie(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216},E.prototype.readUint32BE=E.prototype.readUInt32BE=function(e,r){return e=e>>>0,r||ie(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])},E.prototype.readBigUInt64LE=de(function(e){e=e>>>0,Te(e,"offset");const r=this[e],l=this[e+7];(r===void 0||l===void 0)&&Be(e,this.length-8);const _=r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,k=this[++e]+this[++e]*2**8+this[++e]*2**16+l*2**24;return BigInt(_)+(BigInt(k)<<BigInt(32))}),E.prototype.readBigUInt64BE=de(function(e){e=e>>>0,Te(e,"offset");const r=this[e],l=this[e+7];(r===void 0||l===void 0)&&Be(e,this.length-8);const _=r*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],k=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+l;return(BigInt(_)<<BigInt(32))+BigInt(k)}),E.prototype.readIntLE=function(e,r,l){e=e>>>0,r=r>>>0,l||ie(e,r,this.length);let _=this[e],k=1,D=0;for(;++D<r&&(k*=256);)_+=this[e+D]*k;return k*=128,_>=k&&(_-=Math.pow(2,8*r)),_},E.prototype.readIntBE=function(e,r,l){e=e>>>0,r=r>>>0,l||ie(e,r,this.length);let _=r,k=1,D=this[e+--_];for(;_>0&&(k*=256);)D+=this[e+--_]*k;return k*=128,D>=k&&(D-=Math.pow(2,8*r)),D},E.prototype.readInt8=function(e,r){return e=e>>>0,r||ie(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]},E.prototype.readInt16LE=function(e,r){e=e>>>0,r||ie(e,2,this.length);const l=this[e]|this[e+1]<<8;return l&32768?l|4294901760:l},E.prototype.readInt16BE=function(e,r){e=e>>>0,r||ie(e,2,this.length);const l=this[e+1]|this[e]<<8;return l&32768?l|4294901760:l},E.prototype.readInt32LE=function(e,r){return e=e>>>0,r||ie(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},E.prototype.readInt32BE=function(e,r){return e=e>>>0,r||ie(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},E.prototype.readBigInt64LE=de(function(e){e=e>>>0,Te(e,"offset");const r=this[e],l=this[e+7];(r===void 0||l===void 0)&&Be(e,this.length-8);const _=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(l<<24);return(BigInt(_)<<BigInt(32))+BigInt(r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)}),E.prototype.readBigInt64BE=de(function(e){e=e>>>0,Te(e,"offset");const r=this[e],l=this[e+7];(r===void 0||l===void 0)&&Be(e,this.length-8);const _=(r<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(_)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+l)}),E.prototype.readFloatLE=function(e,r){return e=e>>>0,r||ie(e,4,this.length),h.read(this,e,!0,23,4)},E.prototype.readFloatBE=function(e,r){return e=e>>>0,r||ie(e,4,this.length),h.read(this,e,!1,23,4)},E.prototype.readDoubleLE=function(e,r){return e=e>>>0,r||ie(e,8,this.length),h.read(this,e,!0,52,8)},E.prototype.readDoubleBE=function(e,r){return e=e>>>0,r||ie(e,8,this.length),h.read(this,e,!1,52,8)};function oe(a,e,r,l,_,k){if(!E.isBuffer(a))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>_||e<k)throw new RangeError('"value" argument is out of bounds');if(r+l>a.length)throw new RangeError("Index out of range")}E.prototype.writeUintLE=E.prototype.writeUIntLE=function(e,r,l,_){if(e=+e,r=r>>>0,l=l>>>0,!_){const Y=Math.pow(2,8*l)-1;oe(this,e,r,l,Y,0)}let k=1,D=0;for(this[r]=e&255;++D<l&&(k*=256);)this[r+D]=e/k&255;return r+l},E.prototype.writeUintBE=E.prototype.writeUIntBE=function(e,r,l,_){if(e=+e,r=r>>>0,l=l>>>0,!_){const Y=Math.pow(2,8*l)-1;oe(this,e,r,l,Y,0)}let k=l-1,D=1;for(this[r+k]=e&255;--k>=0&&(D*=256);)this[r+k]=e/D&255;return r+l},E.prototype.writeUint8=E.prototype.writeUInt8=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,1,255,0),this[r]=e&255,r+1},E.prototype.writeUint16LE=E.prototype.writeUInt16LE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,2,65535,0),this[r]=e&255,this[r+1]=e>>>8,r+2},E.prototype.writeUint16BE=E.prototype.writeUInt16BE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,2,65535,0),this[r]=e>>>8,this[r+1]=e&255,r+2},E.prototype.writeUint32LE=E.prototype.writeUInt32LE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,4,4294967295,0),this[r+3]=e>>>24,this[r+2]=e>>>16,this[r+1]=e>>>8,this[r]=e&255,r+4},E.prototype.writeUint32BE=E.prototype.writeUInt32BE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,4,4294967295,0),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4};function nn(a,e,r,l,_){un(e,l,_,a,r,7);let k=Number(e&BigInt(4294967295));a[r++]=k,k=k>>8,a[r++]=k,k=k>>8,a[r++]=k,k=k>>8,a[r++]=k;let D=Number(e>>BigInt(32)&BigInt(4294967295));return a[r++]=D,D=D>>8,a[r++]=D,D=D>>8,a[r++]=D,D=D>>8,a[r++]=D,r}function rn(a,e,r,l,_){un(e,l,_,a,r,7);let k=Number(e&BigInt(4294967295));a[r+7]=k,k=k>>8,a[r+6]=k,k=k>>8,a[r+5]=k,k=k>>8,a[r+4]=k;let D=Number(e>>BigInt(32)&BigInt(4294967295));return a[r+3]=D,D=D>>8,a[r+2]=D,D=D>>8,a[r+1]=D,D=D>>8,a[r]=D,r+8}E.prototype.writeBigUInt64LE=de(function(e,r=0){return nn(this,e,r,BigInt(0),BigInt("0xffffffffffffffff"))}),E.prototype.writeBigUInt64BE=de(function(e,r=0){return rn(this,e,r,BigInt(0),BigInt("0xffffffffffffffff"))}),E.prototype.writeIntLE=function(e,r,l,_){if(e=+e,r=r>>>0,!_){const ne=Math.pow(2,8*l-1);oe(this,e,r,l,ne-1,-ne)}let k=0,D=1,Y=0;for(this[r]=e&255;++k<l&&(D*=256);)e<0&&Y===0&&this[r+k-1]!==0&&(Y=1),this[r+k]=(e/D>>0)-Y&255;return r+l},E.prototype.writeIntBE=function(e,r,l,_){if(e=+e,r=r>>>0,!_){const ne=Math.pow(2,8*l-1);oe(this,e,r,l,ne-1,-ne)}let k=l-1,D=1,Y=0;for(this[r+k]=e&255;--k>=0&&(D*=256);)e<0&&Y===0&&this[r+k+1]!==0&&(Y=1),this[r+k]=(e/D>>0)-Y&255;return r+l},E.prototype.writeInt8=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,1,127,-128),e<0&&(e=255+e+1),this[r]=e&255,r+1},E.prototype.writeInt16LE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,2,32767,-32768),this[r]=e&255,this[r+1]=e>>>8,r+2},E.prototype.writeInt16BE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,2,32767,-32768),this[r]=e>>>8,this[r+1]=e&255,r+2},E.prototype.writeInt32LE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,4,2147483647,-2147483648),this[r]=e&255,this[r+1]=e>>>8,this[r+2]=e>>>16,this[r+3]=e>>>24,r+4},E.prototype.writeInt32BE=function(e,r,l){return e=+e,r=r>>>0,l||oe(this,e,r,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4},E.prototype.writeBigInt64LE=de(function(e,r=0){return nn(this,e,r,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),E.prototype.writeBigInt64BE=de(function(e,r=0){return rn(this,e,r,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function sn(a,e,r,l,_,k){if(r+l>a.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function on(a,e,r,l,_){return e=+e,r=r>>>0,_||sn(a,e,r,4),h.write(a,e,r,l,23,4),r+4}E.prototype.writeFloatLE=function(e,r,l){return on(this,e,r,!0,l)},E.prototype.writeFloatBE=function(e,r,l){return on(this,e,r,!1,l)};function cn(a,e,r,l,_){return e=+e,r=r>>>0,_||sn(a,e,r,8),h.write(a,e,r,l,52,8),r+8}E.prototype.writeDoubleLE=function(e,r,l){return cn(this,e,r,!0,l)},E.prototype.writeDoubleBE=function(e,r,l){return cn(this,e,r,!1,l)},E.prototype.copy=function(e,r,l,_){if(!E.isBuffer(e))throw new TypeError("argument should be a Buffer");if(l||(l=0),!_&&_!==0&&(_=this.length),r>=e.length&&(r=e.length),r||(r=0),_>0&&_<l&&(_=l),_===l||e.length===0||this.length===0)return 0;if(r<0)throw new RangeError("targetStart out of bounds");if(l<0||l>=this.length)throw new RangeError("Index out of range");if(_<0)throw new RangeError("sourceEnd out of bounds");_>this.length&&(_=this.length),e.length-r<_-l&&(_=e.length-r+l);const k=_-l;return this===e&&typeof d.prototype.copyWithin=="function"?this.copyWithin(r,l,_):d.prototype.set.call(e,this.subarray(l,_),r),k},E.prototype.fill=function(e,r,l,_){if(typeof e=="string"){if(typeof r=="string"?(_=r,r=0,l=this.length):typeof l=="string"&&(_=l,l=this.length),_!==void 0&&typeof _!="string")throw new TypeError("encoding must be a string");if(typeof _=="string"&&!E.isEncoding(_))throw new TypeError("Unknown encoding: "+_);if(e.length===1){const D=e.charCodeAt(0);(_==="utf8"&&D<128||_==="latin1")&&(e=D)}}else typeof e=="number"?e=e&255:typeof e=="boolean"&&(e=Number(e));if(r<0||this.length<r||this.length<l)throw new RangeError("Out of range index");if(l<=r)return this;r=r>>>0,l=l===void 0?this.length:l>>>0,e||(e=0);let k;if(typeof e=="number")for(k=r;k<l;++k)this[k]=e;else{const D=E.isBuffer(e)?e:E.from(e,_),Y=D.length;if(Y===0)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(k=0;k<l-r;++k)this[k+r]=D[k%Y]}return this};const Ie={};function et(a,e,r){Ie[a]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${a}]`,this.stack,delete this.name}get code(){return a}set code(_){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:_,writable:!0})}toString(){return`${this.name} [${a}]: ${this.message}`}}}et("ERR_BUFFER_OUT_OF_BOUNDS",function(a){return a?`${a} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),et("ERR_INVALID_ARG_TYPE",function(a,e){return`The "${a}" argument must be of type number. Received type ${typeof e}`},TypeError),et("ERR_OUT_OF_RANGE",function(a,e,r){let l=`The value of "${a}" is out of range.`,_=r;return Number.isInteger(r)&&Math.abs(r)>2**32?_=an(String(r)):typeof r=="bigint"&&(_=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(_=an(_)),_+="n"),l+=` It must be ${e}. Received ${_}`,l},RangeError);function an(a){let e="",r=a.length;const l=a[0]==="-"?1:0;for(;r>=l+4;r-=3)e=`_${a.slice(r-3,r)}${e}`;return`${a.slice(0,r)}${e}`}function Qr(a,e,r){Te(e,"offset"),(a[e]===void 0||a[e+r]===void 0)&&Be(e,a.length-(r+1))}function un(a,e,r,l,_,k){if(a>r||a<e){const D=typeof e=="bigint"?"n":"";let Y;throw e===0||e===BigInt(0)?Y=`>= 0${D} and < 2${D} ** ${(k+1)*8}${D}`:Y=`>= -(2${D} ** ${(k+1)*8-1}${D}) and < 2 ** ${(k+1)*8-1}${D}`,new Ie.ERR_OUT_OF_RANGE("value",Y,a)}Qr(l,_,k)}function Te(a,e){if(typeof a!="number")throw new Ie.ERR_INVALID_ARG_TYPE(e,"number",a)}function Be(a,e,r){throw Math.floor(a)!==a?(Te(a,r),new Ie.ERR_OUT_OF_RANGE("offset","an integer",a)):e<0?new Ie.ERR_BUFFER_OUT_OF_BOUNDS:new Ie.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${e}`,a)}const Xr=/[^+/0-9A-Za-z-_]/g;function Zr(a){if(a=a.split("=")[0],a=a.trim().replace(Xr,""),a.length<2)return"";for(;a.length%4!==0;)a=a+"=";return a}function tt(a,e){e=e||1/0;let r;const l=a.length;let _=null;const k=[];for(let D=0;D<l;++D){if(r=a.charCodeAt(D),r>55295&&r<57344){if(!_){if(r>56319){(e-=3)>-1&&k.push(239,191,189);continue}else if(D+1===l){(e-=3)>-1&&k.push(239,191,189);continue}_=r;continue}if(r<56320){(e-=3)>-1&&k.push(239,191,189),_=r;continue}r=(_-55296<<10|r-56320)+65536}else _&&(e-=3)>-1&&k.push(239,191,189);if(_=null,r<128){if((e-=1)<0)break;k.push(r)}else if(r<2048){if((e-=2)<0)break;k.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;k.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;k.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return k}function ei(a){const e=[];for(let r=0;r<a.length;++r)e.push(a.charCodeAt(r)&255);return e}function ti(a,e){let r,l,_;const k=[];for(let D=0;D<a.length&&!((e-=2)<0);++D)r=a.charCodeAt(D),l=r>>8,_=r%256,k.push(_),k.push(l);return k}function hn(a){return C.toByteArray(Zr(a))}function Re(a,e,r,l){let _;for(_=0;_<l&&!(_+r>=e.length||_>=a.length);++_)e[_+r]=a[_];return _}function ae(a,e){return a instanceof e||a!=null&&a.constructor!=null&&a.constructor.name!=null&&a.constructor.name===e.name}function nt(a){return a!==a}const ni=(function(){const a="0123456789abcdef",e=new Array(256);for(let r=0;r<16;++r){const l=r*16;for(let _=0;_<16;++_)e[l+_]=a[r]+a[_]}return e})();function de(a){return typeof BigInt>"u"?ri:a}function ri(){throw new Error("BigInt not supported")}})(t);const F=t.Buffer;n.Blob=t.Blob,n.BlobOptions=t.BlobOptions,n.Buffer=t.Buffer,n.File=t.File,n.FileOptions=t.FileOptions,n.INSPECT_MAX_BYTES=t.INSPECT_MAX_BYTES,n.SlowBuffer=t.SlowBuffer,n.TranscodeEncoding=t.TranscodeEncoding,n.atob=t.atob,n.btoa=t.btoa,n.constants=t.constants,n.default=F,n.isAscii=t.isAscii,n.isUtf8=t.isUtf8,n.kMaxLength=t.kMaxLength,n.kStringMaxLength=t.kStringMaxLength,n.resolveObjectURL=t.resolveObjectURL,n.transcode=t.transcode})(rt)),rt}var ur=$t();class hr extends Error{constructor(t){super(t),this.name="TimeoutError"}}class li extends Error{constructor(t){super(),this.name="AbortError",this.message=t}}const wn=n=>globalThis.DOMException===void 0?new li(n):new DOMException(n),gn=n=>{const t=n.reason===void 0?wn("This operation was aborted."):n.reason;return t instanceof Error?t:wn(t)};function di(n,t){const{milliseconds:i,fallback:s,message:o,customTimers:c={setTimeout,clearTimeout}}=t;let w,f;const R=new Promise((A,y)=>{if(typeof i!="number"||Math.sign(i)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${i}\``);if(t.signal){const{signal:T}=t;T.aborted&&y(gn(T)),f=()=>{y(gn(T))},T.addEventListener("abort",f,{once:!0})}if(i===Number.POSITIVE_INFINITY){n.then(A,y);return}const g=new hr;w=c.setTimeout.call(void 0,()=>{if(s){try{A(s())}catch(T){y(T)}return}typeof n.cancel=="function"&&n.cancel(),o===!1?A():o instanceof Error?y(o):(g.message=o??`Promise timed out after ${i} milliseconds`,y(g))},i),(async()=>{try{A(await n)}catch(T){y(T)}})()}).finally(()=>{R.clear(),f&&t.signal&&t.signal.removeEventListener("abort",f)});return R.clear=()=>{c.clearTimeout.call(void 0,w),w=void 0},R}function yi(n,t,i){let s=0,o=n.length;for(;o>0;){const c=Math.trunc(o/2);let w=s+c;i(n[w],t)<=0?(s=++w,o-=c+1):o=c}return s}class pi{#e=[];enqueue(t,i){i={priority:0,...i};const s={priority:i.priority,id:i.id,run:t};if(this.size===0||this.#e[this.size-1].priority>=i.priority){this.#e.push(s);return}const o=yi(this.#e,s,(c,w)=>w.priority-c.priority);this.#e.splice(o,0,s)}setPriority(t,i){const s=this.#e.findIndex(c=>c.id===t);if(s===-1)throw new ReferenceError(`No promise function with the id "${t}" exists in the queue.`);const[o]=this.#e.splice(s,1);this.enqueue(o.run,{priority:i,id:t})}dequeue(){return this.#e.shift()?.run}filter(t){return this.#e.filter(i=>i.priority===t.priority).map(i=>i.run)}get size(){return this.#e.length}}class ze extends ii{#e;#o;#s=0;#d;#c;#y=0;#n;#a;#t;#p;#r=0;#u;#i;#w;#E=1n;timeout;constructor(t){if(super(),t={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:pi,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${t.intervalCap?.toString()??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${t.interval?.toString()??""}\` (${typeof t.interval})`);this.#e=t.carryoverConcurrencyCount,this.#o=t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0,this.#d=t.intervalCap,this.#c=t.interval,this.#t=new t.queueClass,this.#p=t.queueClass,this.concurrency=t.concurrency,this.timeout=t.timeout,this.#w=t.throwOnTimeout===!0,this.#i=t.autoStart===!1}get#v(){return this.#o||this.#s<this.#d}get#b(){return this.#r<this.#u}#x(){this.#r--,this.#h(),this.emit("next")}#I(){this.#m(),this.#g(),this.#a=void 0}get#T(){const t=Date.now();if(this.#n===void 0){const i=this.#y-t;if(i<0)this.#s=this.#e?this.#r:0;else return this.#a===void 0&&(this.#a=setTimeout(()=>{this.#I()},i)),!0}return!1}#h(){if(this.#t.size===0)return this.#n&&clearInterval(this.#n),this.#n=void 0,this.emit("empty"),this.#r===0&&this.emit("idle"),!1;if(!this.#i){const t=!this.#T;if(this.#v&&this.#b){const i=this.#t.dequeue();return i?(this.emit("active"),i(),t&&this.#g(),!0):!1}}return!1}#g(){this.#o||this.#n!==void 0||(this.#n=setInterval(()=>{this.#m()},this.#c),this.#y=Date.now()+this.#c)}#m(){this.#s===0&&this.#r===0&&this.#n&&(clearInterval(this.#n),this.#n=void 0),this.#s=this.#e?this.#r:0,this.#f()}#f(){for(;this.#h(););}get concurrency(){return this.#u}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);this.#u=t,this.#f()}async#_(t){return new Promise((i,s)=>{t.addEventListener("abort",()=>{s(t.reason)},{once:!0})})}setPriority(t,i){this.#t.setPriority(t,i)}async add(t,i={}){return i.id??=(this.#E++).toString(),i={timeout:this.timeout,throwOnTimeout:this.#w,...i},new Promise((s,o)=>{this.#t.enqueue(async()=>{this.#r++;try{i.signal?.throwIfAborted(),this.#s++;let c=t({signal:i.signal});i.timeout&&(c=di(Promise.resolve(c),{milliseconds:i.timeout})),i.signal&&(c=Promise.race([c,this.#_(i.signal)]));const w=await c;s(w),this.emit("completed",w)}catch(c){if(c instanceof hr&&!i.throwOnTimeout){s();return}o(c),this.emit("error",c)}finally{this.#x()}},i),this.emit("add"),this.#h()})}async addAll(t,i){return Promise.all(t.map(async s=>this.add(s,i)))}start(){return this.#i?(this.#i=!1,this.#f(),this):this}pause(){this.#i=!0}clear(){this.#t=new this.#p}async onEmpty(){this.#t.size!==0&&await this.#l("empty")}async onSizeLessThan(t){this.#t.size<t||await this.#l("next",()=>this.#t.size<t)}async onIdle(){this.#r===0&&this.#t.size===0||await this.#l("idle")}async#l(t,i){return new Promise(s=>{const o=()=>{i&&!i()||(this.off(t,o),s())};this.on(t,o)})}get size(){return this.#t.size}sizeBy(t){return this.#t.filter(t).length}get pending(){return this.#r}get isPaused(){return this.#i}}var it,mn;function wi(){return mn||(mn=1,it=function(){return Date.now()}),it}var st,En;function gi(){if(En)return st;En=1;const n=wi();class t{constructor(o,c,w){const f=this;this._started=n(),this._rescheduled=0,this._scheduled=c,this._args=w,this._triggered=!1,this._timerWrapper=()=>{f._rescheduled>0?(f._scheduled=f._rescheduled-(n()-f._started),f._schedule(f._scheduled)):(f._triggered=!0,o.apply(null,f._args))},this._timer=setTimeout(this._timerWrapper,c)}reschedule(o){o||(o=this._scheduled);const c=n();c+o-(this._started+this._scheduled)<0?(clearTimeout(this._timer),this._schedule(o)):this._triggered?this._schedule(o):(this._started=c,this._rescheduled=o)}_schedule(o){this._triggered=!1,this._started=n(),this._rescheduled=0,this._scheduled=o,this._timer=setTimeout(this._timerWrapper,o)}clear(){clearTimeout(this._timer)}}function i(){if(typeof arguments[0]!="function")throw new Error("callback needed");if(typeof arguments[1]!="number")throw new Error("timeout needed");let s;if(arguments.length>0){s=new Array(arguments.length-2);for(var o=0;o<s.length;o++)s[o]=arguments[o+2]}return new t(arguments[0],arguments[1],s)}return st=i,st}var ot,vn;function mi(){if(vn)return ot;vn=1;const{AbortController:n}=globalThis,t=gi();class i extends n{constructor(o){super(),this._ms=o,this._timer=t(()=>this.abort(),o),Object.setPrototypeOf(this,i.prototype)}abort(){return this._timer.clear(),super.abort()}clear(){this._timer.clear()}reset(){this._timer.clear(),this._timer=t(()=>this.abort(),this._ms)}}return ot={TimeoutController:i},ot}var Ot=mi();const we=(...n)=>n.join("/").replace(/((?<=\/)\/+)|(^\.\/)|((?<=\/)\.\/)/g,"")||".";var ct,bn;function Ei(){if(bn)return ct;bn=1;var n=$t(),t=fi();ct=i;function i(s){if(!(this instanceof i))return new i(s);typeof s=="number"&&(s={max:s}),s||(s={}),n.EventEmitter.call(this),this.cache={},this.head=this.tail=null,this.length=0,this.max=s.max||1e3,this.maxAge=s.maxAge||0}return t(i,n.EventEmitter),Object.defineProperty(i.prototype,"keys",{get:function(){return Object.keys(this.cache)}}),i.prototype.clear=function(){this.cache={},this.head=this.tail=null,this.length=0},i.prototype.remove=function(s){if(typeof s!="string"&&(s=""+s),!!this.cache.hasOwnProperty(s)){var o=this.cache[s];return delete this.cache[s],this._unlink(s,o.prev,o.next),o.value}},i.prototype._unlink=function(s,o,c){this.length--,this.length===0?this.head=this.tail=null:this.head===s?(this.head=o,this.cache[this.head].next=null):this.tail===s?(this.tail=c,this.cache[this.tail].prev=null):(this.cache[o].next=c,this.cache[c].prev=o)},i.prototype.peek=function(s){if(this.cache.hasOwnProperty(s)){var o=this.cache[s];if(this._checkAge(s,o))return o.value}},i.prototype.set=function(s,o){typeof s!="string"&&(s=""+s);var c;if(this.cache.hasOwnProperty(s)){if(c=this.cache[s],c.value=o,this.maxAge&&(c.modified=Date.now()),s===this.head)return o;this._unlink(s,c.prev,c.next)}else c={value:o,modified:0,next:null,prev:null},this.maxAge&&(c.modified=Date.now()),this.cache[s]=c,this.length===this.max&&this.evict();return this.length++,c.next=null,c.prev=this.head,this.head&&(this.cache[this.head].next=s),this.head=s,this.tail||(this.tail=s),o},i.prototype._checkAge=function(s,o){return this.maxAge&&Date.now()-o.modified>this.maxAge?(this.remove(s),this.emit("evict",{key:s,value:o.value}),!1):!0},i.prototype.get=function(s){if(typeof s!="string"&&(s=""+s),!!this.cache.hasOwnProperty(s)){var o=this.cache[s];if(this._checkAge(s,o))return this.head!==s&&(s===this.tail?(this.tail=o.next,this.cache[this.tail].prev=null):this.cache[o.prev].next=o.next,this.cache[o.next].prev=o.prev,this.cache[this.head].next=s,o.prev=this.head,o.next=null,this.head=s),o.value}},i.prototype.evict=function(){if(this.tail){var s=this.tail,o=this.remove(this.tail);this.emit("evict",{key:s,value:o})}},ct}var vi=Ei();const Ct=si(vi),bi=(n,t)=>{const i=n.time-t.time;return i===0&&n.id!==t.id?n.id<t.id?-1:1:i},xi=n=>zt(n.id,++n.time),zt=(n,t)=>(t=t||0,{id:n,time:t}),Ii=(n,t)=>{if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let i=0;i<n.byteLength;i++)if(n[i]!==t[i])return!1;return!0},Ht=n=>{if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")};function Ti(n,t){if(n.length>=255)throw new TypeError("Alphabet too long");for(var i=new Uint8Array(256),s=0;s<i.length;s++)i[s]=255;for(var o=0;o<n.length;o++){var c=n.charAt(o),w=c.charCodeAt(0);if(i[w]!==255)throw new TypeError(c+" is ambiguous");i[w]=o}var f=n.length,B=n.charAt(0),R=Math.log(f)/Math.log(256),A=Math.log(256)/Math.log(f);function y(x){if(x instanceof Uint8Array||(ArrayBuffer.isView(x)?x=new Uint8Array(x.buffer,x.byteOffset,x.byteLength):Array.isArray(x)&&(x=Uint8Array.from(x))),!(x instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(x.length===0)return"";for(var v=0,O=0,F=0,L=x.length;F!==L&&x[F]===0;)F++,v++;for(var C=(L-F)*A+1>>>0,h=new Uint8Array(C);F!==L;){for(var m=x[F],p=0,d=C-1;(m!==0||p<O)&&d!==-1;d--,p++)m+=256*h[d]>>>0,h[d]=m%f>>>0,m=m/f>>>0;if(m!==0)throw new Error("Non-zero carry");O=p,F++}for(var b=C-O;b!==C&&h[b]===0;)b++;for(var N=B.repeat(v);b<C;++b)N+=n.charAt(h[b]);return N}function g(x){if(typeof x!="string")throw new TypeError("Expected String");if(x.length===0)return new Uint8Array;var v=0;if(x[v]!==" "){for(var O=0,F=0;x[v]===B;)O++,v++;for(var L=(x.length-v)*R+1>>>0,C=new Uint8Array(L);x[v];){var h=i[x.charCodeAt(v)];if(h===255)return;for(var m=0,p=L-1;(h!==0||m<F)&&p!==-1;p--,m++)h+=f*C[p]>>>0,C[p]=h%256>>>0,h=h/256>>>0;if(h!==0)throw new Error("Non-zero carry");F=m,v++}if(x[v]!==" "){for(var d=L-F;d!==L&&C[d]===0;)d++;for(var b=new Uint8Array(O+(L-d)),N=O;d!==L;)b[N++]=C[d++];return b}}}function T(x){var v=g(x);if(v)return v;throw new Error(`Non-${t} character`)}return{encode:y,decodeUnsafe:g,decode:T}}var _i=Ti,Ai=_i;class Bi{constructor(t,i,s){this.name=t,this.prefix=i,this.baseEncode=s}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class Si{constructor(t,i,s){if(this.name=t,this.prefix=i,i.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i.codePointAt(0),this.baseDecode=s}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return fr(this,t)}}class Li{constructor(t){this.decoders=t}or(t){return fr(this,t)}decode(t){const i=t[0],s=this.decoders[i];if(s)return s.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const fr=(n,t)=>new Li({...n.decoders||{[n.prefix]:n},...t.decoders||{[t.prefix]:t}});class Oi{constructor(t,i,s,o){this.name=t,this.prefix=i,this.baseEncode=s,this.baseDecode=o,this.encoder=new Bi(t,i,s),this.decoder=new Si(t,i,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}const lr=({name:n,prefix:t,encode:i,decode:s})=>new Oi(n,t,i,s),dr=({prefix:n,name:t,alphabet:i})=>{const{encode:s,decode:o}=Ai(i,t);return lr({prefix:n,name:t,encode:s,decode:c=>Ht(o(c))})},Ci=(n,t,i,s)=>{const o={};for(let A=0;A<t.length;++A)o[t[A]]=A;let c=n.length;for(;n[c-1]==="=";)--c;const w=new Uint8Array(c*i/8|0);let f=0,B=0,R=0;for(let A=0;A<c;++A){const y=o[n[A]];if(y===void 0)throw new SyntaxError(`Non-${s} character`);B=B<<i|y,f+=i,f>=8&&(f-=8,w[R++]=255&B>>f)}if(f>=i||255&B<<8-f)throw new SyntaxError("Unexpected end of data");return w},ki=(n,t,i)=>{const s=t[t.length-1]==="=",o=(1<<i)-1;let c="",w=0,f=0;for(let B=0;B<n.length;++B)for(f=f<<8|n[B],w+=8;w>i;)w-=i,c+=t[o&f>>w];if(w&&(c+=t[o&f<<i-w]),s)for(;c.length*i&7;)c+="=";return c},le=({name:n,prefix:t,bitsPerChar:i,alphabet:s})=>lr({prefix:t,name:n,encode(o){return ki(o,s,i)},decode(o){return Ci(o,s,i,n)}}),$e=le({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});le({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});le({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});le({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});le({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});le({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});le({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});le({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});le({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const se=dr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});dr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Fi=yr,xn=128,Ri=-128,Ni=Math.pow(2,31);function yr(n,t,i){t=t||[],i=i||0;for(var s=i;n>=Ni;)t[i++]=n&255|xn,n/=128;for(;n&Ri;)t[i++]=n&255|xn,n>>>=7;return t[i]=n|0,yr.bytes=i-s+1,t}var Pi=kt,Di=128,In=127;function kt(n,s){var i=0,s=s||0,o=0,c=s,w,f=n.length;do{if(c>=f)throw kt.bytes=0,new RangeError("Could not decode varint");w=n[c++],i+=o<28?(w&In)<<o:(w&In)*Math.pow(2,o),o+=7}while(w>=Di);return kt.bytes=c-s,i}var Ui=Math.pow(2,7),Mi=Math.pow(2,14),qi=Math.pow(2,21),Vi=Math.pow(2,28),Ki=Math.pow(2,35),$i=Math.pow(2,42),ji=Math.pow(2,49),zi=Math.pow(2,56),Hi=Math.pow(2,63),Gi=function(n){return n<Ui?1:n<Mi?2:n<qi?3:n<Vi?4:n<Ki?5:n<$i?6:n<ji?7:n<zi?8:n<Hi?9:10},Wi={encode:Fi,decode:Pi,encodingLength:Gi},He=Wi;const Ft=(n,t=0)=>[He.decode(n,t),He.decode.bytes],Ge=(n,t,i=0)=>(He.encode(n,t,i),t),We=n=>He.encodingLength(n),Rt=(n,t)=>{const i=t.byteLength,s=We(n),o=s+We(i),c=new Uint8Array(o+i);return Ge(n,c,0),Ge(i,c,s),c.set(t,o),new Gt(n,i,t,c)},Yi=n=>{const t=Ht(n),[i,s]=Ft(t),[o,c]=Ft(t.subarray(s)),w=t.subarray(s+c);if(w.byteLength!==o)throw new Error("Incorrect length");return new Gt(i,o,w,t)},Ji=(n,t)=>{if(n===t)return!0;{const i=t;return n.code===i.code&&n.size===i.size&&i.bytes instanceof Uint8Array&&Ii(n.bytes,i.bytes)}};class Gt{constructor(t,i,s,o){this.code=t,this.size=i,this.digest=s,this.bytes=o}}const Tn=(n,t)=>{const{bytes:i,version:s}=n;return s===0?Xi(i,Nt(n),t||se.encoder):Zi(i,Nt(n),t||$e.encoder)},_n=new WeakMap,Nt=n=>{const t=_n.get(n);if(t==null){const i=new Map;return _n.set(n,i),i}return t};class X{constructor(t,i,s,o){this.code=i,this.version=t,this.multihash=s,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:i}=this;if(t!==Se)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(i.code!==es)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return X.createV0(i)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:i}=this.multihash,s=Rt(t,i);return X.createV1(this.code,s)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return X.equals(this,t)}static equals(t,i){const s=i;return s&&t.code===s.code&&t.version===s.version&&Ji(t.multihash,s.multihash)}toString(t){return Tn(this,t)}toJSON(){return{"/":Tn(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const i=t;if(i instanceof X)return i;if(i["/"]!=null&&i["/"]===i.bytes||i.asCID===i){const{version:s,code:o,multihash:c,bytes:w}=i;return new X(s,o,c,w||An(s,o,c.bytes))}else if(i[ts]===!0){const{version:s,multihash:o,code:c}=i,w=Yi(o);return X.create(s,c,w)}else return null}static create(t,i,s){if(typeof i!="number")throw new Error("String codecs are no longer supported");if(!(s.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(i!==Se)throw new Error(`Version 0 CID must use dag-pb (code: ${Se}) block encoding`);return new X(t,i,s,s.bytes)}case 1:{const o=An(t,i,s.bytes);return new X(t,i,s,o)}default:throw new Error("Invalid version")}}static createV0(t){return X.create(0,Se,t)}static createV1(t,i){return X.create(1,t,i)}static decode(t){const[i,s]=X.decodeFirst(t);if(s.length)throw new Error("Incorrect length");return i}static decodeFirst(t){const i=X.inspectBytes(t),s=i.size-i.multihashSize,o=Ht(t.subarray(s,s+i.multihashSize));if(o.byteLength!==i.multihashSize)throw new Error("Incorrect length");const c=o.subarray(i.multihashSize-i.digestSize),w=new Gt(i.multihashCode,i.digestSize,c,o);return[i.version===0?X.createV0(w):X.createV1(i.codec,w),t.subarray(i.size)]}static inspectBytes(t){let i=0;const s=()=>{const[y,g]=Ft(t.subarray(i));return i+=g,y};let o=s(),c=Se;if(o===18?(o=0,i=0):c=s(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const w=i,f=s(),B=s(),R=i+B,A=R-w;return{version:o,codec:c,multihashCode:f,digestSize:B,multihashSize:A,size:R}}static parse(t,i){const[s,o]=Qi(t,i),c=X.decode(o);if(c.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Nt(c).set(s,t),c}}const Qi=(n,t)=>{switch(n[0]){case"Q":{const i=t||se;return[se.prefix,i.decode(`${se.prefix}${n}`)]}case se.prefix:{const i=t||se;return[se.prefix,i.decode(n)]}case $e.prefix:{const i=t||$e;return[$e.prefix,i.decode(n)]}default:{if(t==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[n[0],t.decode(n)]}}},Xi=(n,t,i)=>{const{prefix:s}=i;if(s!==se.prefix)throw Error(`Cannot string encode V0 in ${i.name} encoding`);const o=t.get(s);if(o==null){const c=i.encode(n).slice(1);return t.set(s,c),c}else return o},Zi=(n,t,i)=>{const{prefix:s}=i,o=t.get(s);if(o==null){const c=i.encode(n);return t.set(s,c),c}else return o},Se=112,es=18,An=(n,t,i)=>{const s=We(n),o=s+We(t),c=new Uint8Array(o+i.byteLength);return Ge(n,c,0),Ge(t,c,s),c.set(i,o),c},ts=Symbol.for("@ipld/js-cid/CID"),ns=({name:n,code:t,encode:i})=>new rs(n,t,i);class rs{constructor(t,i,s){this.name=t,this.code=i,this.encode=s}digest(t){if(t instanceof Uint8Array){const i=this.encode(t);return i instanceof Uint8Array?Rt(this.code,i):i.then(s=>Rt(this.code,s))}else throw Error("Unknown type, must be binary type")}}function De({enumerable:n=!0,configurable:t=!1}={}){return{enumerable:n,configurable:t,writable:!1}}function*is(n,t){if(t!=null&&typeof t=="object")if(Array.isArray(t))for(const[i,s]of t.entries()){const o=[...n,i],c=X.asCID(s);c?yield[o.join("/"),c]:typeof s=="object"&&(yield*Pt(s,o))}else{const i=X.asCID(t);i?yield[n.join("/"),i]:yield*Pt(t,n)}}function*Pt(n,t){if(n==null||n instanceof Uint8Array)return;const i=X.asCID(n);i&&(yield[t.join("/"),i]);for(const[s,o]of Object.entries(n)){const c=[...t,s];yield*is(c,o)}}function*ss(n,t){if(Array.isArray(t))for(const[i,s]of t.entries()){const o=[...n,i];yield o.join("/"),typeof s=="object"&&!X.asCID(s)&&(yield*Dt(s,o))}else yield*Dt(t,n)}function*Dt(n,t){if(!(n==null||typeof n!="object"))for(const[i,s]of Object.entries(n)){const o=[...t,i];yield o.join("/"),s!=null&&!(s instanceof Uint8Array)&&typeof s=="object"&&!X.asCID(s)&&(yield*ss(o,s))}}function os(n,t){let i=n;for(const[s,o]of t.entries()){if(i=i[o],i==null)throw new Error(`Object has no property at ${t.slice(0,s+1).map(w=>`[${JSON.stringify(w)}]`).join("")}`);const c=X.asCID(i);if(c)return{value:c,remaining:t.slice(s+1).join("/")}}return{value:i}}class pr{constructor({cid:t,bytes:i,value:s}){if(!t||!i||typeof s>"u")throw new Error("Missing required argument");this.cid=t,this.bytes=i,this.value=s,this.asBlock=this,Object.defineProperties(this,{cid:De(),bytes:De(),value:De(),asBlock:De()})}links(){return Pt(this.value,[])}tree(){return Dt(this.value,[])}get(t="/"){return os(this.value,t.split("/").filter(Boolean))}}async function Ee({value:n,codec:t,hasher:i}){if(typeof n>"u")throw new Error('Missing required argument "value"');if(!t||!i)throw new Error("Missing required argument: codec or hasher");const s=t.encode(n),o=await i.digest(s),c=X.create(1,t.code,o);return new pr({value:n,bytes:s,cid:c})}async function _e({bytes:n,codec:t,hasher:i}){if(!n)throw new Error('Missing required argument "bytes"');if(!t||!i)throw new Error("Missing required argument: codec or hasher");const s=t.decode(n),o=await i.digest(n),c=X.create(1,t.code,o);return new pr({value:s,bytes:n,cid:c})}const cs=n=>async t=>new Uint8Array(await crypto.subtle.digest(n,t)),Je=ns({name:"sha2-256",code:18,encode:cs("SHA-256")}),ge=Ye,me=Je,wr=se,as=async(n,t,i,s,o=null,c=[],w=[])=>{if(n==null)throw new Error("Identity is required, cannot create entry");if(t==null)throw new Error("Entry requires an id");if(i==null)throw new Error("Entry requires a payload");if(c==null||!Array.isArray(c))throw new Error("'next' argument is not an array");o=o||zt(n.publicKey);let f;if(s){const{bytes:y}=await Ee({value:i,codec:ge,hasher:me});f=await s(y)}const B={id:t,payload:f||i,next:c,refs:w,clock:o,v:2},{bytes:R}=await Ee({value:B,codec:ge,hasher:me}),A=await n.sign(n,R);return B.key=n.publicKey,B.identity=n.hash,B.sig=A,B.payload=i,s&&(B._payload=f),B},us=async(n,t)=>{if(!n)throw new Error("Identities is required, cannot verify entry");if(!gr(t))throw new Error("Invalid Log entry");if(!t.key)throw new Error("Entry doesn't have a key");if(!t.sig)throw new Error("Entry doesn't have a signature");const i=Object.assign({},t),s={id:i.id,payload:i._payload||i.payload,next:i.next,refs:i.refs,clock:i.clock,v:i.v},{bytes:o}=await Ee({value:s,codec:ge,hasher:me});return n.verify(t.sig,t.key,o)},gr=n=>n&&n.id!==void 0&&n.next!==void 0&&n.payload!==void 0&&n.v!==void 0&&n.clock!==void 0&&n.refs!==void 0,hs=(n,t)=>n&&t&&n.hash&&n.hash===t.hash,fs=async(n,t,i)=>{let s;if(t)try{const f=await _e({bytes:n,codec:ge,hasher:me});n=await t(f.value),s=f.cid}catch{throw new Error("Could not decrypt entry")}const o=await _e({bytes:n,codec:ge,hasher:me}),c=o.value;if(i)try{const f=await i(c.payload),{value:B}=await _e({bytes:f,codec:ge,hasher:me});c._payload=c.payload,c.payload=B}catch{throw new Error("Could not decrypt payload")}s=s||o.cid;const w=s.toString(wr);return{...c,hash:w}},ls=async(n,t,i)=>{const s=Object.assign({},n);i&&(s.payload=s._payload),delete s._payload,delete s.hash;let{cid:o,bytes:c}=await Ee({value:s,codec:ge,hasher:me});if(t){c=await t(c);const f=await Ee({value:c,codec:ge,hasher:me});o=f.cid,c=f.bytes}return{hash:o.toString(wr),bytes:c}},ue={create:as,verify:us,decode:fs,encode:ls,isEntry:gr,isEqual:hs};function ds(n,t){const i=(c,w)=>c,s=(c,w)=>ps(c,w,i);return((c,w)=>ys(c,w,s))(n,t)}function ys(n,t,i){const s=bi(n.clock,t.clock);return s===0?i(n,t):s}function ps(n,t,i){return n.clock.id===t.clock.id?i(n,t):n.clock.id<t.clock.id?-1:1}function ws(n){const t=`Your log's tiebreaker function, ${n.name}, has returned zero and therefore cannot be`;return(s,o)=>{const c=n(s,o);if(c===0)throw Error(t);return c}}const gs={LastWriteWins:ds,NoZeroes:ws},Wt=async()=>{let n={};const t=async(B,R)=>{n[B]=R};return{put:t,del:async B=>{delete n[B]},get:async B=>n[B],iterator:async function*(){for await(const[B,R]of Object.entries(n))yield[B,R]},merge:async B=>{if(B)for await(const[R,A]of B.iterator())t(R,A)},clear:async()=>{n={}},close:async()=>{}}},ms=Wt,Es=async({storage:n,heads:t,decryptPayloadFn:i,decryptEntryFn:s})=>{n=n||await ms();const o=new TextEncoder,c=new TextDecoder,w=async T=>{T=Bn(T);const x=T.map(O=>({hash:O.hash,next:O.next})),v=o.encode(JSON.stringify(x));await n.put("heads",v)},f=async T=>{const x=await A();if(x.find(O=>ue.isEqual(O,T)))return;const v=Bn([...x,T]);return await w(v),v},B=async T=>{const v=(await A()).filter(O=>O.hash!==T);await w(v)},R=async function*(){const T=await n.get("heads"),x=T?JSON.parse(c.decode(T)):[];for(const v of x)yield v},A=async()=>{const T=[];for await(const x of R())T.push(x);return T},y=async()=>{await n.clear()},g=async()=>{await n.close()};return t&&await w(t),{put:w,set:w,add:f,remove:B,iterator:R,all:A,clear:y,close:g}},Bn=n=>{n=new Set(n);const t={};for(const s of n)for(const o of s.next)t[o]=s.hash;const i=[];for(const s of n)t[s.hash]||i.push(s);return i},at=Wt,vs=async({logHeads:n,entryStorage:t,headsStorage:i,indexStorage:s,encryption:o})=>{const c=o?.replication?.encrypt,w=o?.replication?.decrypt,f=o?.data?.encrypt,B=o?.data?.decrypt,R=t||await at(),A=s||await at();i=i||await at();const y=await Es({storage:i,heads:n,decryptPayloadFn:B,decryptEntryFn:w}),g=async p=>{const d=await R.get(p);if(d)return await ue.decode(d,w,B)};return{get:g,getBytes:async p=>R.get(p),has:async p=>await A.get(p)!=null,heads:async()=>{const p=[];for(const{hash:d}of await y.all()){const b=await g(d);p.push(b)}return p},setHead:async p=>{const{hash:d,bytes:b}=await ue.encode(p,c,f);return await R.put(d,b),await A.put(d,!0),await y.set([{hash:d,next:p.next}]),d},addHead:async p=>(await y.add(p),p.hash),removeHeads:async p=>{for(const d of p)await y.remove(d)},addVerified:async p=>{for(const d of p)await A.put(d,!0),R.persist&&await R.persist(d)},storage:R,clear:async()=>{await A.clear(),await y.clear(),await R.clear()},close:async()=>{await A.close(),await y.close(),await R.close()}}},{LastWriteWins:bs,NoZeroes:xs}=gs,Is=()=>new Date().getTime().toString(),Ts=(n,t)=>Math.max(n,t.clock.time),_s=async()=>({canAppend:async n=>!0}),As=async(n,{logId:t,logHeads:i,access:s,entryStorage:o,headsStorage:c,indexStorage:w,sortFn:f,encryption:B}={})=>{if(n==null)throw new Error("Identity is required");if(i!=null&&!Array.isArray(i))throw new Error("'logHeads' argument must be an array");const R=t||Is();B=B||{};const A=B.data?.encrypt;s=s||await _s();const y=await vs({logHeads:i,entryStorage:o,indexStorage:w,headsStorage:c,encryption:B});f=xs(f||bs);const g=new ze({concurrency:1}),T=new ze({concurrency:1}),x=async()=>{const E=Math.max(0,(await v()).reduce(Ts,0));return zt(n.publicKey,E)},v=async()=>(await y.heads()).sort(f).reverse(),O=async()=>{const E=[];for await(const K of p())E.unshift(K);return E},F=async E=>{if(!E)throw new Error("hash is required");return y.get(E)},L=async E=>y.has(E),C=async(E,K={referencesCount:0})=>{const H=async()=>{const $=await v(),G=$.map(M=>M.hash),U=await q($,K.referencesCount+$.length),u=await ue.create(n,R,E,A,xi(await x()),G,U);if(!await s.canAppend(u))throw new Error(`Could not append entry:
Key "${n.hash}" is not allowed to write to the log`);const I=await y.setHead(u);return{...u,hash:I}};return g.add(H)},h=async E=>{if(!E)throw new Error("Log instance not defined");if(!P(E))throw new Error("Given argument is not an instance of Log");await y.storage.merge(E.storage);const K=await E.heads();for(const H of K)await m(H)},m=async E=>{const K=async()=>{if(await L(E.hash))return!1;const $=async M=>{if(M.id!==R)throw new Error(`Entry's id (${M.id}) doesn't match the log's id (${R}).`);if(!await s.canAppend(M))throw new Error(`Could not append entry:
Key "${M.identity}" is not allowed to write to the log`);if(!await ue.verify(n,M))throw new Error(`Could not validate signature for entry "${M.hash}"`)};await $(E);const G=(await v()).map(M=>M.hash),U=new Set([E.hash]),u=new Set([...E.next,...E.refs]),S=new Set,I=async()=>{const M=Array.from(u.values()).filter(L).map(F),z=await Promise.all(M);for(const j of z){u.delete(j.hash),await $(j),U.add(j.hash);for(const W of[...j.next,...j.refs])!await L(W)&&!U.has(W)?u.add(W):G.includes(W)&&S.add(W)}u.size>0&&await I()};return await I(),await y.addVerified(U.values()),await y.removeHeads(S.values()),await y.addHead(E),!0};return T.add(K)},p=async function*(E,K){K=K||(()=>!1),E=E||await v();let $=E.sort(f);const G={};let U=[];const u={},S=M=>!(G[M]||u[M]);let I;for(;$.length>0;)if($=$.sort(f),I=$.pop(),I){const{hash:M,next:z}=I;if(!G[M]){if(yield I,await K(I)===!0)break;G[M]=!0,u[M]=!0,U=[...U,...z].filter(S);const W=V=>{if(!G[V]&&!u[V])return u[V]=!0,F(V)},Z=await Promise.all(U.map(W));U=Z.filter(V=>V!=null).reduce((V,J)=>Array.from(new Set([...V,...J.next])),[]).filter(S),$=[...Z,...$]}}},d=async function*({amount:E=-1,gt:K,gte:H,lt:$,lte:G}={}){if(E===0)return;if(typeof G=="string"&&(G=[await F(G)]),typeof $=="string"){const V=await F($);$=await Promise.all(V.next.map(Q=>F(Q)))}if($!=null&&!Array.isArray($))throw new Error("lt must be a string or an array of Entries");if(G!=null&&!Array.isArray(G))throw new Error("lte must be a string or an array of Entries");const U=($||G||await v()).filter(V=>V!=null),u=K||H?await F(K||H):null,S=u||E===-1?-1:E;let I=0;const M=async V=>(I++,V?!!(I>=S&&S!==-1||u&&ue.isEqual(V,u)):!1),z=u&&E!==-1&&!$&&!G,j=z?new Ct(E+2):null;let W=0;const Z=p(U,M);for await(const V of Z){const J=$&&ue.isEqual(V,U),Q=K&&ue.isEqual(V,u);J||Q||(z?j.set(W++,V.hash):yield V)}if(z){const V=j.keys.length,J=V>E?V-E:0,Q=j.keys.slice(J,V);for(const ce of Q){const xe=j.get(ce);yield await F(xe)}}},b=async()=>{await g.clear(),await T.clear(),await y.clear()},N=async()=>{await g.onIdle(),await T.onIdle(),await y.close()},P=E=>E&&E.id!==void 0&&E.clock!==void 0&&E.heads!==void 0&&E.values!==void 0&&E.access!==void 0&&E.identity!==void 0&&E.storage!==void 0,q=async(E,K=0)=>{let H=[];const $=async G=>H.length>=K&&K!==-1;for await(const{hash:G}of p(E,$))H.push(G);return H=H.slice(E.length+1,K),H};return{id:R,clock:x,heads:v,values:O,all:O,get:F,has:L,append:C,join:h,joinEntry:m,traverse:p,iterator:d,clear:b,close:N,access:s,identity:n,storage:y.storage,encryption:B}},Bs=3e4,Ss=async({ipfs:n,log:t,events:i,onSynced:s,start:o,timeout:c})=>{if(!n)throw new Error("An instance of ipfs is required.");if(!t)throw new Error("An instance of log is required.");const w=n.libp2p,f=n.libp2p.services.pubsub,B=t.id,R=we("/orbitdb/heads/",B),A=new ze({concurrency:1}),y=new Set;i=i||new ur.EventEmitter,c??=Bs;let g=!1;const T=async d=>{const b=await t.heads();i.emit("join",d,b)},x=d=>(async function*(){const b=await t.heads();for await(const{hash:N}of b)yield await t.storage.get(N)})(),v=d=>async b=>{for await(const N of b){const P=N.subarray();if(P&&s){const q=await ue.decode(P,t.encryption.replication?.decrypt,t.encryption.data?.decrypt);await s(q)}}g&&await T(d)},O=async({connection:d,stream:b})=>{const N=String(d.remotePeer);try{y.add(N),await fn(b,v(N),x,b)}catch(P){y.delete(N),i.emit("error",P)}},F=async d=>{const b=async()=>{const{peerId:N,subscriptions:P}=d.detail,q=String(N),E=P.find(K=>K.topic===B);if(E)if(E.subscribe){if(y.has(q))return;const K=new Ot.TimeoutController(c),{signal:H}=K;try{y.add(q);const $=await w.dialProtocol(N,R,{signal:H});await fn(x,$,v(q))}catch($){y.delete(q),$.name==="UnsupportedProtocolError"||i.emit("error",$)}finally{K&&K.clear()}}else y.delete(q),i.emit("leave",q)};A.add(b)},L=async d=>{const{topic:b,data:N}=d.detail,P=async()=>{try{if(N&&s){const q=await ue.decode(N,t.encryption.replication?.decrypt,t.encryption.data?.decrypt);await s(q)}}catch(q){i.emit("error",q)}};b===B&&A.add(P)},C=async d=>{y.delete(d.detail.toString())},h=async d=>{if(g&&d&&d.hash){const b=await t.storage.get(d.hash);await f.publish(B,b)}},m=async()=>{g&&(g=!1,await A.clear(),f.removeEventListener("subscription-change",F),f.removeEventListener("message",L),await w.unhandle(R),await f.unsubscribe(B),w.removeEventListener("peer:disconnect",C),y.clear())},p=async()=>{g||(f.addEventListener("subscription-change",F),f.addEventListener("message",L),await f.subscribe(B),await w.handle(R,O),w.addEventListener("peer:disconnect",C),g=!0)};return o!==!1&&await p(),{add:h,stop:m,start:p,events:i,peers:y}},ve=async(n,t)=>({put:async(A,y)=>{await n.put(A,y),await t.put(A,y)},get:async A=>{let y=await n.get(A);return y||(y=await t.get(A),y&&await n.put(A,y)),y},del:async A=>{await n.del(A),await t.del(A)},persist:async A=>{n.persist&&await n.persist(A),t.persist&&await t.persist(A)},iterator:async function*({amount:A,reverse:y}={}){const g=[],T={amount:A||-1,reverse:y||!1};for(const x of[n,t])for await(const[v,O]of x.iterator(T))g[v]||(g[v]=!0,yield[v,O])},merge:async A=>{await n.merge(A),await t.merge(A),await A.merge(n),await A.merge(t)},clear:async()=>{await n.clear(),await t.clear()},close:async()=>{await n.close(),await t.close()}}),Sn=3e4,Qe=async({ipfs:n,pin:t,timeout:i}={})=>{if(!n)throw new Error("An instance of ipfs is required.");const s=new Set,o=async(g,T)=>{const x=X.parse(g,se),{signal:v}=new Ot.TimeoutController(i||Sn);await n.blockstore.put(x,T,{signal:v}),await f(g)},c=async g=>{},w=async g=>{const T=X.parse(g,se),x=new Ot.TimeoutController(i||Sn);s.add(x);const v=await n.blockstore.get(T,{signal:x.signal});if(s.delete(x),v)return v},f=async g=>{const T=X.parse(g,se);t&&!await n.pins.isPinned(T)&&await oi(n.pins.add(T))};return{put:o,del:c,get:w,persist:f,iterator:async function*(){},merge:async g=>{},clear:async()=>{},close:async()=>{for(const g in s)g.abort();s.clear()}}};var ut={},ht={},ye={},Ue={},ft={},Ln;function Ls(){return Ln||(Ln=1,ft.supports=function(...t){const i=t.reduce((s,o)=>Object.assign(s,o),{});return Object.assign(i,{snapshots:i.snapshots||!1,permanence:i.permanence||!1,seek:i.seek||!1,clear:i.clear||!1,getMany:i.getMany||!1,keyIterator:i.keyIterator||!1,valueIterator:i.valueIterator||!1,iteratorNextv:i.iteratorNextv||!1,iteratorAll:i.iteratorAll||!1,status:i.status||!1,createIfMissing:i.createIfMissing||!1,errorIfExists:i.errorIfExists||!1,deferredOpen:i.deferredOpen||!1,promises:i.promises||!1,streams:i.streams||!1,encodings:Object.assign({},i.encodings),events:Object.assign({},i.events),additionalMethods:Object.assign({},i.additionalMethods)})}),ft}var lt={},dt,On;function fe(){return On||(On=1,dt=class extends Error{constructor(t,i){super(t||""),typeof i=="object"&&i!==null&&(i.code&&(this.code=String(i.code)),i.expected&&(this.expected=!0),i.transient&&(this.transient=!0),i.cause&&(this.cause=i.cause)),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}),dt}var pe={},yt,Cn;function mr(){if(Cn)return yt;Cn=1;let n=null;return yt=function(){return n===null&&(n={textEncoder:new TextEncoder,textDecoder:new TextDecoder}),n},yt}var Le={},pt={},kn;function Er(){if(kn)return pt;kn=1;const n=fe(),t=new Set(["buffer","view","utf8"]);class i{constructor(o){if(this.encode=o.encode||this.encode,this.decode=o.decode||this.decode,this.name=o.name||this.name,this.format=o.format||this.format,typeof this.encode!="function")throw new TypeError("The 'encode' property must be a function");if(typeof this.decode!="function")throw new TypeError("The 'decode' property must be a function");if(this.encode=this.encode.bind(this),this.decode=this.decode.bind(this),typeof this.name!="string"||this.name==="")throw new TypeError("The 'name' property must be a string");if(typeof this.format!="string"||!t.has(this.format))throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");o.createViewTranscoder&&(this.createViewTranscoder=o.createViewTranscoder),o.createBufferTranscoder&&(this.createBufferTranscoder=o.createBufferTranscoder),o.createUTF8Transcoder&&(this.createUTF8Transcoder=o.createUTF8Transcoder)}get commonName(){return this.name.split("+")[0]}createBufferTranscoder(){throw new n(`Encoding '${this.name}' cannot be transcoded to 'buffer'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}createViewTranscoder(){throw new n(`Encoding '${this.name}' cannot be transcoded to 'view'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}createUTF8Transcoder(){throw new n(`Encoding '${this.name}' cannot be transcoded to 'utf8'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}}return pt.Encoding=i,pt}var Fn;function vr(){if(Fn)return Le;Fn=1;const{Buffer:n}=jt()||{},{Encoding:t}=Er(),i=mr();class s extends t{constructor(f){super({...f,format:"buffer"})}createViewTranscoder(){return new o({encode:this.encode,decode:f=>this.decode(n.from(f.buffer,f.byteOffset,f.byteLength)),name:`${this.name}+view`})}createBufferTranscoder(){return this}}class o extends t{constructor(f){super({...f,format:"view"})}createBufferTranscoder(){return new s({encode:f=>{const B=this.encode(f);return n.from(B.buffer,B.byteOffset,B.byteLength)},decode:this.decode,name:`${this.name}+buffer`})}createViewTranscoder(){return this}}class c extends t{constructor(f){super({...f,format:"utf8"})}createBufferTranscoder(){return new s({encode:f=>n.from(this.encode(f),"utf8"),decode:f=>this.decode(f.toString("utf8")),name:`${this.name}+buffer`})}createViewTranscoder(){const{textEncoder:f,textDecoder:B}=i();return new o({encode:R=>f.encode(this.encode(R)),decode:R=>this.decode(B.decode(R)),name:`${this.name}+view`})}createUTF8Transcoder(){return this}}return Le.BufferFormat=s,Le.ViewFormat=o,Le.UTF8Format=c,Le}var Rn;function Os(){if(Rn)return pe;Rn=1;const{Buffer:n}=jt()||{Buffer:{isBuffer:()=>!1}},{textEncoder:t,textDecoder:i}=mr()(),{BufferFormat:s,ViewFormat:o,UTF8Format:c}=vr(),w=f=>f;return pe.utf8=new c({encode:function(f){return n.isBuffer(f)?f.toString("utf8"):ArrayBuffer.isView(f)?i.decode(f):String(f)},decode:w,name:"utf8",createViewTranscoder(){return new o({encode:function(f){return ArrayBuffer.isView(f)?f:t.encode(f)},decode:function(f){return i.decode(f)},name:`${this.name}+view`})},createBufferTranscoder(){return new s({encode:function(f){return n.isBuffer(f)?f:ArrayBuffer.isView(f)?n.from(f.buffer,f.byteOffset,f.byteLength):n.from(String(f),"utf8")},decode:function(f){return f.toString("utf8")},name:`${this.name}+buffer`})}}),pe.json=new c({encode:JSON.stringify,decode:JSON.parse,name:"json"}),pe.buffer=new s({encode:function(f){return n.isBuffer(f)?f:ArrayBuffer.isView(f)?n.from(f.buffer,f.byteOffset,f.byteLength):n.from(String(f),"utf8")},decode:w,name:"buffer",createViewTranscoder(){return new o({encode:function(f){return ArrayBuffer.isView(f)?f:n.from(String(f),"utf8")},decode:function(f){return n.from(f.buffer,f.byteOffset,f.byteLength)},name:`${this.name}+view`})}}),pe.view=new o({encode:function(f){return ArrayBuffer.isView(f)?f:t.encode(f)},decode:w,name:"view",createBufferTranscoder(){return new s({encode:function(f){return n.isBuffer(f)?f:ArrayBuffer.isView(f)?n.from(f.buffer,f.byteOffset,f.byteLength):n.from(String(f),"utf8")},decode:w,name:`${this.name}+buffer`})}}),pe.hex=new s({encode:function(f){return n.isBuffer(f)?f:n.from(String(f),"hex")},decode:function(f){return f.toString("hex")},name:"hex"}),pe.base64=new s({encode:function(f){return n.isBuffer(f)?f:n.from(String(f),"base64")},decode:function(f){return f.toString("base64")},name:"base64"}),pe}var Nn;function Cs(){if(Nn)return lt;Nn=1;const n=fe(),t=Os(),{Encoding:i}=Er(),{BufferFormat:s,ViewFormat:o,UTF8Format:c}=vr(),w=Symbol("formats"),f=Symbol("encodings"),B=new Set(["buffer","view","utf8"]);class R{constructor(O){if(Array.isArray(O)){if(!O.every(F=>B.has(F)))throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'")}else throw new TypeError("The first argument 'formats' must be an array");this[f]=new Map,this[w]=new Set(O);for(const F in t)try{this.encoding(F)}catch(L){if(L.code!=="LEVEL_ENCODING_NOT_SUPPORTED")throw L}}encodings(){return Array.from(new Set(this[f].values()))}encoding(O){let F=this[f].get(O);if(F===void 0){if(typeof O=="string"&&O!==""){if(F=T[O],!F)throw new n(`Encoding '${O}' is not found`,{code:"LEVEL_ENCODING_NOT_FOUND"})}else{if(typeof O!="object"||O===null)throw new TypeError("First argument 'encoding' must be a string or object");F=A(O)}const{name:L,format:C}=F;if(!this[w].has(C))if(this[w].has("view"))F=F.createViewTranscoder();else if(this[w].has("buffer"))F=F.createBufferTranscoder();else if(this[w].has("utf8"))F=F.createUTF8Transcoder();else throw new n(`Encoding '${L}' cannot be transcoded`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"});for(const h of[O,L,F.name,F.commonName])this[f].set(h,F)}return F}}lt.Transcoder=R;function A(v){if(v instanceof i)return v;const O="type"in v&&typeof v.type=="string"?v.type:void 0,F=v.name||O||`anonymous-${x++}`;switch(y(v)){case"view":return new o({...v,name:F});case"utf8":return new c({...v,name:F});case"buffer":return new s({...v,name:F});default:throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'")}}function y(v){return"format"in v&&v.format!==void 0?v.format:"buffer"in v&&typeof v.buffer=="boolean"?v.buffer?"buffer":"utf8":"code"in v&&Number.isInteger(v.code)?"view":"buffer"}const g={binary:t.buffer,"utf-8":t.utf8},T={...t,...g};let x=0;return lt}var Me={},wt,Pn;function ks(){return Pn||(Pn=1,wt=typeof queueMicrotask=="function"?queueMicrotask:n=>Promise.resolve().then(n)),wt}var Dn;function Xe(){if(Dn)return Me;Dn=1;var n=ks();return Me.fromCallback=function(t,i){if(t===void 0){var s=new Promise(function(o,c){t=function(w,f){w?c(w):o(f)}});t[i!==void 0?i:"promise"]=s}else if(typeof t!="function")throw new TypeError("Callback must be a function");return t},Me.fromPromise=function(t,i){if(i===void 0)return t;t.then(function(s){n(()=>i(null,s))}).catch(function(s){n(()=>i(s))})},Me}var Oe={},qe={},Un;function Yt(){return Un||(Un=1,qe.getCallback=function(n,t){return typeof n=="function"?n:t},qe.getOptions=function(n,t){return typeof n=="object"&&n!==null?n:t!==void 0?t:{}}),qe}var Mn;function be(){if(Mn)return Oe;Mn=1;const{fromCallback:n}=Xe(),t=fe(),{getOptions:i,getCallback:s}=Yt(),o=Symbol("promise"),c=Symbol("callback"),w=Symbol("working"),f=Symbol("handleOne"),B=Symbol("handleMany"),R=Symbol("autoClose"),A=Symbol("finishWork"),y=Symbol("returnMany"),g=Symbol("closing"),T=Symbol("handleClose"),x=Symbol("closed"),v=Symbol("closeCallbacks"),O=Symbol("keyEncoding"),F=Symbol("valueEncoding"),L=Symbol("abortOnClose"),C=Symbol("legacy"),h=Symbol("keys"),m=Symbol("values"),p=Symbol("limit"),d=Symbol("count"),b=Object.freeze({}),N=()=>{};let P=!1;class q{constructor(U,u,S){if(typeof U!="object"||U===null){const I=U===null?"null":typeof U;throw new TypeError(`The first argument must be an abstract-level database, received ${I}`)}if(typeof u!="object"||u===null)throw new TypeError("The second argument must be an options object");this[x]=!1,this[v]=[],this[w]=!1,this[g]=!1,this[R]=!1,this[c]=null,this[f]=this[f].bind(this),this[B]=this[B].bind(this),this[T]=this[T].bind(this),this[O]=u[O],this[F]=u[F],this[C]=S,this[p]=Number.isInteger(u.limit)&&u.limit>=0?u.limit:1/0,this[d]=0,this[L]=!!u.abortOnClose,this.db=U,this.db.attachResource(this),this.nextTick=U.nextTick}get count(){return this[d]}get limit(){return this[p]}next(U){let u;if(U===void 0)u=new Promise((S,I)=>{U=(M,z,j)=>{M?I(M):this[C]?z===void 0&&j===void 0?S():S([z,j]):S(z)}});else if(typeof U!="function")throw new TypeError("Callback must be a function");return this[g]?this.nextTick(U,new t("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[w]?this.nextTick(U,new t("Iterator is busy: cannot call next() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[w]=!0,this[c]=U,this[d]>=this[p]?this.nextTick(this[f],null):this._next(this[f])),u}_next(U){this.nextTick(U)}nextv(U,u,S){return S=s(u,S),S=n(S,o),u=i(u,b),Number.isInteger(U)?(this[g]?this.nextTick(S,new t("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[w]?this.nextTick(S,new t("Iterator is busy: cannot call nextv() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(U<1&&(U=1),this[p]<1/0&&(U=Math.min(U,this[p]-this[d])),this[w]=!0,this[c]=S,U<=0?this.nextTick(this[B],null,[]):this._nextv(U,u,this[B])),S[o]):(this.nextTick(S,new TypeError("The first argument 'size' must be an integer")),S[o])}_nextv(U,u,S){const I=[],M=(z,j,W)=>{if(z)return S(z);if(this[C]?j===void 0&&W===void 0:j===void 0)return S(null,I);I.push(this[C]?[j,W]:j),I.length===U?S(null,I):this._next(M)};this._next(M)}all(U,u){return u=s(U,u),u=n(u,o),U=i(U,b),this[g]?this.nextTick(u,new t("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[w]?this.nextTick(u,new t("Iterator is busy: cannot call all() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[w]=!0,this[c]=u,this[R]=!0,this[d]>=this[p]?this.nextTick(this[B],null,[]):this._all(U,this[B])),u[o]}_all(U,u){let S=this[d];const I=[],M=()=>{const j=this[p]<1/0?Math.min(1e3,this[p]-S):1e3;j<=0?this.nextTick(u,null,I):this._nextv(j,b,z)},z=(j,W)=>{j?u(j):W.length===0?u(null,I):(I.push.apply(I,W),S+=W.length,M())};M()}[A](){const U=this[c];return this[L]&&U===null?N:(this[w]=!1,this[c]=null,this[g]&&this._close(this[T]),U)}[y](U,u,S){this[R]?this.close(U.bind(null,u,S)):U(u,S)}seek(U,u){if(u=i(u,b),!this[g]){if(this[w])throw new t("Iterator is busy: cannot call seek() until next() has completed",{code:"LEVEL_ITERATOR_BUSY"});{const S=this.db.keyEncoding(u.keyEncoding||this[O]),I=S.format;u.keyEncoding!==I&&(u={...u,keyEncoding:I});const M=this.db.prefixKey(S.encode(U),I);this._seek(M,u)}}}_seek(U,u){throw new t("Iterator does not support seek()",{code:"LEVEL_NOT_SUPPORTED"})}close(U){return U=n(U,o),this[x]?this.nextTick(U):this[g]?this[v].push(U):(this[g]=!0,this[v].push(U),this[w]?this[L]&&this[A]()(new t("Aborted on iterator close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this._close(this[T])),U[o]}_close(U){this.nextTick(U)}[T](){this[x]=!0,this.db.detachResource(this);const U=this[v];this[v]=[];for(const u of U)u()}async*[Symbol.asyncIterator](){try{let U;for(;(U=await this.next())!==void 0;)yield U}finally{this[x]||await this.close()}}}class E extends q{constructor(U,u){super(U,u,!0),this[h]=u.keys!==!1,this[m]=u.values!==!1}[f](U,u,S){const I=this[A]();if(U)return I(U);try{u=this[h]&&u!==void 0?this[O].decode(u):void 0,S=this[m]&&S!==void 0?this[F].decode(S):void 0}catch(M){return I(new $("entry",M))}u===void 0&&S===void 0||this[d]++,I(null,u,S)}[B](U,u){const S=this[A]();if(U)return this[y](S,U);try{for(const I of u){const M=I[0],z=I[1];I[0]=this[h]&&M!==void 0?this[O].decode(M):void 0,I[1]=this[m]&&z!==void 0?this[F].decode(z):void 0}}catch(I){return this[y](S,new $("entries",I))}this[d]+=u.length,this[y](S,null,u)}end(U){return!P&&typeof console<"u"&&(P=!0,console.warn(new t("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",{code:"LEVEL_LEGACY"}))),this.close(U)}}class K extends q{constructor(U,u){super(U,u,!1)}[f](U,u){const S=this[A]();if(U)return S(U);try{u=u!==void 0?this[O].decode(u):void 0}catch(I){return S(new $("key",I))}u!==void 0&&this[d]++,S(null,u)}[B](U,u){const S=this[A]();if(U)return this[y](S,U);try{for(let I=0;I<u.length;I++){const M=u[I];u[I]=M!==void 0?this[O].decode(M):void 0}}catch(I){return this[y](S,new $("keys",I))}this[d]+=u.length,this[y](S,null,u)}}class H extends q{constructor(U,u){super(U,u,!1)}[f](U,u){const S=this[A]();if(U)return S(U);try{u=u!==void 0?this[F].decode(u):void 0}catch(I){return S(new $("value",I))}u!==void 0&&this[d]++,S(null,u)}[B](U,u){const S=this[A]();if(U)return this[y](S,U);try{for(let I=0;I<u.length;I++){const M=u[I];u[I]=M!==void 0?this[F].decode(M):void 0}}catch(I){return this[y](S,new $("values",I))}this[d]+=u.length,this[y](S,null,u)}}class $ extends t{constructor(U,u){super(`Iterator could not decode ${U}`,{code:"LEVEL_DECODE_ERROR",cause:u})}}for(const G of["_ended property","_nexting property","_end method"])Object.defineProperty(E.prototype,G.split(" ")[0],{get(){throw new t(`The ${G} has been removed`,{code:"LEVEL_LEGACY"})},set(){throw new t(`The ${G} has been removed`,{code:"LEVEL_LEGACY"})}});return E.keyEncoding=O,E.valueEncoding=F,Oe.AbstractIterator=E,Oe.AbstractKeyIterator=K,Oe.AbstractValueIterator=H,Oe}var Ve={},qn;function Fs(){if(qn)return Ve;qn=1;const{AbstractKeyIterator:n,AbstractValueIterator:t}=be(),i=Symbol("iterator"),s=Symbol("callback"),o=Symbol("handleOne"),c=Symbol("handleMany");class w extends n{constructor(R,A){super(R,A),this[i]=R.iterator({...A,keys:!0,values:!1}),this[o]=this[o].bind(this),this[c]=this[c].bind(this)}}class f extends t{constructor(R,A){super(R,A),this[i]=R.iterator({...A,keys:!1,values:!0}),this[o]=this[o].bind(this),this[c]=this[c].bind(this)}}for(const B of[w,f]){const R=B===w,A=R?y=>y[0]:y=>y[1];B.prototype._next=function(y){this[s]=y,this[i].next(this[o])},B.prototype[o]=function(y,g,T){const x=this[s];y?x(y):x(null,R?g:T)},B.prototype._nextv=function(y,g,T){this[s]=T,this[i].nextv(y,g,this[c])},B.prototype._all=function(y,g){this[s]=g,this[i].all(y,this[c])},B.prototype[c]=function(y,g){const T=this[s];y?T(y):T(null,g.map(A))},B.prototype._seek=function(y,g){this[i].seek(y,g)},B.prototype._close=function(y){this[i].close(y)}}return Ve.DefaultKeyIterator=w,Ve.DefaultValueIterator=f,Ve}var Ce={},Vn;function Rs(){if(Vn)return Ce;Vn=1;const{AbstractIterator:n,AbstractKeyIterator:t,AbstractValueIterator:i}=be(),s=fe(),o=Symbol("nut"),c=Symbol("undefer"),w=Symbol("factory");class f extends n{constructor(y,g){super(y,g),this[o]=null,this[w]=()=>y.iterator(g),this.db.defer(()=>this[c]())}}class B extends t{constructor(y,g){super(y,g),this[o]=null,this[w]=()=>y.keys(g),this.db.defer(()=>this[c]())}}class R extends i{constructor(y,g){super(y,g),this[o]=null,this[w]=()=>y.values(g),this.db.defer(()=>this[c]())}}for(const A of[f,B,R])A.prototype[c]=function(){this.db.status==="open"&&(this[o]=this[w]())},A.prototype._next=function(y){this[o]!==null?this[o].next(y):this.db.status==="opening"?this.db.defer(()=>this._next(y)):this.nextTick(y,new s("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},A.prototype._nextv=function(y,g,T){this[o]!==null?this[o].nextv(y,g,T):this.db.status==="opening"?this.db.defer(()=>this._nextv(y,g,T)):this.nextTick(T,new s("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},A.prototype._all=function(y,g){this[o]!==null?this[o].all(g):this.db.status==="opening"?this.db.defer(()=>this._all(y,g)):this.nextTick(g,new s("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},A.prototype._seek=function(y,g){this[o]!==null?this[o]._seek(y,g):this.db.status==="opening"&&this.db.defer(()=>this._seek(y,g))},A.prototype._close=function(y){this[o]!==null?this[o].close(y):this.db.status==="opening"?this.db.defer(()=>this._close(y)):this.nextTick(y)};return Ce.DeferredIterator=f,Ce.DeferredKeyIterator=B,Ce.DeferredValueIterator=R,Ce}var gt={},mt={},Kn;function br(){if(Kn)return mt;Kn=1;const{fromCallback:n}=Xe(),t=fe(),{getCallback:i,getOptions:s}=Yt(),o=Symbol("promise"),c=Symbol("status"),w=Symbol("operations"),f=Symbol("finishClose"),B=Symbol("closeCallbacks");class R{constructor(y){if(typeof y!="object"||y===null){const g=y===null?"null":typeof y;throw new TypeError(`The first argument must be an abstract-level database, received ${g}`)}this[w]=[],this[B]=[],this[c]="open",this[f]=this[f].bind(this),this.db=y,this.db.attachResource(this),this.nextTick=y.nextTick}get length(){return this[w].length}put(y,g,T){if(this[c]!=="open")throw new t("Batch is not open: cannot call put() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const x=this.db._checkKey(y)||this.db._checkValue(g);if(x)throw x;const v=T&&T.sublevel!=null?T.sublevel:this.db,O=T,F=v.keyEncoding(T&&T.keyEncoding),L=v.valueEncoding(T&&T.valueEncoding),C=F.format;T={...T,keyEncoding:C,valueEncoding:L.format},v!==this.db&&(T.sublevel=null);const h=v.prefixKey(F.encode(y),C),m=L.encode(g);return this._put(h,m,T),this[w].push({...O,type:"put",key:y,value:g}),this}_put(y,g,T){}del(y,g){if(this[c]!=="open")throw new t("Batch is not open: cannot call del() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const T=this.db._checkKey(y);if(T)throw T;const x=g&&g.sublevel!=null?g.sublevel:this.db,v=g,O=x.keyEncoding(g&&g.keyEncoding),F=O.format;return g={...g,keyEncoding:F},x!==this.db&&(g.sublevel=null),this._del(x.prefixKey(O.encode(y),F),g),this[w].push({...v,type:"del",key:y}),this}_del(y,g){}clear(){if(this[c]!=="open")throw new t("Batch is not open: cannot call clear() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});return this._clear(),this[w]=[],this}_clear(){}write(y,g){return g=i(y,g),g=n(g,o),y=s(y),this[c]!=="open"?this.nextTick(g,new t("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"})):this.length===0?this.close(g):(this[c]="writing",this._write(y,T=>{this[c]="closing",this[B].push(()=>g(T)),T||this.db.emit("batch",this[w]),this._close(this[f])})),g[o]}_write(y,g){}close(y){return y=n(y,o),this[c]==="closing"?this[B].push(y):this[c]==="closed"?this.nextTick(y):(this[B].push(y),this[c]!=="writing"&&(this[c]="closing",this._close(this[f]))),y[o]}_close(y){this.nextTick(y)}[f](){this[c]="closed",this.db.detachResource(this);const y=this[B];this[B]=[];for(const g of y)g()}}return mt.AbstractChainedBatch=R,mt}var $n;function Ns(){if($n)return gt;$n=1;const{AbstractChainedBatch:n}=br(),t=fe(),i=Symbol("encoded");class s extends n{constructor(c){super(c),this[i]=[]}_put(c,w,f){this[i].push({...f,type:"put",key:c,value:w})}_del(c,w){this[i].push({...w,type:"del",key:c})}_clear(){this[i]=[]}_write(c,w){this.db.status==="opening"?this.db.defer(()=>this._write(c,w)):this.db.status==="open"?this[i].length===0?this.nextTick(w):this.db._batch(this[i],c,w):this.nextTick(w,new t("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"}))}}return gt.DefaultChainedBatch=s,gt}var Et,jn;function Ps(){if(jn)return Et;jn=1;const n=fe(),t=Object.prototype.hasOwnProperty,i=new Set(["lt","lte","gt","gte"]);return Et=function(s,o){const c={};for(const w in s)if(t.call(s,w)&&!(w==="keyEncoding"||w==="valueEncoding")){if(w==="start"||w==="end")throw new n(`The legacy range option '${w}' has been removed`,{code:"LEVEL_LEGACY"});if(w==="encoding")throw new n("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead",{code:"LEVEL_LEGACY"});i.has(w)?c[w]=o.encode(s[w]):c[w]=s[w]}return c.reverse=!!c.reverse,c.limit=Number.isInteger(c.limit)&&c.limit>=0?c.limit:-1,c},Et}var vt,zn;function xr(){if(zn)return vt;zn=1;let n;return vt=typeof queueMicrotask=="function"?queueMicrotask.bind(typeof window<"u"?window:ci):t=>(n||(n=Promise.resolve())).then(t).catch(i=>setTimeout(()=>{throw i},0)),vt}var bt,Hn;function Ds(){if(Hn)return bt;Hn=1;const n=xr();return bt=function(t,...i){i.length===0?n(t):n(()=>t(...i))},bt}var ke={},Gn;function Us(){if(Gn)return ke;Gn=1;const{AbstractIterator:n,AbstractKeyIterator:t,AbstractValueIterator:i}=be(),s=Symbol("unfix"),o=Symbol("iterator"),c=Symbol("handleOne"),w=Symbol("handleMany"),f=Symbol("callback");class B extends n{constructor(g,T,x,v){super(g,T),this[o]=x,this[s]=v,this[c]=this[c].bind(this),this[w]=this[w].bind(this),this[f]=null}[c](g,T,x){const v=this[f];if(g)return v(g);T!==void 0&&(T=this[s](T)),v(g,T,x)}[w](g,T){const x=this[f];if(g)return x(g);for(const v of T){const O=v[0];O!==void 0&&(v[0]=this[s](O))}x(g,T)}}class R extends t{constructor(g,T,x,v){super(g,T),this[o]=x,this[s]=v,this[c]=this[c].bind(this),this[w]=this[w].bind(this),this[f]=null}[c](g,T){const x=this[f];if(g)return x(g);T!==void 0&&(T=this[s](T)),x(g,T)}[w](g,T){const x=this[f];if(g)return x(g);for(let v=0;v<T.length;v++){const O=T[v];O!==void 0&&(T[v]=this[s](O))}x(g,T)}}class A extends i{constructor(g,T,x){super(g,T),this[o]=x}}for(const y of[B,R])y.prototype._next=function(g){this[f]=g,this[o].next(this[c])},y.prototype._nextv=function(g,T,x){this[f]=x,this[o].nextv(g,T,this[w])},y.prototype._all=function(g,T){this[f]=T,this[o].all(g,this[w])};for(const y of[A])y.prototype._next=function(g){this[o].next(g)},y.prototype._nextv=function(g,T,x){this[o].nextv(g,T,x)},y.prototype._all=function(g,T){this[o].all(g,T)};for(const y of[B,R,A])y.prototype._seek=function(g,T){this[o].seek(g,T)},y.prototype._close=function(g){this[o].close(g)};return ke.AbstractSublevelIterator=B,ke.AbstractSublevelKeyIterator=R,ke.AbstractSublevelValueIterator=A,ke}var xt,Wn;function Ms(){if(Wn)return xt;Wn=1;const n=fe(),{Buffer:t}=jt()||{},{AbstractSublevelIterator:i,AbstractSublevelKeyIterator:s,AbstractSublevelValueIterator:o}=Us(),c=Symbol("prefix"),w=Symbol("upperBound"),f=Symbol("prefixRange"),B=Symbol("parent"),R=Symbol("unfix"),A=new TextEncoder,y={separator:"!"};xt=function({AbstractLevel:F}){class L extends F{static defaults(h){if(typeof h=="string")throw new n("The subleveldown string shorthand for { separator } has been removed",{code:"LEVEL_LEGACY"});if(h&&h.open)throw new n("The subleveldown open option has been removed",{code:"LEVEL_LEGACY"});return h==null?y:h.separator?h:{...h,separator:"!"}}constructor(h,m,p){const{separator:d,manifest:b,...N}=L.defaults(p);m=O(m,d);const P=d.charCodeAt(0)+1,q=h[B]||h;if(!A.encode(m).every(H=>H>P&&H<127))throw new n(`Prefix must use bytes > ${P} < 127`,{code:"LEVEL_INVALID_PREFIX"});super(g(q,b),N);const E=(h.prefix||"")+d+m+d,K=E.slice(0,-1)+String.fromCharCode(P);this[B]=q,this[c]=new x(E),this[w]=new x(K),this[R]=new v,this.nextTick=q.nextTick}prefixKey(h,m){if(m==="utf8")return this[c].utf8+h;if(h.byteLength===0)return this[c][m];if(m==="view"){const p=this[c].view,d=new Uint8Array(p.byteLength+h.byteLength);return d.set(p,0),d.set(h,p.byteLength),d}else{const p=this[c].buffer;return t.concat([p,h],p.byteLength+h.byteLength)}}[f](h,m){h.gte!==void 0?h.gte=this.prefixKey(h.gte,m):h.gt!==void 0?h.gt=this.prefixKey(h.gt,m):h.gte=this[c][m],h.lte!==void 0?h.lte=this.prefixKey(h.lte,m):h.lt!==void 0?h.lt=this.prefixKey(h.lt,m):h.lte=this[w][m]}get prefix(){return this[c].utf8}get db(){return this[B]}_open(h,m){this[B].open({passive:!0},m)}_put(h,m,p,d){this[B].put(h,m,p,d)}_get(h,m,p){this[B].get(h,m,p)}_getMany(h,m,p){this[B].getMany(h,m,p)}_del(h,m,p){this[B].del(h,m,p)}_batch(h,m,p){this[B].batch(h,m,p)}_clear(h,m){this[f](h,h.keyEncoding),this[B].clear(h,m)}_iterator(h){this[f](h,h.keyEncoding);const m=this[B].iterator(h),p=this[R].get(this[c].utf8.length,h.keyEncoding);return new i(this,h,m,p)}_keys(h){this[f](h,h.keyEncoding);const m=this[B].keys(h),p=this[R].get(this[c].utf8.length,h.keyEncoding);return new s(this,h,m,p)}_values(h){this[f](h,h.keyEncoding);const m=this[B].values(h);return new o(this,h,m)}}return{AbstractSublevel:L}};const g=function(F,L){return{...F.supports,createIfMissing:!1,errorIfExists:!1,events:{},additionalMethods:{},...L,encodings:{utf8:T(F,"utf8"),buffer:T(F,"buffer"),view:T(F,"view")}}},T=function(F,L){return F.supports.encodings[L]?F.keyEncoding(L).name===L:!1};class x{constructor(L){this.utf8=L,this.view=A.encode(L),this.buffer=t?t.from(this.view.buffer,0,this.view.byteLength):{}}}class v{constructor(){this.cache=new Map}get(L,C){let h=this.cache.get(C);return h===void 0&&(C==="view"?h=function(m,p){return p.subarray(m)}.bind(null,L):h=function(m,p){return p.slice(m)}.bind(null,L),this.cache.set(C,h)),h}}const O=function(F,L){let C=0,h=F.length;for(;C<h&&F[C]===L;)C++;for(;h>C&&F[h-1]===L;)h--;return F.slice(C,h)};return xt}var Yn;function Jn(){if(Yn)return Ue;Yn=1;const{supports:n}=Ls(),{Transcoder:t}=Cs(),{EventEmitter:i}=$t(),{fromCallback:s}=Xe(),o=fe(),{AbstractIterator:c}=be(),{DefaultKeyIterator:w,DefaultValueIterator:f}=Fs(),{DeferredIterator:B,DeferredKeyIterator:R,DeferredValueIterator:A}=Rs(),{DefaultChainedBatch:y}=Ns(),{getCallback:g,getOptions:T}=Yt(),x=Ps(),v=Symbol("promise"),O=Symbol("landed"),F=Symbol("resources"),L=Symbol("closeResources"),C=Symbol("operations"),h=Symbol("undefer"),m=Symbol("deferOpen"),p=Symbol("options"),d=Symbol("status"),b=Symbol("defaultOptions"),N=Symbol("transcoder"),P=Symbol("keyEncoding"),q=Symbol("valueEncoding"),E=()=>{};class K extends i{constructor(u,S){if(super(),typeof u!="object"||u===null)throw new TypeError("The first argument 'manifest' must be an object");S=T(S);const{keyEncoding:I,valueEncoding:M,passive:z,...j}=S;this[F]=new Set,this[C]=[],this[m]=!0,this[p]=j,this[d]="opening",this.supports=n(u,{status:!0,promises:!0,clear:!0,getMany:!0,deferredOpen:!0,snapshots:u.snapshots!==!1,permanence:u.permanence!==!1,keyIterator:!0,valueIterator:!0,iteratorNextv:!0,iteratorAll:!0,encodings:u.encodings||{},events:Object.assign({},u.events,{opening:!0,open:!0,closing:!0,closed:!0,put:!0,del:!0,batch:!0,clear:!0})}),this[N]=new t(G(this)),this[P]=this[N].encoding(I||"utf8"),this[q]=this[N].encoding(M||"utf8");for(const W of this[N].encodings())this.supports.encodings[W.commonName]||(this.supports.encodings[W.commonName]=!0);this[b]={empty:Object.freeze({}),entry:Object.freeze({keyEncoding:this[P].commonName,valueEncoding:this[q].commonName}),key:Object.freeze({keyEncoding:this[P].commonName})},this.nextTick(()=>{this[m]&&this.open({passive:!1},E)})}get status(){return this[d]}keyEncoding(u){return this[N].encoding(u??this[P])}valueEncoding(u){return this[N].encoding(u??this[q])}open(u,S){S=g(u,S),S=s(S,v),u={...this[p],...T(u)},u.createIfMissing=u.createIfMissing!==!1,u.errorIfExists=!!u.errorIfExists;const I=M=>{this[d]==="closing"||this[d]==="opening"?this.once(O,M?()=>I(M):I):this[d]!=="open"?S(new o("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN",cause:M})):S()};return u.passive?this[d]==="opening"?this.once(O,I):this.nextTick(I):this[d]==="closed"||this[m]?(this[m]=!1,this[d]="opening",this.emit("opening"),this._open(u,M=>{if(M){this[d]="closed",this[L](()=>{this.emit(O),I(M)}),this[h]();return}this[d]="open",this[h](),this.emit(O),this[d]==="open"&&this.emit("open"),this[d]==="open"&&this.emit("ready"),I()})):this[d]==="open"?this.nextTick(I):this.once(O,()=>this.open(u,S)),S[v]}_open(u,S){this.nextTick(S)}close(u){u=s(u,v);const S=I=>{this[d]==="opening"||this[d]==="closing"?this.once(O,I?S(I):S):this[d]!=="closed"?u(new o("Database is not closed",{code:"LEVEL_DATABASE_NOT_CLOSED",cause:I})):u()};if(this[d]==="open"){this[d]="closing",this.emit("closing");const I=M=>{this[d]="open",this[h](),this.emit(O),S(M)};this[L](()=>{this._close(M=>{if(M)return I(M);this[d]="closed",this[h](),this.emit(O),this[d]==="closed"&&this.emit("closed"),S()})})}else this[d]==="closed"?this.nextTick(S):this.once(O,()=>this.close(u));return u[v]}[L](u){if(this[F].size===0)return this.nextTick(u);let S=this[F].size,I=!0;const M=()=>{--S===0&&(I?this.nextTick(u):u())};for(const z of this[F])z.close(M);I=!1,this[F].clear()}_close(u){this.nextTick(u)}get(u,S,I){if(I=g(S,I),I=s(I,v),S=T(S,this[b].entry),this[d]==="opening")return this.defer(()=>this.get(u,S,I)),I[v];if($(this,I))return I[v];const M=this._checkKey(u);if(M)return this.nextTick(I,M),I[v];const z=this.keyEncoding(S.keyEncoding),j=this.valueEncoding(S.valueEncoding),W=z.format,Z=j.format;return(S.keyEncoding!==W||S.valueEncoding!==Z)&&(S=Object.assign({},S,{keyEncoding:W,valueEncoding:Z})),this._get(this.prefixKey(z.encode(u),W),S,(V,J)=>{if(V)return(V.code==="LEVEL_NOT_FOUND"||V.notFound||/NotFound/i.test(V))&&(V.code||(V.code="LEVEL_NOT_FOUND"),V.notFound||(V.notFound=!0),V.status||(V.status=404)),I(V);try{J=j.decode(J)}catch(Q){return I(new o("Could not decode value",{code:"LEVEL_DECODE_ERROR",cause:Q}))}I(null,J)}),I[v]}_get(u,S,I){this.nextTick(I,new Error("NotFound"))}getMany(u,S,I){if(I=g(S,I),I=s(I,v),S=T(S,this[b].entry),this[d]==="opening")return this.defer(()=>this.getMany(u,S,I)),I[v];if($(this,I))return I[v];if(!Array.isArray(u))return this.nextTick(I,new TypeError("The first argument 'keys' must be an array")),I[v];if(u.length===0)return this.nextTick(I,null,[]),I[v];const M=this.keyEncoding(S.keyEncoding),z=this.valueEncoding(S.valueEncoding),j=M.format,W=z.format;(S.keyEncoding!==j||S.valueEncoding!==W)&&(S=Object.assign({},S,{keyEncoding:j,valueEncoding:W}));const Z=new Array(u.length);for(let V=0;V<u.length;V++){const J=u[V],Q=this._checkKey(J);if(Q)return this.nextTick(I,Q),I[v];Z[V]=this.prefixKey(M.encode(J),j)}return this._getMany(Z,S,(V,J)=>{if(V)return I(V);try{for(let Q=0;Q<J.length;Q++)J[Q]!==void 0&&(J[Q]=z.decode(J[Q]))}catch(Q){return I(new o(`Could not decode one or more of ${J.length} value(s)`,{code:"LEVEL_DECODE_ERROR",cause:Q}))}I(null,J)}),I[v]}_getMany(u,S,I){this.nextTick(I,null,new Array(u.length).fill(void 0))}put(u,S,I,M){if(M=g(I,M),M=s(M,v),I=T(I,this[b].entry),this[d]==="opening")return this.defer(()=>this.put(u,S,I,M)),M[v];if($(this,M))return M[v];const z=this._checkKey(u)||this._checkValue(S);if(z)return this.nextTick(M,z),M[v];const j=this.keyEncoding(I.keyEncoding),W=this.valueEncoding(I.valueEncoding),Z=j.format,V=W.format;(I.keyEncoding!==Z||I.valueEncoding!==V)&&(I=Object.assign({},I,{keyEncoding:Z,valueEncoding:V}));const J=this.prefixKey(j.encode(u),Z),Q=W.encode(S);return this._put(J,Q,I,ce=>{if(ce)return M(ce);this.emit("put",u,S),M()}),M[v]}_put(u,S,I,M){this.nextTick(M)}del(u,S,I){if(I=g(S,I),I=s(I,v),S=T(S,this[b].key),this[d]==="opening")return this.defer(()=>this.del(u,S,I)),I[v];if($(this,I))return I[v];const M=this._checkKey(u);if(M)return this.nextTick(I,M),I[v];const z=this.keyEncoding(S.keyEncoding),j=z.format;return S.keyEncoding!==j&&(S=Object.assign({},S,{keyEncoding:j})),this._del(this.prefixKey(z.encode(u),j),S,W=>{if(W)return I(W);this.emit("del",u),I()}),I[v]}_del(u,S,I){this.nextTick(I)}batch(u,S,I){if(!arguments.length){if(this[d]==="opening")return new y(this);if(this[d]!=="open")throw new o("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._chainedBatch()}if(typeof u=="function"?I=u:I=g(S,I),I=s(I,v),S=T(S,this[b].empty),this[d]==="opening")return this.defer(()=>this.batch(u,S,I)),I[v];if($(this,I))return I[v];if(!Array.isArray(u))return this.nextTick(I,new TypeError("The first argument 'operations' must be an array")),I[v];if(u.length===0)return this.nextTick(I),I[v];const M=new Array(u.length),{keyEncoding:z,valueEncoding:j,...W}=S;for(let Z=0;Z<u.length;Z++){if(typeof u[Z]!="object"||u[Z]===null)return this.nextTick(I,new TypeError("A batch operation must be an object")),I[v];const V=Object.assign({},u[Z]);if(V.type!=="put"&&V.type!=="del")return this.nextTick(I,new TypeError("A batch operation must have a type property that is 'put' or 'del'")),I[v];const J=this._checkKey(V.key);if(J)return this.nextTick(I,J),I[v];const Q=V.sublevel!=null?V.sublevel:this,ce=Q.keyEncoding(V.keyEncoding||z),xe=ce.format;if(V.key=Q.prefixKey(ce.encode(V.key),xe),V.keyEncoding=xe,V.type==="put"){const Ae=this._checkValue(V.value);if(Ae)return this.nextTick(I,Ae),I[v];const Fe=Q.valueEncoding(V.valueEncoding||j);V.value=Fe.encode(V.value),V.valueEncoding=Fe.format}Q!==this&&(V.sublevel=null),M[Z]=V}return this._batch(M,W,Z=>{if(Z)return I(Z);this.emit("batch",u),I()}),I[v]}_batch(u,S,I){this.nextTick(I)}sublevel(u,S){return this._sublevel(u,H.defaults(S))}_sublevel(u,S){return new H(this,u,S)}prefixKey(u,S){return u}clear(u,S){if(S=g(u,S),S=s(S,v),u=T(u,this[b].empty),this[d]==="opening")return this.defer(()=>this.clear(u,S)),S[v];if($(this,S))return S[v];const I=u,M=this.keyEncoding(u.keyEncoding);return u=x(u,M),u.keyEncoding=M.format,u.limit===0?this.nextTick(S):this._clear(u,z=>{if(z)return S(z);this.emit("clear",I),S()}),S[v]}_clear(u,S){this.nextTick(S)}iterator(u){const S=this.keyEncoding(u&&u.keyEncoding),I=this.valueEncoding(u&&u.valueEncoding);if(u=x(u,S),u.keys=u.keys!==!1,u.values=u.values!==!1,u[c.keyEncoding]=S,u[c.valueEncoding]=I,u.keyEncoding=S.format,u.valueEncoding=I.format,this[d]==="opening")return new B(this,u);if(this[d]!=="open")throw new o("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._iterator(u)}_iterator(u){return new c(this,u)}keys(u){const S=this.keyEncoding(u&&u.keyEncoding),I=this.valueEncoding(u&&u.valueEncoding);if(u=x(u,S),u[c.keyEncoding]=S,u[c.valueEncoding]=I,u.keyEncoding=S.format,u.valueEncoding=I.format,this[d]==="opening")return new R(this,u);if(this[d]!=="open")throw new o("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._keys(u)}_keys(u){return new w(this,u)}values(u){const S=this.keyEncoding(u&&u.keyEncoding),I=this.valueEncoding(u&&u.valueEncoding);if(u=x(u,S),u[c.keyEncoding]=S,u[c.valueEncoding]=I,u.keyEncoding=S.format,u.valueEncoding=I.format,this[d]==="opening")return new A(this,u);if(this[d]!=="open")throw new o("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._values(u)}_values(u){return new f(this,u)}defer(u){if(typeof u!="function")throw new TypeError("The first argument must be a function");this[C].push(u)}[h](){if(this[C].length===0)return;const u=this[C];this[C]=[];for(const S of u)S()}attachResource(u){if(typeof u!="object"||u===null||typeof u.close!="function")throw new TypeError("The first argument must be a resource object");this[F].add(u)}detachResource(u){this[F].delete(u)}_chainedBatch(){return new y(this)}_checkKey(u){if(u==null)return new o("Key cannot be null or undefined",{code:"LEVEL_INVALID_KEY"})}_checkValue(u){if(u==null)return new o("Value cannot be null or undefined",{code:"LEVEL_INVALID_VALUE"})}}K.prototype.nextTick=Ds();const{AbstractSublevel:H}=Ms()({AbstractLevel:K});Ue.AbstractLevel=K,Ue.AbstractSublevel=H;const $=function(U,u){return U[d]!=="open"?(U.nextTick(u,new o("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"})),!0):!1},G=function(U){return Object.keys(U.supports.encodings).filter(u=>!!U.supports.encodings[u])};return Ue}var Qn;function Ir(){return Qn||(Qn=1,ye.AbstractLevel=Jn().AbstractLevel,ye.AbstractSublevel=Jn().AbstractSublevel,ye.AbstractIterator=be().AbstractIterator,ye.AbstractKeyIterator=be().AbstractKeyIterator,ye.AbstractValueIterator=be().AbstractValueIterator,ye.AbstractChainedBatch=br().AbstractChainedBatch),ye}var It,Xn;function qs(){if(Xn)return It;Xn=1,It=t;const n=xr();function t(i,s,o){if(typeof s!="number")throw new Error("second argument must be a Number");let c,w,f,B,R,A=!0,y;Array.isArray(i)?(c=[],f=w=i.length):(B=Object.keys(i),c={},f=w=B.length);function g(x){function v(){o&&o(x,c),o=null}A?n(v):v()}function T(x,v,O){if(c[x]=O,v&&(R=!0),--f===0||v)g(v);else if(!R&&y<w){let F;B?(F=B[y],y+=1,i[F](function(L,C){T(F,L,C)})):(F=y,y+=1,i[F](function(L,C){T(F,L,C)}))}}y=s,f?B?B.some(function(x,v){return i[x](function(O,F){T(x,O,F)}),v===s-1}):i.some(function(x,v){return x(function(O,F){T(v,O,F)}),v===s-1}):g(null),A=!1}return It}var Tt={},_t,Zn;function Tr(){return Zn||(Zn=1,_t=function(t){const i=t.gte!==void 0?t.gte:t.gt!==void 0?t.gt:void 0,s=t.lte!==void 0?t.lte:t.lt!==void 0?t.lt:void 0,o=t.gte===void 0,c=t.lte===void 0;return i!==void 0&&s!==void 0?IDBKeyRange.bound(i,s,o,c):i!==void 0?IDBKeyRange.lowerBound(i,o):s!==void 0?IDBKeyRange.upperBound(s,c):null}),_t}var At,er;function _r(){if(er)return At;er=1;const n=new TextEncoder;return At=function(t){return t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):n.encode(t)},At}var tr;function Vs(){if(tr)return Tt;tr=1;const{AbstractIterator:n}=Ir(),t=Tr(),i=_r(),s=Symbol("cache"),o=Symbol("finished"),c=Symbol("options"),w=Symbol("currentOptions"),f=Symbol("position"),B=Symbol("location"),R=Symbol("first"),A={};class y extends n{constructor(x,v,O){super(x,O),this[s]=[],this[o]=this.limit===0,this[c]=O,this[w]={...O},this[f]=void 0,this[B]=v,this[R]=!0}_nextv(x,v,O){if(this[R]=!1,this[o])return this.nextTick(O,null,[]);if(this[s].length>0)return x=Math.min(x,this[s].length),this.nextTick(O,null,this[s].splice(0,x));this[f]!==void 0&&(this[c].reverse?(this[w].lt=this[f],this[w].lte=void 0):(this[w].gt=this[f],this[w].gte=void 0));let F;try{F=t(this[w])}catch{return this[o]=!0,this.nextTick(O,null,[])}const L=this.db.db.transaction([this[B]],"readonly"),C=L.objectStore(this[B]),h=[];if(this[c].reverse){const m=!this[c].values&&C.openKeyCursor?"openKeyCursor":"openCursor";C[m](F,"prev").onsuccess=p=>{const d=p.target.result;if(d){const{key:b,value:N}=d;this[f]=b,h.push([this[c].keys&&b!==void 0?i(b):void 0,this[c].values&&N!==void 0?i(N):void 0]),h.length<x?d.continue():g(L)}else this[o]=!0}}else{let m,p;const d=()=>{if(m===void 0||p===void 0)return;const b=Math.max(m.length,p.length);b===0||x===1/0?this[o]=!0:this[f]=m[b-1],h.length=b;for(let N=0;N<b;N++){const P=m[N],q=p[N];h[N]=[this[c].keys&&P!==void 0?i(P):void 0,this[c].values&&q!==void 0?i(q):void 0]}g(L)};this[c].keys||x<1/0?C.getAllKeys(F,x<1/0?x:void 0).onsuccess=b=>{m=b.target.result,d()}:(m=[],this.nextTick(d)),this[c].values?C.getAll(F,x<1/0?x:void 0).onsuccess=b=>{p=b.target.result,d()}:(p=[],this.nextTick(d))}L.onabort=()=>{O(L.error||new Error("aborted by user")),O=null},L.oncomplete=()=>{O(null,h),O=null}}_next(x){if(this[s].length>0){const[v,O]=this[s].shift();this.nextTick(x,null,v,O)}else if(this[o])this.nextTick(x);else{let v=Math.min(100,this.limit-this.count);this[R]&&(this[R]=!1,v=1),this._nextv(v,A,(O,F)=>{if(O)return x(O);this[s]=F,this._next(x)})}}_all(x,v){this[R]=!1;const O=this[s].splice(0,this[s].length),F=this.limit-this.count-O.length;if(F<=0)return this.nextTick(v,null,O);this._nextv(F,A,(L,C)=>{if(L)return v(L);O.length>0&&(C=O.concat(C)),v(null,C)})}_seek(x,v){this[R]=!0,this[s]=[],this[o]=!1,this[f]=void 0,this[w]={...this[c]};let O;try{O=t(this[c])}catch{this[o]=!0;return}O!==null&&!O.includes(x)?this[o]=!0:this[c].reverse?this[w].lte=x:this[w].gte=x}}Tt.Iterator=y;function g(T){typeof T.commit=="function"&&T.commit()}return Tt}var Bt,nr;function Ks(){return nr||(nr=1,Bt=function(t,i,s,o,c){if(o.limit===0)return t.nextTick(c);const w=t.db.transaction([i],"readwrite"),f=w.objectStore(i);let B=0;w.oncomplete=function(){c()},w.onabort=function(){c(w.error||new Error("aborted by user"))};const R=f.openKeyCursor?"openKeyCursor":"openCursor",A=o.reverse?"prev":"next";f[R](s,A).onsuccess=function(y){const g=y.target.result;g&&(f.delete(g.key).onsuccess=function(){(o.limit<=0||++B<o.limit)&&g.continue()})}}),Bt}var rr;function $s(){if(rr)return ht;rr=1;const{AbstractLevel:n}=Ir(),t=fe(),i=qs(),{fromCallback:s}=Xe(),{Iterator:o}=Vs(),c=_r(),w=Ks(),f=Tr(),B="level-js-",R=Symbol("idb"),A=Symbol("namePrefix"),y=Symbol("location"),g=Symbol("version"),T=Symbol("store"),x=Symbol("onComplete"),v=Symbol("promise");class O extends n{constructor(L,C,h){if(typeof C=="function"||typeof h=="function")throw new t("The levelup-style callback argument has been removed",{code:"LEVEL_LEGACY"});const{prefix:m,version:p,...d}=C||{};if(super({encodings:{view:!0},snapshots:!1,createIfMissing:!1,errorIfExists:!1,seek:!0},d),typeof L!="string")throw new Error("constructor requires a location string argument");this[y]=L,this[A]=m??B,this[g]=parseInt(p||1,10),this[R]=null}get location(){return this[y]}get namePrefix(){return this[A]}get version(){return this[g]}get db(){return this[R]}get type(){return"browser-level"}_open(L,C){const h=indexedDB.open(this[A]+this[y],this[g]);h.onerror=function(){C(h.error||new Error("unknown error"))},h.onsuccess=()=>{this[R]=h.result,C()},h.onupgradeneeded=m=>{const p=m.target.result;p.objectStoreNames.contains(this[y])||p.createObjectStore(this[y])}}[T](L){return this[R].transaction([this[y]],L).objectStore(this[y])}[x](L,C){const h=L.transaction;h.onabort=function(){C(h.error||new Error("aborted by user"))},h.oncomplete=function(){C(null,L.result)}}_get(L,C,h){const m=this[T]("readonly");let p;try{p=m.get(L)}catch(d){return this.nextTick(h,d)}this[x](p,function(d,b){if(d)return h(d);if(b===void 0)return h(new t("Entry not found",{code:"LEVEL_NOT_FOUND"}));h(null,c(b))})}_getMany(L,C,h){const m=this[T]("readonly"),p=L.map(d=>b=>{let N;try{N=m.get(d)}catch(P){return b(P)}N.onsuccess=()=>{const P=N.result;b(null,P===void 0?P:c(P))},N.onerror=P=>{P.stopPropagation(),b(N.error)}});i(p,16,h)}_del(L,C,h){const m=this[T]("readwrite");let p;try{p=m.delete(L)}catch(d){return this.nextTick(h,d)}this[x](p,h)}_put(L,C,h,m){const p=this[T]("readwrite");let d;try{d=p.put(C,L)}catch(b){return this.nextTick(m,b)}this[x](d,m)}_iterator(L){return new o(this,this[y],L)}_batch(L,C,h){const m=this[T]("readwrite"),p=m.transaction;let d=0,b;p.onabort=function(){h(b||p.error||new Error("aborted by user"))},p.oncomplete=function(){h()};function N(){const P=L[d++],q=P.key;let E;try{E=P.type==="del"?m.delete(q):m.put(P.value,q)}catch(K){b=K,p.abort();return}d<L.length?E.onsuccess=N:typeof p.commit=="function"&&p.commit()}N()}_clear(L,C){let h,m;try{h=f(L)}catch{return this.nextTick(C)}if(L.limit>=0)return w(this,this[y],h,L,C);try{const p=this[T]("readwrite");m=h?p.delete(h):p.clear()}catch(p){return this.nextTick(C,p)}this[x](m,C)}_close(L){this[R].close(),this.nextTick(L)}}return O.destroy=function(F,L,C){typeof L=="function"&&(C=L,L=B),C=s(C,v);const h=indexedDB.deleteDatabase(L+F);return h.onsuccess=function(){C()},h.onerror=function(m){C(m)},C[v]},ht.BrowserLevel=O,ht}var ir;function js(){return ir||(ir=1,ut.Level=$s().BrowserLevel),ut}var zs=js();const Hs="./level",Gs="view",Ut=async({path:n,valueEncoding:t}={})=>{n=n||Hs,t=t||Gs;const i=new zs.Level(n,{valueEncoding:t,passive:!0});return await i.open(),{put:async(A,y)=>{await i.put(A,y)},del:async A=>{await i.del(A)},get:async A=>{try{const y=await i.get(A);if(y)return y}catch{}},iterator:async function*({amount:A,reverse:y}={}){const g={limit:A||-1,reverse:y||!1};for await(const[T,x]of i.iterator(g))yield[T,x]},merge:async A=>{},clear:async()=>{await i.clear()},close:async()=>{await i.close()}}},sr=1e6,he=async({size:n}={})=>{let t=new Ct(n||sr);return{put:async(R,A)=>{t.set(R,A)},del:async R=>{t.remove(R)},get:async R=>t.get(R),iterator:async function*(){for await(const R of t.keys){const A=t.get(R);yield[R,A]}},merge:async R=>{if(R)for await(const[A,y]of R.iterator())t.set(A,y)},clear:async()=>{t=new Ct(n||sr)},close:async()=>{}}},Ws=16,St=1e3,Jt=async({ipfs:n,identity:t,address:i,name:s,access:o,directory:c,meta:w,headsStorage:f,entryStorage:B,indexStorage:R,referencesCount:A,syncAutomatically:y,onUpdate:g,encryption:T})=>{c=we(c||"./orbitdb",`./${i}/`),w=w||{},A=Number(A)>-1?A:Ws,B=B||await ve(await he({size:St}),await Qe({ipfs:n,pin:!0})),f=f||await ve(await he({size:St}),await Ut({path:we(c,"/log/_heads/")})),R=R||await ve(await he({size:St}),await Ut({path:we(c,"/log/_index/")})),T=T||{};const x=await As(t,{logId:i,access:o,entryStorage:B,headsStorage:f,indexStorage:R,encryption:T}),v=new ur.EventEmitter,O=new ze({concurrency:1}),F=async p=>{const d=async()=>{const N=await x.append(p,{referencesCount:A});return await m.add(N),g&&await g(x,N),v.emit("update",N),N.hash};return await O.add(d)},L=async p=>{const d=async()=>{try{p&&await x.joinEntry(p)&&(g&&await g(x,p),v.emit("update",p))}catch(b){console.error(b)}};await O.add(d)},C=async()=>{await m.stop(),await O.onIdle(),await x.close(),o&&o.close&&await o.close(),v.emit("close")},h=async()=>{await O.clear(),await x.clear(),o&&o.drop&&await o.drop(),v.emit("drop")},m=await Ss({ipfs:n,log:x,events:v,onSynced:L,start:y});return{address:i,name:s,identity:t,meta:w,close:C,drop:h,addOperation:F,log:x,sync:m,peers:m.peers,events:v,access:o}},Ar="documents",Ys={indexBy:"_id"},Br=({indexBy:n}=Ys)=>async({ipfs:t,identity:i,address:s,name:o,access:c,directory:w,meta:f,headsStorage:B,entryStorage:R,indexStorage:A,referencesCount:y,syncAutomatically:g,onUpdate:T,encrypt:x})=>{const v=await Jt({ipfs:t,identity:i,address:s,name:o,access:c,directory:w,meta:f,headsStorage:B,entryStorage:R,indexStorage:A,referencesCount:y,syncAutomatically:g,encrypt:x}),{addOperation:O,log:F}=v,L=async b=>{const N=b[n];if(!N)throw new Error(`The provided document doesn't contain field '${n}'`);return O({op:"PUT",key:N,value:b})},C=async b=>{if(!await h(b))throw new Error(`No document with key '${b}' in the database`);return O({op:"DEL",key:b,value:null})},h=async b=>{for await(const N of p())if(b===N.key)return N},m=async b=>{const N=[];for await(const P of p())b(P.value)&&N.push(P.value);return N},p=async function*({amount:b}={}){const N={};let P=0;for await(const q of F.iterator()){const{op:E,key:K,value:H}=q.payload;if(E==="PUT"&&!N[K]?(N[K]=!0,P++,yield{hash:q.hash,key:K,value:H}):E==="DEL"&&!N[K]&&(N[K]=!0),P>=b)break}};return{...v,type:Ar,put:L,del:C,get:h,iterator:p,query:m,indexBy:n,all:async()=>{const b=[];for await(const N of p())b.unshift(N);return b}}};Br.type=Ar;const Sr="events",Lr=()=>async({ipfs:n,identity:t,address:i,name:s,access:o,directory:c,meta:w,headsStorage:f,entryStorage:B,indexStorage:R,referencesCount:A,syncAutomatically:y,onUpdate:g,encryption:T})=>{const x=await Jt({ipfs:n,identity:t,address:i,name:s,access:o,directory:c,meta:w,headsStorage:f,entryStorage:B,indexStorage:R,referencesCount:A,syncAutomatically:y,onUpdate:g,encryption:T}),{addOperation:v,log:O}=x,F=async m=>v({op:"ADD",key:null,value:m}),L=async m=>(await O.get(m)).payload.value,C=async function*({gt:m,gte:p,lt:d,lte:b,amount:N}={}){const P=O.iterator({gt:m,gte:p,lt:d,lte:b,amount:N});for await(const q of P){const E=q.hash,K=q.payload.value;yield{hash:E,value:K}}};return{...x,type:Sr,add:F,get:L,iterator:C,all:async()=>{const m=[];for await(const p of C())m.unshift(p);return m}}};Lr.type=Sr;const Or="keyvalue",Cr=()=>async({ipfs:n,identity:t,address:i,name:s,access:o,directory:c,meta:w,headsStorage:f,entryStorage:B,indexStorage:R,referencesCount:A,syncAutomatically:y,onUpdate:g,encryption:T})=>{const x=await Jt({ipfs:n,identity:t,address:i,name:s,access:o,directory:c,meta:w,headsStorage:f,entryStorage:B,indexStorage:R,referencesCount:A,syncAutomatically:y,onUpdate:g,encryption:T}),{addOperation:v,log:O}=x,F=async(p,d)=>v({op:"PUT",key:p,value:d}),L=async p=>v({op:"DEL",key:p,value:null}),C=async p=>{for await(const d of O.traverse()){const{op:b,key:N,value:P}=d.payload;if(b==="PUT"&&N===p)return P;if(b==="DEL"&&N===p)return}},h=async function*({amount:p}={}){const d={};let b=0;for await(const N of O.traverse()){const{op:P,key:q,value:E}=N.payload;if(P==="PUT"&&!d[q]){d[q]=!0,b++;const K=N.hash;yield{key:q,value:E,hash:K}}else P==="DEL"&&!d[q]&&(d[q]=!0);if(b>=p)break}};return{...x,type:Or,put:F,set:F,del:L,get:C,iterator:h,all:async()=>{const p=[];for await(const d of h())p.unshift(d);return p}}};Cr.type=Or;const Mt={},Qt=n=>{if(!n.type)throw new Error("Database type does not contain required field 'type'.");Mt[n.type]=n},Js=n=>{if(!n)throw new Error("Type not specified");if(!Mt[n])throw new Error(`Unsupported database type: '${n}'`);return Mt[n]};Qt(Lr);Qt(Br);Qt(Cr);const Qs=async(n,t,i)=>{if(!n)throw new Error("No signature given");if(!t)throw new Error("Given publicKey was undefined");if(!i)throw new Error("Given input data was undefined");i instanceof Uint8Array||(i=typeof i=="string"?Ke(i):new Uint8Array(i));const s=(c,w,f)=>c.verify(w,f);let o=!1;try{const c=ui(Ke(t,"base16"));o=await s(c,i,Ke(n,"base16"))}catch{}return Promise.resolve(o)},qt=async(n,t)=>{if(!n)throw new Error("No signing key given");if(!t)throw new Error("Given input data was undefined");return t instanceof Uint8Array||(t=typeof t=="string"?Ke(t):new Uint8Array(t)),Kt(await n.sign(t),"base16")},Xs=he({size:1e3}),kr=async(n,t,i)=>{const s=await Xs,o=await s.get(n);let c=!1;if(o){const w=(f,B)=>B instanceof Uint8Array?hi(f,B)===0:f.toString()===B.toString();c=o.publicKey===t&&w(o.data,i)}else{const w=await Qs(n,t,i);c=w,w&&await s.put(n,{publicKey:t,data:i})}return c},Zs="./keystore",Fr=async({storage:n,path:t}={})=>{n=n||await ve(await he({size:1e3}),await Ut({path:t||Zs}));const i=await he({size:1e3}),s=async()=>{await n.close(),await i.close()},o=async()=>{await n.clear(),await i.clear()},c=async A=>{if(!A)throw new Error("id needed to check a key");let y=!1,g=await i.get(A);if(g)y=!0;else try{g=await n.get("private_"+A),y=g!=null}catch{console.error("Error: ENOENT: no such file or directory")}return y},w=async(A,y)=>{const{privateKey:g}=y;await n.put("private_"+A,g);const T=ln(g);await i.put(A,T)};return{clear:o,close:s,hasKey:c,addKey:w,createKey:async A=>{if(!A)throw new Error("id needed to create a key");const y=await ai("secp256k1"),g={publicKey:y.publicKey.raw,privateKey:y.raw};return await w(A,g),y},getKey:async A=>{if(!A)throw new Error("id needed to get a key");let y=await i.get(A);if(!y){let g;try{g=await n.get("private_"+A)}catch{}if(!g)return;y=ln(g),await i.put(A,y)}return y},getPublic:(A,y={})=>{const g=["hex","buffer"],T=y.format||"hex";if(g.indexOf(T)===-1)throw new Error("Supported formats are `hex` and `buffer`");const x=A.publicKey.raw;return T==="buffer"?x:Kt(x,"base16")}}},Rr=Ye,Nr=Je,eo=se,Pr=async({id:n,publicKey:t,signatures:i,type:s,sign:o,verify:c}={})=>{if(!n)throw new Error("Identity id is required");if(!t)throw new Error("Invalid public key");if(!i)throw new Error("Signatures object is required");if(!i.id)throw new Error("Signature of id is required");if(!i.publicKey)throw new Error("Signature of publicKey+id is required");if(!s)throw new Error("Identity type is required");i=Object.assign({},i);const w={id:n,publicKey:t,signatures:i,type:s,sign:o,verify:c},{hash:f,bytes:B}=await to(w);return w.hash=f,w.bytes=B,w},to=async n=>{const{id:t,publicKey:i,signatures:s,type:o}=n,c={id:t,publicKey:i,signatures:s,type:o},{cid:w,bytes:f}=await Ee({value:c,codec:Rr,hasher:Nr});return{hash:w.toString(eo),bytes:Uint8Array.from(f)}},no=async n=>{const{value:t}=await _e({bytes:n,codec:Rr,hasher:Nr});return Pr({...t})},ro=n=>!!(n.id&&n.hash&&n.bytes&&n.publicKey&&n.signatures&&n.signatures.id&&n.signatures.publicKey&&n.type),io=(n,t)=>n.id===t.id&&n.hash===t.hash&&n.type===t.type&&n.publicKey===t.publicKey&&n.signatures.id===t.signatures.id&&n.signatures.publicKey===t.signatures.publicKey,Dr="publickey",so=async n=>{const{id:t,publicKey:i,signatures:s}=n;return kr(s.publicKey,t,i+s.id)},Xt=({keystore:n})=>async()=>{if(!n)throw new Error("PublicKeyIdentityProvider requires a keystore parameter");return{type:Dr,getId:async({id:s}={})=>{if(!s)throw new Error("id is required");const o=await n.getKey(s)||await n.createKey(s);return Kt(o.publicKey.raw,"base16")},signIdentity:async(s,{id:o}={})=>{if(!o)throw new Error("id is required");const c=await n.getKey(o);if(!c)throw new Error(`Signing key for '${o}' not found`);return qt(c,s)}}};Xt.verifyIdentity=so;Xt.type=Dr;const Zt={},oo=n=>Object.keys(Zt).includes(n),Lt=n=>{if(!oo(n))throw new Error(`IdentityProvider type '${n}' is not supported`);return Zt[n]},co=n=>{if(!n.type||typeof n.type!="string")throw new Error("Given IdentityProvider doesn't have a field 'type'.");if(!n.verifyIdentity)throw new Error("Given IdentityProvider doesn't have a function 'verifyIdentity'.");Zt[n.type]=n};co(Xt);const ao=we("./orbitdb","identities"),uo=async({keystore:n,path:t,storage:i,ipfs:s}={})=>{n=n||await Fr({path:t||ao}),i||(i=s?await ve(await he({size:1e3}),await Qe({ipfs:s,pin:!0})):await Wt());const o=await he({size:1e3}),c=async A=>{const y=await i.get(A);if(y)return no(y)},w=async(A={})=>{A.keystore=n;const y=Lt("publickey"),T=await(A.provider||y({keystore:n}))();if(!Lt(T.type))throw new Error("Identity provider is unknown. Use useIdentityProvider(provider) to register the identity provider");const x=await T.getId(A),v=await n.getKey(x)||await n.createKey(x),O=n.getPublic(v),F=await qt(v,x),L=await T.signIdentity(O+F,A),h=await Pr({id:x,publicKey:O,signatures:{id:F,publicKey:L},type:T.type,sign:B,verify:R});return await i.put(h.hash,h.bytes),h},f=async A=>{if(!ro(A))return!1;const{id:y,publicKey:g,signatures:T}=A;if(!await R(T.id,g,y))return!1;const v=await o.get(T.id);if(v)return io(A,v);const F=await Lt(A.type).verifyIdentity(A);return F&&await o.put(T.id,A),F},B=async(A,y)=>{const g=await n.getKey(A.id);if(!g)throw new Error("Private signing key not found from KeyStore");return await qt(g,y)},R=async(A,y,g)=>await kr(A,y,g);return{createIdentity:w,verifyIdentity:f,getIdentity:c,sign:B,verify:R,keystore:n}},ho=n=>{if(n=n.toString(),!n.startsWith("/orbitdb")&&!n.startsWith("\\orbitdb"))return!1;n=n.replaceAll("/orbitdb/",""),n=n.replaceAll("\\orbitdb\\",""),n=n.replaceAll("/",""),n=n.replaceAll("\\","");let t;try{t=X.parse(n,se)}catch{return!1}return t!==void 0},or=n=>{if(n&&n.protocol==="orbitdb"&&n.hash)return n;const t="orbitdb",i=n.replace("/orbitdb/","").replace("\\orbitdb\\","");return{protocol:t,hash:i,address:n,toString:()=>we("/",t,i)}},cr=Ye,ar=Je,fo=se,lo=async({ipfs:n,storage:t}={})=>(t=t||await ve(await he({size:1e5}),await Qe({ipfs:n,pin:!0})),{get:async c=>{const w=await t.get(c),{value:f}=await _e({bytes:w,codec:cr,hasher:ar});return f&&await t.put(c,w),f},create:async({name:c,type:w,accessController:f,meta:B})=>{if(!c)throw new Error("name is required");if(!w)throw new Error("type is required");if(!f)throw new Error("accessController is required");const R=Object.assign({name:c,type:w,accessController:f},B!==void 0?{meta:B}:{}),{cid:A,bytes:y}=await Ee({value:R,codec:cr,hasher:ar}),g=A.toString(fo);return await t.put(g,y),{hash:g,manifest:R}},close:async()=>{await t.close()}}),Ur=async(n=32)=>{const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";let i="",s=0;for(;s<n;)i+=t.charAt(Math.floor(Math.random()*t.length)),s+=1;return i},Mr=Ye,qr=Je,yo=se,po=async({storage:n,type:t,params:i})=>{const s={type:t,...i},{cid:o,bytes:c}=await Ee({value:s,codec:Mr,hasher:qr}),w=o.toString(yo);return await n.put(w,c),w},je="ipfs",Ze=({write:n,storage:t}={})=>async({orbitdb:i,identities:s,address:o})=>{if(t=t||await ve(await he({size:1e3}),await Qe({ipfs:i.ipfs,pin:!0})),n=n||[i.identity.id],o){const w=await t.get(o.replaceAll("/ipfs/","")),{value:f}=await _e({bytes:w,codec:Mr,hasher:qr});n=f.write}else o=await po({storage:t,type:je,params:{write:n}}),o=we("/",je,o);return{type:je,address:o,write:n,canAppend:async w=>{const f=await s.getIdentity(w.identity);if(!f)return!1;const{id:B}=f;return n.includes(B)||n.includes("*")?await s.verifyIdentity(f):!1}}};Ze.type=je;const Vr="orbitdb",Kr=({write:n}={})=>async({orbitdb:t,identities:i,address:s,name:o})=>{s=s||o||await Ur(64),n=n||[t.identity.id];const c=await t.open(s,{type:"keyvalue",AccessController:Ze({write:n})});s=c.address;const w=async x=>{const v=await i.getIdentity(x.identity);if(!v)return!1;const{id:O}=v;return await y("write",O)||await y("admin",O)?await i.verifyIdentity(v):!1},f=async()=>{const x=[];for await(const O of c.iterator())x[O.key]=O.value;const v=O=>{const F=O[0];x[F]=new Set([...x[F]||[],...O[1]])};return Object.entries({...x,admin:new Set([...x.admin||[],...c.access.write])}).forEach(v),x},B=async x=>(await f())[x]||new Set([]),R=async()=>{await c.close()},A=async()=>{await c.drop()},y=async(x,v)=>{const O=new Set(await B(x));return O.has(v)||O.has("*")};return{type:Vr,address:s,write:n,canAppend:w,capabilities:f,get:B,grant:async(x,v)=>{const O=new Set([...await c.get(x)||[],v]);await c.put(x,Array.from(O.values()))},revoke:async(x,v)=>{const O=new Set(await c.get(x)||[]);O.delete(v),O.size>0?await c.put(x,Array.from(O.values())):await c.del(x)},close:R,drop:A,events:c.events}};Kr.type=Vr;const Vt={},wo=n=>{if(!Vt[n])throw new Error(`AccessController type '${n}' is not supported`);return Vt[n]},$r=n=>{if(!n.type)throw new Error("AccessController does not contain required field 'type'.");Vt[n.type]=n};$r(Ze);$r(Kr);const go="events",mo=Ze,xo=async({ipfs:n,id:t,identity:i,identities:s,directory:o}={})=>{if(n==null)throw new Error("IPFS instance is a required argument.");t=t||await Ur();const c=n.libp2p.peerId;o=o||"./orbitdb";let w;s?w=s.keystore:(w=await Fr({path:we(o,"./keystore")}),s=await uo({ipfs:n,keystore:w})),i?i.provider&&(i=await s.createIdentity({...i})):i=await s.createIdentity({id:t});const f=await lo({ipfs:n});let B={};const R=async(g,{type:T,meta:x,sync:v,Database:O,AccessController:F,headsStorage:L,entryStorage:C,indexStorage:h,referencesCount:m,encryption:p}={})=>{let d,b,N;if(B[g])return B[g];if(ho(g)){const q=or(g);b=await f.get(q.hash);const E=b.accessController.split("/",2).pop();F=wo(E)(),N=await F({orbitdb:{open:R,identity:i,ipfs:n},identities:s,address:b.accessController}),d=b.name,T=T||b.type,x=b.meta}else{T=T||go,F=F||mo(),N=await F({orbitdb:{open:R,identity:i,ipfs:n},identities:s,name:g});const q=await f.create({name:g,type:T,accessController:N.address,meta:x});if(b=q.manifest,g=or(q.hash),d=b.name,x=b.meta,B[g])return B[g]}if(O=O||Js(T)(),!O)throw new Error(`Unsupported database type: '${T}'`);g=g.toString();const P=await O({ipfs:n,identity:i,address:g,name:d,access:N,directory:o,meta:x,syncAutomatically:v,headsStorage:L,entryStorage:C,indexStorage:h,referencesCount:m,encryption:p});return P.events.on("close",A(g)),B[g]=P,P},A=g=>()=>{delete B[g]};return{id:t,open:R,stop:async()=>{for(const g of Object.values(B))await g.close();w&&await w.close(),f&&await f.close(),B={}},ipfs:n,directory:o,keystore:w,identities:s,identity:i,peerId:c}};export{ve as ComposedStorage,Jt as Database,_s as DefaultAccessController,Br as Documents,ue as Entry,Lr as Events,Ze as IPFSAccessController,Qe as IPFSBlockStorage,uo as Identities,Fr as KeyStore,Cr as KeyValue,he as LRUStorage,Ut as LevelStorage,As as Log,Wt as MemoryStorage,Kr as OrbitDBAccessController,Xt as PublicKeyIdentityProvider,xo as createOrbitDB,ro as isIdentity,ho as isValidAddress,$r as useAccessController,Qt as useDatabaseType,co as useIdentityProvider};
